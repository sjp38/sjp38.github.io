<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>English on Happy Hacking</title>
    <link>https://sjp38.github.io/tags/english/</link>
    <description>Recent content in English on Happy Hacking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>sj38.park@gmail.com (SeongJae Park)</managingEditor>
    <webMaster>sj38.park@gmail.com (SeongJae Park)</webMaster>
    <lastBuildDate>Wed, 13 Sep 2017 13:46:00 +0900</lastBuildDate>
    
	<atom:link href="https://sjp38.github.io/tags/english/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Idle Page Tracking Tools</title>
      <link>https://sjp38.github.io/post/idle_page_tracking/</link>
      <pubDate>Wed, 13 Sep 2017 13:46:00 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/idle_page_tracking/</guid>
      <description>idle_page_tracking[1] is a simple, stupid toolbox for idle pages tracking. It can be used to get real working set size of a process.
Tools This section gives brief description and usage of each tool in box.
userprog userprog is a sample synthetic workload for test of other tools. It interactively allocates and access specified pages in the allocated pages. After execution, it first asks how many pages to allocates. Once you type in how many pages to allocate, the program will repeatedly asks how many pages in the allocated pages you want to do access.</description>
    </item>
    
    <item>
      <title>lkml livestream</title>
      <link>https://sjp38.github.io/post/lkml_go/</link>
      <pubDate>Sun, 28 May 2017 17:51:43 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/lkml_go/</guid>
      <description>I wrote a simple, stupid program[1] that showing LKML[2] mails in terminal briefly like twitter livestream in Go language. It is just an early version and so many things to be complemented exists, though. Nevertheless, now it just works as I wanted at first.
쏟아지는 LKML[2] 의 메일들을 트위터 라이브스트림처럼 터미널에 보여주는 간단한 프로그램[1] 을 go 언어로 만들어 봤습니다. 아직 보완할 점 투성이지만 이제 최초의 목적대로는 동작하는군요.
References [1] https://github.</description>
    </item>
    
    <item>
      <title>Updating Google Chrome on Fedora 23</title>
      <link>https://sjp38.github.io/post/fedora-chrome-update/</link>
      <pubDate>Mon, 20 Mar 2017 22:24:26 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/fedora-chrome-update/</guid>
      <description>I am using Fedora 23 laptop and installed stable version Google Chrome from its official website [0]. In this case, just using Updates of Fedora Software program doesn&amp;rsquo;t update Chrome automatically. For the case, follow below commands to update your Chrome:
$ sudo dnf update google-chrome-stable ... $ sudo killall chrome $ google-chrome-stable  The second killall command is necessary because Chrome doesn&amp;rsquo;t kill its process by just cliking Close button.</description>
    </item>
    
    <item>
      <title>Golang kakaotalk chat bot making</title>
      <link>https://sjp38.github.io/post/kakaobot/</link>
      <pubDate>Wed, 15 Mar 2017 22:40:32 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/kakaobot/</guid>
      <description>I have developed a chat bot [1] for Kakaotalk [2] using Go language because I have been curious about the process of Kakaotalk chat bot development process. Implementation to major version has consumed only two hours owing to power of Go language, simpleness of Kakaotalk auto-reply API, and simple simple functionality requirement of my bot. It has coded really simply and in brute-force manner, do only simple echoing. However, for the reason, the code could be helpful for beginner of Kakaotalk chat bot or Go language Restful API server programmer.</description>
    </item>
    
    <item>
      <title>Using arping to know ip-MAC mapping</title>
      <link>https://sjp38.github.io/post/arping-howto/</link>
      <pubDate>Tue, 07 Mar 2017 19:41:16 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/arping-howto/</guid>
      <description>You can use arping to know IP address to MAC address mapping of your local network. Usage is simple:
arping [-AbDfhqUV] [-c count] [-w deadline] [-s source] -I interface destination  For example, you may use the command as below:
$ arping -I eth0 10.0.0.1 ARPING 10.0.0.1 from 10.0.0.2 eth0 Unicast reply from 10.0.0.1 [11:22:33:44:55:66] 0.123ms Unicast reply from 10.0.0.1 [11:22:33:44:55:66] 0.251ms ...  Secret of the tool is ARP protocol [1].</description>
    </item>
    
    <item>
      <title>Starting &#39;Linux Kernel Hack&#39; series</title>
      <link>https://sjp38.github.io/post/001_linux_dev_intro/</link>
      <pubDate>Sat, 04 Mar 2017 15:53:08 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/001_linux_dev_intro/</guid>
      <description>많은 영역에서 사용되고 있는 리눅스 커널. 그렇기에 만져볼수록 재밌고 뜯어볼수록 신기합니다. 아마도 이게 hack 의 재미가 아닐까요.
리눅스 커널을 hack 하는데에 필요한 기본적인 내용부터 몇가지 팁들, 소스 코드는 어떻게 가져오고 어떻게 빌드해서 시스템에 설치를 하는지, 패치는 어떻게 보내면 되는지와 같은 것들을 정리해 볼까 합니다.
So many environments and users are using Linux kernel. That&amp;rsquo;s why it is so fun and mysterious to touch and analyze it. Maybe it is the fun of hack.</description>
    </item>
    
    <item>
      <title>GCMA: Guaranteed Contiguous Memory Allocator</title>
      <link>https://sjp38.github.io/post/gcma/</link>
      <pubDate>Sat, 14 Jan 2017 07:11:23 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/gcma/</guid>
      <description>GCMA (Guaranteed Contiguous Memory Allocator) is a contiguous memory allocator for Linux kernel that guarantees fast latency, success of allocation, and reasonable system memory utilization. Our evaluation on Raspberry Pi 2 shows 15 to 130 times faster and more predictable allocation latency without system performance degradation compared to Linux v3.18 default CMA.
The project has been introduced by Linux Foundation Korea Forum 2014[1] and Embedded Operating Systems Workshop 2015[2]. A paper about the project has been published by proceeding of Embedded Operating Systems Workshop 2015 and 45th issue of ACM SIGBED Review.</description>
    </item>
    
  </channel>
</rss>