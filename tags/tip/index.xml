<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Tip on hacklog</title>
    <link>https://sjp38.github.io/tags/tip/</link>
    <description>Recent content in Tip on hacklog</description>
    <image>
      <title>hacklog</title>
      <url>https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.131.0</generator>
    <language>en</language>
    <lastBuildDate>Wed, 13 May 2020 06:40:03 +0200</lastBuildDate>
    <atom:link href="https://sjp38.github.io/tags/tip/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sphynx document on Github pages Needs `.nojekyll` File</title>
      <link>https://sjp38.github.io/posts/en/sphynx_doc_on_github_pages_needs_nojekyll/</link>
      <pubDate>Wed, 13 May 2020 06:40:03 +0200</pubDate>
      <guid>https://sjp38.github.io/posts/en/sphynx_doc_on_github_pages_needs_nojekyll/</guid>
      <description>I recently tried to upload the Linux kernel document which is generated in html form using the Sphynx build system[1] on a Github page[2] so that people can read DAMON[3] document from everywhere. The upload was very easy. I simply created the repo, put the generated html doc at Documentation/output/ into the repo and pushed. However, the theme was not applied.
Github assumes every Github pages to be based on Jekyll[4], and because every files and directories starting with underscores are handled special in Jekyll, some directories Sphynx created were ignored.</description>
    </item>
    <item>
      <title>Sphynx document on Github pages Needs `.nojekyll` File</title>
      <link>https://sjp38.github.io/posts/ko/sphynx_doc_on_github_pages_needs_nojekyll/</link>
      <pubDate>Wed, 13 May 2020 06:40:03 +0200</pubDate>
      <guid>https://sjp38.github.io/posts/ko/sphynx_doc_on_github_pages_needs_nojekyll/</guid>
      <description>최근, Sphynx 빌드 시스템[1] 을 사용해 html 로 빌드한 리눅스 커널 문서를 Github page[2] 에 올리려 했습니다. DAMON[3] 문서를 어디서나 볼 수 있게 하려 함이었는데요. 업로드는 쉬웠습니다. 리포지토리 만들고, Sphynx 로 빌드된 Documentation/output/ 의 문서를 여기에 집어넣고 푸시했죠. 하지만, 테마가 적용되지 않아 보기 안좋더군요.
Github 은 모든 Github page 들이 Jekyll[4] 에 기반하고 있다고 생각하며, Jekyll 에서는 _ 로 시작하는 이름의 모든 파일과 디렉토리가 특수하게 처리되기 때문에, Sphynx 에서 생성한 일부 디렉토리가 무시되고 있었습니다.</description>
    </item>
    <item>
      <title>Integrate external git repository with its history</title>
      <link>https://sjp38.github.io/posts/ko/integrate_external_git_repository_with_history/</link>
      <pubDate>Thu, 27 Jun 2019 17:02:49 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/ko/integrate_external_git_repository_with_history/</guid>
      <description>프로젝트 a 와 프로젝트 b 를 병렬로 진행하고 있었는데, 두개의 리포지토리를 합치고 싶어지는 경우가 있습니다. 예컨대 프로젝트 a 의 성격이 보다 범용이 되었고 프로젝트 b 는 프로젝트 a 를 위한 도구적 성격이 되는 경우가 있겠죠. a 프로젝트에 &amp;lsquo;b&amp;rsquo; 디렉토리를 만들고 그 아래 기존 프로젝트 b 의 파일들을 위치하고 싶습니다. 하지만 기존 b 프로젝트의 git 히스토리들도 유지하고 싶습니다. 비슷한 사례로 리눅스 커널 메모리 모델 프로젝트는 별도의 리포지토리[1] 로 개발되었지만 리눅스 업스트림 리포지토리의 tools/ 디렉토리 아래로 머지[2] 되었는데, 이 때 기존 개발 히스토리를 유지했죠.</description>
    </item>
    <item>
      <title>Linux Kernel Debugging Using QEMU</title>
      <link>https://sjp38.github.io/posts/en/qemu_kernel_debugging/</link>
      <pubDate>Mon, 07 May 2018 18:21:01 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/en/qemu_kernel_debugging/</guid>
      <description>You can use classical debugger for your Linux kernel programming, though Torvalds doesn&amp;rsquo;t like it. I also do not prefer such use of debuggers, but admit that sometimes debuggers are quite useful. ;)
There are several ways to debug Linux kernel, but one of above is to set up a Linux virtual machine using QEMU and debugging the Linux kernel of the virtual machine from the host machine. This post summarises how to debug the Linux kernel in this way.</description>
    </item>
    <item>
      <title>QEMU 를 사용한 리눅스 커널 디버깅</title>
      <link>https://sjp38.github.io/posts/ko/qemu_kernel_debugging/</link>
      <pubDate>Mon, 07 May 2018 18:21:01 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/ko/qemu_kernel_debugging/</guid>
      <description>토발즈는 좋아하지 않지만, 리눅스 커널 프로그래밍에도 디버거를 사용할 수 있습니다. 저도 디버거 사용을 좋아하지는 않는 편이지만, 경우에 따라선 디버거를 사용하는게 좋을 때도 있고 취향은 존중되어야죠. ;)
커널 디버깅 방법은 여러가지가 있는데, 그 중 하나는 QEMU 등을 이용한 리눅스 가상 머신을 띄워 두고, 호스트 머신에서 해당 가상 머신의 리눅스 커널을 디버깅 하는 방법입니다. 이 글에선 이렇게 디버깅 하는 방법을 간단히 정리해 봅니다.
테스트 환경 글 작성 과정에서 테스트에 사용한 주요 소프트웨어들과 버전은 다음과 같습니다.</description>
    </item>
    <item>
      <title>Kernel text addresses removed from calltrace</title>
      <link>https://sjp38.github.io/posts/en/kernel-text-addresses-removed-from-calltrace/</link>
      <pubDate>Fri, 16 Jun 2017 16:46:09 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/en/kernel-text-addresses-removed-from-calltrace/</guid>
      <description>최근 커널은 stakc dump 에서 콜 트레이스(Call Trace) 에 각 코드의 메모리 어드레스를 찍어주지 않습니다. 이에 대해 포스팅을 해봅니다.
Call Trace 커널은 문제가 발생하거나 하면 문제의 원인을 찾을 수 있는 다양한 정보를 담고 있는 stack dump 를 로그로 뿌려 줍니다. 문제의 원인을 찾는데 매우 소중한 정보입니다. 그 정보 중에서도 중요한 것 중 하나가 콜 트레이스로, 이 문제의 순간에 오기까지 어느 함수의 어느 지점에서 어느 함수를 호출해서 여기까지 왔는가를 담는 정보입니다.</description>
    </item>
    <item>
      <title>Kernel text addresses removed from calltrace</title>
      <link>https://sjp38.github.io/posts/ko/kernel-text-addresses-removed-from-calltrace/</link>
      <pubDate>Fri, 16 Jun 2017 16:46:09 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/ko/kernel-text-addresses-removed-from-calltrace/</guid>
      <description>최근 커널은 stakc dump 에서 콜 트레이스(Call Trace) 에 각 코드의 메모리 어드레스를 찍어주지 않습니다. 이에 대해 포스팅을 해봅니다.
Call Trace 커널은 문제가 발생하거나 하면 문제의 원인을 찾을 수 있는 다양한 정보를 담고 있는 stack dump 를 로그로 뿌려 줍니다. 문제의 원인을 찾는데 매우 소중한 정보입니다. 그 정보 중에서도 중요한 것 중 하나가 콜 트레이스로, 이 문제의 순간에 오기까지 어느 함수의 어느 지점에서 어느 함수를 호출해서 여기까지 왔는가를 담는 정보입니다.</description>
    </item>
    <item>
      <title>원격 데스크탑의 clipboard 를 ssh 와 xclip 으로 복사해오기</title>
      <link>https://sjp38.github.io/posts/ko/xclip_copy_remote_clipboard/</link>
      <pubDate>Fri, 31 Mar 2017 13:53:54 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/ko/xclip_copy_remote_clipboard/</guid>
      <description>여러개의 리눅스 데스크탑 PC 를 한 책상 위에서 사용하는 경우가 있다. 이 때, 한 PC 에서 Ctrl-C 해서 clipboard 에 복사한 내용을 다른쪽 PC 에서 Ctrl-V 로 붙여넣고 싶은 경우가 있다. 여러가지 해결책이 있겠으나, 다음과 같이 ssh 와 xclip 을 사용해서 해결할 수도 있다:
$ ssh &amp;lt;username&amp;gt;@&amp;lt;remote host&amp;gt; &amp;#39;DISPLAY=:0 xclip -o -selection clipboard&amp;#39; | \ xclip -i -selection clipboard 참고: http://askubuntu.com/questions/513442/can-two-pcs-with-ubuntu-share-the-clipboard-buffer</description>
    </item>
    <item>
      <title>Updating Google Chrome on Fedora 23</title>
      <link>https://sjp38.github.io/posts/en/fedora-chrome-update/</link>
      <pubDate>Mon, 20 Mar 2017 22:24:26 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/en/fedora-chrome-update/</guid>
      <description>I am using Fedora 23 laptop and installed stable version Google Chrome from its official website [0]. In this case, just using Updates of Fedora Software program doesn&amp;rsquo;t update Chrome automatically. For the case, follow below commands to update your Chrome:
$ sudo dnf update google-chrome-stable ... $ sudo killall chrome $ google-chrome-stable The second killall command is necessary because Chrome doesn&amp;rsquo;t kill its process by just cliking Close button. Or, you may reboot your computer but you wouldn&amp;rsquo;t like that.</description>
    </item>
    <item>
      <title>Updating Google Chrome on Fedora 23</title>
      <link>https://sjp38.github.io/posts/ko/fedora-chrome-update/</link>
      <pubDate>Mon, 20 Mar 2017 22:24:26 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/ko/fedora-chrome-update/</guid>
      <description>랩톱에 Fedora 23 을 깔고 크롬을 공식 홈페이지 [0] 에서 다운받아 메인 브라우저로 사용하고 있습니다. 그런데 이렇게 설치한 경우에는 단순히 Fedora Software 프로그램의 Updates 기능을 통해 업데이트가 되지 않더군요. 이런 경우에는 다음의 커맨드를 통해 직접 업데이트를 할 수 있습니다:
$ sudo dnf update google-chrome-stable ... $ sudo killall chrome $ google-chrome-stable 두번째의 killall 커맨드는 Chrome 프로세스들이 닫기 버튼을 누르는 것만으로는 모두 종료되지 않기 때문에 명시적으로 종료시키기 위해 필요합니다. 컴퓨터를 아예 리붓 하는 방법도 있겠지만 별로 그러고 싶지는 않을테지요.</description>
    </item>
    <item>
      <title>Using arping to know ip-MAC mapping</title>
      <link>https://sjp38.github.io/posts/en/arping-howto/</link>
      <pubDate>Tue, 07 Mar 2017 19:41:16 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/en/arping-howto/</guid>
      <description>You can use arping to know IP address to MAC address mapping of your local network. Usage is simple:
arping [-AbDfhqUV] [-c count] [-w deadline] [-s source] -I interface destination For example, you may use the command as below:
$ arping -I eth0 10.0.0.1 ARPING 10.0.0.1 from 10.0.0.2 eth0 Unicast reply from 10.0.0.1 [11:22:33:44:55:66] 0.123ms Unicast reply from 10.0.0.1 [11:22:33:44:55:66] 0.251ms ... Secret of the tool is ARP protocol [1]. To know the MAC address of the machine that has a specific IP address, IP protocol layer uses the protocol.</description>
    </item>
    <item>
      <title>Using arping to know ip-MAC mapping</title>
      <link>https://sjp38.github.io/posts/ko/arping-howto/</link>
      <pubDate>Tue, 07 Mar 2017 19:41:16 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/ko/arping-howto/</guid>
      <description>로컬 네트워크에서 어떤 IP 주소가 어떤 MAC 어드레스에 매핑되는지 알기 위해 arping 을 사용할 수 있습니다. 사용법은 간단합니다:
arping [-AbDfhqUV] [-c count] [-w deadline] [-s source] -I interface destination 예를 들면, 다음과 같습니다:
$ arping -I eth0 10.0.0.1 ARPING 10.0.0.1 from 10.0.0.2 eth0 Unicast reply from 10.0.0.1 [11:22:33:44:55:66] 0.123ms Unicast reply from 10.0.0.1 [11:22:33:44:55:66] 0.251ms ... 이 툴의 동작 원리는 ARP 프로토콜 [1] 입니다. IP 프로토콜 레이어는 이 프로토콜을 사용해 특정 IP 주소를 사용하는 기계의 MAC 어드레스를 파악하고 이 주소를 아랫단의 Ethernet 레이어에 보냅니다.</description>
    </item>
    <item>
      <title>uninstall kernel</title>
      <link>https://sjp38.github.io/posts/ko/uninstall-kernel/</link>
      <pubDate>Fri, 20 Jan 2017 13:18:56 +0900</pubDate>
      <guid>https://sjp38.github.io/posts/ko/uninstall-kernel/</guid>
      <description>테스트 등을 위해 소스코드로부터 커널을 직접 빌드, 설치하기 시작하면 어느새 수많은 커널이 설치되어 있는 것을 확인할 수 있다. 삭제를 위해선 make install 로 만들어진 파일들을 직접 제거하고 grub 을 업데이트 해줘야 한다.
예를 들어 시스템이 현재 부팅되어 있는 버전의 커널을 언인스톨하고자 한다면 다음의 일련의 커맨드를 입력하면 된다:
# rm /boot/vmlinuz-$(uname -r) # rm /boot/initrd.img-$(uname -r) # rm /boot/System.map-$(uname -r) # rm /boot/config-$(uname -r) # rm -fr /lib/modules/$(uname -r) # rm /var/lib/initramfs-tools/$(uname -r) # update-grub2 다른 버전의 설치되어있는 커널을 제거하고 싶다면 위의 $(uname -r) 부분을 제거하고자 하는 커널 버전으로 대체하면 된다.</description>
    </item>
  </channel>
</rss>
