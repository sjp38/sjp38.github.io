<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kernel | hacklog</title>
    <link>https://sjp38.github.io/ko/tags/kernel/</link>
      <atom:link href="https://sjp38.github.io/ko/tags/kernel/index.xml" rel="self" type="application/rss+xml" />
    <description>kernel</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>ko-kr</language><lastBuildDate>Sun, 15 Jan 2023 10:34:06 -0800</lastBuildDate>
    <image>
      <url>https://sjp38.github.io/img/tux.png</url>
      <title>kernel</title>
      <link>https://sjp38.github.io/ko/tags/kernel/</link>
    </image>
    
    <item>
      <title>DAMON Evaluation</title>
      <link>https://sjp38.github.io/ko/post/damon_evaluation/</link>
      <pubDate>Sun, 15 Jan 2023 10:34:06 -0800</pubDate>
      <guid>https://sjp38.github.io/ko/post/damon_evaluation/</guid>
      <description>&lt;p&gt;DAMON is lightweight.  It increases system memory usage by 0.39% and slows
target workloads down by 1.16%.&lt;/p&gt;
&lt;p&gt;DAMON is accurate and useful for memory management optimizations.  An
experimental DAMON-based operation scheme for THP, namely &amp;lsquo;ethp&amp;rsquo;, removes
76.15% of THP memory overheads while preserving 51.25% of THP speedup.  Another
experimental DAMON-based &amp;lsquo;proactive reclamation&amp;rsquo; implementation, namely &amp;lsquo;prcl&amp;rsquo;,
reduces 93.38% of residential sets and 23.63% of system memory footprint while
incurring only 1.22% runtime overhead in the best case (parsec3/freqmine).&lt;/p&gt;
&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;
&lt;p&gt;On QEMU/KVM based virtual machines utilizing 130GB of RAM and 36 vCPUs hosted
by AWS EC2 i3.metal instances that running a kernel that v24 DAMON patchset is
applied, I measure runtime and consumed system memory while running various
realistic workloads with several configurations.  From each of PARSEC3 [3] and
SPLASH-2X [4] benchmark suites I pick 12 workloads, so I use 24 workloads in
total.  I use another wrapper scripts [5] for convenient setup and run of the
workloads.&lt;/p&gt;
&lt;h2 id=&#34;measurement&#34;&gt;Measurement&lt;/h2&gt;
&lt;p&gt;For the measurement of the amount of consumed memory in system global scope, I
drop caches before starting each of the workloads and monitor &amp;lsquo;MemFree&amp;rsquo; in the
&amp;lsquo;/proc/meminfo&amp;rsquo; file.  To make results more stable, I repeat the runs 5 times
and average results.&lt;/p&gt;
&lt;h2 id=&#34;configurations&#34;&gt;Configurations&lt;/h2&gt;
&lt;p&gt;The configurations I use are as below.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;orig: Linux v5.10 with &amp;lsquo;madvise&amp;rsquo; THP policy&lt;/li&gt;
&lt;li&gt;rec: &amp;lsquo;orig&amp;rsquo; plus DAMON running with virtual memory access recording&lt;/li&gt;
&lt;li&gt;prec: &amp;lsquo;orig&amp;rsquo; plus DAMON running with physical memory access recording&lt;/li&gt;
&lt;li&gt;thp: same with &amp;lsquo;orig&amp;rsquo;, but use &amp;lsquo;always&amp;rsquo; THP policy&lt;/li&gt;
&lt;li&gt;ethp: &amp;lsquo;orig&amp;rsquo; plus a DAMON operation scheme, &amp;lsquo;efficient THP&amp;rsquo;&lt;/li&gt;
&lt;li&gt;prcl: &amp;lsquo;orig&amp;rsquo; plus a DAMON operation scheme, &amp;lsquo;proactive reclaim [6]&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I use &amp;lsquo;rec&amp;rsquo; for measurement of DAMON overheads to target workloads and system
memory.  &amp;lsquo;prec&amp;rsquo; is for physical memory monitroing and recording.  It monitors
17GB sized &amp;lsquo;System RAM&amp;rsquo; region.  The remaining configs including &amp;lsquo;thp&amp;rsquo;, &amp;lsquo;ethp&amp;rsquo;,
and &amp;lsquo;prcl&amp;rsquo; are for measurement of DAMON monitoring accuracy.&lt;/p&gt;
&lt;p&gt;&amp;lsquo;ethp&amp;rsquo; and &amp;lsquo;prcl&amp;rsquo; are simple DAMON-based operation schemes developed for
proof of concepts of DAMON.  &amp;lsquo;ethp&amp;rsquo; reduces memory space waste of THP [1,2],
by using DAMON for the decision of promotions and demotion for huge pages,
while &amp;lsquo;prcl&amp;rsquo; is as similar as the original work.  For example, those can be
implemented as below::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# format: &amp;lt;min/max size&amp;gt; &amp;lt;min/max frequency (0-100)&amp;gt; &amp;lt;min/max age&amp;gt; &amp;lt;action&amp;gt;
# ethp: Use huge pages if a region shows &amp;gt;=5% access rate, use regular
# pages if a region &amp;gt;=2MB shows 0 access rate for &amp;gt;=7 seconds
min     max     5       max     min     max     hugepage
2M      max     min     min     7s      max     nohugepage

# prcl: If a region &amp;gt;=4KB shows 0 access rate for &amp;gt;=5 seconds, page out.
4K      max     0       0       5s     max     pageout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that these examples are designed with my only straightforward intuition
because those are for only proof of concepts and monitoring accuracy of DAMON.
In other words, those are not for production.  For production use, those should
be more tuned.  For automation of such tuning, you can use a user space tool
called DAMOOS [8].  For the evaluation, we use &amp;lsquo;ethp&amp;rsquo; as same to above
example, but we use DAMOOS-tuned &amp;lsquo;prcl&amp;rsquo; for each workload.&lt;/p&gt;
&lt;p&gt;The evaluation is done using the tests package for DAMON, &lt;code&gt;damon-tests&lt;/code&gt; [7].
Using it, you can do the evaluation and generate a report on your own.&lt;/p&gt;
&lt;p&gt;[1] &amp;ldquo;Redis latency problems troubleshooting&amp;rdquo;, &lt;a href=&#34;https://redis.io/topics/latency&#34;&gt;https://redis.io/topics/latency&lt;/a&gt;&lt;br&gt;
[2] &amp;ldquo;Disable Transparent Huge Pages (THP)&amp;quot;,
&lt;a href=&#34;https://docs.mongodb.com/manual/tutorial/transparent-huge-pages/&#34;&gt;https://docs.mongodb.com/manual/tutorial/transparent-huge-pages/&lt;/a&gt;&lt;br&gt;
[3] &amp;ldquo;The PARSEC Becnhmark Suite&amp;rdquo;, &lt;a href=&#34;https://parsec.cs.princeton.edu/index.htm&#34;&gt;https://parsec.cs.princeton.edu/index.htm&lt;/a&gt;&lt;br&gt;
[4] &amp;ldquo;SPLASH-2x&amp;rdquo;, &lt;a href=&#34;https://parsec.cs.princeton.edu/parsec3-doc.htm#splash2x&#34;&gt;https://parsec.cs.princeton.edu/parsec3-doc.htm#splash2x&lt;/a&gt;&lt;br&gt;
[5] &amp;ldquo;parsec3_on_ubuntu&amp;rdquo;, &lt;a href=&#34;https://github.com/sjp38/parsec3_on_ubuntu&#34;&gt;https://github.com/sjp38/parsec3_on_ubuntu&lt;/a&gt;&lt;br&gt;
[6] &amp;ldquo;Proactively reclaiming idle memory&amp;rdquo;, &lt;a href=&#34;https://lwn.net/Articles/787611/&#34;&gt;https://lwn.net/Articles/787611/&lt;/a&gt;&lt;br&gt;
[7] &amp;ldquo;damon-tests&amp;rdquo;, &lt;a href=&#34;https://github.com/awslabs/damon-tests&#34;&gt;https://github.com/awslabs/damon-tests&lt;/a&gt;&lt;br&gt;
[8] &amp;ldquo;DAMOOS&amp;rdquo;, &lt;a href=&#34;https://github.com/awslabs/damoos&#34;&gt;https://github.com/awslabs/damoos&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;results&#34;&gt;Results&lt;/h1&gt;
&lt;p&gt;Below two tables show the measurement results.  The runtimes are in seconds
while the memory usages are in KiB.  Each configuration except &amp;lsquo;orig&amp;rsquo; shows
its overhead relative to &amp;lsquo;orig&amp;rsquo; in percent within parenthesizes.::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;runtime                 orig     rec      (overhead) prec     (overhead) thp      (overhead) ethp     (overhead) prcl     (overhead)
parsec3/blackscholes    139.658  140.168  (0.37)     139.385  (-0.20)    138.367  (-0.92)    139.279  (-0.27)    147.024  (5.27)
parsec3/bodytrack       123.788  124.622  (0.67)     123.636  (-0.12)    125.115  (1.07)     123.840  (0.04)     141.928  (14.65)
parsec3/canneal         207.491  210.318  (1.36)     217.927  (5.03)     174.287  (-16.00)   202.609  (-2.35)    225.483  (8.67)
parsec3/dedup           18.292   18.301   (0.05)     18.378   (0.47)     18.264   (-0.15)    18.298   (0.03)     20.541   (12.30)
parsec3/facesim         343.893  340.286  (-1.05)    338.217  (-1.65)    332.953  (-3.18)    333.840  (-2.92)    365.650  (6.33)
parsec3/fluidanimate    339.959  326.886  (-3.85)    330.286  (-2.85)    331.239  (-2.57)    326.011  (-4.10)    341.684  (0.51)
parsec3/freqmine        445.987  436.332  (-2.16)    435.946  (-2.25)    435.704  (-2.31)    437.595  (-1.88)    451.414  (1.22)
parsec3/raytrace        184.106  182.158  (-1.06)    182.056  (-1.11)    183.180  (-0.50)    183.545  (-0.30)    202.197  (9.83)
parsec3/streamcluster   599.990  674.091  (12.35)    617.314  (2.89)     521.864  (-13.02)   551.971  (-8.00)    696.127  (16.02)
parsec3/swaptions       220.462  222.637  (0.99)     220.449  (-0.01)    219.921  (-0.25)    221.607  (0.52)     223.956  (1.59)
parsec3/vips            87.767   88.700   (1.06)     87.461   (-0.35)    87.466   (-0.34)    87.875   (0.12)     91.768   (4.56)
parsec3/x264            110.843  117.856  (6.33)     113.023  (1.97)     108.665  (-1.97)    115.434  (4.14)     117.811  (6.29)
splash2x/barnes         131.441  129.275  (-1.65)    128.341  (-2.36)    119.317  (-9.22)    126.199  (-3.99)    147.602  (12.30)
splash2x/fft            59.705   58.382   (-2.22)    58.858   (-1.42)    45.949   (-23.04)   59.939   (0.39)     64.548   (8.11)
splash2x/lu_cb          132.552  131.604  (-0.72)    131.846  (-0.53)    132.320  (-0.18)    132.100  (-0.34)    140.289  (5.84)
splash2x/lu_ncb         150.215  149.670  (-0.36)    149.646  (-0.38)    148.823  (-0.93)    149.416  (-0.53)    152.338  (1.41)
splash2x/ocean_cp       84.033   76.405   (-9.08)    75.104   (-10.63)   73.487   (-12.55)   77.789   (-7.43)    77.380   (-7.92)
splash2x/ocean_ncp      153.833  154.247  (0.27)     156.227  (1.56)     106.619  (-30.69)   139.299  (-9.45)    165.030  (7.28)
splash2x/radiosity      143.566  143.654  (0.06)     142.426  (-0.79)    141.193  (-1.65)    141.740  (-1.27)    157.817  (9.93)
splash2x/radix          49.984   49.996   (0.02)     50.519   (1.07)     46.573   (-6.82)    50.724   (1.48)     50.695   (1.42)
splash2x/raytrace       133.238  134.337  (0.83)     134.389  (0.86)     134.833  (1.20)     131.073  (-1.62)    145.541  (9.23)
splash2x/volrend        121.700  120.652  (-0.86)    120.560  (-0.94)    120.629  (-0.88)    119.581  (-1.74)    129.422  (6.35)
splash2x/water_nsquared 370.771  375.236  (1.20)     376.829  (1.63)     355.592  (-4.09)    354.087  (-4.50)    419.606  (13.17)
splash2x/water_spatial  133.295  132.931  (-0.27)    132.762  (-0.40)    133.090  (-0.15)    133.809  (0.39)     153.647  (15.27)
total                   4486.580 4538.750 (1.16)     4481.600 (-0.11)    4235.430 (-5.60)    4357.660 (-2.87)    4829.510 (7.64)


memused.avg             orig         rec          (overhead) prec         (overhead) thp          (overhead) ethp         (overhead) prcl         (overhead)
parsec3/blackscholes    1828693.600  1834084.000  (0.29)     1823839.800  (-0.27)    1819296.600  (-0.51)    1830281.800  (0.09)     1603975.800  (-12.29)
parsec3/bodytrack       1424963.400  1440085.800  (1.06)     1438384.200  (0.94)     1421718.400  (-0.23)    1432834.600  (0.55)     1439283.000  (1.00)
parsec3/canneal         1036782.600  1052828.800  (1.55)     1050148.600  (1.29)     1035104.400  (-0.16)    1051145.400  (1.39)     1050019.400  (1.28)
parsec3/dedup           2511841.400  2507374.000  (-0.18)    2472450.600  (-1.57)    2523557.600  (0.47)     2508912.000  (-0.12)    2493347.200  (-0.74)
parsec3/facesim         537769.800   550740.800   (2.41)     548683.600   (2.03)     543547.800   (1.07)     560556.600   (4.24)     482782.600   (-10.23)
parsec3/fluidanimate    570268.600   585598.000   (2.69)     579837.800   (1.68)     571433.000   (0.20)     582112.800   (2.08)     470073.400   (-17.57)
parsec3/freqmine        982941.400   996253.200   (1.35)     993919.800   (1.12)     990531.800   (0.77)     1000994.400  (1.84)     750685.800   (-23.63)
parsec3/raytrace        1737446.000  1749908.800  (0.72)     1741183.800  (0.22)     1726674.800  (-0.62)    1748530.200  (0.64)     1552275.600  (-10.66)
parsec3/streamcluster   115857.000   155194.400   (33.95)    158272.800   (36.61)    122125.200   (5.41)     134545.600   (16.13)    133448.600   (15.18)
parsec3/swaptions       13694.200    28451.800    (107.76)   28464.600    (107.86)   12797.800    (-6.55)    25328.200    (84.96)    28138.400    (105.48)
parsec3/vips            2976126.400  3002408.600  (0.88)     3008218.800  (1.08)     2978258.600  (0.07)     2995428.600  (0.65)     2936338.600  (-1.34)
parsec3/x264            3233886.200  3258790.200  (0.77)     3248355.000  (0.45)     3232070.000  (-0.06)    3256360.200  (0.69)     3254707.400  (0.64)
splash2x/barnes         1210470.600  1211918.600  (0.12)     1204507.000  (-0.49)    1210892.800  (0.03)     1217414.800  (0.57)     944053.400   (-22.01)
splash2x/fft            9697440.000  9604535.600  (-0.96)    9210571.800  (-5.02)    9867368.000  (1.75)     9637571.800  (-0.62)    9804092.000  (1.10)
splash2x/lu_cb          510680.400   521792.600   (2.18)     517724.600   (1.38)     513500.800   (0.55)     519980.600   (1.82)     351787.000   (-31.11)
splash2x/lu_ncb         512896.200   529353.600   (3.21)     521248.600   (1.63)     513493.200   (0.12)     523793.400   (2.12)     418701.600   (-18.37)
splash2x/ocean_cp       3320800.200  3313688.400  (-0.21)    3225585.000  (-2.87)    3359032.200  (1.15)     3316591.800  (-0.13)    3304702.200  (-0.48)
splash2x/ocean_ncp      3915132.400  3917401.000  (0.06)     3884086.400  (-0.79)    7050398.600  (80.08)    4532528.600  (15.77)    3920395.800  (0.13)
splash2x/radiosity      1456908.200  1467611.800  (0.73)     1453612.600  (-0.23)    1466695.400  (0.67)     1467495.600  (0.73)     421197.600   (-71.09)
splash2x/radix          2345874.600  2318202.200  (-1.18)    2261499.200  (-3.60)    2438228.400  (3.94)     2373697.800  (1.19)     2336605.600  (-0.40)
splash2x/raytrace       43258.800    57624.200    (33.21)    55164.600    (27.52)    46204.400    (6.81)     60475.000    (39.80)    48865.400    (12.96)
splash2x/volrend        149615.000   163809.400   (9.49)     162115.400   (8.36)     149119.600   (-0.33)    162747.800   (8.78)     157734.600   (5.43)
splash2x/water_nsquared 40384.400    54848.600    (35.82)    53796.600    (33.21)    41455.800    (2.65)     53226.400    (31.80)    58260.600    (44.27)
splash2x/water_spatial  670580.200   680444.200   (1.47)     670020.400   (-0.08)    668262.400   (-0.35)    678552.000   (1.19)     372931.000   (-44.39)
total                   40844300.000 41002900.000 (0.39)     40311600.000 (-1.30)    44301900.000 (8.47)     41671052.000 (2.02)     38334431.000 (-6.14)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;damon-overheads&#34;&gt;DAMON Overheads&lt;/h2&gt;
&lt;p&gt;In total, DAMON virtual memory access recording feature (&amp;lsquo;rec&amp;rsquo;) incurs 1.16%
runtime overhead and 0.39% memory space overhead.  Even though the size of the
monitoring target region becomes much larger with the physical memory access
recording (&amp;lsquo;prec&amp;rsquo;), it still shows only modest amount of overhead (-0.11% for
runtime and -1.30% for memory footprint).&lt;/p&gt;
&lt;p&gt;For a convenient test run of &amp;lsquo;rec&amp;rsquo; and &amp;lsquo;prec&amp;rsquo;, I use a Python wrapper.  The
wrapper constantly consumes about 10-15MB of memory.  This becomes a high
memory overhead if the target workload has a small memory footprint.
Nonetheless, the overheads are not from DAMON, but from the wrapper, and thus
should be ignored.  This fake memory overhead continues in &amp;lsquo;ethp&amp;rsquo; and &amp;lsquo;prcl&amp;rsquo;,
as those configurations are also using the Python wrapper.&lt;/p&gt;
&lt;h2 id=&#34;efficient-thp&#34;&gt;Efficient THP&lt;/h2&gt;
&lt;p&gt;THP &amp;lsquo;always&amp;rsquo; enabled policy achieves 5.60% speedup but incurs 8.47% memory
overhead.  It achieves 30.69% speedup in the best case, but 80.08% memory
overhead in the worst case.  Interestingly, both the best and worst-case are
with &amp;lsquo;splash2x/ocean_ncp&amp;rsquo;).&lt;/p&gt;
&lt;p&gt;The 2-lines implementation of data access monitoring based THP version (&amp;lsquo;ethp&amp;rsquo;)
shows 2.87% speedup and 2.02% memory overhead.  In other words, &amp;lsquo;ethp&amp;rsquo; removes
76.15% of THP memory waste while preserving 51.25% of THP speedup in total.  In
the case of the &amp;lsquo;splash2x/ocean_ncp&amp;rsquo;, &amp;lsquo;ethp&amp;rsquo; removes 80.30% of THP memory waste
while preserving 30.79% of THP speedup.&lt;/p&gt;
&lt;h2 id=&#34;proactive-reclamation&#34;&gt;Proactive Reclamation&lt;/h2&gt;
&lt;p&gt;As similar to the original work, I use 4G &amp;lsquo;zram&amp;rsquo; swap device for this
configuration.  Also note that we use DAMOOS-tuned ethp schemes for each
workload.&lt;/p&gt;
&lt;p&gt;In total, our 1 line implementation of Proactive Reclamation, &amp;lsquo;prcl&amp;rsquo;, incurred
7.64% runtime overhead in total while achieving 6.14% system memory footprint
reduction.  Even in the worst case, the runtime overhead was only 16.02%.&lt;/p&gt;
&lt;p&gt;Nonetheless, as the memory usage is calculated with &amp;lsquo;MemFree&amp;rsquo; in
&amp;lsquo;/proc/meminfo&amp;rsquo;, it contains the SwapCached pages.  As the swapcached pages can
be easily evicted, I also measured the residential set size of the workloads::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rss.avg                 orig         rec          (overhead) prec         (overhead) thp          (overhead) ethp         (overhead) prcl         (overhead)
parsec3/blackscholes    587536.800   585720.000   (-0.31)    586233.400   (-0.22)    587045.400   (-0.08)    586753.400   (-0.13)    252207.400   (-57.07)
parsec3/bodytrack       32302.200    32290.600    (-0.04)    32261.800    (-0.13)    32215.800    (-0.27)    32173.000    (-0.40)    6798.800     (-78.95)
parsec3/canneal         842370.600   841443.400   (-0.11)    844012.400   (0.19)     838074.400   (-0.51)    841700.800   (-0.08)    840804.000   (-0.19)
parsec3/dedup           1180414.800  1164634.600  (-1.34)    1188886.200  (0.72)     1207821.000  (2.32)     1193896.200  (1.14)     572359.200   (-51.51)
parsec3/facesim         311848.400   311709.800   (-0.04)    311790.800   (-0.02)    317345.800   (1.76)     315443.400   (1.15)     188488.000   (-39.56)
parsec3/fluidanimate    531868.000   531885.600   (0.00)     531828.800   (-0.01)    532988.000   (0.21)     532959.600   (0.21)     415153.200   (-21.94)
parsec3/freqmine        552491.000   552718.600   (0.04)     552807.200   (0.06)     556574.200   (0.74)     554374.600   (0.34)     36573.400    (-93.38)
parsec3/raytrace        879683.400   880752.200   (0.12)     879907.000   (0.03)     870631.000   (-1.03)    880952.200   (0.14)     293119.200   (-66.68)
parsec3/streamcluster   110991.800   110937.200   (-0.05)    110964.600   (-0.02)    115606.800   (4.16)     116199.000   (4.69)     110108.200   (-0.80)
parsec3/swaptions       5665.000     5718.400     (0.94)     5720.600     (0.98)     5682.200     (0.30)     5628.600     (-0.64)    3613.800     (-36.21)
parsec3/vips            32143.600    31823.200    (-1.00)    31912.200    (-0.72)    33164.200    (3.18)     33925.800    (5.54)     27813.600    (-13.47)
parsec3/x264            81534.000    81811.000    (0.34)     81708.400    (0.21)     83052.400    (1.86)     83758.800    (2.73)     81691.800    (0.19)
splash2x/barnes         1220515.200  1218291.200  (-0.18)    1217699.600  (-0.23)    1228551.600  (0.66)     1220669.800  (0.01)     681096.000   (-44.20)
splash2x/fft            9915850.400  10036461.000 (1.22)     9881242.800  (-0.35)    10334603.600 (4.22)     10006993.200 (0.92)     8975181.200  (-9.49)
splash2x/lu_cb          511327.200   511679.000   (0.07)     511761.600   (0.08)     511971.600   (0.13)     511711.200   (0.08)     338005.000   (-33.90)
splash2x/lu_ncb         511505.000   506816.800   (-0.92)    511392.800   (-0.02)    496623.000   (-2.91)    511410.200   (-0.02)    404734.000   (-20.87)
splash2x/ocean_cp       3398834.000  3405017.800  (0.18)     3415287.800  (0.48)     3443604.600  (1.32)     3416264.200  (0.51)     3387134.000  (-0.34)
splash2x/ocean_ncp      3947092.800  3939805.400  (-0.18)    3952311.600  (0.13)     7165858.800  (81.55)    4610075.000  (16.80)    3944753.400  (-0.06)
splash2x/radiosity      1475024.000  1474053.200  (-0.07)    1475032.400  (0.00)     1483718.800  (0.59)     1475919.600  (0.06)     99637.200    (-93.25)
splash2x/radix          2431302.200  2416928.600  (-0.59)    2455596.800  (1.00)     2568526.400  (5.64)     2479966.800  (2.00)     2437406.600  (0.25)
splash2x/raytrace       23274.400    23278.400    (0.02)     23287.200    (0.05)     28828.000    (23.86)    27800.200    (19.45)    5667.000     (-75.65)
splash2x/volrend        44106.800    44151.400    (0.10)     44186.000    (0.18)     45200.400    (2.48)     44751.200    (1.46)     16912.000    (-61.66)
splash2x/water_nsquared 29427.200    29425.600    (-0.01)    29402.400    (-0.08)    28055.400    (-4.66)    28572.400    (-2.90)    13207.800    (-55.12)
splash2x/water_spatial  664312.200   664095.600   (-0.03)    663025.200   (-0.19)    664100.600   (-0.03)    663597.400   (-0.11)    261214.200   (-60.68)
total                   29321300.000 29401500.000 (0.27)     29338300.000 (0.06)     33179900.000 (13.16)    30175600.000 (2.91)     23393600.000 (-20.22)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In total, 20.22% of residential sets were reduced.&lt;/p&gt;
&lt;p&gt;With parsec3/freqmine, &amp;lsquo;prcl&amp;rsquo; reduced 93.38% of residential sets and 23.63% of
system memory usage while incurring only 1.22% runtime overhead.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2022년 오픈소스 커밋 통계</title>
      <link>https://sjp38.github.io/ko/post/my_opensource_commits_stat_2022/</link>
      <pubDate>Sat, 31 Dec 2022 13:48:12 -0800</pubDate>
      <guid>https://sjp38.github.io/ko/post/my_opensource_commits_stat_2022/</guid>
      <description>&lt;p&gt;2022년 마지막 날을 맞아, 저의 간단하고 버그가 많은 스크립트와[1] github 을 통해
저의 오픈소스 커밋 통계를 내봤습니다.&lt;/p&gt;
&lt;h2 id=&#34;리눅스-커널-통계&#34;&gt;리눅스 커널 통계&lt;/h2&gt;
&lt;p&gt;리눅스 커널의 메모리 관리 서브시스템과 커널 전체의 2022년 통계를 위해 제 버그
많은 스크립트를[1] 아래와 같이 돌려 봤습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sjp38.github.io/img/2022_open_source_commits_stat/linux_kernel_authors.png&#34; alt=&#34;script outputs&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;메모리-관리-서브시스템&#34;&gt;메모리 관리 서브시스템&lt;/h3&gt;
&lt;p&gt;2022년 한해, 305명의 사람들이 리눅스 커널 메모리 관리 서브시스템 개발에 참여해
81,631 라인의 변경을 2,135 개 커밋으로 만들었습니다.&lt;/p&gt;
&lt;p&gt;변경한 라인 수와 커밋 갯수 기준으로 저는 그 305명 가운데 두번째와 (10,537
라인) 세번째로 (106 커밋) 큰 변경을 만들었군요.&lt;/p&gt;
&lt;h3 id=&#34;리눅스-커널-전체&#34;&gt;리눅스 커널 전체&lt;/h3&gt;
&lt;p&gt;2022년 한해, 5,286명의 사람들이 리눅스 커널 개발에 참여해 6,841,739 라인의
변경을 77,636 개 커밋으로 만들었습니다.&lt;/p&gt;
&lt;p&gt;변경한 라인 수와 커밋 갯수 기준으로 저는 그 5,286명 가운데 85번째와 (11,907
라인) 89번째로 (155 커밋) 큰 변경을 만들었군요.&lt;/p&gt;
&lt;h2 id=&#34;github&#34;&gt;Github&lt;/h2&gt;
&lt;p&gt;Github 에서 저는 2022년 한해동안 2,316 개 커밋을 만들었습니다.  이건 제 github
메인 계정의 이메일 주소로 만들어진 커밋만 세기 때문에 리눅스 커널을 포함한 일부
프로젝트로의 제 커밋은 포함 안된 수치이긴 합니다.  2022년은 사흘 빼고는 매일
커밋을 만들었군요.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sjp38.github.io/img/2022_open_source_commits_stat/github_sj38_park_3d.png&#34; alt=&#34;github contributions in 3d&#34;&gt;
&lt;img src=&#34;https://sjp38.github.io/img/2022_open_source_commits_stat/github_sj38_park_2d.png&#34; alt=&#34;github contributions in 2d&#34;&gt;&lt;/p&gt;
&lt;p&gt;아무래도 2022년은 제게도 세계에게도 바쁜 해였던 것 같습니다.  저도 커뮤니티도
2023년에도 즐거운 해킹을 이어갈 수 있길 바랍니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://github.com/sjp38/lazybox/blob/master/git_helpers/authors.py&#34;&gt;https://github.com/sjp38/lazybox/blob/master/git_helpers/authors.py&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>나의 리눅스 커널 컨트리뷰션 10주년</title>
      <link>https://sjp38.github.io/ko/post/linux_kernel_contribution_10th_anniversary/</link>
      <pubDate>Sun, 16 Oct 2022 09:09:55 -0700</pubDate>
      <guid>https://sjp38.github.io/ko/post/linux_kernel_contribution_10th_anniversary/</guid>
      <description>&lt;p&gt;오늘은 제가 리눅스 커널에 처음 기여를 한지 10년이 되는 날입니다.  그 작고
사소했던 패치를 포함해, 지난 10년간 총 381개의 패치를 메인라인에 기여했네요.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --author SeongJae --reverse
commit cf174b0ef52ad8184779e1da4132e2d9d17247e5
Author: SeongJae Park &amp;lt;sj38.park@gmail.com&amp;gt;
Date:   Tue Oct 16 16:47:50 2012 +0900

    staging: csr: csr_framework_ext_types.h: fix coding style

    Fix coding style of csr_framework_ext_types.h
        
    Signed-off-by: SeongJae Park &amp;lt;sj38.park@gmail.com&amp;gt;
    Signed-off-by: Greg Kroah-Hartman &amp;lt;gregkh@linuxfoundation.org&amp;gt;

[...]
$ git log --author SeongJae --oneline | wc -l
381
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다음 10년을 기대합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DAMON 을 이용한 프로파일링의 한 예</title>
      <link>https://sjp38.github.io/ko/post/damon_profile_callstack_example/</link>
      <pubDate>Thu, 25 Feb 2021 07:20:30 +0100</pubDate>
      <guid>https://sjp38.github.io/ko/post/damon_profile_callstack_example/</guid>
      <description>&lt;p&gt;DAMON[0] 이 프로파일링만을 위한 건 아니지만, DAMON 을 프로파일링에 활용하는
방법에 대한 괜찮은 직관적 예를 여태 소개한 적이 없다는 걸 깨달았습니다.
간단하지만 현실적인 DAMON 의 프로파일링 도구로써의 사용법은 모니터링 결과를
콜스택과 함께 기록한 후 시간대에 맞춰 시각화 하는 것입니다.&lt;/p&gt;
&lt;p&gt;예를 들어, 아래 그림은 SPLASH-2X 벤치마크의 &amp;lsquo;fft&amp;rsquo; 라는 워크로드에 대한 그런
시각화 결과입니다.  여기서, 우린 이 워크로드에 세개의 폭발적 메모리 액세스가
이루어지는 구간이 있는 것을 알 수 있으며, &lt;code&gt;FFT1DOnce.cons::prop.2()&lt;/code&gt; 가 그
첫번째와 두번째 구간에, 그리고 &lt;code&gt;Transpose()&lt;/code&gt; 는 세번째 구간에 연관되어 있음을
알 수 있습니다.  이제 프로그래머는 이 함수들을 깊게 들여다보고 코드를 최적화
(ex: &lt;code&gt;madvise()&lt;/code&gt; 나 &lt;code&gt;mlock()&lt;/code&gt; 을 호출하기) 할 수 있을 겁니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sjp38.github.io/img/damon_callstack.png&#34; alt=&#34;dasmon_callstack_visualization&#34;&gt;&lt;/p&gt;
&lt;p&gt;우린 이 기법을 다양한 실제에 가까운 벤치마크 워크로드들의 &lt;code&gt;mlock()&lt;/code&gt; 기반
최적화에 사용해 보았습니다.  그렇게 최적화 되 버전은 메모리 부족 상태에서 최대
2.5배까지의 성능 향상을 기록했습니다[1].&lt;/p&gt;
&lt;p&gt;주의: 위의 &amp;lsquo;fft&amp;rsquo; 시각화에서 위쪽 두개의 그림 (시간에 따른 워킹셋 크기와 메모리
영역별 접근 빈도) 는 DAMON 유저 스페이스 툴[2] 을 이용해서 그렸고, 가장 아래의
그림 (시간에 따른 콜스택) 은 perf 와 speedscope[3] 을 이용해 그렸습니다.  아직
이걸 완전히 자동화 하는 도구는 없습니다만 (조만간 구현할 계획입니다, 아마도
perf 아래에 perf-script[4] 의 형태로요), 여러분도 아래의 커맨드를 이용해 직접
만들어 보실 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ # run the workload
$ sudo damo record $(pidof &amp;lt;the workload&amp;gt;) &amp;amp;
$ sudo perf record -g --pid $(pidof &amp;lt;the workload&amp;gt;)
$ # after your workload finished (you should also finish perf on your own)
$ damo report wss --sortby time --plot wss.pdf
$ damo report heats --heatmap freq.pdf
$ sudo perf script | speedscope -
$ # open wss.pdf and freq.pdf with our favorite pdf viewer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[0] &lt;a href=&#34;https://damonitor.github.io&#34;&gt;https://damonitor.github.io&lt;/a&gt;&lt;br&gt;
[1] &lt;a href=&#34;https://linuxplumbersconf.org/event/4/contributions/548/attachments/311/590/damon_ksummit19.pdf&#34;&gt;https://linuxplumbersconf.org/event/4/contributions/548/attachments/311/590/damon_ksummit19.pdf&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://lore.kernel.org/linux-mm/20201215115448.25633-8-sjpark@amazon.com/&#34;&gt;https://lore.kernel.org/linux-mm/20201215115448.25633-8-sjpark@amazon.com/&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://www.speedscope.app/&#34;&gt;https://www.speedscope.app/&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;https://lore.kernel.org/linux-mm/20210107120729.22328-1-sjpark@amazon.com/&#34;&gt;https://lore.kernel.org/linux-mm/20210107120729.22328-1-sjpark@amazon.com/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DAMON 테스트 패키지가 GPL v2 로 릴리즈 되었습니다</title>
      <link>https://sjp38.github.io/ko/post/damon-tests_open_sourced/</link>
      <pubDate>Sat, 26 Sep 2020 08:47:12 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/damon-tests_open_sourced/</guid>
      <description>&lt;p&gt;DAMON 은 kselftest 와 kunit 에 기반한 여러 테스트를 자신의 패치셋에 포함시켜
두고 있습니다.  커널 트리에 위치하는 테스트는 짧은 수행시간만 가지는게
바람직하므로, 시간을 오래 소요하는 테스트들을 패키지화 해서 저희 회사 내에서만
사용해 오고 있었습니다.  테스트는 좋은 문서로 사용될 수 있고 컨트리뷰터들에게도
필요하죠.  그런 이유로, 이 패키지를 오픈소스로 만들겠다고 지난 커널 서밋
발표에서 이야기 했었습니다
(&lt;a href=&#34;https://linuxplumbersconf.org/event/7/contributions/659/)&#34;&gt;https://linuxplumbersconf.org/event/7/contributions/659/)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;어제, 이 &lt;a href=&#34;https://github.com/awslabs/damon-tests&#34;&gt;패키지&lt;/a&gt; 를 마침내 GPL v2
라이센스의 오픈소스로 릴리즈 했습니다.  이제 DAMON 인터페이스를 이해하고
여러분의 기계 위에서 스스로 DAMON 을 테스트 하는데 이 패키지를 사용하실 수
있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DAMON 쇼케이스 웹사이트를 열었습니다</title>
      <link>https://sjp38.github.io/ko/post/damon_github_page/</link>
      <pubDate>Sat, 16 May 2020 13:25:55 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/damon_github_page/</guid>
      <description>&lt;p&gt;DAMON 소개를 위한 웹사이트[1] 를 열었습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DAMON 공식 문서[2],&lt;/li&gt;
&lt;li&gt;실제에 가까운 여러 워크로드의 힙[3], mmap() 된 영역[4], 그리고 스택[5] 에
대한 히트맵 포맷의 동적 액세스 패턴들,&lt;/li&gt;
&lt;li&gt;동적 워킹셋 사이즈의 분포[6] 와 시간대에 따른 워킹셋 사이즈의 변화양상[7],
그리고&lt;/li&gt;
&lt;li&gt;성능 테스트 결과[8]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;를 확인해 보실 수 있습니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://damonitor.github.io&#34;&gt;https://damonitor.github.io&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://damonitor.github.io/doc/html/latest&#34;&gt;https://damonitor.github.io/doc/html/latest&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/heatmap.0.html&#34;&gt;https://damonitor.github.io/test/result/visual/latest/heatmap.0.html&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/heatmap.1.html&#34;&gt;https://damonitor.github.io/test/result/visual/latest/heatmap.1.html&lt;/a&gt;&lt;br&gt;
[5] &lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/heatmap.2.html&#34;&gt;https://damonitor.github.io/test/result/visual/latest/heatmap.2.html&lt;/a&gt;&lt;br&gt;
[6] &lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/wss_sz.html&#34;&gt;https://damonitor.github.io/test/result/visual/latest/wss_sz.html&lt;/a&gt;&lt;br&gt;
[7] &lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/wss_time.html&#34;&gt;https://damonitor.github.io/test/result/visual/latest/wss_time.html&lt;/a&gt;&lt;br&gt;
[8] &lt;a href=&#34;https://damonitor.github.io/test/result/perf/latest/html/index.html&#34;&gt;https://damonitor.github.io/test/result/perf/latest/html/index.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DAMON: Data Access Monitor</title>
      <link>https://sjp38.github.io/ko/post/damon/</link>
      <pubDate>Fri, 27 Dec 2019 18:21:07 +0100</pubDate>
      <guid>https://sjp38.github.io/ko/post/damon/</guid>
      <description>&lt;p&gt;The trend of increasing data intensive workloads and limited DRAM capacity
makes dynamic access pattern based optimal memory management important.  Such
mechnisms can be made only when not only accurate but also efficient dynamic
access pattern monitoring is available.&lt;/p&gt;
&lt;p&gt;DAMON is a Data Access MONitoring framework subsystem for the Linux kernel that
developed for such memory management.  It is designed with some core mechanism
(refer to
&lt;a href=&#34;https://docs.kernel.org/mm/damon/design.html&#34;&gt;Design&lt;/a&gt; for the detail), which
can make it&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;accurate (the monitoring output is useful enough for DRAM level memory
management; It might not appropriate for CPU Cache levels, though),&lt;/li&gt;
&lt;li&gt;light-weight (the monitoring overhead is low enough to be applied online),
and&lt;/li&gt;
&lt;li&gt;scalable (the upper-bound of the overhead is in constant range regardless of
the size of target workloads).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DAMON therefore makes development of any access pattern based memory management
available.  For easier development of such system, DAMON further provides a
feature called DAMOS (DAMon-based Operation Schemes).  Using it, DAMON users
can develop and run their access-aware memory management with no code but
simple configurations.  Simple mechanisms made on top of DAMOS
&lt;a href=&#34;https://www.amazon.science/publications/daos-data-access-aware-operating-system&#34;&gt;achieve&lt;/a&gt;
up to 12% performance improvement and 91% memory saving.&lt;/p&gt;
&lt;p&gt;Detailed evaluation of DAMON and DAMON-based system optimizations are
available at another &lt;a href=&#34;https://sjp38.github.io/ko/post/damon_evaluation/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;demo-video&#34;&gt;Demo Video&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://sjp38.github.io/img/damo_monitor_water_nsquared.gif&#34; alt=&#34;damo monitor for water_nsquared&#34;&gt;&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/l63eqbVBZRY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;demo-screenshot&#34;&gt;Demo Screenshot&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://sjp38.github.io/img/masim_stairs_heatmap_ascii.png&#34; alt=&#34;masim stairs heatmap in ascii&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;recent-news&#34;&gt;Recent News&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;2023-03-10&lt;/em&gt;: A DAMON talk proposal for
&lt;a href=&#34;https://events.linuxfoundation.org/open-source-summit-north-america/&#34;&gt;OSSummit NA&lt;/a&gt;
has accepted.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023-03-06&lt;/em&gt;: DAMOS filters feature has introduced as one of the most
significant changes for Linux v6.3 by an LWN
&lt;a href=&#34;https://lwn.net/Articles/924384/&#34;&gt;article&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023-02-24&lt;/em&gt;: A preprint of an academic paper that compares their approach
against DAMON has &lt;a href=&#34;https://arxiv.org/pdf/2302.09468.pdf&#34;&gt;uploaded&lt;/a&gt; to ArXiv.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023-02-13&lt;/em&gt;: LSF/MM/BPF topic proposal for DAMON has
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20230214003328.55285-1-sj@kernel.org/&#34;&gt;posted&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023-02-09&lt;/em&gt;: DAMON debugfs deprecation patchset has
&lt;a href=&#34;https://lore.kernel.org/damon/20230209192009.7885-1-sj@kernel.org/&#34;&gt;posted&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;You can start using DAMON by&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;installing &lt;a href=&#34;#install&#34;&gt;DAMON-enabled kernel&lt;/a&gt; and its
&lt;a href=&#34;#user-space-tool&#34;&gt;user-space tool&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;following the &lt;a href=&#34;https://github.com/awslabs/damo#getting-started&#34;&gt;tutorial&lt;/a&gt; of
the user-space tool, and&lt;/li&gt;
&lt;li&gt;run the automated &lt;a href=&#34;#tests-package&#34;&gt;tests suite&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By following those, you will be able to know if DAMON works on your machine and
how you can use it.&lt;/p&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;DAMON is implemented in the Linux kernel, so you should install DAMON-enabled
Linux kernel to use it.  To check if you&amp;rsquo;re already running DAMON-enabled
kernel, you could:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ if grep CONFIG_DAMON /boot/config-$(uname -r); then echo &amp;quot;installed&amp;quot;; fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are an &lt;a href=&#34;https://aws.amazon.com/amazon-linux-2/&#34;&gt;Amazon Linux 2&lt;/a&gt; user,
you can install a DAMON-enabled Linux kernels which are based on v5.10 or v5.4
using
&lt;a href=&#34;https://aws.amazon.com/premiumsupport/knowledge-center/ec2-install-extras-library-software/&#34;&gt;amazon-linux-extras&lt;/a&gt;.
For example, if you want to use DAMON with Amazon Linux v5.10 kernel, below
commands will work.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo yum install -y amazon-linux-extras
$ sudo amazon-linux-extras install kernel-5.10
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that AL2 v5.10.y contains all DAMON features that available on mainline
while AL2 5.4.y contains only a part of DAMON features, so AL2 v5.10.y is more
recommended.&lt;/p&gt;
&lt;p&gt;If your package system doesn&amp;rsquo;t support DAMON-enabled kernel, you can
&lt;a href=&#34;#source-code&#34;&gt;fetch&lt;/a&gt; a DAMON-merged Linux kernel source tree (it has merged in
Linux mainline tree since v5.15), build, and install it.  Note that you should
enable kernel configuration options for DAMON, depending on your demands.  For
example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $THE_FETCHED_DAMON_KERNEL_SOURCE_TREE
$ make olddefconfig
$ echo &#39;CONFIG_DAMON=y&#39; &amp;gt;&amp;gt; /.config
$ echo &#39;CONFIG_DAMON_KUNIT_TEST=y&#39; &amp;gt;&amp;gt; /.config
$ echo &#39;CONFIG_DAMON_VADDR=y&#39; &amp;gt;&amp;gt; /.config
$ echo &#39;CONFIG_DAMON_PADDR=y&#39; &amp;gt;&amp;gt; /.config
$ echo &#39;CONFIG_DAMON_VADDR_KUNIT_TEST=y&#39; &amp;gt;&amp;gt; /.config
$ echo &#39;CONFIG_DAMON_SYSFS=y&#39; &amp;gt;&amp;gt; /.config
$ echo &#39;CONFIG_DAMON_DBGFS=y&#39; &amp;gt;&amp;gt; /.config
$ echo &#39;CONFIG_DAMON_DBGFS_KUNIT_TEST=y&#39; &amp;gt;&amp;gt; /.config
$ echo &#39;CONFIG_DAMON_RECLAIM=y&#39; &amp;gt;&amp;gt; /.config
$ echo &#39;CONFIG_DAMON_LRU_SORT=y&#39; &amp;gt;&amp;gt; /.config
$ make -j$(nproc)
$ sudo make modules_install install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;There are several DAMON-merged Linux kernel source trees for different users.
You may pick one among those based on your needs.&lt;/p&gt;
&lt;p&gt;For users who want only a &lt;strong&gt;stable&lt;/strong&gt; version of DAMON, below trees are
available.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linus Torvalds&amp;rsquo; &lt;a href=&#34;https://git.kernel.org/torvalds/h/master&#34;&gt;mainline tree&lt;/a&gt;
contains the latest stable version of DAMON since v5.15.&lt;/li&gt;
&lt;li&gt;Amazon Linux 2
&lt;a href=&#34;https://github.com/amazonlinux/linux/tree/amazon-5.10.y/master&#34;&gt;v5.10.y tree&lt;/a&gt;
and
&lt;a href=&#34;https://github.com/amazonlinux/linux/tree/amazon-5.4.y/master&#34;&gt;v5.4.y tree&lt;/a&gt;
also contain stable versions of DAMON.  Note that AL2 v5.10.y contains all
DAMON features that available on the latest major releases of Linux while AL2
5.4.y contains only a part of DAMON features, so AL2 v5.10.y is more
recommended.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you have interests in DAMON features under &lt;strong&gt;development&lt;/strong&gt;, below trees will
be appropriate.  These trees contain latest version of DAMON which having
features under development.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/akpm/mm/h/mm-unstable&#34;&gt;mm-unstable&lt;/a&gt; contains the
latest DAMON patches, which are under testing with other unstable memory
management subsystem patches.  So this tree is likely unstable and frequently
updated, but would be a good baseline for your DAMON development.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/sj/h/damon/next&#34;&gt;damon/next&lt;/a&gt; contains the latest
changes, which might not tested at all.  So this tree is likely more unstable
and frequently updated than mm-unstable.  This tree also contains some
changes that exist only for DAMON hacks itself rather than eventually be
merged in the mainline.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For people who have interest in DAMON features under development but use LTS
kernels as their baseline, there &lt;em&gt;were&lt;/em&gt; trees that based on three latest LTS
kernels.&lt;/p&gt;
&lt;p&gt;NOTE: Below trees were continuously getting DAMON backports on latest 5.4.y,
5.10.y, and 5.15.y.  But those are deprecated as of 2022-09-03, and therefore
there will be no update to the trees.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/sj/h/damon/for-v5.15.y&#34;&gt;damon/for-v5.15.y&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/sj/h/damon/for-v5.10.y&#34;&gt;damon/for-v5.10.y&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/sj/h/damon/for-v5.4.y&#34;&gt;damon/for-v5.4.y&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The source code of DAPTRACE, which is a prototype of DAMON, is also
&lt;a href=&#34;https://github.com/daptrace&#34;&gt;available&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;user-space-tool&#34;&gt;User-space Tool&lt;/h2&gt;
&lt;p&gt;A user-space tool for DAMON, which is called DAMO, is available at
&lt;a href=&#34;https://github.com/awslabs/damo&#34;&gt;Github&lt;/a&gt; and
&lt;a href=&#34;https://pypi.org/project/damo/&#34;&gt;PyPi&lt;/a&gt;.  You may start using DAMON by following
the &lt;a href=&#34;https://github.com/awslabs/damo#getting-started&#34;&gt;Getting Started&lt;/a&gt; of the
tool for start.&lt;/p&gt;
&lt;h2 id=&#34;tests-package&#34;&gt;Tests Package&lt;/h2&gt;
&lt;p&gt;There is a &lt;a href=&#34;https://github.com/awslabs/damon-tests&#34;&gt;tests suite&lt;/a&gt; for
correctness verification and performance evaluation of DAMON.  Those are
actively used for the development of DAMON.  Using that, you can test DAMON on
your machine with only a few simple commands or deeply understand the user
interface of DAMON.&lt;/p&gt;
&lt;p&gt;So, if you finished the
&lt;a href=&#34;https://github.com/awslabs/damo#getting-started&#34;&gt;tutorial&lt;/a&gt; but have no idea
about what to do next, running the tests would be a good start.  If any test
fails, please report that to the maintainer via mail (&lt;a href=&#34;mailto:sj@kernel.org&#34;&gt;sj@kernel.org&lt;/a&gt; or
&lt;a href=&#34;mailto:damon@lists.linux.dev&#34;&gt;damon@lists.linux.dev&lt;/a&gt;) or
&lt;a href=&#34;https://github.com/awslabs/damon-tests/issues&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;official-document&#34;&gt;Official Document&lt;/h2&gt;
&lt;p&gt;The official document of DAMON in the latest mainline for
&lt;a href=&#34;https://docs.kernel.org/admin-guide/mm/damon/index.html&#34;&gt;users/sysadmins&lt;/a&gt; and
&lt;a href=&#34;https://docs.kernel.org/mm/damon/index.html&#34;&gt;kernel programmers&lt;/a&gt; are
available.  Document for DAMON in the &lt;a href=&#34;#source-code&#34;&gt;damon/next&lt;/a&gt; tree, which
focused on DAMON only and contains some more DAMON-specific contents, is also
&lt;a href=&#34;https://damonitor.github.io/doc/html/next/&#34;&gt;available&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;showcase-website&#34;&gt;Showcase Website&lt;/h2&gt;
&lt;p&gt;There is a showcase &lt;a href=&#34;https://damonitor.github.io/_index&#34;&gt;website&lt;/a&gt; that you can
get more information of DAMON.
The site hosts&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href=&#34;https://damonitor.github.io/doc/html/next/&#34;&gt;documentation&lt;/a&gt; of
DAMON that contains contents on &lt;a href=&#34;#source-code&#34;&gt;damon/next&lt;/a&gt; tree,&lt;/li&gt;
&lt;li&gt;the heatmap format dynamic access pattern of various realistic workloads for
&lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/rec.heatmap.0.png.html&#34;&gt;heap&lt;/a&gt;
area,
&lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/rec.heatmap.1.png.html&#34;&gt;mmap()-ed&lt;/a&gt;
area,
and
&lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/rec.heatmap.2.png.html&#34;&gt;stack&lt;/a&gt;
area,&lt;/li&gt;
&lt;li&gt;the dynamic working set size
&lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/rec.wss_sz.png.html&#34;&gt;distribution&lt;/a&gt;
and chronological working set
size &lt;a href=&#34;https://damonitor.github.io/test/result/visual/latest/rec.wss_time.png.html&#34;&gt;changes&lt;/a&gt;,
and&lt;/li&gt;
&lt;li&gt;the latest performance test
&lt;a href=&#34;https://damonitor.github.io/test/result/perf/latest/html/index.html&#34;&gt;results&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;evaluation-results&#34;&gt;Evaluation Results&lt;/h2&gt;
&lt;p&gt;Evaluation of DAMON and DAMON-based system optimizations are
&lt;a href=&#34;https://sjp38.github.io/ko/post/damon_evaluation/&#34;&gt;available&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;damon-based-system-optimization-guide&#34;&gt;DAMON-based System Optimization Guide&lt;/h2&gt;
&lt;p&gt;A guide for DAMON-based system optimizations are also
&lt;a href=&#34;https://sjp38.github.io/ko/post/damon_optimization_guide/&#34;&gt;available&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;community&#34;&gt;Community&lt;/h2&gt;
&lt;p&gt;DAMON is maintained and developed by its own community, which is a sub-set of
the linux kernel development community.&lt;/p&gt;
&lt;p&gt;The community is mainly driven by the mailing list (&lt;a href=&#34;mailto:damon@lists.linux.dev&#34;&gt;damon@lists.linux.dev&lt;/a&gt;).
All the patches are posted there and reviewed.  Almost every discussions are
also made there.  You can subscribe to the mailing list via
&lt;a href=&#34;https://subspace.kernel.org/lists.linux.dev.html&#34;&gt;subspace.kernel.org&lt;/a&gt;
following the &lt;a href=&#34;https://subspace.kernel.org/#subscribing&#34;&gt;instruction&lt;/a&gt;.  You
could also read the mails without subscription via
&lt;a href=&#34;https://lore.kernel.org/damon/&#34;&gt;lore&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The community also have an open, regular, and informal virtual bi-weekly
meeting series for DAMON community called DAMON Beer/Coffee/Tea chat
&lt;a href=&#34;https://lore.kernel.org/damon/20220810225102.124459-1-sj@kernel.org/&#34;&gt;series&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;publications-and-presentations&#34;&gt;Publications and Presentations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Current Status and Future Plans of DAMON.&lt;/strong&gt;
In &lt;em&gt;The Linux Kernel Summit&lt;/em&gt;, September 2022.
&lt;a href=&#34;https://lpc.events/event/16/contributions/1224/attachments/1107/2137/damon_status_plan_ksummit_2022.pdf&#34;&gt;Slides&lt;/a&gt;,
&lt;a href=&#34;https://youtu.be/e2SZoUPhDRg?t=13245&#34;&gt;Video&lt;/a&gt;,
&lt;a href=&#34;https://lpc.events/event/16/contributions/1224/&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jonathan Corbet, &lt;strong&gt;LRU-list manipulation with DAMON.&lt;/strong&gt; In Linux Weekly News,
August 2022.  &lt;a href=&#34;https://lwn.net/Articles/905370/&#34;&gt;Article&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Current Status, Future Plans, and Possible Collaborations
for DAMON.&lt;/strong&gt; In &lt;em&gt;The Linux Kernel Summit&lt;/em&gt;, September 2022.
&lt;a href=&#34;https://lpc.events/event/16/contributions/1224/&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, Madhuparna Bhowmik, Alexandru Uta, &lt;strong&gt;DAOS: Data Access-aware
Operating System.&lt;/strong&gt; In &lt;em&gt;The 31st International ACM Symposium on
High-Performance Parallel and Distributed Computing (HPDC&#39;22)&lt;/em&gt;, June 2022.
&lt;a href=&#34;https://www.amazon.science/publications/daos-data-access-aware-operating-system&#34;&gt;Paper&lt;/a&gt;,
&lt;a href=&#34;https://damonitor.github.io/misc/daos_hpdc_2022_slides.pdf&#34;&gt;Slides&lt;/a&gt;,
&lt;a href=&#34;https://damonitor.github.io/misc/daos_hpdc_2022_poster.pdf&#34;&gt;Poster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Writing a fine-grained access pattern oriented lightweight
kernel module using DAMON/DAMOS in 10 minutes.&lt;/strong&gt;
In &lt;em&gt;The Linux Kernel Summit&lt;/em&gt;, September 2021.
&lt;a href=&#34;https://linuxplumbersconf.org/event/11/contributions/984/attachments/870/1670/daos_ksummit_2021.pdf&#34;&gt;Slides&lt;/a&gt;,
&lt;a href=&#34;https://youtu.be/gpFfJkrrEEs?t=5290&#34;&gt;Video&lt;/a&gt;,
&lt;a href=&#34;https://linuxplumbersconf.org/event/11/contributions/984/&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jonathan Corbet, &lt;strong&gt;Using DAMON for proactive reclaim.&lt;/strong&gt; In Linux Weekly News,
July 2021.  &lt;a href=&#34;https://lwn.net/Articles/863753/&#34;&gt;Article&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;DAMON: Data Access Monitoring Framework for Fun and Memory
Management Optimizations,&lt;/strong&gt; In &lt;em&gt;The Linux Kernel Summit&lt;/em&gt;, August 2020.
&lt;a href=&#34;https://www.linuxplumbersconf.org/event/7/contributions/659/attachments/503/1195/damon_ksummit_2020.pdf&#34;&gt;Slides&lt;/a&gt;,
&lt;a href=&#34;https://youtu.be/jOBkKMA0uF0?t=10696&#34;&gt;Video&lt;/a&gt;,
&lt;a href=&#34;https://www.linuxplumbersconf.org/event/7/contributions/659/&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Yunjae Lee, Yunhee Kim, and Heon. Y. Yeom, &lt;strong&gt;Lightweight Memory Tracing for
Hot Data Identification,&lt;/strong&gt; In &lt;em&gt;Cluster computing&lt;/em&gt;, 2020.
&lt;a href=&#34;https://link.springer.com/article/10.1007/s10586-020-03130-1&#34;&gt;Paper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jonathan Corbet, &lt;strong&gt;Memory-management optimization with DAMON.&lt;/strong&gt; In Linux
Weekly News, February 2020.
&lt;a href=&#34;https://lwn.net/Articles/812707/&#34;&gt;Article&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, Yunjae Lee, Heon Y. Yeom, &lt;strong&gt;Profiling Dynamic Data Access
Patterns with Controlled Overhead and Quality.&lt;/strong&gt; In 20th ACM/IFIP
International Middleware Conference Industry, December 2019.
&lt;a href=&#34;https://dl.acm.org/citation.cfm?id=3368125&#34;&gt;Paper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Tracing Data Access Pattern with Bounded Overhead and
Best-effort Accuracy.&lt;/strong&gt; In &lt;em&gt;The Linux Kernel Summit&lt;/em&gt;, September 2019.
&lt;a href=&#34;https://linuxplumbersconf.org/event/4/contributions/548/attachments/311/590/damon_ksummit19.pdf&#34;&gt;Slides&lt;/a&gt;,
&lt;a href=&#34;https://linuxplumbersconf.org/event/4/contributions/548/&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, Yunjae Lee, Yunhee Kim, Heon Y. Yeom, &lt;strong&gt;Profiling Dynamic Data
Access Patterns with Bounded Overhead and Accuracy.&lt;/strong&gt; In IEEE International
Workshop on Foundations and Applications of Self-* Systems (FAS* 2019),
June 2019.
&lt;a href=&#34;https://ieeexplore.ieee.org/abstract/document/8791992&#34;&gt;Paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;news&#34;&gt;News&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;2023-03-10&lt;/em&gt;: A DAMON talk proposal for
&lt;a href=&#34;https://events.linuxfoundation.org/open-source-summit-north-america/&#34;&gt;OSSummit NA&lt;/a&gt;
has accepted.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023-03-06&lt;/em&gt;: DAMOS filters feature has introduced as one of the most
significant changes for Linux v6.3 by an LWN
&lt;a href=&#34;https://lwn.net/Articles/924384/&#34;&gt;article&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023-02-24&lt;/em&gt;: A preprint of an academic paper that compares their approach
against DAMON has &lt;a href=&#34;https://arxiv.org/pdf/2302.09468.pdf&#34;&gt;uploaded&lt;/a&gt; to ArXiv.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023-02-13&lt;/em&gt;: LSF/MM/BPF topic proposal for DAMON has
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20230214003328.55285-1-sj@kernel.org/&#34;&gt;posted&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2023-02-09&lt;/em&gt;: DAMON debugfs deprecation patchset has
&lt;a href=&#34;https://lore.kernel.org/damon/20230209192009.7885-1-sj@kernel.org/&#34;&gt;posted&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-12-29&lt;/em&gt;: DAMON development summary of 2022 has
&lt;a href=&#34;https://lore.kernel.org/lkml/20221229171209.162356-1-sj@kernel.org/&#34;&gt;shared&lt;/a&gt;
and &lt;a href=&#34;https://www.phoronix.com/news/DAMON-Linux-2022&#34;&gt;featured&lt;/a&gt; by Phoronix.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-12-16&lt;/em&gt;: The DAMOS filtering for anon pages and/or memory
cgroups have
&lt;a href=&#34;https://lore.kernel.org/mm-commits/20221216235930.526BAC433EF@smtp.kernel.org/&#34;&gt;merged&lt;/a&gt;
in mm tree.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-10-19&lt;/em&gt;: An RFC patchset for efficient query-like DAMON monitoring results
have
&lt;a href=&#34;https://lore.kernel.org/damon/20221019001317.104270-1-sj@kernel.org/&#34;&gt;posted&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-09-15&lt;/em&gt;: The &lt;a href=&#34;https://youtu.be/e2SZoUPhDRg?t=13245&#34;&gt;video&lt;/a&gt; for my kernel
summit DAMON talk this year is now available at Youtube&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-09-09&lt;/em&gt;: The plan for the first in-person DAMON community meetup at LPC
and the in-person office hour at OSSummit EU has
&lt;a href=&#34;https://lore.kernel.org/damon/20220909173856.55818-1-sj@kernel.org/&#34;&gt;announced&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-09-06&lt;/em&gt;: AL2 5.10 kernel&amp;rsquo;s DAMON code has
&lt;a href=&#34;https://github.com/amazonlinux/linux/commit/5441c2036382e1957492a6d762f0dfbd172aa225&#34;&gt;updated&lt;/a&gt;
to that of v5.19&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-08-30&lt;/em&gt;: AL2 5.10 kernel&amp;rsquo;s DAMON code has
&lt;a href=&#34;https://github.com/amazonlinux/linux/commit/8fde5ce7c81c1ecf6c3ac2595774eac0e6784869&#34;&gt;updated&lt;/a&gt;
to that of v5.18&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-08-22&lt;/em&gt;: LWN &lt;a href=&#34;https://lwn.net/Articles/905370/&#34;&gt;introduced&lt;/a&gt; DAMON-based
LRU-lists manipulation (DAMON_LRU_SORT) in detail&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-08-15&lt;/em&gt;: LWN &lt;a href=&#34;https://lwn.net/Articles/904032/&#34;&gt;introduced&lt;/a&gt; DAMON’s new
features including &amp;lsquo;LRU_SORT&amp;rsquo; as significant changes for Linux 6.0&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-08-12&lt;/em&gt;: Bi-weekly DAMON Beer/Coffee/Tea Chat series for open, regular,
and informal community syncups and discussions has
&lt;a href=&#34;https://lore.kernel.org/damon/20220810225102.124459-1-sj@kernel.org/&#34;&gt;announced&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-07-29&lt;/em&gt;: Current status, future plans, and possible collaborations for
DAMON will be &lt;a href=&#34;https://lpc.events/event/16/contributions/1224/&#34;&gt;presented&lt;/a&gt; at
the Kernel Summit 2022.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-06-26&lt;/em&gt;: The poster of the DAOS
&lt;a href=&#34;https://www.amazon.science/publications/daos-data-access-aware-operating-system&#34;&gt;paper&lt;/a&gt;
is
&lt;a href=&#34;https://damonitor.github.io/misc/daos_hpdc_2022_poster.pdf&#34;&gt;available&lt;/a&gt; online.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-06-13&lt;/em&gt;: DAMON-based LRU-lists sorting patchset has
&lt;a href=&#34;https://lore.kernel.org/damon/20220613192301.8817-1-sj@kernel.org/&#34;&gt;posted&lt;/a&gt;
and immediately
&lt;a href=&#34;https://lore.kernel.org/mm-commits/20220613194036.C4AC5C34114@smtp.kernel.org/&#34;&gt;merged&lt;/a&gt;
in the -mm tree&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-05-04&lt;/em&gt;: A paper introducing DAMON and related works have accepted by
&lt;a href=&#34;https://www.hpdc.org/2022/program/accepted/&#34;&gt;HPDC22&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-05-03&lt;/em&gt;: Now DAMON has its own open mailing
&lt;a href=&#34;https://lore.kernel.org/damon/&#34;&gt;list&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-04-29&lt;/em&gt;: Patches for DAMON online tuning have
&lt;a href=&#34;https://lore.kernel.org/mm-commits/20220429162617.04E08C385A7@smtp.kernel.org/&#34;&gt;merged&lt;/a&gt;
in -mm tree&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-04-27&lt;/em&gt;: Android has
&lt;a href=&#34;https://android.googlesource.com/kernel/common/+log/b3190b539a0845d3b849926b723deeeacc7491a4&#34;&gt;backported&lt;/a&gt;
and
&lt;a href=&#34;https://android.googlesource.com/kernel/common/+/0496c13ded02bd72426d189b777bf303fe490f62&#34;&gt;enabled&lt;/a&gt;
building &lt;code&gt;DAMON&lt;/code&gt; and &lt;code&gt;DAMON_RECLAIM&lt;/code&gt; for the common kernel.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-04-27&lt;/em&gt;: Alibaba has
&lt;a href=&#34;https://lore.kernel.org/linux-mm/e3c1beb1-e3d5-6e26-bae2-06785080b57e@linux.alibaba.com/&#34;&gt;shared&lt;/a&gt;
thier own DAMON user space
&lt;a href=&#34;https://github.com/aliyun/data-profile-tools&#34;&gt;tool&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-02-28&lt;/em&gt;: The DAMON sysfs interface patchset has
&lt;a href=&#34;https://lore.kernel.org/mm-commits/20220228194808.91315C340F3@smtp.kernel.org/&#34;&gt;merged&lt;/a&gt;
in -mm tree.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-02-17&lt;/em&gt;: An &lt;a href=&#34;https://lore.kernel.org/linux-mm/20220217161938.8874-1-sj@kernel.org/&#34;&gt;RFC
patchset&lt;/a&gt;
for sysfs-based DAMON&amp;rsquo;s new user interface has posted.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-01-20&lt;/em&gt;: A
&lt;a href=&#34;https://lkml.kernel.org/r/20220119133110.24901-1-sj@kernel.org&#34;&gt;roadmap&lt;/a&gt; of
DAMON has shared.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2022-01-09&lt;/em&gt;: Linux 5.16 is released.  &amp;ldquo;DAMON-based proactive memory
reclamation, operation schemes and physical memory monitoring&amp;rdquo; are marked as
prominent features of the release by the &lt;a href=&#34;https://kernelnewbies.org/Linux_5.16&#34;&gt;Kernel
newbies&lt;/a&gt; and
&lt;a href=&#34;https://kernelnewbies.org/Linux_5.16&#34;&gt;LWN&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-12-23&lt;/em&gt;: A great blog
&lt;a href=&#34;https://stevescargall.com/2021/12/23/how-to-build-a-custom-linux-kernel-to-test-data-access-monitor-damon/&#34;&gt;post&lt;/a&gt;
for DAMON-enabled kernel has uploaded&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-11-07&lt;/em&gt;: DAMON patches for automated memory management
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=68536f8e01e571f553f78fa058ba543de3834452&#34;&gt;optimization&lt;/a&gt;,
the physical address space monitoring
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c638072107f52ec35f292c97b6f3df9b9f2ed87d&#34;&gt;support&lt;/a&gt;,
and &lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bec976b69143&#34;&gt;proactive
reclamation&lt;/a&gt;
have merged in the mainline.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-11-01&lt;/em&gt;: DAMON has
&lt;a href=&#34;https://kernelnewbies.org/Linux_5.15#DAMON.2C_a_data_access_monitor&#34;&gt;released&lt;/a&gt;
with Linux &lt;a href=&#34;https://lwn.net/Articles/874493&#34;&gt;v5.15&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-10-14&lt;/em&gt;: DAMON_RECLAIM patchset is
&lt;a href=&#34;https://github.com/amazonlinux/linux/commit/99c8ec092e82&#34;&gt;merged&lt;/a&gt; in the
Amazon Linux 5.10.y kernel tree.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-10-02&lt;/em&gt;: DAMOS patchset is
&lt;a href=&#34;https://lore.kernel.org/mm-commits/20211001233339.SV5JeiSqb%25akpm@linux-foundation.org/&#34;&gt;merged&lt;/a&gt;
in the -mm tree.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-09-23&lt;/em&gt;: DAMON and DAMOS are presented in the kernel summit.
&lt;a href=&#34;https://linuxplumbersconf.org/event/11/contributions/984/attachments/870/1670/daos_ksummit_2021.pdf&#34;&gt;Slides&lt;/a&gt;,
&lt;a href=&#34;https://youtu.be/gpFfJkrrEEs?t=5290&#34;&gt;Video&lt;/a&gt;,
&lt;a href=&#34;https://linuxplumbersconf.org/event/11/contributions/984/&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-09-16&lt;/em&gt;: DAMON development tree on
&lt;a href=&#34;https://git.kernel.org/sj/h/damon/next/about&#34;&gt;kernel.org&lt;/a&gt; is created.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-09-08&lt;/em&gt;: DAMON patchset is
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2d338201d5311bcd79d42f66df4cecbcbc5f4f2c&#34;&gt;merged&lt;/a&gt;
in the Linus Torvalds&amp;rsquo; tree, aka
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/damon?id=2d338201d5311bcd79d42f66df4cecbcbc5f4f2c&#34;&gt;mainline&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-09-07&lt;/em&gt;: DAMON/DAMOS will be
&lt;a href=&#34;https://linuxplumbersconf.org/event/11/contributions/984/&#34;&gt;presented&lt;/a&gt; at
the Kernel Summit 2021&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-08-31&lt;/em&gt;: DAMON user-space tool is uploaded to the official Python
packages system, &lt;a href=&#34;https://pypi.org/project/damo/&#34;&gt;PyPi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-08-06&lt;/em&gt;: DAMON patchset is
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20210805174324.2aaf0fb67cd19da893a86d80@linux-foundation.org/&#34;&gt;merged&lt;/a&gt;
in the -mm tree&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-07-27&lt;/em&gt;: LWN published a second
&lt;a href=&#34;https://lwn.net/Articles/863753/&#34;&gt;article&lt;/a&gt; introducing DAMON patchset series&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-06-11&lt;/em&gt;: DAMON-based proactive reclamation RFC patchset has shared on the
&lt;a href=&#34;https://news.ycombinator.com/item?id=27459675&#34;&gt;hackernews&lt;/a&gt; and introduced by a
Phoronix
&lt;a href=&#34;https://www.phoronix.com/scan.php?page=news_item&amp;amp;px=DAMON-Page-Reclamation-RFC&#34;&gt;article&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-05-31&lt;/em&gt;: DAMON-based proactive reclamation RFC patchset has
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20210531133816.12689-1-sj38.park@gmail.com/&#34;&gt;posted&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-05-26&lt;/em&gt;: DAMON-enabled Amazon Linux 2 kernels have &lt;a href=&#34;https://twitter.com/sjpark0x00/status/1397484233413832705&#34;&gt;deployed to all
users&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-05-07&lt;/em&gt;: DAMON has merged in the public source tree for Amazon Linux
v5.4.y
&lt;a href=&#34;https://github.com/amazonlinux/linux/tree/amazon-5.4.y/master/mm/damon&#34;&gt;kernel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-04-05&lt;/em&gt;: &lt;code&gt;damo&lt;/code&gt; now supports heatmap visualization on the
&lt;a href=&#34;https://raw.githubusercontent.com/awslabs/damo/master/for_doc/masim_zigzag_heatmap_ascii.png&#34;&gt;terminal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-03-31&lt;/em&gt;: DAMON user-space tool (&lt;code&gt;damo&lt;/code&gt;) is released as an
&lt;a href=&#34;https://github.com/awslabs/damo&#34;&gt;individual open source project&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-03-19&lt;/em&gt;: DAMON has merged in the public source tree for Amazon Linux
v5.10.y
&lt;a href=&#34;https://github.com/amazonlinux/linux/tree/amazon-5.10.y/master/mm/damon&#34;&gt;kernel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-03-04&lt;/em&gt;: DAMON supports for two latest LTS kernels
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20210304100732.7844-1-sjpark@amazon.com/&#34;&gt;announced&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-03-03&lt;/em&gt;: DAMON is merged in v5.10 based public Amazon Linux kernel
&lt;a href=&#34;https://github.com/amazonlinux/linux/commit/10e0ec07f9085a42f724b28912a1dadc0b5d3c80&#34;&gt;tree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-02-25&lt;/em&gt;: An example usage of DAMON for profiling is
&lt;a href=&#34;https://twitter.com/sjpark0x00/status/1364591344300273666&#34;&gt;shared&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021-01-07&lt;/em&gt;: A runtime system for DAMON-based optimal operation scheme finding
is &lt;a href=&#34;https://github.com/awslabs/damoos&#34;&gt;released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-12-03&lt;/em&gt;: Further plans around DAMON is
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20201202082731.24828-1-sjpark@amazon.com&#34;&gt;shared&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-11-17&lt;/em&gt;: A real-world user story of DAMON is
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20201117143021.11883-1-sjpark@amazon.com/&#34;&gt;shared&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-09-26&lt;/em&gt;: The tests package for DAMON is
&lt;a href=&#34;https://github.com/awslabs/damon-tests&#34;&gt;released&lt;/a&gt; under GPL v2 license&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-08-19&lt;/em&gt;: A demo video is &lt;a href=&#34;https://youtu.be/l63eqbVBZRY&#34;&gt;available&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-08-05&lt;/em&gt;: DAMON will be
&lt;a href=&#34;https://www.linuxplumbersconf.org/event/7/contributions/659/&#34;&gt;presented&lt;/a&gt; at
the Kernel Summit 2020&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-06-04&lt;/em&gt;: Physical Memory Monitoring is now
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20200603141135.10575-1-sjpark@amazon.com/&#34;&gt;available&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-05-18&lt;/em&gt;: DAMON showcase website is announced&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-05-13&lt;/em&gt;: DAMON official document is uploaded
&lt;a href=&#34;https://damonitor.github.io/doc/html/latest/admin-guide/mm/damon/&#34;&gt;online&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-02-20&lt;/em&gt;: DAMON has introduced by an LWN
&lt;a href=&#34;https://lwn.net/Articles/812707/&#34;&gt;article&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-02-10&lt;/em&gt;: The first RFC of Data Access Monitoring-based Operating Schemes
(DAMOS) has posted to
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20200210150921.32482-1-sjpark@amazon.com/&#34;&gt;LKML&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-01-23&lt;/em&gt;: The RFC of DAMON has introduced by LWN&amp;rsquo;s &lt;a href=&#34;https://lwn.net/Articles/809100/&#34;&gt;&amp;lsquo;Kernel patches of
interest&amp;rsquo;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2020-01-20&lt;/em&gt;: The first RFC patchset of DAMON has posted to
&lt;a href=&#34;https://lore.kernel.org/linux-mm/20200110131522.29964-1-sjpark@amazon.com/&#34;&gt;LKML&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.4/</link>
      <pubDate>Tue, 19 Nov 2019 23:13:19 +0100</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.4/</guid>
      <description>&lt;h2 id=&#34;patch-rfc-v3-0036-add-kernelmemorysanitizer-infrastructure&#34;&gt;[PATCH RFC v3 00/36] Add KernelMemorySanitizer infrastructure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191122112621.204798-1-glider@google.com&#34;&gt;https://lkml.kernel.org/r/20191122112621.204798-1-glider@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;초기화 되지 않은 메모리 영역에 접근함으로써 생기는 에러를 검출해내는 구글의
KMSAN 세번째 RFC 패치셋입니다.  다른 SAN 시리즈와 마찬가지로 구글 syzkaller 에
사용되어 지난 2년간 200개가 넘는 버그를 찾아냈다고 하네요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmmbpf-2020-call-for-proposals&#34;&gt;LSF/MM/BPF: 2020: Call for Proposals&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191122172502.vffyfxlqejthjib6@macbook-pro-91.dhcp.thefacebook.com&#34;&gt;https://lkml.kernel.org/r/20191122172502.vffyfxlqejthjib6@macbook-pro-91.dhcp.thefacebook.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;내년 LSF/MM 의 CFP 가 나왔습니다.  근데, 내년부턴 LSF/MM 에 BPF 세션이
추가되네요, 명칭도 LSF/MM/BPF 로 바뀌었습니다.  BPF 의 위상이 새삼 느껴지네요!&lt;/p&gt;
&lt;h2 id=&#34;linux-54&#34;&gt;Linux 5.4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjmzaD=BZ1hjUYu+RTnSGDLfCRwCdg99GeQpCjEwo9uzw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjmzaD=BZ1hjUYu+RTnSGDLfCRwCdg99GeQpCjEwo9uzw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여덟번의 rc 릴리즈를 끝으로 드디어 5.4 정식 버전이 릴리즈 되었습니다.  다행히
지난 일주일 간은 정말 별일 없었다는군요.  Thanksgiving 을 대비해 일찍 들어온
5.5 를 위한 풀리퀘스트가 대부분이었고, 네트워킹과 GPU 쪽의 일부 업데이트가
대부분이었다고 합니다.&lt;/p&gt;
&lt;p&gt;이렇게 5.5 머지 윈도우가 열렸는데, 머지윈도우 중에 Thanksgiving 이 있다는게
조금 걱정되긴 합니다만, 토발즈는 큰일은 없을 걸로 믿으며, 아이들 돌보느라 조금
처리가 늦어질 순 있겠다고 하네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc8</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc8/</link>
      <pubDate>Tue, 12 Nov 2019 20:08:10 +0100</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc8/</guid>
      <description>&lt;h2 id=&#34;patch-0013-finish-off-smp_read_barrier_depends&#34;&gt;&lt;code&gt;[PATCH 00/13] Finish off [smp_]read_barrier_depends()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191108170120.22331-1-will@kernel.org&#34;&gt;https://lkml.kernel.org/r/20191108170120.22331-1-will@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Alpha 에만 의존적인 메모리 모델 요소인 &lt;code&gt;smp_read_barrier_depends()&lt;/code&gt; 는
&lt;code&gt;READ_ONCE()&lt;/code&gt; 에 내장됨으로써 Alpha-specific 하지 않은 커널 코드에서는 Alpha 를
신경쓰지 않아도 되게 되었죠.  그럼에도 불구하고 이걸 신경쓰는 코드가 올라오는게
신경쓰였나 봅니다.
이 패치셋은 커널 코드의 모든 문서와 주석에서 해당 기능에 대한 설명을 삭제해
버립니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0010-add-kernel-concurrency-sanitizer-kcsan&#34;&gt;[PATCH v4 00/10] Add Kernel Concurrency Sanitizer (KCSAN)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191114180303.66955-1-elver@google.com&#34;&gt;https://lkml.kernel.org/r/20191114180303.66955-1-elver@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;구글의 동시성 버그를 잡아주는 KCSAN 패치입니다.  이번 버전은 x86 만을 위한
버전이지만 조만간 ARM64 와 POWER 지원을 추가할 예정이라는군요.  이번 네번째
버전은 이전 버전에 비해 성능이 33% 향상되었다고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-54-rc8&#34;&gt;Linux 5.4-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiyR4Np_n5O6=rbf1GVNdr_zUd1WAC_GJDnc_hUhHqwWg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiyR4Np_n5O6=rbf1GVNdr_zUd1WAC_GJDnc_hUhHqwWg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;정식버전이 나올지 rc8 이 나올지 나름 두근두근한 일주일이었는데, 결국 rc8 이
나왔습니다.  하지만 딱히 문제가 있었던 건 아니라는군요.  떠들썩했던 인텔 취약점
패치가 들어온 한주였음에도 매우 조용했다고 합니다.&lt;/p&gt;
&lt;p&gt;다다음주는 Thanksgiving 이군요.  이 점을 생각하면 다음주는 5.4 에 대한
수정사항보다는 5.5 머지윈도우를 위한 early pull request 가 오길 바란다고
합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc7/</link>
      <pubDate>Mon, 11 Nov 2019 07:17:00 +0100</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-54-rc7&#34;&gt;Linux 5.4-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wivmGEOTha5XkRHgH6VwfiroiN+PFVMNK3B0r-d0eFLPQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wivmGEOTha5XkRHgH6VwfiroiN+PFVMNK3B0r-d0eFLPQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 버전이 릴리즈 되었습니다.  지난 rc6 때도 변경량이 생각보다 많아
토발즈가 고민했는데, 이번주도 토발즈가 원했던 것보단 변경량이 많았다고
하는군요.  다음주에 rc8 을 낼지 5.4 정식 버전을 낼지는 좀 더 고민해 봐야겠다고
합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc6/</link>
      <pubDate>Sat, 02 Nov 2019 09:24:21 +0100</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-v8-mmdebug-add-tests-validating-architecture-page-table-helpers&#34;&gt;[PATCH V8] mm/debug: Add tests validating architecture page table helpers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1572240562-23630-1-git-send-email-anshuman.khandual@arm.com&#34;&gt;https://lkml.kernel.org/r/1572240562-23630-1-git-send-email-anshuman.khandual@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아키텍쳐별 페이지 테이블 헬퍼 등을 테스트 하는 코드를 추가하는 패치입니다.
&lt;code&gt;CONFIG_DEBUG_VM_PGTABLE&lt;/code&gt; 컨피규레이션이 켜져 있으면 동작합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-v2-0025-add-kernelmemorysanitizer-infrastructure&#34;&gt;[PATCH RFC v2 00/25] Add KernelMemorySanitizer infrastructure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191030142237.249532-1-glider@google.com&#34;&gt;https://lkml.kernel.org/r/20191030142237.249532-1-glider@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;초기화 되지 않은 메모리 영역에 액세스 하는 에러를 찾아주는 KMSAN 을 커널에
추가하는 패치입니다.
KCSAN 과 비슷하게 syzkaller 를 통해 돌아가게끔 되어 있군요.&lt;/p&gt;
&lt;p&gt;False positive 문제가 존재할 수는 있는 모양입니다만, 구글 내부에서 syzbot 을
통해 테스트 한 환경에서는 중요한 false positive 는 나오지 않은 모양입니다.
구글 외부에서는 또 모른다는 거죠.&lt;/p&gt;
&lt;p&gt;요즘 커널 개발 프로세스를 개선하자는 이야기가 있고, 그 중에는 패치의 히스토리를
알고 싶다는 이야기가 많죠.
그래서인지 이 메일은 구글 내부 리뷰 시스템인 Gerrit 으로의 링크를 포함시켰네요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-v2-mm-proactive-compaction&#34;&gt;[RFC v2] mm: Proactive compaction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191031005127.8037-1-nigupta@nvidia.com&#34;&gt;https://lkml.kernel.org/r/20191031005127.8037-1-nigupta@nvidia.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 할당을 위해선 연속된 메모리 할당이 필요합니다.
Fragmentation 이 심한 시스템에선 이 할당이 어렵죠.
리눅스는 그래서 compaction 기법을 사용하는데요, 이걸 좀 더 적극적으로 하자는
패치입니다.
이를 통해 latency 가 개선될 수 있죠.&lt;/p&gt;
&lt;p&gt;단순히 hugepage 를 최대한, compaction 을 요청해가며 할당받는 드라이버를 통해 성능을 테스트 했군요.
80th percentile latency 까지는 몇십배 넘게 할당 응답시간을 줄였는데, 90th
percentile 부턴 별 차이 없군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-0010-autonuma-optimize-memory-placement-in-memory-tiering-system&#34;&gt;[RFC 00/10] autonuma: Optimize memory placement in memory tiering system&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191101075727.26683-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20191101075727.26683-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DRAM 과 PMEM 등으로 구성되어 PMEM 을 NUMA node 로 간주하는 multi-tiering memory
system 을 염두에 두고 hot page / cold page 를 구분할 수 있게 해주는
패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-54-rc6&#34;&gt;Linux 5.4-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wg+8=w=sEx9WBF0OJj0SumQ4p-LuP8waRH=TSdAYDeqGg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wg+8=w=sEx9WBF0OJj0SumQ4p-LuP8waRH=TSdAYDeqGg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OSSEU 가 종료되고 토발즈는 집에 잘 도착했고, 시차 적응도 큰 문제는 없었기에
평소대로의 타이밍에 릴리즈가 가능했다고 합니다.
지난 rc5 도 큰 크기였고, rc6 는 이제 슬슬 변경사항이 줄어들어야 할, 토발즈
말로는 그러길 바라는 시점인데, 그렇지 못했습니다.
네트워킹 쪽에서 시점을 맞추지 못한 뒤늦은 풀리퀘스트들이 있었기 때문인데, 딱히
급작스런 문제가 있는 건 아니라는군요.
그렇다곤 해도 토발즈는 조금 찜찜한 모양입니다.
다음주까지 동향을 지켜봐야겠지만 다음주까지도 충분히 변경사항이 줄어들지
않는다면 rc8 까지 가야할 수도 있겠다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc5/</link>
      <pubDate>Sun, 27 Oct 2019 12:48:30 +0100</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc5/</guid>
      <description>&lt;h2 id=&#34;patch-0012-mm-remove-__arch_has_4level_hack&#34;&gt;&lt;code&gt;[PATCH 00/12] mm: remove __ARCH_HAS_4LEVEL_HACK&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1571822941-29776-1-git-send-email-rppt@kernel.org&#34;&gt;https://lkml.kernel.org/r/1571822941-29776-1-git-send-email-rppt@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;서로 다른 아키텍쳐 간의 페이지 테이블 구조로 인해 사용해야 했던
&lt;code&gt;__ARCH_HAS_4LEVEL_HACK&lt;/code&gt; 을 제거하는 패치입니다.  Alpha, arm, c6x 등의
아키텍쳐가 변경되는군요.
UML, qemu 등에서 부팅 테스트를 거쳤군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-54-rc5&#34;&gt;Linux 5.4-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgpewLxHxnO71tFHh=M4C4iUofJykMqq3r=eRyxUyVsiw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgpewLxHxnO71tFHh=M4C4iUofJykMqq3r=eRyxUyVsiw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다섯번째 rc 버전 릴리즈입니다.
하지만 안타깝게도 이번 릴리즈는 마냥 조용하진 않았다는군요.
최근의 다른 rc5 들에 비하면 조금 큰 크기의 릴리즈가 되었습니다.
그렇다곤 해도 아주 특이할 만한 정도는 아니라 토발즈도 큰 걱정은 없다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc4/</link>
      <pubDate>Wed, 16 Oct 2019 20:29:00 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc4/</guid>
      <description>&lt;h2 id=&#34;patch-08-add-kernel-concurrency-sanitizer-kcsan&#34;&gt;[PATCH 0/8] Add Kernel Concurrency Sanitizer (KCSAN)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191016083959.186860-1-elver@google.com&#34;&gt;https://lkml.kernel.org/r/20191016083959.186860-1-elver@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;구글에서 만든 동시성 버그 탐색기능, KCSAN 을 추가하는 패치셋입니다.
처음 세상에 모습을 드러낸건 9월이었고, 최근 컨퍼런스들에서도 발표가 있었죠.
메커니즘은 간단하다면 간단한, 샘플링 기반입니다.
구글 내부 fuzzing tester 인 syzkaller 는 이미 이 기능을 켠채 돌아간다는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-22-mm-zswap-support-thp&#34;&gt;[PATCH 2/2] mm, zswap: Support THP&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1571111349-5041-2-git-send-email-teawater@gmail.com&#34;&gt;https://lkml.kernel.org/r/1571111349-5041-2-git-send-email-teawater@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Zswap 이THP 를 지원하도록 수정하는 패치입니다.  그냥 &lt;code&gt;zswap_frontswap_store()&lt;/code&gt;
함수가 THP 페이지를 연속적인 4 KiB 페이지로 인식하고 처리하게끔 했군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-v1-0026-add-kernelmemorysanitizer-infrastructure&#34;&gt;[PATCH RFC v1 00/26] Add KernelMemorySanitizer infrastructure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191018094304.37056-1-glider@google.com&#34;&gt;https://lkml.kernel.org/r/20191018094304.37056-1-glider@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;구글에서 만든 또다른 sanitizer, KMSAN 입니다.  자매품으로 address sanitizer
등이 있고, 앞서 소개한 concurrency sanitizer 도 있죠.  KMSAN 은 초기화 안된
메모리에의 접근 문제를 찾아내는 Sanitizer 입니다.
Syzkaller 에 적용되어 지난 2년간 무려 200개가 넘는 문제를 발견했다고 합니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 KMSAN 을 적용한 커널을 QEMU 에서 부팅시킬 수 있게 해줍니다.
알려진 false positive 는 없지만 실제로 적용해보면 있을수도 있다고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-54-rc4&#34;&gt;Linux 5.4-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wh3jhffc0u7s5n=-zUFpztuh+0Hfth4vwuyfc5SpBmvSA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wh3jhffc0u7s5n=-zUFpztuh+0Hfth4vwuyfc5SpBmvSA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;네번째 rc 버전 릴리즈입니다.  딱히 특별한 일 없이 평범한 릴리즈라고
자평하는군요.  토발즈는 이번주에 OSSummit Europe 참가를 위해 프랑스로 가는
모양입니다.  하지만 지금처럼 조용하면 큰일은 없을 것 같다고 하네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc3/</link>
      <pubDate>Sun, 13 Oct 2019 12:22:50 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-54-rc3&#34;&gt;Linux 5.4-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjOhveT=qrq8HHyL7gpA5fmBtDa2ue7sO5ZSEBrrcY6Vg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjOhveT=qrq8HHyL7gpA5fmBtDa2ue7sO5ZSEBrrcY6Vg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;세번째 rc 릴리즈입니다.  실제 문제가 발견되고 그에 대한 수정이 본격적으로
시작되는 시즌이라 rc2보단 당연히 크지만 역대 rc3 들과 비교하면 작은 편의
릴리즈라는군요.
staging driver 일부가 사라진 게 조금 릴리즈 크기를 크게 보이게 만들 수 있다는게
그나마 유의할 점일까요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc2/</link>
      <pubDate>Sat, 05 Oct 2019 11:46:07 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-v18-0019-kunit-introduce-kunit-the-linux-kernel-unit-testing-framework&#34;&gt;[PATCH v18 00/19] kunit: introduce KUnit, the Linux kernel unit testing framework&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190923090249.127984-1-brendanhiggins@google.com&#34;&gt;https://lkml.kernel.org/r/20190923090249.127984-1-brendanhiggins@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어떻게 보면 별거 아닌 이유로 5.4 머지윈도우에서 튕겨나가고 만 kunit.
요청받은대로 파일 위치를 하위 디렉토리로 변경한 kunit 새 버전의 패치셋이
올라왔습니다.
&amp;lsquo;kunit/&amp;rsquo; 디렉토리와 kunit 을 위한 &amp;lsquo;Kconfig&amp;rsquo; 파일을 &amp;lsquo;lib/&amp;rsquo; 아래로 옮겼군요.&lt;/p&gt;
&lt;p&gt;이후 벌어진 대화가 재미있는데요, 토발즈는 이걸 5.5에 넣을 예정인데, 가능하면
그동안 실제 테스트 코드도 추가되면 좋겠다고 했습니다.
근데 테스트 프레임웍이 머지안되었는데 테스트 코드를?  메인테이너 간에 일이
복잡해지고 컨플릭 날 확률이 높아지니 이걸로 꽤 많은 이야기가 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-perf-script-python-integrate-page-reclaim-analyze-script&#34;&gt;[PATCH v2] perf script python: integrate page reclaim analyze script&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1569899984-16272-1-git-send-email-laoar.shao@gmail.com&#34;&gt;https://lkml.kernel.org/r/1569899984-16272-1-git-send-email-laoar.shao@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Page reclaim 을 좀더 잘 분석하기 위한 perf script 를 추가하는 패치셋의 두번째
버전입니다.
첫번째 버전은 이 블로그에서도 소개한 바 있죠.
첫번째 버전 이후로의 변화 중 눈에 띄는 건 파이썬 2.7 과 3.6 에서 모두
돌아가게끔 한 것이군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v5-0011-introduces-new-count-based-method-for-tracking-lockless-pagetable-walks&#34;&gt;[PATCH v5 00/11] Introduces new count-based method for tracking lockless pagetable walks&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191003013325.2614-1-leonardo@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20191003013325.2614-1-leonardo@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP promotion/demotion 과 동시에 page table 조작이 일어나는 걸 막기 위해
존재하는 &lt;code&gt;serialize_against_pte_lookup()&lt;/code&gt; 함수로 인해 발생하는 &lt;code&gt;munmap()&lt;/code&gt;
레이턴시 문제를 동시의 page table walk 존재 여부를 카운트 기반으로 추적해,
필요없을 땐 락을 잡지 않게 함으로써 레이턴시를 놀랍게 개선한 패치셋의 다섯번째
버전입니다.
이 블로그에서도 소개했죠.
지난 버전 이후로 인터럽트 처리 부분을 포함한 일부 부분이 조금 수정되었군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-export-cma-alloc-and-release&#34;&gt;[PATCH] mm: export cma alloc and release&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191002212257.196849-1-salyzyn@android.com&#34;&gt;https://lkml.kernel.org/r/20191002212257.196849-1-salyzyn@android.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cma_alloc()&lt;/code&gt; 과 &lt;code&gt;cma_release()&lt;/code&gt; 함수를 드라이버에서도 쓸 수 있게 export 해주는
패치셋입니다.
안드로이드 ION 이라던지 RDMA, Camera 모듈들이 이에 의존적이어서 드라이버 레벨로
빌드가 안되기 때문에 이런 변경을 제안했다네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-54-rc2&#34;&gt;Linux 5.4-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiNT4Yk+36OXMyPuesrU88cFyDG_XnjRiKwaac09PJpQw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiNT4Yk+36OXMyPuesrU88cFyDG_XnjRiKwaac09PJpQw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다시 일요일 오후 릴리즈로 돌아왔습니다.
큰 변화는 없고 그저 소소한 수정 사항들 뿐이었다는군요.
일반적으로 진짜 regression 에 대한 파악이 이루어지고 그에 대한 수정이
시작되는건 rc2 후라는 걸 감안하면 매우 평범한 릴리즈라고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc1/</link>
      <pubDate>Sat, 21 Sep 2019 10:00:48 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.4-rc1/</guid>
      <description>&lt;h2 id=&#34;patch-02-introduce-new-perf-script-page-reclaim&#34;&gt;[PATCH 0/2] introduce new perf-script page-reclaim&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1568817522-8754-1-git-send-email-laoar.shao@gmail.com&#34;&gt;https://lkml.kernel.org/r/1568817522-8754-1-git-send-email-laoar.shao@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Page reclaim 관련 성능 메트릭을 분석하기 위한 perf script 커맨드를 추가하는
패치입니다.  Direct reclaim 으로 인한 응답시간 폭증, page reclaim 이 왜
일어났는지, page reclaim 의 효과는 어땠는지 등을 알 수 있다는군요.&lt;/p&gt;
&lt;p&gt;구체적으로는 direct reclaim 이 몇번 일어났는지, 그 latency 분포는 어땠는지,
file / anon page 별로 reclaim, scan, sync write, async write 이 몇번
일어났는지, kswapd 는 몇번 일어났는지, kswapd latency 는 어땠는지 등등을
보입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ perf script report page-reclaim
    Direct reclaims: 4924
    Direct latency (ms)        total         max         avg         min
                          177823.211    6378.977      36.114       0.051
    Direct file reclaimed 22920
    Direct file scanned 28306
    Direct file sync write I/O 0
    Direct file async write I/O 0
    Direct anon reclaimed 212567
    Direct anon scanned 1446854
    Direct anon sync write I/O 0
    Direct anon async write I/O 278325
    Direct order      0     1     3
                   4870    23    31
    Wake kswapd requests 716
    Wake order      0     1
                  715     1

    Kswapd reclaims: 9
    Kswapd latency (ms)        total         max         avg         min
                           86353.046   42128.816    9594.783     120.736
    Kswapd file reclaimed 366461
    Kswapd file scanned 369554
    Kswapd file sync write I/O 0
    Kswapd file async write I/O 0
    Kswapd anon reclaimed 362594
    Kswapd anon scanned 693938
    Kswapd anon sync write I/O 0
    Kswapd anon async write I/O 330663
    Kswapd order      0     1     3
                      3     1     5
    Kswapd re-wakes 705

    Per process latency (ms):
         pid[comm]             total         max         avg         min
               timestamp  latency(ns)
           1[systemd]        276.764     248.933       21.29       0.293
           3406860552338: 16819800
           3406877381650: 5532855
           3407458799399: 929517
           3407459796042: 916682
           3407460763220: 418989
           3407461250236: 332355
           3407461637534: 401731
           3407462092234: 449219
           3407462605855: 292857
           3407462952343: 372700
           3407463364947: 414880
           3407463829547: 949162
           3407464813883: 248933444
         163[kswapd0]      86353.046   42128.816    9594.783     120.736
           3357637025977: 1026962745
           3358915619888: 41268642175
           3400239664127: 42128816204
           3443784780373: 679641989
           3444847948969: 120735792
           3445001978784: 342713657
           ...
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;git-pull-kselftest-update-for-linux-54-rc1&#34;&gt;[GIT PULL] Kselftest update for Linux 5.4-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/be8059f4-8e8f-cd18-0978-a9c861f6396b@linuxfoundation.org&#34;&gt;https://lkml.kernel.org/r/be8059f4-8e8f-cd18-0978-a9c861f6396b@linuxfoundation.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이블로그에서도 여러차례 소개했던 kunit 은 제가 오랫동안 메인라인에 머지되기를
기다려 왔던 기능입니다.
이번 kernel summit 에서 발표한 제 damon 이란 프로젝트도 kunit 을 이용해 test
driven development 기법을 적용했고, 그 효과를 톡톡히 봤죠.
이 패치셋이 4.9에 들어갈 예정이었고, Shuah Kahn 이 이번 머지 윈도우에
풀리퀘스트에 이 패치셋을 포함해 보냈는데요.
토발즈가 바로 퉤에엣 을 시전했습니다.&lt;/p&gt;
&lt;p&gt;이유가 재미있습니다, kunit 패치는 리눅스 소스코드 루트 디렉토리에 &lt;code&gt;kunit/&lt;/code&gt;
디렉토리를 추가하는데, 이게 토발즈 마음에 들지 않았습니다.
토발즈의 tab 키를 활용한 자동완성 기능을 부셨기 때문이죠.
&lt;code&gt;kernel/&lt;/code&gt; 디렉토리로 이용하기 위해 &lt;code&gt;k&lt;/code&gt; 만 타이핑 하고 탭키를 누르면 되었는데,
이제 &lt;code&gt;kunit/&lt;/code&gt; 디렉토리 때문에 이게 안되는 거죠.&lt;/p&gt;
&lt;p&gt;생각하기에 따라선 좀 억지 아니냐고 생각할 수 있고 저도 kunit 의 오랜 팬으로써
좀 아쉬운 마음이 있었는데요.
또 이제와서 생각해 보면 저도 &lt;code&gt;kernel/&lt;/code&gt; 넘어가기 위해 한번 더 키보드에 손대야
하는게 좀 불쾌했던 거 같기도 하네요. ;)&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0011-introduces-new-count-based-method-for-monitoring-lockless-pagetable-walks&#34;&gt;[PATCH v4 00/11] Introduces new count-based method for monitoring lockless pagetable walks&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190927234008.11513-1-leonardo@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190927234008.11513-1-leonardo@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;128개 vcpu 의 qemu 가 THP 로 매핑된 496 GiB 메모리 영역을 &lt;code&gt;munmap()&lt;/code&gt; 완료하는데
무려 275초가 걸린다고 합니다.
그 원인은 &lt;code&gt;serialize_against_pte_lookup()&lt;/code&gt; 함수였다고 하는군요.
이 함수는 &lt;code&gt;find_current_mm_pte()&lt;/code&gt; 내에서의 &lt;code&gt;pmd_t&lt;/code&gt; 에서 &lt;code&gt;pte_t&lt;/code&gt; 로의 캐스팅
또는 lockless page table walk 이 THP promotion/demotion 과 동시에 이루어지지
않게끔 보호하는 용도로 사용됩니다.
그렇다면, 실제 lockless page table walk 이 없다면
&lt;code&gt;serialize_against_pte_lookup()&lt;/code&gt; 은 호출될 필요가 없겠죠.&lt;/p&gt;
&lt;p&gt;이를 위해 이 패치셋은 현재 수행되고 있는 &lt;code&gt;find_current_mm_pte()&lt;/code&gt; 함수 갯수를
세고 그 갯수가 0이면 이 오버헤드가 되는 동시성 보호 코드를 생략하게 합니다.&lt;/p&gt;
&lt;p&gt;이 패치를 적용한 후 앞의 문제시 되던 작업에 걸리는 시간이 275초에서 무려 418 ms
으로 줄었다는군요!&lt;/p&gt;
&lt;h2 id=&#34;linux-54-rc1&#34;&gt;Linux 5.4-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgbGJ-SGeevEcgrThhPp+RwYOUUgWoZ3W27cbUpuB3VgA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgbGJ-SGeevEcgrThhPp+RwYOUUgWoZ3W27cbUpuB3VgA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;평소보다 하루 늦은 월요일에 5.4 머지윈도우가 닫히고 rc1 릴리즈가
이루어졌습니다.
좀 미뤄진 머지를 처리하느라 늦어져서 하루 늦은 릴리즈가 되긴 했지만 대수로운
일은 아니라는군요.&lt;/p&gt;
&lt;p&gt;전체적인 릴리즈 내용도 평시와 크게 다른 내용은 없습니다.
AMD DRM 관련 변경이 많이 있지만 이는 하드웨어 구성에 따른 변화니까 무시하면
되고, 그걸 제외하고 보면 평소와 변경사항들의 분포도 비슷하다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.3/</link>
      <pubDate>Thu, 12 Sep 2019 17:59:25 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.3/</guid>
      <description>&lt;h2 id=&#34;patch-x86mm-enable-5-level-paging-support-by-default&#34;&gt;[PATCH] x86/mm: Enable 5-level paging support by default&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190913095452.40592-1-kirill.shutemov@linux.intel.com&#34;&gt;https://lkml.kernel.org/r/20190913095452.40592-1-kirill.shutemov@linux.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5 레벨 페이지 테이블 기능이 들어간지도 어느덧 시간이 지났죠.
인텔 내부적 테스트 상으론 이 기능을 켰을 때 4 레벨 페이지 테이블 기계에서도
딱히 리그레션 등은 나타나지 않았고, 주요 배포판들은 5 레벨 페이지 테이블
서포트를 기본으로 켤것으로 보인다고 합니다.
따라서 이 기능을 아예 디폴트로 켜져있게 하는 패치입니다.&lt;/p&gt;
&lt;p&gt;v5.4 에 들어가기엔 좀 늦은 관계로, v5.5 에 들어갈 것 같다는군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-53&#34;&gt;Linux 5.3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiP4K8DRJWsCo=20hn_6054xBamGKF2kPgUzpB5aMaofA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiP4K8DRJWsCo=20hn_6054xBamGKF2kPgUzpB5aMaofA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LPC 와 커널 서밋 등으로 인해 한주 늦춰진 5.3 릴리즈가 이뤄졌습니다.
지난 일주일은 고요했을 뿐더러, 이 늦춰진 일정 덕에 몇가지 수정도 더 이뤄질 수
있었다고 토발즈는 평하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc8</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc8/</link>
      <pubDate>Wed, 04 Sep 2019 23:56:59 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc8/</guid>
      <description>&lt;h2 id=&#34;patch-rfc-0014-the-new-slab-memory-controller&#34;&gt;[PATCH RFC 00/14] The new slab memory controller&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190905214553.1643060-1-guro@fb.com&#34;&gt;https://lkml.kernel.org/r/20190905214553.1643060-1-guro@fb.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;슬랩 할당자의 실제 메모리 활용률이 대부분 45-65 퍼센트에 불과했다고 합니다.
이는 슬랩 페이지가 각 메모리 cgroup 마다 배타적으로 사용되기 때문입니다.  적은
메모리만 사용하는 cgroup 여러개가 존재하면 슬랩에서 크게 받아놓은 메모리에서
조금씩만 실제 사용되니까 전체 활용률은 낮게 되는거죠.  이 RFC 패치셋은 서로
다른 cgroup 들이 슬랩 페이지를 공유할 수 있게 함으로써 이 문제를 해결합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-53-rc8&#34;&gt;Linux 5.3-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whBQ+6c-h+htiv6pp8ndtv97+45AH9WvdZougDRM6M4VQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whBQ+6c-h+htiv6pp8ndtv97+45AH9WvdZougDRM6M4VQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;평소대로라면 5.3 정식 릴리즈가 되었을테고 별다른 문제는 없었지만, rc7
릴리즈에서 이야기된대로 LPC 와 커널 서밋도 있고 한 이유로, -rc8 이 릴리즈
되었습니다.
그렇다보니 특기할 만한 사항은 없습니다만, 정식 릴리즈를 늦춘 덕에 stable 트리로
넘어갈 뻔한 수정사항 몇가지를 이번 릴리즈 내에 넣을 수 있게 되었다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc7/</link>
      <pubDate>Mon, 02 Sep 2019 10:57:44 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc7/</guid>
      <description>&lt;p&gt;평소보다 늦은 월요일 아침 릴리즈가 이뤄졌습니다.  일요일에 토발즈가
컴퓨터로부터 떨어져 있었다는군요.&lt;/p&gt;
&lt;p&gt;늦어진 릴리즈 덕분에 뒤늦게 들어온 풀리퀘스트를 더 받을 수 있었고, 이로 인해
이번 rc 릴리즈는 평소보다 좀 사이즈가 큽니다.
따라서 이번 릴리즈의 크기가 불안정성을 의미하는 게 아니라 5.3 정식 릴리즈를 늦출 필요는 없습니다만, 공교롭게도 또한 다음주는 LPC 와 커널 서밋이 있죠.
토발즈도 그렇고 많은 다른 개발자들도 이때 LPC 와 커널 서밋에 참가할 거라, rc7
을 마지막으로 5.3 릴리즈를 하면 5.4 머지 윈도우의 많은 시간을 여행에 보내게
되므로, 그냥 rc8 을 릴리즈 하겠다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc6/</link>
      <pubDate>Thu, 22 Aug 2019 15:30:54 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-53-rc6&#34;&gt;Linux 5.3-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgAKCTq+t5YnG6HzrF62=rr9H=q3LqokEP0_bQRHLwYNw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgAKCTq+t5YnG6HzrF62=rr9H=q3LqokEP0_bQRHLwYNw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;오늘은 리눅스의 28번째 생일입니다.  따라서 오늘 rc6 릴리즈는 28년만의
릴리즈이기도 하군요.  토발즈도 감회가 깊었는지 오늘의 릴리즈 메일엔 최초 릴리즈
메일에 적었던 내용과 비슷하게 시작 부분을 꾸몄네요.
감회 깊은 날, 감회 깊은 릴리즈입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;리눅스를 사용하는 여러분들 안녕하세요,

저는 486 AT 클론과 그외의 많은 다른 하드웨어를 위한 (자유) 운영체제를 (취미보단
더 진지하게) 만들고 있습니다.  이 일은 28년째 지속되고 있고, 아직도 끝나지
않았습니다.  이 릴리즈에 의해 만들어진 (또는 그보다 오래된) 모든 버그에 대한
피드백을 부탁드립니다.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;어쨌건, 아주 특별할 건 없는 릴리즈였습니다만, 토발즈가 원하던 것에 비하면
변경사항이 좀 많았다는군요.  다음주에 확실히 변경사항이 줄지 않는다면 rc8 을
만들어야 할 것 같다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc5/</link>
      <pubDate>Mon, 19 Aug 2019 14:19:58 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc5/</guid>
      <description>&lt;h2 id=&#34;rfc-patch-02-add-predictive-memory-reclamation-and-compaction&#34;&gt;[RFC PATCH 0/2] Add predictive memory reclamation and compaction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190813014012.30232-1-khalid.aziz@oracle.com&#34;&gt;https://lkml.kernel.org/r/20190813014012.30232-1-khalid.aziz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널의 page reclamation 과 compaction 등은 기본적으로 시스템 메모리 잔여량이
부족할 때 시작됩니다.  하지만 이땐 이미 때가 늦었습니다.  reclamation 과
compaction 을 열심히 하긴 하지만 어플리케이션은 이미 메모리 부족으로 인한
응답시간 폭증 등을 겪게 됩니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 시스템의 메모리 부족을 미리 예측하고 reclamation 과 compaction 을
시작하기 위한 패치셋입니다.  시간축에 따라 메모리 사용량 변화 추세를 보면 이걸
예측할 수 있지 않겠냐는 것이죠.&lt;/p&gt;
&lt;p&gt;이 패치셋은 이런 아이디어에 기반해 시스템의 메모리 부족을 예측하고 kswapd 를
깨울지 재울지를 결정합니다.  간단한 dd 기반의 테스트를 통해 그 성능을 측정한
결과도 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-kbuild-change-fallthrough-comments-to-attributes&#34;&gt;[PATCH] kbuild: Change fallthrough comments to attributes&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190812214711.83710-1-nhuck@google.com&#34;&gt;https://lkml.kernel.org/r/20190812214711.83710-1-nhuck@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C 언의 &lt;code&gt;switch&lt;/code&gt; 구문의 fall-through 기능은 복잡한 기능을 구현하기 좋긴 한데
암묵적으로 이루어지는 fall-through 를 방지하기 위해 &lt;code&gt;break;&lt;/code&gt; 를 추가하는 걸
깜박하곤 하는 경우가 많습니다.  GCC 는 주석으로 이 부분은 fall-through 가 맞다,
라는걸 지정할 수 있게 하고 이 주석이 없는 경우는 모두 fall-through 를
막아버림으로써 &lt;code&gt;switch&lt;/code&gt; 의 명시적 fall-through 기능이 가능하게 합니다.&lt;/p&gt;
&lt;p&gt;리눅스 커널 역시 이런 방식으로 암묵적 fall-through 에 의한 버그를 극복하려
노력하는데요, clang 은 이걸 주석 형태가 아니라 attribute 형태로 지원합니다.  이
패치는 이런 차이를 어드레스 하기 위한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-mm-proactive-compaction&#34;&gt;[RFC] mm: Proactive compaction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190816214413.15006-1-nigupta@nvidia.com&#34;&gt;https://lkml.kernel.org/r/20190816214413.15006-1-nigupta@nvidia.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 등의 할당 시간은 fragmentation 이 심한 메모리에선 길어지거나 아예
실패할 수 있죠.  Huge page 에 성능이 의존적인 어플리케이션에겐 큰 문제입니다.&lt;/p&gt;
&lt;p&gt;이 패치는 page order 별 fragmentation threshold 를 두고 이에 맞춰 page order
별로 다른 compaction 을 수행하자는 겁니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-53-rc5&#34;&gt;Linux 5.3-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiO5-puMa30fCwtgze57MH2JOzedVcEVotEviYmmQNihQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiO5-puMa30fCwtgze57MH2JOzedVcEVotEviYmmQNihQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다섯번째 rc 릴리즈입니다.  노드 로컬 할당 대 huge page 할당 관련 커밋 일부가
리버트 시키지 않는 등의 몇가지 문제를 제외하면 조용한 릴리즈 주간이었다는군요.
잘 안정화 되어가고 있다는 증거겠지요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc4/</link>
      <pubDate>Mon, 12 Aug 2019 01:40:13 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc4/</guid>
      <description>&lt;h2 id=&#34;rfc-patch-v6-0092-vm-introspection&#34;&gt;[RFC PATCH v6 00/92] VM introspection&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190809160047.8319-1-alazar@bitdefender.com&#34;&gt;https://lkml.kernel.org/r/20190809160047.8319-1-alazar@bitdefender.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;호스트 또는 별도 VM 에서 돌아가는 어플리케이션이 다른 VM들을 제어하거나 상태를
알아보거나 shadow 페이지 테이블을 조정하거나 특정 이벤트 발생시 알림을 받거나
할 수 있게 해주는 KVM introspection 서브시스템을 제안하는 패치입니다.  무려
92개짜리의 거대한 패치군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-15-mmpage_idle-add-per-pid-idle-page-tracking-using-virtual-indexing&#34;&gt;[PATCH v4 1/5] &lt;code&gt;mm/page_idle&lt;/code&gt;: Add per-pid idle page tracking using virtual indexing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190805170451.26009-1-joel@joelfernandes.org&#34;&gt;https://lkml.kernel.org/r/20190805170451.26009-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;페이지 액세스 여부를 알아볼 수 있는 &lt;code&gt;page_idle&lt;/code&gt; 기능을 프로세스별로 트래킹 하기
편하게 만들어 주는 패치의 네번째 버전입니다.  저자는 구글 직원으로,
안드로이드의 heap profiler 가 이 기능을 쓰나봅니다.  이전 버전과의 차이는&amp;hellip;
Swap pte 처리가 추가되었군요.&lt;/p&gt;
&lt;p&gt;다섯번째 버전도 바로 올라왔습니다만, 큰 차이는 없어 보이는군요:
&lt;a href=&#34;https://lkml.kernel.org/r/20190807171559.182301-1-joel@joelfernandes.org&#34;&gt;https://lkml.kernel.org/r/20190807171559.182301-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;linux-53-rc4&#34;&gt;Linux 5.3-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whWJ7Dv9yZBZpxWd1zcAMwokjt7c8YOp-FOf1PXDKGrmQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whWJ7Dv9yZBZpxWd1zcAMwokjt7c8YOp-FOf1PXDKGrmQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;세번째 rc 는 어째선지 작은 크기였다 말했었죠, 그냥 pull request 들이 천천히
왔기 때문이 맞는 것 같다고 합니다.  이번 rc 릴리즈는 평소 크기에 rc3 에
안들어간 내용이 들어간 만큼 크다고 합니다.
덕분에 최근 2년 사이의 rc4 중 가장 크다고 하네요.
rc3 에 안들어갔다가 rc4 에 뒤늦게 들어온 변경사항은 대부분 network 쪽
코드라는군요.&lt;/p&gt;
&lt;p&gt;이번 변경 중 개인적으로 눈에 띄는건 &lt;code&gt;switch-case&lt;/code&gt; 구문의 fall-through 코멘트
업데이트입니다.
LWN 에도 관련 글이 올라왔으니 한번 읽어보는 것도 좋을 겁니다:
&lt;a href=&#34;https://lwn.net/Articles/794944/&#34;&gt;https://lwn.net/Articles/794944/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 rc 릴리즈 개발 과정 시각화 동영상을 아래 링크에서 보실 수 있습니다:
&lt;a href=&#34;https://youtu.be/EB3i8iBuuHM&#34;&gt;https://youtu.be/EB3i8iBuuHM&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc3/</link>
      <pubDate>Wed, 31 Jul 2019 08:40:48 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc3/</guid>
      <description>&lt;h2 id=&#34;patch-v5-0014-provide-generic-top-down-mmap-layout-functions&#34;&gt;[PATCH v5 00/14] Provide generic top-down mmap layout functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190730055113.23635-1-alex@ghiti.fr&#34;&gt;https://lkml.kernel.org/r/20190730055113.23635-1-alex@ghiti.fr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아키텍쳐별로 다르게 구현되어 있던 mmap 레이아웃 함수들을 범용화 시키는 패치셋,
다섯번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v10-0022-generic-page-walk-and-ptdump&#34;&gt;[PATCH v10 00/22] Generic page walk and ptdump&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190731154603.41797-1-steven.price@arm.com&#34;&gt;https://lkml.kernel.org/r/20190731154603.41797-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;역시 아키텍쳐별로 다르게 구현되어 있던 page table walk 과 page table dump
기능을 범용화 시키는 패치입니다.  벌써 10번째 버전이군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-03-address-hugetlb-page-allocation-stalls&#34;&gt;[PATCH 0/3] address hugetlb page allocation stalls&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190802223930.30971-1-mike.kravetz@oracle.com&#34;&gt;https://lkml.kernel.org/r/20190802223930.30971-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sysctl&lt;/code&gt; 이나 &lt;code&gt;procfs&lt;/code&gt; 를 통한 hugetlb 페이지 할당은 수분이나 수시간까지도 오래
걸릴 수 있습니다.  이 패치셋은 이렇게 느린 할당시간 문제를 유발하는 reclaim 과
compaction 쪽 문제를 해결할 수 있는 수정사항들을 담고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-53-rc3&#34;&gt;Linux 5.3-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiW+q32YcUL62XWjAme8giZDo-=kmB9=f_JEgyEgV7eaA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiW+q32YcUL62XWjAme8giZDo-=kmB9=f_JEgyEgV7eaA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;보통 머지 윈도우가 지난 후에는 사람들이 숨을 고르고 넘어가기 때문에 보통 rc2 가
작고 rc3 부터 변경이 많아집니다.  하지만 이번 릴리즈는 이상하게도 rc2 보다
작았다는군요.&lt;/p&gt;
&lt;p&gt;커밋 기반으로 그린 rc3 개발 시각화 동영상을 다음 링크에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/V1qUa2QXZes&#34;&gt;https://youtu.be/V1qUa2QXZes&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Memory: the flat, the discontiguous, and the sparse (Korean)</title>
      <link>https://sjp38.github.io/ko/post/lwn_memory_flat_discontiguous_sparse/</link>
      <pubDate>Wed, 31 Jul 2019 07:45:17 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lwn_memory_flat_discontiguous_sparse/</guid>
      <description>&lt;p&gt;LWN 의 &amp;ldquo;Memory: the flat, the discontiguous, and the sparse&amp;rdquo; 라는 제목의 글의
한글 번역입니다.  원문은 LWN 에서 볼 수 있습니다:
&lt;a href=&#34;https://lwn.net/Articles/789304/&#34;&gt;https://lwn.net/Articles/789304/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;May 27, 2019&lt;/p&gt;
&lt;p&gt;이 기사는 Mike Rapoport 에 의해 기여되었습니다.&lt;/p&gt;
&lt;p&gt;컴퓨터 시스템에서 물리 메모리는 소중한 자원이어서, 이를 효율적으로 관리하기
위한 많은 노력이 기울여져왔습니다.
이 일은 현대의 시스템에서의 메모리 구조가 복잡해짐에 따라 더 어려워졌습니다.
물리 메모리가 실제로 어떻게 위치해 있는가를 다루기 위한 여러 계층의 추상화가
존재합니다; 그런 추상화 중 하나는 &amp;ldquo;메모리 모델&amp;rdquo; 이라고 불립니다.
커널은 세개의 모델을 지원하고 있는데, 그 중 하나는 지원이 멈춰져 가고 있습니다.
이 변경을 이해하기 위한 방법으로, 이 기사는 커널의 메모리 모델들의 진화, 현재
상태, 그리고 있을 법한 미래에 대해 자세히 들여다 봅니다.&lt;/p&gt;
&lt;h2 id=&#34;flatmem&#34;&gt;FLATMEM&lt;/h2&gt;
&lt;p&gt;리눅스가 처음 나왔을 때, 메모리는 평평했습니다: 메모리는 0 부터 수 메가바이트의
물리 주소를 갖는 단순한 선형적 배열일 뿐이었습니다.
각 물리 페이지 프레임은 커널의 &lt;code&gt;mem_map&lt;/code&gt; 배열에 하나의 원소와 연관되었으며, 이
당시에 이 배열은 해당 페이지가 가진 레퍼런스의 갯수를 세는 하나의 &lt;code&gt;unsigned short&lt;/code&gt; 원소로 이루어져 있었습니다.
하지만, 얼마 있지 않아서, 이 &lt;code&gt;mem_map&lt;/code&gt; 의 원소들은 스왑 관리를 위한 &lt;code&gt;age&lt;/code&gt; 와
&lt;code&gt;dirty counter&lt;/code&gt; 를 포함하도록 커졌습니다.
Linux 1.3.50 에서 &lt;code&gt;mem_map&lt;/code&gt; 의 원소들은 마침내 &lt;code&gt;struct page&lt;/code&gt; 로
이름지어졌습니다.&lt;/p&gt;
&lt;p&gt;이 평평한 메모리 매핑은 물리 페이지 프레임 번호 (page-frame number : PFN) 와
그에 대응되는 &lt;code&gt;struct page&lt;/code&gt; 사이의 쉽고 빠른 변환을 제공했습니다; 이 변환
작업은 간단한 배열 인덱스 계산 문제였습니다.
이후 &lt;code&gt;struct page&lt;/code&gt; 의 레이아웃 변경이 있었는데, 새로운 사용처 (예컨대, page
cache) 들과 &lt;code&gt;struct page&lt;/code&gt; 의 캐시 성능 최적화를 위한 것이었습니다.
메모리 매핑은 깔끔하고 효율적인 평평한 배열로 유지되었습니다만, 이는 중요한
단점을 가지고 있었습니다: 물리 주소 공간 상의 큰 공백을 처리할 수 없었습니다.
이 메모리 매핑 가운데 공백에 연관된 부분은 낭비되어지거나, ARM 에서처럼, 메모리
매핑 자체가 공백을 가질 수 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;discontigmem&#34;&gt;DISCONTIGMEM&lt;/h2&gt;
&lt;p&gt;상당히 비연속적인 물리 메모리를 효율적으로 처리하기 위한 지원이 리눅스를 NUMA
기계들 위에서 잘 동작하도록 하기 위한 노력의 일환으로 1999년에 메모리 관리
서브시스템으로 들어왔습니다.
이 코드는 &lt;code&gt;CONFIG_DISCONTIGMEM&lt;/code&gt; 설정 옵션에 종속적이어서, 이 메모리 모델은
&lt;code&gt;DISCONTIGMEM&lt;/code&gt; 이라 이름지어진 첫번째 모델이었습니다.&lt;/p&gt;
&lt;p&gt;이 &lt;code&gt;DISCONTIGMEM&lt;/code&gt; 모델은 메모리 노드 (memory node) 라는 개념을 소개했는데, 이
개념은 여전히 NUMA 메모리 관리의 기본으로 남아있습니다.
각 노드는 free-page lists, in-use page lists, least-recently-used (LRU) 정보,
사용 통계 등을 포함한, (대부분) 독립적인 메모리 관리 서브시스템을 갖습니다.
이런 것들 가운데, &lt;code&gt;struct pglist_data&lt;/code&gt; (또는 짧게 &lt;code&gt;pg_data_t&lt;/code&gt;) 로 표현되는 노드
데이터는 하나의 노드에 대한 메모리 매핑 정보를 가지고 있습니다.
각 노드가 연속적인 물리 메모리를 가지고 있다는 가정 하에, 노드당 하나의 &lt;code&gt;struct page&lt;/code&gt; 배열을 갖는 것은 평평한 메모리 매핑 안의 거대한 공백 문제를 해결했습니다.&lt;/p&gt;
&lt;p&gt;하지만 이게 공짜로 된 건 아닙니다.
&lt;code&gt;DISCONTIGMEM&lt;/code&gt; 에서는, 예를 들면 어떤 PFN 을 그에 연관된 &lt;code&gt;struct page&lt;/code&gt; 로
변환하기 위해 특정 페이지를 어떤 노드가 가지고 있는지를 알 수 있어야 합니다.
비슷하게, 페이지를 가지고 PFN 을 구하기 위해 어떤 노드의 메모리 맵이 해당
&lt;code&gt;struct page&lt;/code&gt; 를 가지고 있는지도 알 수 있어야 합니다.
긴 진화의 끝에, &lt;code&gt;KVADDR_TO_NID()&lt;/code&gt;, &lt;code&gt;LOCAL_MAP_BASE()&lt;/code&gt;, &lt;code&gt;ADDR_TO_MAPBASE()&lt;/code&gt;,
그리고 &lt;code&gt;LOCAL_BASE_ADDR()&lt;/code&gt; 매크로를 처음 정의한 &lt;code&gt;mips64&lt;/code&gt; 부터 시작해서 PFN 의
&lt;code&gt;struct page&lt;/code&gt; 로의 변환과 그 반대 작업은 &lt;code&gt;include/asm-generic/memory_model.h&lt;/code&gt;
안에 정의된, 비교적 간단한 &lt;code&gt;pfn_to_page()&lt;/code&gt; 와 &lt;code&gt;page_to_pfn()&lt;/code&gt; 매크로로 수행되게
되었습니다.&lt;/p&gt;
&lt;p&gt;하지만, DISCONTIGMEM 은 약점이 있었습니다: 메모리 핫플러그 (hotplug) 와
핫리무브 (hot remove) 입니다.
실제 NUMA 노드는 실제 핫플러그를 지원하기엔 너무 굵은 크기였고, 노드를 쪼개는
것은 불필요한게 많은 단편화와 오버헤드를 가져올 것이었습니다.
각 노드가 독립적인 메모리 관리 구조체들을 연관된 비용과 함께 가짐을 기억해
보세요; 노드를 쪼개는 것은 그런 비용을 상당히 증가시킬 겁니다.&lt;/p&gt;
&lt;h2 id=&#34;sparsemem&#34;&gt;SPARSEMEM&lt;/h2&gt;
&lt;p&gt;이 한계는 SPARSEMEM 을 통해 해결되었습니다.  이 모델은 메모리 매핑을
아키텍쳐별로 정의된 임의의 크기의 섹션들의 집합으로 추상화 했습니다.
각 섹션은 &lt;code&gt;struct mem_section&lt;/code&gt; 으로 표현되며, (코드에 설명된 바에 따르면):
&amp;ldquo;논리적으로, &lt;code&gt;struct page&lt;/code&gt; 의 배열로의 포인터입니다.  하지만, 다른 마술을 통해
저장됩니다&amp;rdquo;.
이 섹션들의 배열은 &lt;code&gt;SECTION_SIZE&lt;/code&gt; 크기로 효율적으로 쪼개질 수 있는 메타 메모리
매핑입니다.
PFN 과 &lt;code&gt;struct page&lt;/code&gt; 사이의 효율적인 변환을 위해, PFN 의 상위 비트 몇개는 이
섹션 배열로의 인덱스로 사용됩니다.
반대 방향 변환을 위해선, 이 섹션 넘버가 page 의 flag 로 인코딩 됩니다.&lt;/p&gt;
&lt;p&gt;이 모델이 리눅스 커널에 소개되고 몇달 후, SPARSEMEM 은 &lt;code&gt;SPARSEMEM_EXTREME&lt;/code&gt; 으로
확장되었는데, 이 모델은 산재하는 물리 주소 공간을 갖는 시스템에 적합합니다.
&lt;code&gt;SPARSEMEM_EXTREME&lt;/code&gt; 에서는, 첫번째 레벨은 &lt;code&gt;mem_section&lt;/code&gt; 구조체들로의 포인터가
되고, 실제 &lt;code&gt;mem_section&lt;/code&gt; 객체는 실제로 꽂힌 물리 메모리에 기반해서 동적으로
할당됩니다.&lt;/p&gt;
&lt;p&gt;2007년에 SPARSEMEM 의 또다른 개선이 이루어졌습니다; 이는 SPARSEMEM 의 일반적인
가상 메모리 매핑 지원 또는 &lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 이라고 불렸습니다.
&lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 의 아이디어는 전체 메모리 매핑이 가상 연속 공간에 매핑되어
있지만, 활성화된 섹션들만이 물리 페이지로 연결되어 있도록 하자는 것입니다.
이 모델은 32-bit 시스템에서는 물리 메모리의 크기가 가상 주소 공간을 넘을 수
있기 때문에 잘 동작하지 못할 수 있습니다.
하지만, 64-bit 시스템에서 &lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 은 확실히 우수합니다.
추가적인 페이지 테이블 엔트리 사용이라는 비용 아래, &lt;code&gt;page_to_pfn()&lt;/code&gt; 과
&lt;code&gt;pfn_to_page()&lt;/code&gt; 는 평평한 모델만큼이나 간단해 졌습니다.&lt;/p&gt;
&lt;p&gt;SPARSEMEM 메모리 모델의 마지막 확장은 꽤 최근 (2016) 이었습니다; 이는
persistent 메모리 디바이스의 사용 증가로 인해 이루어졌습니다.
메모리 매핑을 메인 메모리가 아니라 그런 디바이스들 내에 직접 저장하는 걸
지원하기 위해, 이 가상 메모리 매핑은 &lt;code&gt;struct vmem_altmap&lt;/code&gt; 을 사용할 수 있게
되었는데, 이 구조체는 persistent 메모리 안의 페이지 구조체를 제공합니다.&lt;/p&gt;
&lt;p&gt;2005년으로 돌아가보면, SPARSEMEM 은 &amp;ldquo;새로운, 그리고 실험적인 &lt;code&gt;discontiguous memory&lt;/code&gt; 의 대체재&amp;rdquo; 로 설명되었습니다.
&lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 을 추가한 커밋은 그것을 &amp;ldquo;우리가 SPARSEMEM 을 대부분의
시스템에 기본 (그리고 유일한) 옵션이 되게 할 가능성이 있다&amp;rdquo; 고 했습니다.
그리고 실제로, 일부 아키텍쳐는 DISCONTIGMEM 에서 SPARSEMEM 으로 옮겨탔습니다.
2008년, &lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 은 x86-64 를 위한 유일한 메모리 모델이 되었는데,
FLATMEM 보단 조금 비싸지만 DISCONTIGMEM 보다는 효율적이기 때문입니다.&lt;/p&gt;
&lt;p&gt;메모리 핫플러그, persistent 메모리 지원, 다양한 성능 최적화와 같은 최근의
메모리 관리 분야 개발은 모두 SPARSEMEM 모델을 타겟으로 하고 있습니다.
하지만 과거의 모델들은 여전히 존재해서, 아키텍쳐와 메모리 관리 코드 상의 많은
&lt;code&gt;#ifdef&lt;/code&gt; 블록의 존재와, 관련된 구성 옵션의 특별한 미로의 존재라는 추가비용을
유발하고 있습니다.
남아있는 &lt;code&gt;DISCONTIGMEM&lt;/code&gt; 사용자들을 &lt;code&gt;SPARSEMEM&lt;/code&gt; 으로 완전히 바꿔타게 하려는
노력들이 있습니다만, ia64 나 mips64 와 같은 아키텍쳐들을 그렇게 변화시키기는
쉬운 작업이 아닐 겁니다.
그리고 ARC 아키텍쳐의 DISCONTIGMEM 사용은 &amp;ldquo;normal&amp;rdquo; 메모리 아래 &amp;ldquo;high memory&amp;rdquo;
영역의 존재를 갖는데, 이는 분명 변경하기 어려울 겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc2/</link>
      <pubDate>Fri, 26 Jul 2019 08:41:19 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-v6-05-introduce-madv_cold-and-madv_pageout&#34;&gt;[PATCH v6 0/5] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190723062539.198697-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190723062539.198697-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어플리케이션의 메모리를 좀 더 적극적으로 reclaim 시킴으로써 반응성을 높이기
위한 패치셋의 일부를 따로 떼어낸, &lt;code&gt;MADV_COLD&lt;/code&gt; 와 &lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 힌트를
&lt;code&gt;madvise()&lt;/code&gt; 에 추가하는 패치의 여섯번째 버전입니다.&lt;/p&gt;
&lt;p&gt;일곱번째 버전도 빠르게 올라왔군요:
&lt;a href=&#34;https://lkml.kernel.org/r/20190726023435.214162-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190726023435.214162-1-minchan@kernel.org&lt;/a&gt;
단순히 mmotm 최신 버전 위로 리베이스 한 것 같네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v9-0021-generic-page-walk-and-ptdump&#34;&gt;[PATCH v9 00/21] Generic page walk and ptdump&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190722154210.42799-1-steven.price@arm.com&#34;&gt;https://lkml.kernel.org/r/20190722154210.42799-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;x86 과 arm64 가 범용적 페이지 테이블 워킹을 하도록 했던 해치셋을 조금 더 확장한
버전입니다.  기존 대비 페이지 테이블 덤프 기능도 일반화 시킨게 차이군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v1-12-mmpage_idle-add-support-for-per-pid-page_idle-using-virtual-indexing&#34;&gt;[PATCH v1 1/2] mm/page_idle: Add support for per-pid page_idle using virtual indexing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190722213205.140845-1-joel@joelfernandes.org&#34;&gt;https://lkml.kernel.org/r/20190722213205.140845-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널은 &lt;code&gt;page_idle&lt;/code&gt; 이라는 인터페이스를 통해 특정 페이지의 액세스 여부를
파악할 수 있게 합니다.  저도 이걸 통해서 wss 를 재거나 하는데 쓸 수 있는
&lt;a href=&#34;https://github.com/sjp38/idle_page_tracking&#34;&gt;도구&lt;/a&gt;를 만들었었죠.&lt;/p&gt;
&lt;p&gt;문제는 이 인터페이스는 쓰기가 조금 복잡합니다.  PFN 을 가지고 페이지를 지목할
수 있게 되어 있기 때문에 특정 프로세스의 데이터 액세스를 추적하려면 해당
프로세스가 사용하고 있는 가상 메모리가 어떤 PFN 으로 매핑되어 있는지 알아야
하기 때문이죠.  달리 말하면 &lt;code&gt;page_idle&lt;/code&gt; 인터페이스가 글로벌하기 때문에 생기는
문제입니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 &lt;code&gt;/proc/&amp;lt;pid&amp;gt;/page_idle&lt;/code&gt; 파일을 생성하고 이를 통해 프로세스 단위로
virtual page frame number (VFN) 을 통해 페이지 트랙킹을 할 수 있게 합니다.
이로써 이 인터페이스를 사용하는 유저스페이스 도구의 코드가 간단해질 뿐더러 보안
이슈도 좀 더 편리해지죠.  구글에선 내부적으로 이를 통해 heap profiler
(heapprofd) 를 좀 더 쉽게 만들었나보군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-mmpage_idle-simple-idle-page-tracking-for-virtual-memory&#34;&gt;[PATCH RFC] mm/page_idle: simple idle page tracking for virtual memory&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/156388286599.2859.5353604441686895041.stgit@buzz&#34;&gt;https://lkml.kernel.org/r/156388286599.2859.5353604441686895041.stgit@buzz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞에서 소개한 패치와 비슷하게 &lt;code&gt;page_idle&lt;/code&gt; 을 간편화 시키는 패치셋입니다.  특정
pid 의 모든 mapped page frame 의 access bit 을 한번에 clear 할 수 있게 합니다.
인터페이스는 &lt;code&gt;echo 6 &amp;gt; /proc/&amp;lt;pid&amp;gt;/clear_refs&lt;/code&gt; 같은 형태군요.  이후,
&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/smaps&lt;/code&gt; 파일을 이용해 현재 idle 한 페이지들의 갯수를 알 수
있습니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-53-rc2&#34;&gt;Linux 5.3-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiiKRJprQDJqJzdcjdaGs73UtVPTM2+jOHWdMgu5Sp2HQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiiKRJprQDJqJzdcjdaGs73UtVPTM2+jOHWdMgu5Sp2HQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;두번째 rc 버전이 예정대로 나왔습니다.  변경사항이 많은 머지윈도우였던 만큼 rc2
도 꽤 수정사항이 많은 것 같습니다.  전체적으로 문서, arch 코드, 그리고 드라이버
쪽 수정사항이 대부분인 듯 하군요.&lt;/p&gt;
&lt;p&gt;앞선 rc1 릴리즈부터 이번 릴리즈 사이의 변경 사항의 시각화 비디오를 아래
링크에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/yxtq3-lhebQ&#34;&gt;https://youtu.be/yxtq3-lhebQ&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc1/</link>
      <pubDate>Thu, 11 Jul 2019 02:42:22 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.3-rc1/</guid>
      <description>&lt;h2 id=&#34;patch-v5-05-introduce-madv_cold-and-madv_pageout&#34;&gt;[PATCH v5 0/5] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190714233401.36909-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190714233401.36909-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MADV_COLD&lt;/code&gt; 와 &lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 을 구현하는 패치, 어느새 다섯번째 버전입니다.  큰
변경은 없는 것 같군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-03-make-working-with-compound-pages-easier&#34;&gt;[PATCH v2 0/3] Make working with compound pages easier&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190721104612.19120-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20190721104612.19120-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 를 다루기 쉽게끔 &lt;code&gt;page_size()&lt;/code&gt;, &lt;code&gt;page_shift()&lt;/code&gt;, 그리고
&lt;code&gt;compound_nr()&lt;/code&gt; 이라는 세개의 helper 함수를 추가하고 이 함수들을 사용하게끔
기존 코드를 다듬는 패치셋입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PAGE_SIZE &amp;lt;&amp;lt; compound_order(page)&lt;/code&gt; 는 &lt;code&gt;page_size(page)&lt;/code&gt; 가,
&lt;code&gt;PAGE_SHIFT + compound_order(page)&lt;/code&gt; 는 &lt;code&gt;page_shift(page)&lt;/code&gt; 가, 그리고
&lt;code&gt;1 &amp;lt;&amp;lt; compound_order(page)&lt;/code&gt; 는 &lt;code&gt;compound_nr(page)&lt;/code&gt; 가 되는 것이죠.&lt;/p&gt;
&lt;h2 id=&#34;linux-53-rc1&#34;&gt;Linux 5.3-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wiVjkTqzP6OppBuLQZ+t1mpRQC4T+Ho4Wg2sBAapKd--Q@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/wiVjkTqzP6OppBuLQZ+t1mpRQC4T+Ho4Wg2sBAapKd--Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 릴리즈 사이의 변경 사항을 시각화 한 비디오를 아래 링크에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/vx_BUvs00u8&#34;&gt;https://youtu.be/vx_BUvs00u8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2주일이 지나고 5.3 을 향한 첫번째 rc 릴리즈가 이루어졌습니다.&lt;/p&gt;
&lt;p&gt;이번 rc 릴리즈는 커밋 갯수로 볼 때 꽤 큰 릴리즈입니다.  4.12, 4.15, 4.19 때의
머지 윈도우와 비슷한 정도라는군요.  참고로 가장 큰 머지윈도우는 아직 4.9 의
것이었습니다.&lt;/p&gt;
&lt;p&gt;이번 머지 윈도우는 초기에 두개의 버그가 나와서 토발즈를 괴롭게 했다고 하는데요.
하나는 토발즈의 커널 컨피규레이션이 너무 간단하게 되어 있어 어떤 코드가 테스트
되지 않아 토발즈가 만들어낸 버그였고, 다른 하나는 패치 자체에 존재하는
버그였다고 합니다.  토발즈가 유발한 버그는 토발즈가 고쳤고, 두번째 버그를
일으킨 패치는 그냥 리버트 시켰다고 하는군요.&lt;/p&gt;
&lt;p&gt;그렇다고는 해도 이번 머지 윈도우의 후반부는 충분히 스무스하게 이뤄졌다고
합니다.&lt;/p&gt;
&lt;p&gt;그리고 이번 머지 윈도우에 이름을 올린 개발자는 총 1600명이었다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.2/</link>
      <pubDate>Mon, 01 Jul 2019 15:48:04 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.2/</guid>
      <description>&lt;h2 id=&#34;patch-v5-0012-sara-a-new-stacked-lsm&#34;&gt;[PATCH v5 00/12] S.A.R.A. a new stacked LSM&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1562410493-8661-1-git-send-email-s.mesoraca16@gmail.com&#34;&gt;https://lkml.kernel.org/r/1562410493-8661-1-git-send-email-s.mesoraca16@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다양한 보안 측정을 위한 공용 인터페이스를 제공하는 스택 기반의 리눅스 보안
모듈입니다.  이름이 재밌네요. S.A.R.A 는 S.A.R.A is Another Recursive Acronym
의 약자라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-52&#34;&gt;Linux 5.2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whtW3FdruS-q2zehJPSan1SKtHoFHKX28A3J_1gfTFUMw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whtW3FdruS-q2zehJPSan1SKtHoFHKX28A3J_1gfTFUMw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 릴리즈 중간엔 토발즈의 여행이 있었죠.  초반엔 예상 외로 큰 rc 릴리즈도
있었구요.  해서 이번주는 rc8 이 릴리즈 될지 5.2가 릴리즈 될지 저도 좀
궁금했는데, 최종적으로 5.2 릴리즈가 되었습니다.  토발즈도 rc8 을 릴리즈 할까
망설였다고 하네요.  하지만 그래야 할만한 문제가 전혀 없었기에 5.2를 릴리즈
했다고 합니다.&lt;/p&gt;
&lt;p&gt;더불어, 토발즈는 이번 여행 중에도 스쿠버다이빙을 즐겼나보네요.  더크 혼델이
찍은 사진도 공유했습니다:
&lt;a href=&#34;https://hohndel.name/palau-2019&#34;&gt;https://hohndel.name/palau-2019&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc7/</link>
      <pubDate>Thu, 27 Jun 2019 15:35:12 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc7/</guid>
      <description>&lt;h2 id=&#34;patch-v7-04-thp-aware-uprobe&#34;&gt;[PATCH v7 0/4] THP aware uprobe&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190625235325.2096441-1-songliubraving@fb.com&#34;&gt;https://lkml.kernel.org/r/20190625235325.2096441-1-songliubraving@fb.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uprobe&lt;/code&gt; 가 THP 로 받쳐지고 있는 코드에 적용되면 이 THP 는 regular page 로
쪼개집니다.  이 패치셋은 이 문제를 해결합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v9-06-enable-thp-for-text-section-of-non-shmem-files&#34;&gt;[PATCH v9 0/6] Enable THP for text section of non-shmem files&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190625001246.685563-1-songliubraving@fb.com&#34;&gt;https://lkml.kernel.org/r/20190625001246.685563-1-songliubraving@fb.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어플리케이션의 텍스트 섹션을 THP 로 지원해 줌으로써 iTLB 미스를 줄이고 성능을
높이고자 하는 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-52-rc7&#34;&gt;Linux 5.2-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgL5GyQ93o=VyiymFPfw=Z0TGHEPBJrCtGSqFSW2Mhx8g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgL5GyQ93o=VyiymFPfw=Z0TGHEPBJrCtGSqFSW2Mhx8g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여전히 토발즈의 여행 탓에 릴리즈가 평소와 조금 다른 시간대에 이뤄졌습니다,
토발즈 자신의 시점으로는 평소와 같은 일요일 오후지만요.  아마도 아시아 쪽에
있는 것 같군요.  이번 릴리즈는 심지어 바다 위에서의 릴리즈라네요.  인터넷 안될
줄 알았는데 Dirk Hohndel 이 핸폰 핫스팟을 빌려줬다고 ;)&lt;/p&gt;
&lt;p&gt;이번 릴리즈는 고요했고, 별 문제 없었다고 합니다.  다음주엔 정식 릴리즈일까요?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc6/</link>
      <pubDate>Mon, 17 Jun 2019 19:22:48 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-notformerge-05-extend-remote-madvise-api-to-ksm-hints&#34;&gt;[PATCH NOTFORMERGE 0/5] Extend remote madvise API to KSM hints&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190616085835.953-1-oleksandr@redhat.com&#34;&gt;https://lkml.kernel.org/r/20190616085835.953-1-oleksandr@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 여러번 소개한 remote &lt;code&gt;madvise()&lt;/code&gt; 에 대한 관심이 많이 있는 것
같네요.
이 패치셋은 &lt;code&gt;MADV_MERGEABLE&lt;/code&gt;, &lt;code&gt;MADV_UNMERGEABLE&lt;/code&gt; 을 추가해서 KSM 힌트도
&lt;code&gt;madvise()&lt;/code&gt; 를 통해 줄 수 있게 합니다.&lt;/p&gt;
&lt;p&gt;논의를 위한 패치라 이대로 머지되진 않겠지만, 사용처가 많이 늘어날 것 같네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-52-rc6&#34;&gt;Linux 5.2-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wg+nPKhdn=vKSgJQkfOSGhauTO4jyt=0FH9cnM_QChDLw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wg+nPKhdn=vKSgJQkfOSGhauTO4jyt=0FH9cnM_QChDLw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;안타깝게도 기대와 달리 이번 릴리즈는 조용하지 않았습니다.  이번 5.2 개발을
위한 릴리즈 중 머지 윈도우와 rc1 을 제외하면 rc6 가 오히려 가장 많은 변화를
담고 있다는군요.  TCP SACK/fragmentation/mss 수정이 영향을 끼친 것들 중
하나라고 합니다.&lt;/p&gt;
&lt;p&gt;또, 이번에도 릴리즈가 빨라진 건 내일 토발즈가 비행기 타기 때문이랍니다.
컨퍼런스도 참여해야하고 휴양도 취하는 모양입니다.  이 때문에 rc7 은 조금 늦어질
수 있다는군요.  보통은 rc6 가 가장 안정화 되었을 무렵이라 이렇게 일정을
잡았다고 합니다만, 일이 복잡해졌네요.  자신에게 무슨 일이 있으면 Greg 이 대신할
거라고 합니다.&lt;/p&gt;
&lt;p&gt;뭐, 그렇다곤 해도 5.2 릴리즈 진행은 예정대로 진행될 것 같다고도 합니다.  이번
릴리즈의 주요 변경은 SPDX 제외하면 네트워킹, 셀프테스트 그리고 문서화였군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc5/</link>
      <pubDate>Mon, 10 Jun 2019 10:17:29 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc5/</guid>
      <description>&lt;h2 id=&#34;patch-v3-05-thp-aware-uprobe&#34;&gt;[PATCH v3 0/5] THP aware uprobe&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190612220320.2223898-1-songliubraving@fb.com&#34;&gt;https://lkml.kernel.org/r/20190612220320.2223898-1-songliubraving@fb.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;uprobe 는 THP 로 되어있는 페이지를 쪼갭니다.  이로 인해 성능 향상 효과가
사라지죠.  이 패치셋은 uprobe 가 THP 를 인식하게 해서 이런 문제를 제거합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-05-introduce-madv_cold-and-madv_pageout&#34;&gt;[PATCH v2 0/5] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190610111252.239156-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190610111252.239156-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;기존에도 소개한 MADV_COLD 와 MADV_PAGEOUT 을 madvise() 에 추가하는 패치셋의
두번째 버전입니다.  이 패치셋을 ChromeOS 팀의 Brian Geffon 은 가져다가 탭이
백그라운드로 들어가고 45초 이상 그 상태를 유지하면 이 기능을 사용해서 페이지를
proactively swap out 시켰는데, 그 결과 tab 전환 속도가 25% 나 빨라졌다고
합니다.&lt;/p&gt;
&lt;h2 id=&#34;v3-rfc-patch-09-migrate-mode-for-node-reclaim-with-heterogeneous-memory-hierarchy&#34;&gt;[v3 RFC PATCH 0/9] Migrate mode for node reclaim with heterogeneous memory hierarchy&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1560468577-101178-1-git-send-email-yang.shi@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/1560468577-101178-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NUMA node 로 pmem 을 취급할 수 있게 된 이후, 노드간 migration 을 보다
효율적으로 하기 위한 패치셋의 세번째 버전입니다.  LSFMM 에서 이에 대해 토의가
있었는데, 이번 버전은 그에 기반해 수정되었다고 하네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-v52-rc5&#34;&gt;Linux v5.2-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whEQPvLpDbx+WR4Q4jf2FxXjf_zTX3uLy_6ZzHtgTV4LA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whEQPvLpDbx+WR4Q4jf2FxXjf_zTX3uLy_6ZzHtgTV4LA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난주는 토발즈의 여행 때문에 릴리즈가 평소보다 조금 빨리 이루어졌는데요,
이번에도 마찬가지입니다.  앞으로도 2주동안 여행ㅇ을 더 한다네요.&lt;/p&gt;
&lt;p&gt;어쨌든 5.2 가 가까워졌습니다.  어느덧 rc5군요.  rc4 대비 사이즈도 많이
줄어들었습니다.  SPDX 업데이트도 없는 덕에 diff 도 깔끔하게 되었구요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc4/</link>
      <pubDate>Tue, 04 Jun 2019 10:49:00 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc4/</guid>
      <description>&lt;h2 id=&#34;patch-0015-slab-movable-objects-smo&#34;&gt;[PATCH 00/15] Slab Movable Objects (SMO)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190603042637.2018-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190603042637.2018-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;전에도 RFC 패치셋은 여기서도 소개했었죠.  Slab 할당자에 할당받은 객체들의
이동이 가능하게끔 하는 패치셋의 정식 패치 버전이 나왔습니다.  변경된
인터페이스는 XArray 와 dcache 에 적용되는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v1-04-introduce-madv_cold-and-madv_pageout&#34;&gt;[PATCH v1 0/4] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190603053655.127730-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190603053655.127730-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;바로 지난주에도 소개한 external madvise 패치셋이 쪼개졌네요.  &lt;code&gt;MADV_COLD&lt;/code&gt; 와
&lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 두개의 새로운 advice 기능 추가 버전만 담은 패치셋입니다.  이게
더 일찍 머지될 가능성이 생겼군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-52-rc4&#34;&gt;Linux 5.2-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjm7FQxdF=RKa8Xe23CLNNpbGDOACewgo8e-hwDJ8TyQg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjm7FQxdF=RKa8Xe23CLNNpbGDOACewgo8e-hwDJ8TyQg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;메일을 받고 깜짝 놀랐습니다, 평소보다 빨랐기 때문이죠.  아시아를 여행중인가?
싶기도 했는데요, 그건 아니고 비행기 여행이 예정되어 있기 때문에 평소보다 일찍
했다는군요.&lt;/p&gt;
&lt;p&gt;지난 rc3 가 좀 작았던 탓인지 이번 rc4 는 덩치가 좀 큽니다.  하지만 그걸
감안하면 별 문제 없어 보인다고 하네요.&lt;/p&gt;
&lt;p&gt;이번 릴리즈에도 SPDX 변경이 많습니다.  변경 자체야 문제가 없긴 한데 diff 를
보기 귀찮게 하는게 조금은 짜증도 나는 것 같네요.&lt;/p&gt;
&lt;p&gt;어쨌든 이렇게 네번째 rc 가 릴리즈 되었습니다.  정식 버전도 많이 남지 않았네요!&lt;/p&gt;
&lt;p&gt;이번 릴리즈의 개발 과정을 시각화 한 비디오를 아래 URL 에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/OooOmr4Z8dw&#34;&gt;https://youtu.be/OooOmr4Z8dw&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc3/</link>
      <pubDate>Tue, 28 May 2019 23:28:37 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc3/</guid>
      <description>&lt;h2 id=&#34;patch-tipcorercu-012&#34;&gt;[PATCH tip/core/rcu 0/12]&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190530145204.GA28526@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190530145204.GA28526@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Paul E. McKenney 로부터의 RCU flavor consolidation 관련 추가 작업과 코드 정리를
위한 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-02-documentation-updates-for-v53&#34;&gt;[PATCH tip/core/rcu 0/2] Documentation updates for v5.3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190530145504.GA29820@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190530145504.GA29820@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 문서 업데이트를 담고 있는 패치셋입니다.  &lt;code&gt;rcuref&lt;/code&gt; 의 실제 예제와
&lt;code&gt;rcu_task_stall_timeout&lt;/code&gt; 의 정의에 대한 내용이 추가되었군요!&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-021-torture-test-updates-for-v53&#34;&gt;[PATCH tip/core/rcu 0/21] Torture-test updates for v5.3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190530151650.GA422@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190530151650.GA422@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 와 spinlock 등을 위해 사용되는 torture 테스트 업데이트를 담은 패치셋입니다.
무려 21개 패치네요!&lt;/p&gt;
&lt;h2 id=&#34;rfcv2-06-introduce-memory-hinting-api-for-external-process&#34;&gt;[RFCv2 0/6] introduce memory hinting API for external process&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190531064313.193437-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190531064313.193437-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다른 어플리케이션의 virtual memory 에 대해 madvise() 를 할 수 있게 하고
&lt;code&gt;MADV_COLD&lt;/code&gt; 등의 힌트를 추가한 패치셋의 두번째 RFC 버전입니다.  LWN 에서도
소개되었고 관련 반응이 매우 뜨겁네요.  저도 매우 흥미롭게 보고 있습니다.
두번째 버전에서는 &lt;code&gt;MADV_COOL&lt;/code&gt; 은 빠졌습니다.  &lt;code&gt;MADV_COLD&lt;/code&gt; 와 &lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 만
남았군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-52-rc3&#34;&gt;Linux 5.2-rc3&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CAHk-=wg1evGTxx-aSNHO+m5xSa1sc6fQe7Y8fH=_ruGcwMyfyA@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;상당히 고요한 한 주였고, 그로 인해 rc3 는 rc2 와 사이즈가 비슷했습니다.  이는
조금 이상한 일인데, 보통 rc2 이후로는 사람들이 드디어 문제를 파악하기 시작하고
rc3 주간에 수정을 하느라 조금은 떠들썩해 왔기 때문이랍니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc2/</link>
      <pubDate>Tue, 21 May 2019 01:27:47 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc2/</guid>
      <description>&lt;h2 id=&#34;rfc-patch-v5-0016-slab-movable-objects-smo&#34;&gt;[RFC PATCH v5 00/16] Slab Movable Objects (SMO)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190520054017.32299-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190520054017.32299-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 소개한 Slab movable objects 패치셋의 다섯번째 버전입니다.  RFC
로는 아마도 마지막 버전이 될거라는군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-0014-mmap_sem-range-locking&#34;&gt;[RFC PATCH 00/14] mmap_sem range locking&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190521045242.24378-1-dave@stgolabs.net&#34;&gt;https://lkml.kernel.org/r/20190521045242.24378-1-dave@stgolabs.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 LSFMM 에서 개인적으로 가장 기대했던 세션이 &lt;code&gt;mmap_sem&lt;/code&gt; 해결에 대한
세션이었습니다.  해당 세션에서는 예전부터 이야기가 나온 range locking 에
대해서도 이야기가 있었는데요, 이 패치셋은 이 range locking 을 사용한 &lt;code&gt;mmap_sem&lt;/code&gt;
문제 해결 시도를 다시 정리해 RFC 의 형태로 올린 것입니다.&lt;/p&gt;
&lt;p&gt;RFC 라는 데서 알 수 있겠지만 이 패치 자체에도 문제가 많지만, 코드 자체보다는 이
range locking 이라는 아이디어가 갖는 한계와 그에 대한 대책 등을 논의해 보고자
올린 것이라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-07-introduce-memory-hinting-api-for-external-process&#34;&gt;[RFC 0/7] introduce memory hinting API for external process&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190520035254.57579-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190520035254.57579-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 여기서도 다룬 구글의 proactive swap 의 안드로이드 버전과 비슷한 일을 위한
패치셋입니다.  안쓰는 데이터 잔뜩 쥐고서는 스왑도 안당하고 있는 앱이 문제죠.
이런 데이터를 &lt;code&gt;madvise()&lt;/code&gt; 에 &lt;code&gt;MADVISE_COLD&lt;/code&gt; 와 &lt;code&gt;MADVISE_COOL&lt;/code&gt; 이라는 추가
힌트를 줘서 어플리케이션 레벨에서 이런 스왑하는게 좋을 데이터를 알려주는
형태입니다.  기존의 &lt;code&gt;MADVISE_WONTNEED&lt;/code&gt; 는 스왑을 하는게 아니라 걍 데이터를
버려버리기 때문에 이런 두개의 힌트를 추가한거죠.&lt;/p&gt;
&lt;p&gt;인공적 벤치마크가 아니라 수백명의 진짜 사용자를 통해 성능 실험을 했다고
하는데요, 구글에서 고용한 테스트 집단일까요?&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0014-provide-generic-top-down-mmap-layout-functions&#34;&gt;[PATCH v4 00/14] Provide generic top-down mmap layout functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190526134746.9315-1-alex@ghiti.fr&#34;&gt;https://lkml.kernel.org/r/20190526134746.9315-1-alex@ghiti.fr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;각 아키텍쳐별로 존재하는 중복 코드를 제거하기 위해 만들어진 범용 top-down mmap
을 위한 패치의 네번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-03-remove-tmem-and-code-depending-on-it&#34;&gt;[PATCH 0/3] remove tmem and code depending on it&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190527103207.13287-1-jgross@suse.com&#34;&gt;https://lkml.kernel.org/r/20190527103207.13287-1-jgross@suse.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xen 의 tmem 기능이 제거되었군요.  관련 코드를 리눅스 커널에서도 제거하는
패치셋입니다.  덕분에 cleancache 가 아예 사라질 모양입니다.  Cleancache 에
의존하는 GCMA 를 만들고 있는 제 입장에선 쇼킹한 일입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-52-rc2&#34;&gt;Linux 5.2-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgob1t2g9iQZCuZ8My39CY26xGb6nqjVhCtb1nTirsR2Q@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgob1t2g9iQZCuZ8My39CY26xGb6nqjVhCtb1nTirsR2Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일정대로 두번째 rc2 가 릴리즈 되었습니다.  이번엔 그야말로 특기할 만한 점이
없다는군요.  그나마 큰 변화는 SPDX 관련 변경들 뿐이었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc1/</link>
      <pubDate>Wed, 08 May 2019 10:22:05 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.2-rc1/</guid>
      <description>&lt;h2 id=&#34;patch-mm-introduce-page_size&#34;&gt;[PATCH] mm: Introduce page_size()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190510181242.24580-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20190510181242.24580-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 등의 경우를 위해 페이지의 실제 크기를 구하려면 &lt;code&gt;PAGE_SIZE &amp;lt;&amp;lt; compound_order(page)&lt;/code&gt; 를 해야 하는게 짜증난 Matthew Wilcox 가 별도의 함수를
만들고 기존 코드들을 이 함수를 사용하도록 변경한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-0015-remove-order-argument-from-many-mm-functions&#34;&gt;[PATCH v2 00/15] Remove &amp;lsquo;order&amp;rsquo; argument from many mm functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190510135038.17129-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20190510135038.17129-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mm 쪽 함수들은 order 를 인자로 많이 받죠.  어차피 gfp_t 는 무조건 받으니까 이
타입의 상위 bit 을 order 목적으로 사용하자는 패치입니다.  이 패치의 장점은?
커널 텍스트 사이즈를 줄인다는 것입니다 :)&lt;/p&gt;
&lt;h2 id=&#34;maintainers--kernel-summit-2019-planning-kick-off&#34;&gt;Maintainer&amp;rsquo;s / Kernel Summit 2019 planning kick-off&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190513230643.GA4347@mit.edu&#34;&gt;https://lkml.kernel.org/r/20190513230643.GA4347@mit.edu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해의 커널 서밋 / 메인테이너 서밋을 위한 안내 메일입니다.  작년엔 커널 서밋은
LPC 와, 메인테이너 서밋은 OSSEU 와 함께 열렸었죠.  올해는 둘 다 LPC 와 함께
합니다.&lt;/p&gt;
&lt;p&gt;메인테이너 서밋은 올해는 아예 30명으로 더욱 작게 모이는군요.&lt;/p&gt;
&lt;p&gt;커널 서밋 발표 주제는 5월 31일까지 받습니다.  발표주제 선정되면 LPC 티켓도
준다는군요!&lt;/p&gt;
&lt;h2 id=&#34;linux-52-rc1&#34;&gt;Linux 5.2-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgxi6fnxZ+p5Zdqr-i4s=xhOCBJL6s_RauYkjxM2CpXeA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgxi6fnxZ+p5Zdqr-i4s=xhOCBJL6s_RauYkjxM2CpXeA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.2 릴리즈를 위한 머지윈도우가 끝나고 rc1 버전이 릴리즈 되었습니다.  이번 머지
윈도우 중간에 토발즈의 개인적 여행이 있다고 했지만 다행히 잘 정리되었나보군요.
별다른 건은 없었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.1/</link>
      <pubDate>Tue, 30 Apr 2019 14:16:49 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.1/</guid>
      <description>&lt;h2 id=&#34;rfc-patch-v4-0015-slab-movable-objects-smo&#34;&gt;[RFC PATCH v4 00/15] Slab Movable Objects (SMO)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190430030746.26102-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190430030746.26102-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 이 블로그에서도 공유한 SMO 패치의 새 버전입니다.  이번 버전은 dcache 쪽
코드를 많이 수정했군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-51&#34;&gt;Linux 5.1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whsbDxdapMJGvy9OkVSrKMsKRJBTrH-Qj-qTbkMUGnWUw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whsbDxdapMJGvy9OkVSrKMsKRJBTrH-Qj-qTbkMUGnWUw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.1 릴리즈입니다.  일요일 오후 릴리즈란 점은 평소와 같지만 평소보다 조금 늦은
시간이긴 했는데요, 오늘 갑자기 받은 풀 리퀘스트도 있었고, 이번 머지윈도우
기간에 졸업식에 참석해야 해서 조금 망설였다는군요.&lt;/p&gt;
&lt;p&gt;하지만 풀리퀘스트도 그렇게 크진 않고, 몇일 머지윈도우에 자리 비우는 정도는
어떻게든 할 수 있을거라 생각해서 5.1 릴리즈가 이뤄졌습니다!&lt;/p&gt;
&lt;p&gt;이제 5.2 머지윈도우의 시작이군요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc7/</link>
      <pubDate>Fri, 26 Apr 2019 11:02:24 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc7/</guid>
      <description>&lt;h2 id=&#34;re-lsfmm-preliminary-agenda--anyone--anyone--bueller-&#34;&gt;Re: [LSF/MM] Preliminary agenda ? Anyone &amp;hellip; anyone ? Bueller ?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/83fda245-849a-70cc-dde0-5c451938ee97@kernel.dk&#34;&gt;https://lkml.kernel.org/r/83fda245-849a-70cc-dde0-5c451938ee97@kernel.dk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해의 LSFMM 스케쥴이 구글 문서로 공유되고 있었군요:
&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1Z1pDL-XeUT1ZwMWrBL8T8q3vtSqZpLPgF3Bzu_jejfk/edit#gid=0&#34;&gt;https://docs.google.com/spreadsheets/d/1Z1pDL-XeUT1ZwMWrBL8T8q3vtSqZpLPgF3Bzu_jejfk/edit#gid=0&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-proactive-memory-reclaim&#34;&gt;[LSF/MM TOPIC] Proactive Memory Reclaim&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CALvZod4V+56pZbPkFDYO3+60Xr0_ZjiSgrfJKs_=Bd4AjdvFzA@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이제 LSFMM 이 얼마 안남았습니다만, 또하나의 주제 제안이 올라왔습니다.&lt;/p&gt;
&lt;p&gt;메모리 오버커밋으로 인해 direct reclaim 이 발생하고, 이는 latency sensitive
어플리케이션의 latency 를 크게 저하시키니, 시스템이 좀 더 적극적으로 memory
reclaim 을 해서 direct reclaim 을 최소화 시켜보자는 건데요.  잘 접근되지 않는
cold memory 를 추적해서 미리미리 reclaim 시키자는 겁니다.  챌린지는 물론 cold
memory 를 어떻게 잘 추적하냐는 거지요.  이와 함께 커널의 &lt;code&gt;idle_page_tracking&lt;/code&gt;
의 비효율성도 이야기 했습니다.&lt;/p&gt;
&lt;p&gt;이 주제로 올해 ASPLOS 에 논문도 냈군요: &lt;a href=&#34;https://youtu.be/aKddds6jn1s&#34;&gt;https://youtu.be/aKddds6jn1s&lt;/a&gt;
개인적으로 최근 연구하고 있는 주제와도 관계 있을 수 있어서 흥미롭습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-docsvm-add-documentation-of-memory-models&#34;&gt;[PATCH] docs/vm: add documentation of memory models&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1556101715-31966-1-git-send-email-rppt@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/1556101715-31966-1-git-send-email-rppt@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FLAT, DISCONTIG, SPARSE 등의 다양한 메모리 모델에 대한 문서화 추가 패치입니다.
처음 코드 들여다 볼 때 조금 헷갈리던 부분인데 잘 설명되었군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-lightning-round&#34;&gt;[LSF/MM TOPIC] Lightning round?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190425211906.GH4739@mit.edu&#34;&gt;https://lkml.kernel.org/r/20190425211906.GH4739@mit.edu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 LSFMM 에는 라이트닝 토크 세션이 있는데요, 거기서 block layer 에 암호화
레이어를 추가하는 방안에 대해 이야기 해보자는 Ted 의 의견입니다.  안드로이드
쪽에서 이걸 열심히 해보고 있나보군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-04-toolsvmslabinfo-add-fragmentation-output&#34;&gt;[PATCH 0/4] tools/vm/slabinfo: Add fragmentation output&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190426022622.4089-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190426022622.4089-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SLAB vs SLUB 토론 중 현재 slab allocator 의 fragmentation 정도를 알려주는
도구가 있으면 좋겠다는 이야기가 있었는데, 이를 위한 기능을 추가한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51-rc7&#34;&gt;Linux 5.1-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whvWQbP20g77U4QRXQDS5w+kf=V-P2QjMkgA-OwJJjHtg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whvWQbP20g77U4QRXQDS5w+kf=V-P2QjMkgA-OwJJjHtg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난번 rc6 가 거대했던 건 역시 풀 리퀘스트 타이밍 때문이었는지, 이번 rc7 은
다행히도 크기가 작은 편이라고 합니다.  네트워킹 쪽 변경이 좀 있고, 나머진
평소같이 아키텍쳐, 파일 시스템, 그외 드라이버 등의 변경이 내용을 차지했네요.
따라서 다음주엔 5.1이 예정대로 나올 것 같다고 합니다!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc6/</link>
      <pubDate>Tue, 16 Apr 2019 23:02:17 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-v12-0031-speculative-page-faults&#34;&gt;[PATCH v12 00/31] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernl.org/r/20190416134522.17540-1-ldufour@linux.ibm.com&#34;&gt;https://lkml.kernl.org/r/20190416134522.17540-1-ldufour@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;오랫만에 업데이트 된 SPF 패치셋으로, 이번 패치셋은 v5.1 위로 리베이스
되었습니다.  RCU 에서 Fine-grained reader-writer locking 으로 옮겼던 vma 보호를
다시 RCU 로 되돌린 게 눈에 띄는군요.  기존엔 패치셋만 공개했는데, 이젠 패치셋이
적용된 코드 트리를 github 으로도 제공합니다:
&lt;a href=&#34;https://github.com/ldu4/linux/tree/spf-v12&#34;&gt;https://github.com/ldu4/linux/tree/spf-v12&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;patch-v3-0011-provide-generic-top-down-mmap-layout-functions&#34;&gt;[PATCH v3 00/11] Provide generic top-down mmap layout functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190417052247.17809-1-alex@ghiti.fr&#34;&gt;https://lkml.kernel.org/r/20190417052247.17809-1-alex@ghiti.fr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아키텍쳐별로 별도 구현을 하지 않고도 전체 mmap 레이아웃을 접근할 수 있게 해주는
범용 함수들을 구현하는 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-v51-rc6&#34;&gt;Linux v5.1-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wii=Ym24FWf7J2s1CEwCXU3hjVXeHSkV3A8X5iAj6eT8Q@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wii=Ym24FWf7J2s1CEwCXU3hjVXeHSkV3A8X5iAj6eT8Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;부활절이었군요.  어쨌건 토발즈는 그런 사소한 휴일에 릴리즈 일정을 바꾸진
않았습니다.&lt;/p&gt;
&lt;p&gt;이번 rc6 는 평소보다 조금 커다란 릴리즈였고, 때문에 토발즈도 다시 한번 꼼꼼히
살펴봤지만 그렇게까지 이상한 일은 아니라는군요.  4.18 때와 5.0 때도
이정도였답니다.&lt;/p&gt;
&lt;p&gt;네트워킹 쪽 변경이 좀 컸고, 드라이버, arch, selftests 와 perf 쪽에 변경이
있었으며, core mm, filesystem, scheduler, tracing 쪽에도 변경이 조금씩 있었다고
하는군요.&lt;/p&gt;
&lt;p&gt;어쨌건 그다지 이상한 건 없다고 합니다.  적어도 아직까진 5.1 을 향한 여정엔
문제가 없어 보이네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc5/</link>
      <pubDate>Tue, 09 Apr 2019 17:33:01 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc5/</guid>
      <description>&lt;h2 id=&#34;v2-rfc-patch-09-another-approach-to-use-pmem-as-numa-node&#34;&gt;[v2 RFC PATCH 0/9] Another Approach to Use PMEM as NUMA Node&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1554955019-29472-1-git-send-email-yang.shi@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/1554955019-29472-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;본 블로그를 통해 지속적으로 소개하고 있는, PMEM as NUMA node 를 위한, 보다 나은
hotness 기반 page location 을 위한 패치셋입니다.
기존 코멘트에 기반해서 두번째 버전을 내놓았군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v3-0015-slab-movable-objects-smo&#34;&gt;[RFC PATCH v3 00/15] Slab Movable Objects (SMO)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190411013441.5415-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190411013441.5415-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;최근 LWN 에서도 소개된 (&lt;a href=&#34;https://lwn.net/Articles/784964/&#34;&gt;https://lwn.net/Articles/784964/&lt;/a&gt;) 패치입니다.
Slab allocator 에서 할당된 object 가 free page 가운데에 박혀 있어 page 를
회수할 수 없는 fragmentation 이 발생합니다.
이 패치셋은 slab allocator 로 할당된 object 의 사용자에게 가능하면 해당 object
들을 움직여 달라고 callback 할 수 있게 함으로써 이 fragmentation 을 해결하려
합니다.&lt;/p&gt;
&lt;p&gt;앞의 버전에 비해서 변경된 건 LWN 기사에 달린 코멘트를 기반으로 한 개선들이군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-guarantee-natural-alignment-for-kmalloc&#34;&gt;[LSF/MM TOPIC] guarantee natural alignment for kmalloc()?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/790b68b7-3689-0ff6-08ae-936728bc6458@suse.cz&#34;&gt;https://lkml.kernel.org/r/790b68b7-3689-0ff6-08ae-936728bc6458@suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LSFMM 을 위한 늦은 주제네요.
kmalloc() 이 2의 승수 크기 얼라인먼트를 지키도록 하는 패치에 대해서 논의하고
싶어합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51-rc5&#34;&gt;Linux 5.1-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjvcuyCQGnfOhooaL1H4H63qXO=xgo+9yncSOG=eK+kbA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjvcuyCQGnfOhooaL1H4H63qXO=xgo+9yncSOG=eK+kbA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다섯번째 rc 커널입니다.  v5.1이 얼마 남지 않았군요.
이번 릴리즈에선 대부분 드라이버 쪽 변경이 있었으며, 딱히 이상하거나 수상한
움직임은 없다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc4/</link>
      <pubDate>Sun, 07 Apr 2019 23:17:55 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc4/</guid>
      <description>&lt;p&gt;Linux v5.1-rc3 릴리즈 후 Linux v.5.1-rc4 릴리즈 사이 기간에 LKML 에 올라온
흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v8-0020-convert-x86--arm64-to-use-generic-page-walk&#34;&gt;[PATCH v8 00/20] Convert x86 &amp;amp; arm64 to use generic page walk&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190403141627.11664-1-steven.price@arm.com&#34;&gt;https://lkml.kernel.org/r/20190403141627.11664-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;전에 이 블로그에도 공유했던, &lt;code&gt;walk_page_range()&lt;/code&gt; 함수가 커널에서 사용하는
페이지 테이블은 지원하지 않아서 아키텍쳐별로 page table walk 기능을 구현한 걸
&lt;code&gt;walk_page_range()&lt;/code&gt; 의 개선을 통해 가능하게 하고자 하는 패치의 여덟번째
버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-add-vm-event-for-page-cache-miss&#34;&gt;[PATCH] mm: add vm event for page cache miss&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1554185720-26404-1-git-send-email-laoar.shao@gmail.com&#34;&gt;https://lkml.kernel.org/r/1554185720-26404-1-git-send-email-laoar.shao@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Page cache miss 로 인해 사용중인 데이터베이스에 레이턴시가 증가하는 문제가
있는데, 기존 커널에는 페이지 캐시 미스 카운트를 세는 기능이 없기 때문에 만들어
봤다고 합니다.  반응은&amp;hellip; 별로 좋지 않군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-0025-accelerate-page-migration-and-use-memcg-for-pmem-management&#34;&gt;[RFC PATCH 00/25] Accelerate page migration and use memcg for PMEM management&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190404020046.32741-1-zi.yan@sent.com&#34;&gt;https://lkml.kernel.org/r/20190404020046.32741-1-zi.yan@sent.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 이 블로그에서도 소개한대로 PMEM 을 좀 많이 느린 NUMA node 로 다룰 수 있게
되었습니다.  따라서 적절한 페이지 마이그레이션이 중요해지죠.  리눅스 자체 page
replacement policy 를 이용해 page migration 을 하는 방법이 제기되었지만 그
방법은 충분한 쓰루풋을 제공하지 않고 너무 가끔 replacement 가 일어나 hot / cold
를 제대로 구분하기 어려운 문제가 있다고 이 메일은 주장하고, 자신이 생각하는
해결책을 RFC 의 형태로 제시하고 있습니다.&lt;/p&gt;
&lt;p&gt;실제 기존 방식의 마이그레이션 쓰루풋과 자신이 제안한 방식의 쓰루풋을 비교하면서
설명하는데, 재밌네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-tipcorercu-04-forbid-static-srcu-use-in-modules&#34;&gt;[PATCH RFC tip/core/rcu 0/4] Forbid static SRCU use in modules&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190402142816.GA13084@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190402142816.GA13084@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;로드될 수 있는 모듈 내에서의 &lt;code&gt;DEFINE_SRCU()&lt;/code&gt; 와 &lt;code&gt;DEFINE_STATIC_SRCU()&lt;/code&gt; 사용을
급지하는 패치셋입니다.  로드 되는 모듈에서 이걸 사용하면 메모리 회수가 안될
것이기 때문이죠.  대신 동적으로 메모리 할당받고 초기화 해서 쓰고, 모듈 exit 될
때 제대로 메모리 해제 시키라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51-rc4&#34;&gt;Linux 5.1-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=widsb0vN7kqt8ATfNuNW6a54JpKjc6W0XPjt5=LW7UeGQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=widsb0vN7kqt8ATfNuNW6a54JpKjc6W0XPjt5=LW7UeGQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 릴리즈는 초반 rc 들이 좀 커서 걱정을 끼쳤었는데, rc4 는 다행히도
작아졌다고 합니다.  딱히 별다른 게 없다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc3/</link>
      <pubDate>Tue, 26 Mar 2019 08:53:41 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc3/</guid>
      <description>&lt;h2 id=&#34;patch-tipcorercu-04-documentation-updates-for-v52&#34;&gt;[PATCH tip/core/rcu 0/4] Documentation updates for v5.2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190326230408.GA17069@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190326230408.GA17069@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v5.2 에 머지될 목적의 RCU 문서화 업데이트 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-018-miscellaneous-fixes-for-v52&#34;&gt;[PATCH tip/core/rcu 0/18] Miscellaneous fixes for v5.2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190326231253.GA18343@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190326231253.GA18343@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v5.2 를 위한 RCU 의 다양한 업데이트 패치셋입니다.  rcu 를 위한 메일링 리스트도
추가되었군요.  &lt;a href=&#34;mailto:rcu@vger.kernel.org&#34;&gt;rcu@vger.kernel.org&lt;/a&gt; 입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-09-torture-test-updates-for-v52&#34;&gt;[PATCH tip/core/rcu 0/9] Torture-test updates for v5.2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190326233054.GA21523@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190326233054.GA21523@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v5.2 를 위한 torture test 의 업데이트 패치셋입니다.  LKMM 이라던지 formal
verification 도 많은 발전이 있었지만, torture test 도 없어질 순 없겠죠.&lt;/p&gt;
&lt;h2 id=&#34;linux-51-rc3&#34;&gt;Linux 5.1-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiHmEqxBvp3dfTqOut+NHzbNaip=BrnBO48SCTfnApLRg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiHmEqxBvp3dfTqOut+NHzbNaip=BrnBO48SCTfnApLRg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;한국시간으로 만우절 아침, 5.1 을 위한 세번째 rc 버전이 릴리즈 되었습니다.  이번
릴리즈는 다른 rc3 들에 비해 조금 많은 변화가 있었기에 좋은 현상은 아니지만
그렇다 해도 아직 rc3 정도니까 큰 문제는 아닐 거라 하는군요.  전체적으로 코드가
추가된 것보다 제거된 게 많은 것 같습니다.
어쨌건 앞으로는 점점 변경양이 줄었으면 좋겠다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unit test for the Linux kernel using Kunit</title>
      <link>https://sjp38.github.io/ko/post/kunit_intro/</link>
      <pubDate>Wed, 20 Mar 2019 15:32:29 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/kunit_intro/</guid>
      <description>&lt;p&gt;업데이트 (2020-01-01): KUnit 은 v5.5 머지 윈도우 사이 메인라인에
머지되었습니다.  이 포스트 작성 시점 이후로 많은 KUnit 에도 많은 변화가 있었고,
따라서 아래 내용 중 일부, 특히 테스트 셋업과 수행 부분은 좀 많이 달라졌습니다.
해당 내용을 위해선 &lt;a href=&#34;https://www.kernel.org/doc/html/latest/dev-tools/kunit/index.html&#34;&gt;공식
문서&lt;/a&gt; 를
참고하시길 권장합니다.  또한, 최신 버전은 파이썬 버전 종속성이 생겨서 우분투
16.04 위에서는 문제를 겪으실 수 있습니다.  최신버전의 파이썬을 쓰시거나 그냥
우분투 18.04 를 사용하시길 권장합니다.&lt;/p&gt;
&lt;p&gt;지난 2월 말에 FAST&#39;19 학회를 다녀왔는데요, &lt;a href=&#34;https://thunk.org/tytso/&#34;&gt;Ted Tso&lt;/a&gt;
도 왔더군요.  심지어 구글 부스를 지키고 계시더라구요.  어쩌다보니
식사자리에서 합석하고 잡담 나눈 레드햇 개발자 분들이랑 이야기를 하고 있길래
껴서 좀 이야기를 했는데, 이야기 중 테스트에 대한 이야기가 나왔고, 이에 Ted 가
KUnit 이라는 도구를 소개해 줬습니다.  잠깐 사용해 보니 매우 매력적인 것 같아서
이 블로그에서도 소개해 볼까 합니다.&lt;/p&gt;
&lt;p&gt;KUnit 은 이름에서 짐작했겠지만 리눅스 커널을 위한 유닛 테스트 프레임웍입니다.
구글의 Brendan Higgins 라는 분이 개발하고 있고, 커널 내에 머지되는 걸 목표로
해서 LKML 에도 &lt;a href=&#34;https://lkml.org/lkml/2019/2/14/1144&#34;&gt;RFC 패치&lt;/a&gt;를 보내고
있습니다.
구글러다 보니 구글에서 호스팅 되는
&lt;a href=&#34;https://kunit.googlesource.com/linux/&#34;&gt;소스트리&lt;/a&gt; 위에서 개발을 하고 있고,
&lt;a href=&#34;https://google.github.io/kunit-docs/third_party/kernel/docs/&#34;&gt;문서화&lt;/a&gt; 도 잘
해뒀군요.&lt;/p&gt;
&lt;p&gt;이 글은 이런 KUnit 을 사용하는 법을 간단히 정리해 봅니다.  글 내의 테스트에
사용된 환경은 Ubuntu 16.04 서버 버전입니다.&lt;/p&gt;
&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;
&lt;p&gt;Kunit 개발 커널은 &lt;a href=&#34;https://kunit.googlesource.com&#34;&gt;https://kunit.googlesource.com&lt;/a&gt; 에서 받을 수 있습니다.  간단히
아래 명령으로 커널 코드를 땡겨옵시다.  여기선 가장 최근에 RFC 패치를 보냈던
5.0-rc5 위의 버전으로 가져오겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone -b kunit/rfc/5.0-rc5/v4 https://kunit.googlesource.com/linux
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;물론, [Patchwork]
(&lt;a href=&#34;https://lore.kernel.org/patchwork/project/lkml/list/?series=383391&#34;&gt;https://lore.kernel.org/patchwork/project/lkml/list/?series=383391&lt;/a&gt;) 을 통해
KUnit 패치만 직접 받아와 사용중인 커널에 적용하실 수도 있습니다.  전 v5.0 버전
위에도 적용해 봤는데 문제 없이 잘 적용되더군요.&lt;/p&gt;
&lt;p&gt;이어서 KUnit 을 위한 패키지를 깔아야 할텐데요, 커널 빌드에 필요한 패키지만 깔면
됩니다.  커널 빌드에 필요한 패키지에 대한 정보는 이 블로그의 커널 빌드 및
설치에 대한 &lt;a href=&#34;https://sjp38.github.io/ko/post/linux-kernel-build/&#34;&gt;포스트&lt;/a&gt; 를 참고해 주세요.&lt;/p&gt;
&lt;h1 id=&#34;test&#34;&gt;Test&lt;/h1&gt;
&lt;p&gt;커널 빌드 종속성 패키지까지 다 설치했다면 준비가 거의 끝났습니다.  잘
돌아가는지 확인해 보기 위해 kunit 에서 제공하는 예제 테스트들을 돌려봅시다.&lt;/p&gt;
&lt;p&gt;KUnit 을 돌리기 위해선 configuration 을 커널 트리 루트에 &lt;code&gt;kunitconfig&lt;/code&gt; 라는
이름의 파일로 써줘야 합니다.  이 설정은 어떤 테스트를 돌릴지 등을 지정합니다.
일단 아래 내용으로 해당 파일을 써줍시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd linux
$ echo CONFIG_KUNIT=y &amp;gt; kunitconfig
$ echo CONFIG_KUNIT_TEST=y &amp;gt;&amp;gt; kunitconfig
$ echo CONFIG_KUNIT_EXAMPLE_TEST=y &amp;gt;&amp;gt; kunitconfig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이제 다음의 간단한 명령만으로 KUnit 예제 테스트를 돌릴 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./tools/testing/kunit/kunit.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;아래와 같은 결과가 터미널에 뜰겁니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[11:31:47] Building KUnit Kernel ...
[11:32:12] Starting KUnit Kernel ...
[11:32:12] ==============================
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_init_resources
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_alloc_resource
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_free_resource
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_cleanup_resources
[11:32:13] ==============================
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_try_catch_successful_try_no_catch
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_try_catch_unsuccessful_try_does_catch
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_generic_try_catch_successful_try_no_catch
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_generic_try_catch_unsuccessful_try_does_catch
[11:32:13] ==============================
[11:32:13] [PASSED] string-stream-test:string_stream_test_get_string
[11:32:13] [PASSED] string-stream-test:string_stream_test_add_and_clear
[11:32:13] ==============================
[11:32:13] [PASSED] example:example_simple_test
[11:32:13] ==============================
[11:32:13] Testing complete. 11 tests run. 0 failed. 0 crashed.
[11:32:13] Elapsed time: 26.005s total, 0.000s configuring, 25.736s building, 0.268s running.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;kunit-resource-test, kunit-try-catch-test, string-stream-tets, example&lt;/code&gt; 등의
예제 테스트가 돌아갔고, 모두 테스트를 통과해서 문제가 없음을 보여줍니다.&lt;/p&gt;
&lt;p&gt;KUnit 은 테스트를 위해 커널도 빌드하기 때문에 빌드 시간이 조금 길긴 합니다.  이
경우엔 26초 정도 걸렸네요.  하지만 이건 처음 빌드라 그렇고, 기존에 빌드를
해두고 파일 하나만 수정하는 경우엔 약 10초 정도 걸리는 것 같습니다.  하지만
이후 실제 테스트를 돌리는건 매우 짧은 시간을 필요로 합니다.  이 경우 0.27초
가량 걸렸군요!  따라서 테스트가 늘어나도 많은 시간을 요하지 않습니다.&lt;/p&gt;
&lt;p&gt;스스로를 위한 유닛 테스트를 추가하는 법은 Kunit 공식 문서[1] 를 참고하시기
바랍니다.  어렵지 않습니다 :)&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://google.github.io/kunit-docs/third_party/kernel/docs/start.html#writing-your-first-test&#34;&gt;https://google.github.io/kunit-docs/third_party/kernel/docs/start.html#writing-your-first-test&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;리눅스 커널을 위한 Unit test framework 인 KUnit 에 대한 간단한 소개와 사용법을
설명했습니다.  저도 최근 개발에 활용하고 있는데, TDD 의 장점을 오랫만에 느낄 수
있었습니다.  하루 빨리 업스트림에도 머지되었으면 좋겠네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc2/</link>
      <pubDate>Tue, 19 Mar 2019 12:11:11 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-v5-0019-convert-x86--arm64-to-use-generic-page-walk&#34;&gt;[PATCH v5 00/19] Convert x86 &amp;amp; arm64 to use generic page walk&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190321141953.31960-1-steven.price@arm.com&#34;&gt;https://lkml.kernel.org/r/20190321141953.31960-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널이 &lt;code&gt;walk_page_range()&lt;/code&gt; 함수를 제공하긴 하지만 이 함수는 커널에 의해
사용되는 페이지 테이블은 볼수가 없기 때문에 각 아키텍쳐별로 페이지 테이블
순회를 위한 기능을 별도로 만들어 사용하고 있습니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 &lt;code&gt;walk_page_range()&lt;/code&gt; 가 커널의 페이지 테이블을 만질 수 있도록
확장함으로써 그런 불필요한 아키텍쳐별 파편화를 줄이려 합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v6-07-psi-pressure-stall-monitors-v6&#34;&gt;[PATCH v6 0/7] psi: pressure stall monitors v6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190319235619.260832-1-surenb@google.com&#34;&gt;https://lkml.kernel.org/r/20190319235619.260832-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시스템이 어떤 부분의 pressure 를 받는지 쉽게 확인하기 위한 pressure stall
monitor 구현 패치의 여섯 번째 버전입니다.  안드로이드는 이미 이 기능을 적용해서
모바일 기기의 메모리 부족 문제를 해결하고 있다는군요.&lt;/p&gt;
&lt;p&gt;파일 기반의 기존 인터페이스는 자주 들여다보면 오버헤드가 있기 때문에 유저가
&lt;code&gt;poll()&lt;/code&gt; 할 수 있는 형태로 인터페이스를 개선한 것 같습니다.&lt;/p&gt;
&lt;p&gt;이 패치 기반으로 안드로이드의 low memory killer daemon 을 개선했고, 결과 false
positive memory pressure 를 vmpressure signal 대비 약 10배까지 줄일 수 있었다고
합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-remove-support-for-deprecated-pf-and-pf-in-vsprintf&#34;&gt;[PATCH 0/2] Remove support for deprecated %pf and %pF in vsprintf&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190322132108.25501-1-sakari.ailus@linux.intel.com&#34;&gt;https://lkml.kernel.org/r/20190322132108.25501-1-sakari.ailus@linux.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;함수 포인터의 프린트를 위해 사용되는 프린트 포맷 지시어인 %pf 와 %pF 를 거의
같은 일을 하면서 ia64, ppc64, parisc64 아키텍쳐에선 좀 더 많은 일을 해주는 $ps
와 %pS 로 대체하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-010-another-approach-to-use-pmem-as-numa-node&#34;&gt;[RFC PATCH 0/10] Another Approach to Use PMEM as NUMA Node&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1553316275-21985-1-git-send-email-yang.shi@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/1553316275-21985-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 이 블로그에서도 소개한 바 있는 PMEM 을 매우 느린 NUMA node 로 쓰는 패치가
머지되었습니다.
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c221c0b0308fd01d9fb33a16f64d2fd95f8830a4&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c221c0b0308fd01d9fb33a16f64d2fd95f8830a4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그럼 이렇게 평범한 NUMA node 로 인식되는 PMEM 을 어떻게 잘 쓸 것인가? 하는
문제가 남아있는데, 이 패치셋은 이를 위한 패치입니다.&lt;/p&gt;
&lt;p&gt;기본적으로 DRAM 을 먼저 쓰게 만들고, 사용자가 기존의 방식대로 명시적으로 NUMA
인터페이스를 사용해 PMEM 을 요청하면 할당해 줍니다.  그리고, 자주 접근되는
페이지는 vma 단위로 조사해서 DRAM 으로 migrate 시킵니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51-rc2&#34;&gt;Linux 5.1-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgg_PRWs3a6u2gnFLQjhxOJcrFkqqWVnLw60eQAwD-DNw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgg_PRWs3a6u2gnFLQjhxOJcrFkqqWVnLw60eQAwD-DNw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;두번째 rc 입니다.  아직 rc 라고 하기엔 고칠 문제도 찾지 못한 상태라고 할 수
있겠지만요.  따라서 토발즈는 열심히 테스트 해달라고 하네요.&lt;/p&gt;
&lt;p&gt;어쨌건 이번 릴리즈도 크게 특이한 사항은 없다고 합니다, 다만 이번 수정사항 중
2/3 가량이 tools/ 쪽에 집중되었다고 하네요.  perf 쪽의 변경 때문이라고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc1/</link>
      <pubDate>Mon, 04 Mar 2019 13:07:30 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.1-rc1/</guid>
      <description>&lt;p&gt;Linux v5.0 릴리즈 (2019-03-03) 부터 v5.1-rc1 릴리즈 (2019-03-17) 사이의 머지
윈도우 기간 LKML 에 올라온 흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;cma-allocation-failure&#34;&gt;CMA allocation failure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/57e0bc63-0be9-498b-8ffc-3b073e01e299@email.android.com&#34;&gt;https://lkml.kernel.org/r/57e0bc63-0be9-498b-8ffc-3b073e01e299@email.android.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;제게도 GCMA 레이턴시 관련 문의를 보냈던 분인데, LKML 에도 관련 도움을 요청하는
메일을 보냈군요.&lt;/p&gt;
&lt;p&gt;왜 CMA 가 할당에 실패하는지 이유를 묻는 메일인데요, 답은 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-using-xarray-to-manage-the-vma&#34;&gt;[LSF/MM TOPIC] Using XArray to manage the VMA&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/7da20892-f92a-68d8-4804-c72c1cb0d090@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/7da20892-f92a-68d8-4804-c72c1cb0d090@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MM 의 오랜 숙원 중 하나는 &lt;code&gt;mmap_sem&lt;/code&gt; 으로 인한 확장성 문제 해결이죠.  기존의 RB
tree 대신 XArray 를 사용하는 것으로 새로운 시도를 시작해 보는건 어떨지 LSFMM
에서 토의해보자는, speculative page fault 의 최근 메인테이너인 Laurent 의
메일입니다.
곧바로 XArray 메인테이너인 Matthew 의 답장이 오는군요.
꼭 해보려는 의지가 강력해 보입니다.&lt;/p&gt;
&lt;h2 id=&#34;mmcmac-high-latency-for-cma-allocation&#34;&gt;mm/cma.c: High latency for cma allocation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/SG2PR02MB3098E44824F5AA69BC04F935E8470@SG2PR02MB3098.apcprd02.prod.outlook.com&#34;&gt;https://lkml.kernel.org/r/SG2PR02MB3098E44824F5AA69BC04F935E8470@SG2PR02MB3098.apcprd02.prod.outlook.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이어지는 CMA 레이턴시에 대한 문의입니다.  제게 GCMA 레이턴시에 대해 온 문의에
대해서는 제 실험 환경을 보내주고 그쪽 환경에서 돌려본 후 결과를 알려달라
했는데, 아직 답이 없군요.
좀 더 자세한 분석 결과를 달라는 Michal 의 답변이 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51-rc1&#34;&gt;Linux 5.1-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wj1c_Tb-wwM6qaPLdggXtW3rOh1JzYUOs+O7PsHt-=+jg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wj1c_Tb-wwM6qaPLdggXtW3rOh1JzYUOs+O7PsHt-=+jg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v5.1 머지 윈도우가 종료되고 v5.1-rc1 이 릴리즈 되었습니다.  이번 릴리즈도 크게
다른 건 없고 매우 평범했다고 합니다.  좋은 징조인데요, 변경사항의 60%를 차지한
드라이버 가운데 habanalab 의 AI 가속기 칩 드라이버를 조금 특별한 변경사항으로
토발즈는 꼽네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.0/</link>
      <pubDate>Mon, 25 Feb 2019 13:16:39 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.0/</guid>
      <description>&lt;p&gt;Linux v5.0-rc8 릴리즈 (2019-02-24) 부터 Linux v5.0 릴리즈 (2019-03-03) 사이
기간에 LKML 에 올라온 흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-05-v5-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;&lt;code&gt;[PATCH 0/5] [v5] Allow persistent memory to be used like normal RAM&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190225185727.BCBD768C@viggo.jf.intel.com&#34;&gt;https://lkml.kernel.org/r/20190225185727.BCBD768C@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 몇번 소개했던, persistent memory 를 좀 많이 느린 numa node 인 것처럼 해서
시스템이 사용할 수 있게 하는 접근법의 패치 다섯번째 버전입니다.
이제 개선은 어느정도 된 것 같으니 슬슬 머지되야하지 않겠냐고 주장하는군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-v50&#34;&gt;Linux v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjuG6HiGbD7DCGfvDvhr_1WZUR-eYF2qWGbYyn9k6unvg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjuG6HiGbD7DCGfvDvhr_1WZUR-eYF2qWGbYyn9k6unvg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;마침내 5.0 릴리즈입니다!  제 랩톱에도 바로 받아다가 설치했습니다! ;)  물론 5.0
릴리즈에 특별한 기능 추가라던지 하는건 없고 그저 시간이 꽤 지나서 이렇게
된거라곤 하지만 어쨌든 느낌은 새롭군요.&lt;/p&gt;
&lt;p&gt;rc8 릴리즈 후에도 양은 크게 줄었지만 패치가 좀 있었습니다.  그렇게 고쳐진 버그
중 하나로는 uninitialized variable 문제가 있었는데, gcc 가 알아서 초기화를
시켜주다보니 워닝이 안떴었군요.  물론 다른 컴파일러를 사용하면 문제가 생기게
되니 무쓸모한 변경은 아니었다 자평합니다.&lt;/p&gt;
&lt;p&gt;어쨌든, 이렇게 v5.0 커널이 정식으로 나왔고, v5.1 을 향한 여정이 시작되었습니다!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc8</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc8/</link>
      <pubDate>Tue, 19 Feb 2019 08:33:37 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc8/</guid>
      <description>&lt;p&gt;Linux v5.0-rc7 릴리즈 (2019년 2월 17일) 부터 v5.0-rc8 릴리즈 (2019년 2월 24일)
사이의 기간에 LKML 에 올라온 흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-attend-mm-track-numa-thp-locality-reclaim&#34;&gt;[LSF/MM ATTEND] MM track: NUMA, THP locality, reclaim&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190218143203.GW9565@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20190218143203.GW9565@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mel Gorman 의 LSF/MM 참여 메일입니다.  NUMA remote THP vs NUMA local non-THP,
NUMA, 메모리 계층 그리고 디바이스 메모리, NUMA rebalancing 과 메모리 reclaim 에
참여하고 싶다고 이야기 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-lsfmm-attend-read-only-mapping-of-program-text&#34;&gt;&lt;code&gt;[LSF/MM TOPIC ][LSF/MM ATTEND] Read-only Mapping of Program Text&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/379F21DD-006F-4E33-9BD5-F81F9BA75C10@oracle.com&#34;&gt;https://lkml.kernel.org/r/379F21DD-006F-4E33-9BD5-F81F9BA75C10@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 를 활용해 read-only text 를 매핑함으로써 성능을 높이려는 시도를 해오고
있는데, 하나의 base page 를 먼저 읽고 이어서 추가적인 page 를 읽는게 진짜로
사용될지 모르는 readahead 때문에 의논을 해보고 싶다고 하네요.
또, 파일시스템에게 컨텐츠가 큰 청크를 필요로 할지 알려주는 인터페이스가 있으면
좋겠다는군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-v50-rc8&#34;&gt;Linux v5.0-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgtNhecfn_nOi0Yuy7XQSswfozz0CvRMn0WsQhk0YZfyw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgtNhecfn_nOi0Yuy7XQSswfozz0CvRMn0WsQhk0YZfyw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;rc8 이 나올지 바로 v5.0 이 나올지 궁금했는데, 결국 v5.0 릴리즈는 한주 더
미뤄지게 되었습니다.  rc7 때보다도 많은 패치가 이번 기간에 들어왔다는군요.&lt;/p&gt;
&lt;p&gt;그렇다고 아주 특별한 변경이 있었던 건 아니지만 그렇다고 서두를 것도 없으므로
그냥 rc8 을 릴리즈하기로 결정했다고 하네요.&lt;/p&gt;
&lt;p&gt;어쨌건 다음주에는 분명 v5.0 이 나오겠죠!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc7/</link>
      <pubDate>Mon, 18 Feb 2019 12:30:24 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc7/</guid>
      <description>&lt;h2 id=&#34;patch-v15-0018-block-support-multi-page-bvec&#34;&gt;[PATCH V15 00/18] block: support multi-page bvec&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190215111324.30129-1-ming.lei@redhat.com&#34;&gt;https://lkml.kernel.org/r/20190215111324.30129-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시스템의 RAM 이 커지고 huge page 가 널리 사용되면서 물리적으로 연속된
페이지들의 I/O 가 흔해지고 있습니다.  이를 위해 &lt;code&gt;struct bio_bvec&lt;/code&gt; 이 물리적으로
연속된 여러 페이지를 다룰 수 있게 해주는 패치의 15번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;memory-management-facing-a-400gpbs-network-link&#34;&gt;Memory management facing a 400Gpbs network link&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/01000168e2f54113-485312aa-7e08-4963-af92-803f8c7d21e6-000000@email.amazonses.com&#34;&gt;https://lkml.kernel.org/r/01000168e2f54113-485312aa-7e08-4963-af92-803f8c7d21e6-000000@email.amazonses.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해 내로 400Gbps 인피니밴드가 가능해질 거라고 합니다!  이건 프로세서-메모리
사이의 밴드위쓰를 넘길 수 있는 스피드죠!  단일 하드웨어 쓰레드는 20GB/s 이기
때문입니다.  이 재미있는 트렌드를 커널은 어떻게 대처해야 할 것인가 하는
메일입니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-generating-physically-contiguous-memory&#34;&gt;[LSF/MM TOPIC] Generating physically contiguous memory&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CEDBC792-DE5A-42CB-AA31-40C039470BD0@nvidia.com&#34;&gt;https://lkml.kernel.org/r/CEDBC792-DE5A-42CB-AA31-40C039470BD0@nvidia.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GPU, FPGA, NIC, RDMA 같은 고성능 디바이스들에게 있어 물리적 연속 메모리는 매우
중요합니다.  이 디바이스들은 내부적으로 고밀도의 computation 을 하는데 tlb miss
와 이어지는 page table walk 로 인한 성능 문제가 CPU 에 비해서도 매우 크기
때문이라는군요.&lt;/p&gt;
&lt;p&gt;Boot time reservation 도, THP 도 유연성이 부족하기 때문에 새로운 패치도 만들고,
관련해서 LSF/MM 에서 논의해 보자는군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-v4-0017-kunit-introduce-kunit-the-linux-kernel-unit-testing-framework&#34;&gt;[RFC v4 00/17] kunit: introduce KUnit, the Linux kernel unit testing framework&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190214213729.21702-1-brendanhiggins@google.com&#34;&gt;https://lkml.kernel.org/r/20190214213729.21702-1-brendanhiggins@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널은 다양한 테스트를 가지고 있지만 unit test framework 은 아직 없었죠.
그걸 만든 패치입니다!&lt;/p&gt;
&lt;h2 id=&#34;linux-50-rc7&#34;&gt;Linux 5.0-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgvF18PqBch4=56DFwCamYpy+owngTZXGnjVbFgKq467g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgvF18PqBch4=56DFwCamYpy+owngTZXGnjVbFgKq467g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;휴일을 끼고 시작된 머지 윈도우로 이래저래 걱정도 있던 5.0 릴리즈들이었습니다만
이번 rc 릴리즈는 정말 별다른 게 없네요.  매우 고요한 릴리즈였다고 합니다.
아마도 다음주에 5.0 정식 릴리즈가 될 걸로 보이네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc6/</link>
      <pubDate>Mon, 11 Feb 2019 12:40:20 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-v4-11-psi-introduce-psi-monitor&#34;&gt;[PATCH v4 1/1] psi: introduce psi monitor&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190206023446.177362-1-surenb@google.com&#34;&gt;https://lkml.kernel.org/r/20190206023446.177362-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시스템의 메모리 부족 등의 현상이 어떻게 일어나고 있는지 쉽게 파악할 수 있는
장치를 추가하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-address-space-isolation-inside-the-kernel&#34;&gt;[LSF/MM TOPIC] Address space isolation inside the kernel&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190207072421.GA9120@rapoport-lnx&#34;&gt;https://lkml.kernel.org/r/20190207072421.GA9120@rapoport-lnx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스의 어드레스 스페이스 기능은 유저스페이스 프로그램들이 서로에게 영향을
끼치지 못하게 해줘서 컨테이너 등에 쓰이고 있죠.  하지만 커널은 공유하기 때문에
커널 버그는 여전히 영향을 끼칠 수 있습니다.  커널 코드도 어드레스 스페이스를
어느정도 인식하고 코드 분류를 시킴으로써 그 문제를 줄여보자는 LSF/MM 토론 주제
제안입니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-2019-call-for-proposals-updated&#34;&gt;LSF/MM 2019: Call for Proposals (UPDATED!)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/4f5a15c1-4f9e-acae-5094-2f38c8eebd96@kernel.dk&#34;&gt;https://lkml.kernel.org/r/4f5a15c1-4f9e-acae-5094-2f38c8eebd96@kernel.dk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해 LSF/MM 에는 BPF 트랙이 있을 거라는군요.  이에 따른 공지 업데이트입니다.
BPF 의 상승세가 올해도 계속될 것 같군요!&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-bpf-for-block-devices&#34;&gt;[LSF/MM TOPIC] BPF for Block Devices&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/40D2EB06-6BF2-4233-9196-7A26AC43C64E@raithlin.com&#34;&gt;https://lkml.kernel.org/r/40D2EB06-6BF2-4233-9196-7A26AC43C64E@raithlin.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LSF/MM 에 BPF 라면 당연히 block device 와 BPF 의 결합을 이야기 해야하지
않겠냐는 LSF/MM 토론 제안입니다.  Computational Storage 개념을 이야기 하는데요,
I/O 레이어에서 간단한 연산을 처리해 줌으로써 성능을 높이자는 거죠.  그러기 위한
연산 요청에 BPF 를 쓰자는 것 같습니다.  말 되네요!&lt;/p&gt;
&lt;h2 id=&#34;linux-50-rc6&#34;&gt;Linux 5.0-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whuSY_-hAU8ugVR7a=xz3uZeRrAPdhsoMZHmZ_7Qc49YQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whuSY_-hAU8ugVR7a=xz3uZeRrAPdhsoMZHmZ_7Qc49YQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이제 리눅스 5.0 정식 릴리즈가 얼마 남지 않았네요, 여섯번째 rc 가 나왔습니다.
그런데 이번 rc 는 토발즈가 바랬던 것보다는 조금 변경사항이 많았군요.  대부분
네트워킹 쪽 변경이었다고 합니다만, 그래도 나머지는 큰 문제 없어 보인다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc5/</link>
      <pubDate>Mon, 04 Feb 2019 09:18:08 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc5/</guid>
      <description>&lt;h2 id=&#34;lsfmm-topic-page-flags-can-we-free-up-space-&#34;&gt;[LSF/MM TOPIC] Page flags, can we free up space ?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190122201744.GA3939@redhat.com&#34;&gt;https://lkml.kernel.org/r/20190122201744.GA3939@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널의 page 정보는 &lt;code&gt;PG_&lt;/code&gt; 로 시작하는 플래그를 사용해 현재 상태를
알리는데요, 이걸 저장하는데 사용되는 공간을 더 줄일 수 있을지에 대한 논의를
해보고 싶다는 LSF/MM 제안입니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-use-nvdimm-as-numa-node-and-numa-api&#34;&gt;[LSF/MM TOPIC] Use NVDIMM as NUMA node and NUMA API&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/f0d66b0c-c9b6-a040-c485-1606041a70a2@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/f0d66b0c-c9b6-a040-c485-1606041a70a2@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;알리바바에서는 NVDIMM 을 클라우드 고객들에게 싼 비용의 메모리로 제공하려
한다는군요.  이를 위해 여러 필요성이 있고, 현재 NUMA API 로는 모든 경우를
커퍼하기가 어렵다고 합니다.  때문에, LSFMM 에서 어떤 use-case 와 needs 가
있는지 공유하고 더 나은 NUMA API 에 대해 논의하고자 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-memory-reclaim-with-numa-rebalancing&#34;&gt;[LSF/MM TOPIC] memory reclaim with NUMA rebalancing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190130174847.GD18811@dhcp22.suse.cz&#34;&gt;https://lkml.kernel.org/r/20190130174847.GD18811@dhcp22.suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NVDIMM 을 싸고 무척 느린 NUMA 노드로 인식되고 사용되게끔 하고자 하는 노력들이
있습니다.  이게 완벽하게 동작하려면 hot page 는 가깝고 빠른 NUMA node 에, cold
page 는 멀고 느린 NUMA node 에 위치되도록 커널이 조정해줄 필요가 있겠죠.  NUMA
balancing 기능이 있긴 하지만 cold page 를 멀고 느린 NUMA node 로 보내는 기능은
현재까지는 없습니다.  이에 대한 논의를 LSF/MM 에서 시작해 보자고 하네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-50-rc5&#34;&gt;Linux 5.0-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjoGOgYFCbpazT2Fyv=zHaiagU5PhmiAfrZ5DOmE-y0rg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjoGOgYFCbpazT2Fyv=zHaiagU5PhmiAfrZ5DOmE-y0rg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아무래도 이번 릴리즈들은 머지 윈도우가 길고 연휴와 함께 있었던 탓인지
전체적으로 뭔가 변경사항이 줄지 않는듯 보였는데, 드디어 변경사항이 줄어들고
있다고 합니다.  좋은 신호죠.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc3/</link>
      <pubDate>Mon, 21 Jan 2019 09:21:14 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc3/</guid>
      <description>&lt;h2 id=&#34;lsfmm-2019-call-for-proposals&#34;&gt;LSF/MM 2019: Call for Proposals&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/51b4b263-a0f2-113d-7bdc-f7960b540929@kernel.dk&#34;&gt;https://lkml.kernel.org/r/51b4b263-a0f2-113d-7bdc-f7960b540929@kernel.dk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해의 LSF/MM 을 위한 발표 모집입니다.  올해는 푸에르토리코에서 4월 30일부터
5월 2일까지 열리는군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-numa-memory-hierarchy-and-device-memory&#34;&gt;[LSF/MM TOPIC] NUMA, memory hierarchy and device memory&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190118174512.GA3060@redhat.com&#34;&gt;https://lkml.kernel.org/r/20190118174512.GA3060@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LSF/MM 을 위한 발표 지원입니다.
NUMA API 가 다계층 메모리에 적용될 때의 단점에 대해서 이야기 해보겠다는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0022-increase-success-rates-and-reduce-latency-of-compaction-v3&#34;&gt;[PATCH 00/22] Increase success rates and reduce latency of compaction v3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190118175136.31341-1-mgorman@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20190118175136.31341-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mel Gorman 의 compaction 개선 패치셋 세번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-50-rc3&#34;&gt;Linux 5.0-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whS=6Z_UxzoMjLANupOk3u-8ycERLPnaZxShMTviW0jkQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whS=6Z_UxzoMjLANupOk3u-8ycERLPnaZxShMTviW0jkQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.0 세번째 릴리즈입니다.  지난 릴리즈에서 여행 중이지만 항상 그렇듯 일요일
릴리즈를 하려 한다고 했는데, 이번에도 성공적이군요.  더불어 어디 여행 중인지도
나왔습니다, LCA 2019 여행 중이었군요.  여담이지만 올해 LCA 도 재밌는 발표가
많은 것 같습니다.&lt;/p&gt;
&lt;p&gt;지난 rc2 에서 머지하는 걸 빼먹은 네트워킹 쪽 풀리퀘스트를 이번에 머지했기
때문에 이번 rc3 는 조금 크다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc2/</link>
      <pubDate>Tue, 15 Jan 2019 09:06:44 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-v11-0026-speculative-page-faults&#34;&gt;[PATCH v11 00/26] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/8b0b2c05-89f8-8002-2dce-fa7004907e78@codeaurora.org&#34;&gt;https://lkml.kernel.org/r/8b0b2c05-89f8-8002-2dce-fa7004907e78@codeaurora.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SPF 패치에서 발견된 버그 레포트입니다.  ARM 위에서 데드락 문제가 발견되었군요.
버그 발견자가 패치도 같이 내놓았는데, 이에 대한 토론은 아직도 계속되고 있네요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v7-0016-add-support-for-exclusive-page-frame-ownership&#34;&gt;[RFC PATCH v7 00/16] Add support for eXclusive Page Frame Ownership&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/cover.1547153058.git.khalid.aziz@oracle.com&#34;&gt;https://lkml.kernel.org/r/cover.1547153058.git.khalid.aziz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lsquo;ret2dir&amp;rsquo; 보안 공격[1]에 대비하기 위한 패치입니다.  하지만 이로 인해 tlb 를 좀
많이 flush 해야 하는 문제가 있었고, 이 패치셋은 그에 대한 해결책도 의논하고
있습니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf&#34;&gt;http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;patch-04-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;[PATCH 0/4] Allow persistent memory to be used like normal RAM&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190116181859.D1504459@viggo.jf.intel.com&#34;&gt;https://lkml.kernel.org/r/20190116181859.D1504459@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PMEM 을 사용하기 위해선 현재로썬 어플리케이션 코드를 수정해야 합니다.  그냥
평범한, 조금 느린 RAM 처럼 어플리케이션이 기존에 RAM 접근하듯 접근할 수 있게
하면 안될까요?  이 패치셋은 그런 경우를 위한 드라이버를 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-05-psi-pressure-stall-monitors-v2&#34;&gt;[PATCH v2 0/5] psi: pressure stall monitors v2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190110220718.261134-1-surenb@google.com&#34;&gt;https://lkml.kernel.org/r/20190110220718.261134-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LWN 에서도 소개된 pressure stall monitor 의 두번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-50-rc2&#34;&gt;Linux 5.0-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wicCXd7nALwEz+022iNesJV3DUmejS+dzVRE0D3UGzs_g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wicCXd7nALwEz+022iNesJV3DUmejS+dzVRE0D3UGzs_g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.x 로 나아가는 두번째 릴리즈 후보가 나왔습니다.  이번 머지 윈도우가 휴일이
섞여 있었기 때문에 두번째 rc 를 위한 과정에 문제가 있지 않을까 싶었지만 별 문제
없었다는군요.  그리고 지금 토발즈는 여행중이라 현지시간으로는 항상 하는 일요일
릴리즈가 아니라 월요일 릴리즈라 합니다만, 뭐&amp;hellip; 큰 이슈는 아니죠 ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc1/</link>
      <pubDate>Mon, 07 Jan 2019 11:18:50 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v5.0-rc1/</guid>
      <description>&lt;h2 id=&#34;rfc-v3-03-test-driver-to-analyse-vmalloc-allocator&#34;&gt;[RFC v3 0/3] test driver to analyse vmalloc allocator&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190102085924.14145-1-urezki@gmail.com&#34;&gt;https://lkml.kernel.org/r/20190102085924.14145-1-urezki@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;vmalloc 의 성능과 스트레스 테스트를 위한 모듈을 구현한 패치입니다.  Selftests
에도 테스트 스크립트를 추가했군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-01-mm-add-a-warning-about-high-order-allocations&#34;&gt;[RFC PATCH 0/1] mm: add a warning about high order allocations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181225153927.2873-1-khorenko@virtuozzo.com&#34;&gt;https://lkml.kernel.org/r/20181225153927.2873-1-khorenko@virtuozzo.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;특정 노드의 메모리에 접근이 많이 되고 있는 상황에서 해당 메모리가 fragment 되어
있고 이 시점에서 high order allocation 이 요청되면 이걸 위해 compaction 등이
작동하니까 다른 태스크의 latency 가 떨어질 수 있습니다.  이런 상황을 모니터링
할 수 있게끔, 이 패치는 &lt;code&gt;vm.war_high_order&lt;/code&gt; 라는 값을 sysctl 통해 설정하면 이
값을 넘는 order 의 allocation 이 요청되었을 때 워닝을 뱉어 줍니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-introduce-page_size&#34;&gt;[PATCH] mm: Introduce page_size()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181231134223.20765-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20181231134223.20765-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 의 존재로 인해 페이지의 실제 크기는 모두 똑같지가 않기 때문에 이를
판별할 방법이 필요하죠.  이 패치는 단순히 기존에 좀 복잡하게 직접 페이지 크기를
구하던 것을 별도의 wrapper function 으로 대체하기 위한 준비 작업입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-50-rc1&#34;&gt;Linux 5.0-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wgKYnrL3LjhVkH2Fp+ecmWhLqezT9zmR6CzfcpwcJX0qA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/wgKYnrL3LjhVkH2Fp+ecmWhLqezT9zmR6CzfcpwcJX0qA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널 버전의 숫자가 큰 의미 없게 된지도 오래이긴 합니다만 그래도 메이저
버전 변경은 항상 뭔가 들뜨게 마련이죠.
드디어 5.x 커널의 시대가 시작되었습니다.&lt;/p&gt;
&lt;p&gt;연말/연처 휴일이 섞여 있는 덕에 꽤 오랫만의 릴리즈가 되었고, 그덕에 좀 늦게
풀리퀘스트가 온 것들도 있었지만 큰 문제는 없었다고 하네요.&lt;/p&gt;
&lt;p&gt;메이저 버전이 4.x 에서 5.x 로 바뀌긴 했지만 손가락 발가락 다 써도 4.21 의
버전은 셀수가 없기 때문에 5.x 로 바뀌었을 뿐 특별한 변경이나 새로운 기능은
없다는 점도 한번 더 공지합니다.
하지만 많은 기능들이 추가된 것도 사실이니 원하면 하나 꼽아들고 이거 때문에 5.x
로 업데이트 되었다고 생각해도 좋다고 하는군요.&lt;/p&gt;
&lt;p&gt;이번 릴리즈는 총 11000여개의 커밋을 받아들인 긴 머지 윈도우를 거쳤지만,
그렇다고 유별날 건 없다는군요.  절반 가량이 드라이버, 20%는 아키텍쳐, 10% 툴링,
나머진 여기저기.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perf symbol problem on Linux 4.19</title>
      <link>https://sjp38.github.io/ko/post/perf_symbol_problem_4.19/</link>
      <pubDate>Fri, 21 Dec 2018 17:00:22 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/perf_symbol_problem_4.19/</guid>
      <description>&lt;p&gt;4.19 커널에서 오랫만에 perf 를 다시 빌드하고 써보려고 하니, &lt;code&gt;perf report&lt;/code&gt; 가
아래와 같이 제대로 된 symbol name 을 찾질 못합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo perf record -g ls
arch                     builtin-ftrace.c    builtin-report.c     Documentation       perf.data.old
bench                    builtin.h           builtin-sched.c      examples            perf.h
Build                    builtin-help.c      builtin-script.c     include             perf-read-vdso.c
builtin-annotate.c       builtin-inject.c    builtin-stat.c       jvmti               perf-sys.h
builtin-bench.c          builtin-kallsyms.c  builtin-timechart.c  Makefile            perf-with-kcore.sh
builtin-buildid-cache.c  builtin-kmem.c      builtin-top.c        Makefile.config     pmu-events
builtin-buildid-list.c   builtin-kvm.c       builtin-trace.c      Makefile.perf       python
builtin-c2c.c            builtin-list.c      builtin-version.c    MANIFEST            scripts
builtin-config.c         builtin-lock.c      check-headers.sh     perf-archive.sh     tests
builtin-data.c           builtin-mem.c       command-list.txt     perf.c              trace
builtin-diff.c           builtin-probe.c     CREDITS              perf-completion.sh  ui
builtin-evlist.c         builtin-record.c    design.txt           perf.data           util
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.025 MB perf.data (21 samples) ]
sjpark@hydra:~/linux/tools/perf$ sudo perf report --stdio
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 21  of event &#39;cycles:ppp&#39;
# Event count (approx.): 2712237
#
# Children      Self  Command  Shared Object      Symbol
# ........  ........  .......  .................  .................................
#
    59.39%     0.00%  ls       [unknown]          [k] 0xffffffffa8a00088
            |
            ---0xffffffffa8a00088
               |
               |--51.91%--0xffffffffa8004185
               |          |
               |          |--17.13%--0xffffffffa8212c8b
               |          |          0xffffffffa8212afe
               |          |          0xffffffffa821274a
               |          |          0xffffffffa81bb3c5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;왜이러지 하고 삽질하다가 알고보니 perf 쪽 최신 커밋인 edeb0c90df35 (&amp;ldquo;perf
tools: Stop fallbacking to kallsyms for vdso symbols lookup&amp;rdquo;) 이 만든 버그군요.
해당 커밋만 revert 하고 perf 를 다시 빌드하면 다시 잘 됩니다.&lt;/p&gt;
&lt;p&gt;저만 겪는 문제는 아닌지 버그질라에도 이에 대한 이슈가 올라와 있네요:
&lt;a href=&#34;https://bugzilla.kernel.org/show_bug.cgi?id=201551&#34;&gt;https://bugzilla.kernel.org/show_bug.cgi?id=201551&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News for v4.20</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.20/</link>
      <pubDate>Fri, 21 Dec 2018 08:35:03 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.20/</guid>
      <description>&lt;h2 id=&#34;patch-v5-03-mmkvmvfioppc64-migrate-compound-pages-out-of-cma&#34;&gt;[PATCH V5 0/3] mm/kvm/vfio/ppc64: Migrate compound pages out of CMA&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181219034047.16305-1-aneesh.kumar@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20181219034047.16305-1-aneesh.kumar@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ppc64 에서는 guest os page table 을 CMA area 내에 할당하는데, VFIO 를 쓰는 경우
이게 pinning 되어 있다 보니 CMA area 밖으로 migrate 하는데 실패해, guest os
page table 할당에 실패하고, 이로 인해 guest 시작조차 불가능하게 되는 문제가
있었습니다.&lt;/p&gt;
&lt;p&gt;이 패치는 compound page 에 대해서도 CMA area 밖으로의 migration 이 가능하게
합니다.&lt;/p&gt;
&lt;h2 id=&#34;resend-patch-v3-05-arm64mm-enable-hugetlb-migration&#34;&gt;[RESEND PATCH V3 0/5] arm64/mm: Enable HugeTLB migration&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1545121450-1663-1-git-send-email-anshuman.khandual@arm.com&#34;&gt;https://lkml.kernel.org/r/1545121450-1663-1-git-send-email-anshuman.khandual@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HugeTLB 를 통째로 migrate 할 수 있게 하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-02-hugetlbfs-use-i_mmap_rwsem-for-better-synchronization&#34;&gt;[PATCH v2 0/2] hugetlbfs: use i_mmap_rwsem for better synchronization&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181218223557.5202-1-mike.kravetz@oracle.com&#34;&gt;https://lkml.kernel.org/r/20181218223557.5202-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hugetlbfs 와 truncation 사이에 race conditional bug 가 존재해 왔는데, 이 패치는
&lt;code&gt;i_mmap_rwsem&lt;/code&gt; 을 사용해 동기화를 적용함으로써 이 race bug 를 제거합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-12-mm-swap-check-if-swap-backing-device-is-congested&#34;&gt;[RFC PATCH 1/2] mm: swap: check if swap backing device is congested&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1545115948-25467-1-git-send-email-yang.shi@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/1545115948-25467-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Swap readahead 기능이 이미 다른 요청으로 바쁜 storage device 에 행해진다면 swap
자체 성능도 떨어지고 storage 를 더욱 바빠지게 해서 남들에게도 민폐가 됩니다.
&lt;code&gt;vma_cluster_radahead()&lt;/code&gt; 에서 먼저 storage 의 congestion 을 체크해 보게 하는
패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420-released&#34;&gt;Linux 4.20 released..&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wg0zF4wa87Q5rAhFe2es0t0eExX2UjvKD7-Pghvcbt5Vw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wg0zF4wa87Q5rAhFe2es0t0eExX2UjvKD7-Pghvcbt5Vw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;예정대로 4.20 이 정식 릴리즈 되었습니다.  원했던 것보단 조금 시끄러운
주간이었지만 어쨌건 연말 휴일을 방해하고 싶진 않고 정말 큰 문제가 있는 것 같아
보이진 않기에 릴리즈 했다고 합니다.&lt;/p&gt;
&lt;p&gt;이번 정식 릴리즈에서 개인적으로 눈길 가는건 XArray 입니다.  앞으로도 많은
영역에 쓰이고자 하는 것 같던데, 향후 행보도 궁금합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc7/</link>
      <pubDate>Mon, 17 Dec 2018 09:16:11 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc7/</guid>
      <description>&lt;h2 id=&#34;patch--v9-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V9 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181214062754.13723-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20181214062754.13723-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아직 머지되지 못한 THP swap in 패치셋의 아홉번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-03-reduce-thp-fault-thrashing&#34;&gt;[RFC 0/3] reduce THP fault thrashing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181211142941.20500-1-vbabka@suse.cz&#34;&gt;https://lkml.kernel.org/r/20181211142941.20500-1-vbabka@suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP fault 로 인한 로컬 노드 thrashing 을 해결하기 위한 패치의 RFC 입니다.  THP
fault 성공률을 낮추는 부작용도 있긴 하군요.  아직 테스트도 안된 첫번째 RFC
이니, 이대로 머지되진 않겠지 싶긴 합니다만 재밌네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-420-rc76&#34;&gt;Linux 4.20-rc76&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whv9u9aTEPoCz8h83JJbVK4fmHELJF=GG01ht9=1_MaCQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whv9u9aTEPoCz8h83JJbVK4fmHELJF=GG01ht9=1_MaCQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 버전의 릴리즈입니다&amp;hellip; 만, 이번엔 릴리즈 메일 제목에 오타가
있었군요.  전체적으로 일곱번째인만큼 변경사항이 적습니다.  릴리즈 하는 토발즈
입장에선 반가운 일이군요.  특히나 연휴가 다가오니까요.&lt;/p&gt;
&lt;p&gt;릴리즈 계획은 기존과 같이, 크리스마스 전에 4.20 버전을 릴리즈하고, 이후에 머지
윈도우를 가질텐데, 가급적이면 연휴 전에 미리미리 풀리퀘스트를 보내달라고
하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc6/</link>
      <pubDate>Wed, 05 Dec 2018 08:20:36 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-memory-model-03-updates-to-the-formal-memory-model&#34;&gt;[PATCH memory-model 0/3] Updates to the formal memory model&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181203230411.GA27476@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20181203230411.GA27476@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널 메모리 모델의 업데이트 입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;smp_mb__after_unlock_lock()&lt;/code&gt; 을 추가로 모델링했고, github 리트머스 테스트를
체크하기 위한 스크립트가 추가되었으며, &lt;code&gt;-j&lt;/code&gt; 옵션을 서포트 하게 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;tipcorercu-tracing-replace-synchronize_sched-and-call_rcu_sched&#34;&gt;[tip:core/rcu] tracing: Replace synchronize_sched() and call_rcu_sched()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/tip-7440172974e85b1828bdd84ac6b23b5bcad9c5eb@git.kernel.org&#34;&gt;https://lkml.kernel.org/r/tip-7440172974e85b1828bdd84ac6b23b5bcad9c5eb@git.kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronize_rcu()&lt;/code&gt; 가 이제는 RCU read-side 크리티컬 섹션 만이 아니라
preempt-disable 코드 영역도 기다리므로, &lt;code&gt;synchronize_sched()&lt;/code&gt; 를 대체할 수
있고, &lt;code&gt;call_rcu_sched()&lt;/code&gt; 도 &lt;code&gt;call_rcu()&lt;/code&gt; 로 대체될 수 있습니다.  이 패치는 이
대체를 진행하고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch--v8-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V8 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181207054122.27822-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20181207054122.27822-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그를 통해 여러번 공유한 THP 를 통째로 스왑아웃 / 스왑인 하는 패치입니다.
Daniel 에 의해 레포트된 버그 하나를 고쳐서 여덟번째 버전이 올라왔습니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420-rc6&#34;&gt;Linux 4.20-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wgHSX8x6mOB0xZibbg-xc3veqsQEnHZ1+3H2DbO5MU5Rw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/wgHSX8x6mOB0xZibbg-xc3veqsQEnHZ1+3H2DbO5MU5Rw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난 rc5 릴리즈는 평소와 달리 굉장히 규모가 컸기에 걱정이 있었죠.  이번
릴리즈에는 확연히 변경의 양이 줄어들었다고 합니다.  뭔가 다시 정상적으로 간다는
거죠.  토발즈는 어쨌건 4.20 릴리즈 전에 최소한 하나의 rc 릴리즈는 더 있을
거라고 하는군요.  하지만 여전히 크리스마스 휴일 시즌을 위해 크리스마스 전에
릴리즈를 마치고, 이후 일주일은 푹 쉴테니 그전에 풀리퀘스트도 준비해 두라고
하네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by 4.20-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc5/</link>
      <pubDate>Thu, 29 Nov 2018 08:14:01 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc5/</guid>
      <description>&lt;h2 id=&#34;patch-v12-0020-block-support-multi-page-bvec&#34;&gt;[PATCH V12 00/20] block: support multi-page bvec&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181126021720.19471-1-ming.lei@redhat.com&#34;&gt;https://lkml.kernel.org/r/20181126021720.19471-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct bio_bvec&lt;/code&gt; 하나가 물리적으로 연속적인 여러개의 페이지를 담을 수 있게
해서 block layer 의 효율성을 높이기 위한 시도입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-aio-convert-ioctx_table-to-xarray&#34;&gt;[PATCH] aio: Convert ioctx_table to XArray&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181128183531.5139-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20181128183531.5139-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;aio 쪽의 &lt;code&gt;ioctx_table&lt;/code&gt; 이라는 자료구조가 스펙터에 취약한 자료구조인데, 인덱스
오버플로 문제가 없는 XArray 로 교체하는 패치입니다.  정말 코드가
깔끔해지는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-04v4-drop-the-mmap_sem-when-doing-io-in-the-fault-path&#34;&gt;&lt;code&gt;[PATCH 0/4][V4] drop the mmap_sem when doing IO in the fault path&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181130195812.19536-1-josef@toxicpanda.com&#34;&gt;https://lkml.kernel.org/r/20181130195812.19536-1-josef@toxicpanda.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ps&lt;/code&gt; 등의 도구를 사용해 시스템 상황을 모니터링하는 커다란 어플리케이션을 사용
중인데, 이 과정에서 다른 &lt;code&gt;task&lt;/code&gt; 의 &lt;code&gt;mmap_sem&lt;/code&gt; 을 &lt;code&gt;down_read()&lt;/code&gt; 해야 하는 경우가
종종 생긴다는군요.  문제는 이 &lt;code&gt;mmap_sem&lt;/code&gt; 의 쓰기 권한을 얻어오는 과정이 사실상
mutex 와 동일하니 레이턴시가 크게 늘어날 때가 종종 생긴다고 합니다.  이 문제를
해결하기 위해 &lt;code&gt;retry&lt;/code&gt; 메커니즘을 적용하는 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-09-use-vm_insert_range&#34;&gt;[PATCH v2 0/9] Use vm_insert_range&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181202061707.GA3070@jordon-HP-15-Notebook-PC&#34;&gt;https://lkml.kernel.org/r/20181202061707.GA3070@jordon-HP-15-Notebook-PC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;드라이버가 자신의 커널 메모리를 사용자 vma 로 매핑하는 방법은
&lt;code&gt;vm_insert_page()&lt;/code&gt; 를 사용하는 방식이었고, 여러 페이지를 매핑하려면 이 함수를
루프를 돌면서 수행해야 했는데요, 이게 좀 귀찮으므로 아예 &lt;code&gt;vm_insert_range()&lt;/code&gt;
라는 함수를 추가한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420-rc5&#34;&gt;Linux 4.20-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wizcNrsoyCM1EXQqoswMCYsJaby2iAkZb9wBAzDEhvxNg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wizcNrsoyCM1EXQqoswMCYsJaby2iAkZb9wBAzDEhvxNg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;벌써 다섯번째 rc 릴리즈이므로 변경내용이 줄어들어야 할 타이밍이지만, 이상하게도
이번 릴리즈는 -rc1 을 제외하고는 가장 변경이 큰 릴리즈라는군요.  게다가 arch 쪽
변경사항이 꽤 많은데, 아마도 STIPB 쪽 성능 리그레션 때문인 것으로 보인다고
합니다.  아무튼 일반적인 모습은 아니다보니 릴리즈 일정이 변경될 가능성이
생겼는데요, 너무 미루면 연말연초 휴일에 머지 윈도우가 겹치게 되는데 토발즈는
휴일 동안 머지 윈도우 관리하기 싫고, 그렇다고 더 미루면 토발즈도 1월 후반에
여행 갈거고, 남들도 휴일에 머지 윈도우를 준비하기가 싫을 거라 고민이라
하는군요.&lt;/p&gt;
&lt;p&gt;결국 일단은 크리스마스 직전 쯤 4.20 을 릴리즈 하고, 남들도 머지 윈도우 준비를
그 전까지 마치는 걸 제안하고 있습니다.  물론, rc6 에서도 변경사항이 충분히
줄어들지 않는다면 릴리즈 일정은 더 늦춰질 수 있겠죠.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc4/</link>
      <pubDate>Mon, 26 Nov 2018 08:06:40 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc4/</guid>
      <description>&lt;h2 id=&#34;patch--v7-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V7 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181120085449.5542-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20181120085449.5542-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Transparent Huge Page 를 쪼개지 않고 swap out / swap in 함으로써 스왑 성능을
최적화 하는 패치의 일곱번째 버전입니다.  이 블로그에서도 소개한 바 있죠.  크게
바뀐 부분은 없지만 최신 버전에 맞춰 리베이스 되었고, Daniel 에 의해 발견된 주소
정렬 관련 문제를 해결했군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-05-fragmentation-avoidance-improvements-v5&#34;&gt;[PATCH 0/5] Fragmentation avoidance improvements v5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181123114528.28802-1-mgorman@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20181123114528.28802-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시스템이 충분히 오래 운영되거나 특정한 패턴의 워크로드가 동작하게 되면 시스템의
메모리는 fragment 되게 마련이어서, 장기적으로 물리적 연속 페이지 할당이
실패하게 됩니다.  이 패치셋은 메모리 분절화를 야기하는 워크로드 (이벤트)를
정의하고 그런 이벤트의 발생을 줄이는 내용을 담고 있습니다.&lt;/p&gt;
&lt;p&gt;최적화 방법은 다음과 같습니다.  먼저, lower id free list 가 사용 가능하면 high
order free list 를 쪼개기보다 그걸 먼저 사용합니다.  메모리 분절화 이벤트가
발생하면 임시적으로 워터마크를 높입니다.  kswapd 가 일어나서 적은양의 오래된
메모리를 리클레임하고, 이어서 kcompactd 가 일어나서 시스템 메모리 연속성을
복구시킵니다.  물론 이는 오버헤드를 추가합니다.  마지막으로, kswapd 가 진전을
일으킬 수 있도록 일부 movable 페이지 할당을 기다리게 합니다.  이 기다리는 시간
역시 오버헤드와 연관되므로 적절히 맞춰질 필요가 있겠죠.&lt;/p&gt;
&lt;p&gt;이 패치셋을 적용한 결과 94% 이상 메모리 분절화를 줄일 수 있었다고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;git-pull-xarray-updates&#34;&gt;[GIT PULL] XArray updates&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181124173209.GZ3065@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20181124173209.GZ3065@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XArray 는 작년 OSSummit 에서 처음 발표를 들은 후 주의 깊게 보고 있었는데 이번에
머지되었고 커널 서밋에서도 발표를 들었는데 매우 인상적이었습니다.  DAX 가
XArray 를 사용하도록 수정한 후 DAX 의 버그가 발견되었고, 그에 대한 수정을
포함한 수정사항들을 담은 풀 리퀘스트입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420-rc4&#34;&gt;Linux 4.20-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgdsXyCaLsFEpyUpAeRqVS69u=xo4rzEN+cS=xwz2gajg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgdsXyCaLsFEpyUpAeRqVS69u=xo4rzEN+cS=xwz2gajg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.x 의 마지막이 될 예정인 4.20을 향한 네번째 rc 버전 릴리즈입니다.  변경의 60
퍼센트가 드라이버고, 나머진 네트워킹, 파일시스템쪽 수정과 arch, 문서화
업데이트고 xarray 쪽 수정도 있었군요.  평소와 다를바 없어서 평이한 릴리즈라 할
수 있지만, STIBP 수정이라던지 mm 쪽 수정에 대한 논의가 안끝났다던지 하는 부분은
남아있다는군요.&lt;/p&gt;
&lt;p&gt;한가지 지난 릴리즈 때 이야기 할 것을 빼먹은 것도 이야기 하는데, 풀 리퀘스트에
대한 응답 메일을 Konstantin 이 자동화 했기 때문에 더이상 토발즈 자신이 하나하나
답장을 보내지 않는다는 겁니다.  그리고 이 자동화의 구성상 LKML 의 &lt;code&gt;linux-*&lt;/code&gt;
그룹을 cc 하지 않으면 ack 을 주지 않는데, 그걸로 인해 혼동이 있을 수 있었겠다고
하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc3/</link>
      <pubDate>Mon, 19 Nov 2018 16:53:04 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-420-rc3&#34;&gt;Linux 4.20-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiZmPvR64hDy-pcVJqcxoAwMRd4GrRhRjK04Mhng4nL4g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiZmPvR64hDy-pcVJqcxoAwMRd4GrRhRjK04Mhng4nL4g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리누스 토발즈의 개인적 여행이 있었다는 점을 제외하고는 이상할 것 없는
한주였습니다만, 이번 릴리즈의 변경 사항은 rc3 치고는 상당히 적었다고 하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc2/</link>
      <pubDate>Mon, 12 Nov 2018 08:30:21 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-05-fragmentation-avoidance-improvements-v2&#34;&gt;[PATCH 0/5] Fragmentation avoidance improvements v2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181107183822.15567-1-mgorman@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20181107183822.15567-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;장시간 운영되는 시스템은 결국 메모리가 단편화 (fragmentation) 되게 되어
있습니다.  페이징을 사용하면 단일 페이지 단위 할당은 문제가 없지만, 물리적으로
연속적인 페이지를 할당받기가 어려워지죠.  Mel Gorman 의 이 패치는 이런 메모리
분절화를 좀 더 잘 막을 수 있는 방법을 포함하고 있습니다.&lt;/p&gt;
&lt;p&gt;첫번째 패치는 단일 페이지 또는 적은 물리적 연속 페이지들의 할당 시에 불필요하게
higher order free page zone 을 사용하지 않게 하고, 두번째와 세번째 패치는
kswapd 와 kcompactd 를 사용한 defragmentation 을 좀 더 적극적으로 하게 합니다.
네번째 패치는 movable allocation request 시에 kswapd 를 또 깨우고, kswapd 가
일을 마칠 때까지 멈춰서 기다려 줍니다.
마지막으로 다섯번째 패치는 분절화가 발생해야만 하는 경우, kcompactd 가 처리할
블록들로 해당 분절된 영역을 마크해 둡니다.&lt;/p&gt;
&lt;p&gt;물론 분절화를 막는 대신 오버헤드를 가져올 수 있겠고, Mel 은 이 기능들을 tuning
하거나 꺼버릴 수 있게 했군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-04-fragmentation-avoidance-improvements-v3&#34;&gt;[PATCH 0/4] Fragmentation avoidance improvements v3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181108091218.32715-1-mgorman@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20181108091218.32715-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mel 의 분절화 방지 패치셋은 오버헤드를 가질 수밖에 없었죠.  결국 얼마 되지 않아
세번째 버전의 패치셋[1]을 내놓았는데, 여기선 다섯번째 패치를 걍 없애버렸고,
네번째 패치도 그 오버헤드가 덜하게끔 만들었습니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-mm-thp-implement-thp-reservations-for-anonymous-memory&#34;&gt;[RFC PATCH] mm: thp: implement THP reservations for anonymous memory&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1541746138-6706-1-git-send-email-anthony.yznaga@oracle.com&#34;&gt;https://lkml.kernel.org/r/1541746138-6706-1-git-send-email-anthony.yznaga@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Transparent huge page (THP) 가 켜져 있는 경우, promotion 이 꽤나 급하게
이루어지기 때문에 huge page 를 할당받고는 정작 그 영역을 모두 접근하지 않는
경우엔 메모리 소모가 큽니다.  기존에 이 문제를 해결하기 위한 패치가 있었는데,
그에 대해 Mel Gorman 의 피드백이 있었고, 이 패치는 그 피드백을 받아들여 새로
작성된 패치셋입니다.&lt;/p&gt;
&lt;p&gt;Page fault 가 날 경우 huge page 를 할당할 수 있는 양의 페이지를 할당받되 페이지
한개만 map 해두고 나머지는 reserve 를 해두고, 이후 주변 영역에 fault 가 날
때마다 나머지 페이지들을 계속 map 해주다가 충분히 많은 영역이 fault 났을 경우에
huge page 로 promote 를 해주고, 그 전에 memory pressure 가 발생하면 reserve
해둔 페이지들을 reclaim 하는 형태입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-020-documentation-updates-for-v421v50&#34;&gt;[PATCH tip/core/rcu 0/20] Documentation updates for v4.21/v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181111195619.GA6958@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20181111195619.GA6958@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 문서 업데이트 패치셋입니다.  생각해 보면 리눅스 커널만큼 문서화 잘 된
프로젝트도 드물죠.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-08-automate-initrd-generation-for-v421v50&#34;&gt;[PATCH tip/core/rcu 0/8] Automate initrd generation for v4.21/v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181111200127.GA9511@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20181111200127.GA9511@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 테스트 프레임웍인 rcutorture 는 가상머신 환경을 사용하는데, 이를 위한
initrd 생성을 자동화 하는 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-v420-rc2&#34;&gt;Linux v4.20-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/R7SW0SuwOMMMyRgTFGA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/R7SW0SuwOMMMyRgTFGA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;토발즈가 여행 중이란 걸 제외하고는 별 특이사항 없는 두번째 rc 버전
릴리즈입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the kernel summit</title>
      <link>https://sjp38.github.io/ko/post/ksummit2018_talk/</link>
      <pubDate>Thu, 08 Nov 2018 06:11:48 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/ksummit2018_talk/</guid>
      <description>&lt;p&gt;지난 토요일, Theodore Ts&amp;rsquo;o 로부터 올해 Linux Plumbers Conference 의 한 트랙으로
열리는 커널 서밋에서 GCMA 발표를 해줄 수 있겠냐는 제의를 받았고 물론
그러겠노라고 했습니다.  발표 일정의 [첫번째 드래프트][1]가 올라왔군요.  화요일
아침에 발표하게 됐습니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2018-November/006238.html&#34;&gt;https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2018-November/006238.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKMM Setup and Usage</title>
      <link>https://sjp38.github.io/ko/post/lkmm-install/</link>
      <pubDate>Thu, 08 Nov 2018 04:30:42 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkmm-install/</guid>
      <description>&lt;p&gt;리눅스 커널은 Formalised and executable memory consistent model 을 제공합니다.
줄여서 linux kernel memory model (LKMM) 이라고 하죠.  이 글은 4.19 버전을
기준으로 LKMM 을 실제로 수행해 보기 위한 환경 셋업 과정과 간단한 실행 방법을
정리해 봅니다.  글 작성을 위한 테스트는 Ubuntu 16.04 서버가 설치된 가상머신에서
진행되었습니다.&lt;/p&gt;
&lt;h1 id=&#34;herd7-install&#34;&gt;herd7 install&lt;/h1&gt;
&lt;p&gt;LKMM 은 버전 7.49 의 &amp;ldquo;herd7&amp;rdquo; 과 &amp;ldquo;klitmus7&amp;rdquo; 을 필요로 합니다.  하지만 herd7 은
또 Ocaml 을 위한 패키지 매니저인 OPAM 을 설치할 것을 필요로 하죠.  우분투에선
패키지 시스템이 OPAM 을 지원하므로 아래와 같이 쉽게 설치할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt install opam
$ opam init
$ sudo opam update
$ sudo opam upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;두번째 커맨드 수행 중 다음과 같은 질문이 나오는데, 디폴트 선택을 주기 위해 그냥
엔터를 칩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Do you want OPAM to modify ~/.profile and ~/.ocamlinit?
(default is &#39;no&#39;, use &#39;f&#39; to name a file other than ~/.profile)
    [N/y/f]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;또한 &lt;code&gt;update&lt;/code&gt; 와 &lt;code&gt;upgrade&lt;/code&gt; 명령 시에 root 권한으로 이 커맨드를 수행하는 걸
권장하지 않는다고 하지만 정작 &lt;code&gt;sudo&lt;/code&gt; 없이 하면 권한 없어서 실패합니다.&lt;/p&gt;
&lt;p&gt;이제 다음 명령을 통해 herdtools 의 빌드와 설치를 진행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/herd/herdtools7 &amp;amp;&amp;amp; cd herdtools7
$ git checkout 7.49
$ make all
$ make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;빌드에 약 3분 10여초가 소요됐습니다.  설치가 잘 되었는지 아래와 같이 확인해
봅니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ herd7 -version
7.49, Rev: 93dcbdd89086d5f3e981b280d437309fdeb8b427
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;lkmm-download&#34;&gt;LKMM Download&lt;/h1&gt;
&lt;p&gt;LKMM 은 리눅스 소스 트리의 &lt;code&gt;tools/memory-model/&lt;/code&gt; 디렉토리에 있습니다.
&lt;code&gt;https://kernel.org&lt;/code&gt; 에서 다운받거나 해서 사용하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls ~/linux/tools/memory-model/
Documentation      linux-kernel.cat  linux-kernel.def  lock.cat  scripts
linux-kernel.bell  linux-kernel.cfg  litmus-tests      README
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;herd7-based-litmus-tests-execution&#34;&gt;Herd7 Based Litmus Tests Execution&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ herd7 -conf linux-kernel.cfg litmus-tests/SB+fencembonceonces.litmus
Test SB+fencembonceonces Allowed
States 3
0:r0=0; 1:r0=1;
0:r0=1; 1:r0=0;
0:r0=1; 1:r0=1;
No
Witnesses
Positive: 0 Negative: 3
Condition exists (0:r0=0 /\ 1:r0=0)
Observation SB+fencembonceonces Never 0 3
Time SB+fencembonceonces 0.01
Hash=d66d99523e2cac6b06e66f4c995ebb48
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;klistmus7-based-litmus-tests-execution&#34;&gt;Klistmus7 Based Litmus Tests Execution&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir klitmus_test
$ klitmus7 -o klitmus_test/ litmus-tests/SB+fencembonceonces.litmus
$ cd klitmus_test/
$ ls
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;$ make
$ sudo sh run.sh
$ sudo sh ./run.sh
[sudo] password for sjpark:
Thu Nov  8 04:55:44 KST 2018
Compilation command: klitmus7 -o klitmus_test/ litmus-tests/SB+fencembonceonces.litmus
OPT=
uname -r=4.19.0

Test SB+fencembonceonces Allowed
Histogram (3 states)
16580117:&amp;gt;0:r0=1; 1:r0=0;
16402936:&amp;gt;0:r0=0; 1:r0=1;
3016947 :&amp;gt;0:r0=1; 1:r0=1;
No

Witnesses
Positive: 0, Negative: 36000000
Condition exists (0:r0=0 /\ 1:r0=0) is NOT validated
Hash=d66d99523e2cac6b06e66f4c995ebb48
Observation SB+fencembonceonces Never 0 36000000
Time SB+fencembonceonces 1.40

Thu Nov  8 04:55:45 KST 2018
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc1/</link>
      <pubDate>Wed, 07 Nov 2018 14:43:56 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.20-rc1/</guid>
      <description>&lt;p&gt;리눅스 4.19 버전 릴리즈 후부터 4.20-rc1 버전의 릴리즈까지 LKML 에 오간 메일 중
흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v4-0013-ktask-multithread-cpu-intensive-kernel-work&#34;&gt;[RFC PATCH v4 00/13] ktask: multithread CPU-intensive kernel work&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181105165558.11698-1-daniel.m.jordan@oracle.com&#34;&gt;https://lkml.kernel.org/r/20181105165558.11698-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CPU intensive 한 커널의 일을 여러 work queue 를 이용해 병렬화 시키기 위한
새로운 프레임웍, ktask 구현 및 적용 패치입니다.  이 프레임웍을 이용해 병렬화
시킬 일은 여러가지가 있을텐데, 이 패치는 ktask 프레임웍의 구현과 함께 VFIO
페이지 pinning, 부팅 시점에서의 &lt;code&gt;struct page&lt;/code&gt; 초기화, &lt;code&gt;gigantic page&lt;/code&gt; 의
초기화, 그리고 &lt;code&gt;HugeTLB&lt;/code&gt; 페이지의 할당에 ktask 를 적용하고 있습니다.&lt;/p&gt;
&lt;p&gt;예전에도 올라온 패치인데 이번에 Linux Plumbers Conference 에서 발표할
예정이기에 기존 피드백을 반영한 버전을 올렸군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-09-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;[PATCH 0/9] Allow persistent memory to be used like normal RAM&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181022201317.8558C1D8@viggo.jf.intel.com&#34;&gt;https://lkml.kernel.org/r/20181022201317.8558C1D8@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;기존의 메인 메모리로 쓰이는 DRAM 과 달리 파워가 꺼져도 내용이 날아가지 않는
메모리를 Non-volatile memory 또는 persistent memory 라 하죠.  최근 들어서는
정말 상용으로도 나오고 있는데, 현재로썬 이 pmem 을 쓰려면 어플리케이션을 고쳐야
합니다.&lt;/p&gt;
&lt;p&gt;이 패치는 그러지 않고도 일반 RAM 처럼 pmem 을 사용할 수 있도록 하는 pmem 용
드라이버를 구현했습니다.&lt;/p&gt;
&lt;h2 id=&#34;git-pull-xarray-for-420&#34;&gt;[GIT PULL] XArray for 4.20&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181023200825.GA25444@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20181023200825.GA25444@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 여러번 소개한, XArray 의 4.20 버전을 향한 pull request 입니다.
4.19 때도 시도했지만 들어가지 못했죠.&lt;/p&gt;
&lt;p&gt;이번엔 일단 토발즈에 의해 pull 되었습니다.  그리고 토발즈도 XArray 의
인터페이스 덕에 코드가 한결 간결하고 깔끔해졌음을 이야기 하네요.  특히, dax 쪽
수정사항과 conflict 이 있었는데 이는 dax 쪽의 버그 수정에 의한 것으로, XArray
인터페이스를 쓰면 애초에 그 버그가 발생도 안한다고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420-rc1&#34;&gt;Linux 4.20-rc1&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CAHk-=whDiwASMgw8Q7TNA2MJhf3s=ouK4+_3ioqmobs-yagnkQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;오랫만에 토발즈가 하는 릴리즈입니다.  3.19 다음 4.0 버전이 릴리즈 되었으니 이번
버전은 5.0 이 될 것인지, 4.20 이 될 것인지 흥미진진한 릴리즈였는데요.
결론적으로 4.20 이 되었습니다.  이제 버전을 셀 손가락도 발가락도 남지
않았으므로 다음 버전은 5.0 이 될 거라고 하는군요.&lt;/p&gt;
&lt;p&gt;꽤 많은 변경 사항이 있던 머지 윈도우였지만 그렇다고 기록적인 수준은 아닙니다.&lt;/p&gt;
&lt;p&gt;한편 2주일로 예정되는 머지 윈도우에서 첫번째 주에는 일반적인 풀리퀘스트를 받고,
좀 시간을 두고 들여다봐야 하겠다 싶은 패치들은 두번째 주까지 미뤄뒀다 천천히
보면서 머지하는게 토발즈의 작업 습관이고 다른 메인테이너들도 이 습관을 알고
암묵적으로 지켜왔던 모양인데, 이번엔 두번째 주 수요일에 새로운 풀 리퀘스트가
들어와 토발즈가 조금 불편했던 모양입니다.&lt;/p&gt;
&lt;p&gt;이걸 명시적인 규칙으로 만들어야 할지도 모르겠다 싶기 시작했는데, 빈번하게 있는
일도 아니므로 아직은 그래야 할 필요성이 있을지도 모르겠다 하는 수준의
이야기군요.&lt;/p&gt;
&lt;p&gt;그리고 이번 머지 윈도우에서는 Greg 이 그랬던 것처럼 토발즈도 풀리퀘스트에 ack
메일을 보냈었죠.  이런 작업 방식에 대해서 고민을 하는 이야기도 있었구요.
하지만 아무래도 몇개는 빼먹은 것 같다고 하는군요.  이런 경우 결론은 자동화.
다음 머지 윈도우까지는 이 ack 메일을 자동화 되길 바란다고 하네요.  물론,
토발즈의 바람대로 자동화가 잘 마무리 되지 않으면 운좋게도 토발즈로부터의 ack
메일을 받을 수 있겠습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.19/</link>
      <pubDate>Mon, 22 Oct 2018 17:45:08 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.19/</guid>
      <description>&lt;h2 id=&#34;linux-419&#34;&gt;Linux 4.19&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181022073224.GA5658@kroah.com&#34;&gt;https://lkml.kernel.org/r/20181022073224.GA5658@kroah.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;드디어 9 주간의 안정화를 거쳐 4.19 버전이 릴리즈 되었습니다.  역시 토발즈가
쉬고 있는 관계로 Greg KroahHartman 이 릴리즈 했습니다.  지난 네번의 릴리즈
가운데 가장 큰 릴리즈군요.  그리고 이 버전은 &amp;ldquo;Long Tern&amp;rdquo; 커널 중 하나가 될
예정입니다.&lt;/p&gt;
&lt;p&gt;이번 릴리즈 메일은 토발즈가 잠시 쉬겠다고 했던 메일을 연상케 할정도로 내용이
긴데요, 꽤 많은 부분은 이번 버전 개발 과정에서 이야기 되었던, 새로운 커뮤니티
참여자들과의 관계와 태도에 대한 내용입니다.  Greg 이 매년 발표하고 있는 커널
커뮤니티의 작업 방식 이야기를 예로 들며 설명하네요.  관련해서는 다음주 영국에서
열리는 Maintainers Summit 에서도 좀 더 이야기 할 생각인가 봅니다.&lt;/p&gt;
&lt;p&gt;그리고, 릴리즈 메일의 말미에서 이렇게 이야기 하며 릴리즈 메일을 끝맺는군요:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;And with that, Linus, I&#39;m handing the kernel tree back to you.  You can
have the joy of dealing with the merge window :)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;토발즈가 돌아오려나요?  아니면 새로운 대리인이?&lt;/p&gt;
&lt;h2 id=&#34;git-pull-ack-emails&#34;&gt;Git pull ack emails..&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjS6cjjP+fkZWzzrdZ_fZ1F=PrAGcBc57vKCpNyoD73Vw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjS6cjjP+fkZWzzrdZ_fZ1F=PrAGcBc57vKCpNyoD73Vw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 4.19 릴리즈와 함께 Greg 이 토발즈의 대리인을 그만두기로 했다고 했지만,
그에 대한 토발즈의 공식적 답변은 없었습니다.  때문에 토발즈가 돌아오는건지,
또는 Greg 이 아닌 또다른 사람이 릴리즈 관리를 할지 애매했는데, 토발즈가
돌아왔습니다.&lt;/p&gt;
&lt;p&gt;이 메일을 이렇게 시작하는군요:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So I&amp;rsquo;ve obviously started pulling stuff for the merge window,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;마침 Maintainers Summit 이 있었으니, 거의 Summit 직후 돌아왔다고 볼 수 있을 것
같네요.&lt;/p&gt;
&lt;p&gt;이 메일에선 이와 함께 Greg 이 pull request 마다 꼬박꼬박 응답을 보내줬던 걸
지속할지 말지에 대한 이야기를 하고 있습니다.  토발즈는 풀 리퀘스트를 받으면
일단 빌드 테스트를 진행하고, 그동안 다른 풀 리퀘스트를 보고 그 빌드 테스트도
병렬로 진행하는 파이프라인 형태의 작업 형태를 가지고 있는데, Greg 처럼 하나하나
순차적으로 응답하려면 좀 애매하기 때문입니다.  일단은 응답 보내보고, 그게 정말
중요한지 판단해 보겠다는군요.&lt;/p&gt;
&lt;p&gt;아무튼, 잘 돌아왔어요, 리누스!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc7/</link>
      <pubDate>Mon, 08 Oct 2018 07:54:09 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-419-rc7&#34;&gt;Linux 4.19-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181007154529.GA4493@kroah.com&#34;&gt;https://lkml.kernel.org/r/20181007154529.GA4493@kroah.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;토발즈 없이 진행되는 4.19를 위한 일곱번째 rc 릴리즈입니다.  이번에도 그렉이
대신 하는군요.  이번 릴리즈는 후반부임에도 rc6 보다 조금 더 커졌습니다.  하지만
그렇게까지 큰 차이는 아니라고 하는군요.&lt;/p&gt;
&lt;p&gt;일반적이라면 다음 릴리즈가 4.19 정식 릴리즈일텐데, 10월에 컨퍼런스가 많이
있다보니 rc 릴리즈를 한번 더 할 생각이라는군요.  간만에 rc8 을 보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch--v6-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V6 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181010071924.18767-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20181010071924.18767-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 를 한방에 swap out / swap in 하는 Huang Ying 의 패치, 여섯번째 버전입니다.
기존 버전 대비 달라진 점은 크지 않군요.  좀 더 최신 mmotm/master 위로 rebase 한
정도입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc6/</link>
      <pubDate>Mon, 01 Oct 2018 12:20:27 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-419-rc6&#34;&gt;Linux 4.19-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180930150308.GA5010@kroah.com&#34;&gt;https://lkml.kernel.org/r/20180930150308.GA5010@kroah.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번주도 Greg 에 의해 여섯번째 rc 버전이 릴리즈 되었습니다.  평소 일정대로면
2주일 후 4.19 정식 버전이 릴리즈 될텐데, 아마도 그때까지도 Greg 이 릴리즈 하지
않을까 싶기도 하군요.
전체적으로 특이사항은 없고 Greg 의 시스템에서는 잘 동작하고 있으며 별다른
이슈를 보고받지도 못했다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc5/</link>
      <pubDate>Mon, 24 Sep 2018 10:10:40 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-419-rc5&#34;&gt;Linux 4.19-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180923175547.GA4462@kroah.com&#34;&gt;https://lkml.kernel.org/r/20180923175547.GA4462@kroah.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난주 토발즈가 휴식을 선언한 이유로 한동안 릴리즈는 Greg 이 맡게 되었죠.  이번
릴리즈는 그래서 Greg 이 합니다.&lt;/p&gt;
&lt;p&gt;사회적으로야 이런저런 일이 많았지만 (토발즈의 휴가, Code of Conduct 머지에
관련해 갑론을박이 많군요.) 기술적으로는 별 일 없었던 한주라 평가되는군요.&lt;/p&gt;
&lt;p&gt;사소하지만 재밌는 건 Greg 의 자기 서명.
&lt;code&gt;greg &amp;quot;keeping the seat warm for a few weeks&amp;quot; k-h&lt;/code&gt; 라고 하는군요.
토발즈가 휴가 가있는 동안 의자를 뎁혀 두는 역할이라는 겸손함이 눈에 띄네요.&lt;/p&gt;
&lt;h2 id=&#34;patch--v5-resend-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V5 RESEND 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180925071348.31458-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180925071348.31458-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 의 Swap in/out 을 regular page 로 쪼개지 않고 한방에 하는 패치의 최신
버전입니다&amp;hellip; 만, 기존 대비 버전업이 되진 않았고 리뷰를 요청하기 위해 다시 한번
보냈군요.  그런데 아직 별다른 리뷰가 없네요&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc4/</link>
      <pubDate>Mon, 17 Sep 2018 08:03:05 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-419-rc4-released-an-apology-and-a-maintainership-note&#34;&gt;Linux 4.19-rc4 released, an apology, and a maintainership note&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFy+Hv9O5citAawS+mVZO+ywCKd9NQ2wxUmGsz9ZJzqgJQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFy+Hv9O5citAawS+mVZO+ywCKd9NQ2wxUmGsz9ZJzqgJQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;한국시간 새벽 네시 좀 넘어 이 메일을 받았습니다.  평범한 릴리즈 메일이겠거니
했는데 제목이 뭔가 심상치 않군요.&lt;/p&gt;
&lt;p&gt;일단 4.19를 위한 네번째 release candidate 릴리즈가 되었습니다.  약 3주 후 정식 4.19 버전이 릴리즈 되겠군요.  하지만 이 메일은 그보다 많은 내용을 담고 있습니다.&lt;/p&gt;
&lt;p&gt;자유분방하고 형식에 구애되지 않는 해커 문화에 기원을 두고 있는 리눅스
커뮤니티는 조금 거친 언어 문화로 유명했습니다.  예를 들어 이상한 코드를 보내면
리누스 토발즈와 커뮤니티의 일부 사람들이 이 코드를 꾸짖을 수 있는데 그 과정에서
욕설도 있을 수 있다는 거죠.  어느새 5년이 넘게 흐른 사건이지만 토발즈는
공식석상에서 Nvidia 에 가운데 손가락을 펴서 보여주기도 했죠.  이로 인해 마음에
상처를 받았다는 사람도 꽤 되고, 7년간 리눅스에 패치를 올렸던 Sarah Sharp 라는
인텔의 프로그래머는 이를 이유로 들어 결국 리눅스 커뮤니티에서 빠지기로 해서[1]
한때 많은 논란이 있기도 했습니다.  당시 토발즈는 욕설을 멈출 생각이 없다고
강경하게 맞서기도 했죠[2].&lt;/p&gt;
&lt;p&gt;그랬던 토발즈가 생각이 바뀌었다고 합니다.  올해 커널 메인테이너 서밋은 Linux
Plumbers Conference 와 함께 열릴 예정이었는데 토발즈가 그걸 깜박하고 가족
휴가를 잡는 바람에 토론이 있었고, 이 토론 과정에서 토발즈는 자신의 행위가 커널
개발에 정말로 악영향을 끼치고 있다고 느낀 것 같습니다.  이로 인해 토발즈는 이
메일을 통해 자신의 행위가 잘못되었음을 인정하고 그로 인해 상처 받은 사람들에게
공식적으로 사과를 하고 있습니다.  또한 앞으로 그런 행위를 반복하지 않기 위해
커널 개발에서 잠시 손을 떼고 거울 속의 자신을 바라보며 더 낫게 행동할 수 있도록
하는 시간을 갖겠다고 하는군요.&lt;/p&gt;
&lt;p&gt;리누스 토발즈가 커널 개발에서 손을 떼는건 과거 git 개발을 위해 손을 뗐던
사건[3] 후 처음입니다.  이 사이의 릴리즈 작업은 Greg Kroah-Hartman 에게
부탁했다고 하니 곧바로 전체 개발 작업이 멈추진 않겠습니다.&lt;/p&gt;
&lt;p&gt;이 휴식 시간이 아주 길지는 않을 거고, 토발즈 자신은 너무 지쳐 더이상 리눅스
커널 개발에 손을 데고 싶지 않다는 의도가 아니라고 합니다.  이건 얼마전 너무
지쳤다며 자비로운 종신 독재자 직을 그만둔 귀도 반 로썸의 예[4]와 비교되기도
하는군요, 토발즈도 이를 조금 의식한 거 아닐까 싶습니다.  토발즈는 자신은 여전히
리눅스 커널 개발을 하고 싶고, 잘하고 싶기 때문에 이 선택을 한 것 뿐이며, 어쩌면
단순히 욕설을 감지해 욕설이 포함된 메일은 자동으로 보내지 않는 메일
클라이언트를 개발하고 복귀하는 간단한 일이 될수도 있을 거라고 합니다.&lt;/p&gt;
&lt;p&gt;개인적인 감상은, 글쎄요.  조금 반갑기도 하고 조금 아쉽기도 합니다.  커널
커뮤니티가 거칠고 모욕적인건 사실이지만 어느정도의 긴장감은 필요하다고
생각하기도 했고, 어떤 면에선 더욱 자유분방한 그 분위기를 저는 좋아했던 것도
같아서일 겁니다.  특히 AOSP 와 같이 악플은 커녕 무플이 심한 프로젝트에 참여했던
경험이 있는 저로썬 무플보단 악플이 낫다는 주의를 가졌던 것도 한 이유겠죠.
분명한 건 이 선언은 리눅스 커뮤니티의 외연 확장을 크게 도울 것 같습니다.  그게
마냥 좋기만 한 일일지, 윤리에 대한 자기검열이 커뮤니티의 토론 열기를 식히지는
않을지 걱정되기도 하지만요.  그리고, 이 선언의 최종 결과가 어떨지를 떠나,
그정도 위치에 있고 과거에 뱉어놓은 말들이 많은 리누스 토발즈가 이렇게 깔끔하게
사과를 하는 것도 대단한 멘탈이라 생각됩니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://sarah.thesharps.us/2013/07/15/no-more-verbal-abuse/&#34;&gt;http://sarah.thesharps.us/2013/07/15/no-more-verbal-abuse/&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://arstechnica.com/information-technology/2013/07/linus-torvalds-defends-his-right-to-shame-linux-kernel-developers/&#34;&gt;https://arstechnica.com/information-technology/2013/07/linus-torvalds-defends-his-right-to-shame-linux-kernel-developers/&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://sjp38.github.io/post/git_origin_story_ko/&#34;&gt;https://sjp38.github.io/post/git_origin_story_ko/&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;https://www.i-programmer.info/news/216-python/11967-guido-van-rossum-quits-as-python-bdfl.html&#34;&gt;https://www.i-programmer.info/news/216-python/11967-guido-van-rossum-quits-as-python-bdfl.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc3/</link>
      <pubDate>Tue, 11 Sep 2018 06:01:49 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-419-rc3&#34;&gt;Linux 4.19-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwSxCt0aKkTxcBstthYXqJ5LtxRbO-CDyqgNwU94Ldq+w@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwSxCt0aKkTxcBstthYXqJ5LtxRbO-CDyqgNwU94Ldq+w@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;세번째 rc 릴리즈입니다.  어느새 이번 안정화 기간도 중반을 향하는군요.  시간 참
빠릅니다.  전체적으로 평범한 릴리즈입니다.  딱히 언급할 거리가 없군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v2-08-lru_lock-scalability-and-smp-list-functions&#34;&gt;[RFC PATCH v2 0/8] lru_lock scalability and SMP list functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180911004240.4758-1-daniel.m.jordan@oracle.com&#34;&gt;https://lkml.kernel.org/r/20180911004240.4758-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해 LSF/MM 서밋에서도 이야기되었던, &lt;code&gt;lru_lock&lt;/code&gt; 의 확장성을 개선하기 위한
노력의 정리입니다.  LRU 리스트에 여러 쓰레드가 실제 데이터를 겹쳐 쓰지 않는다면
동시에 접근할 수 있는 새로운 오퍼레이션 세개 (&lt;code&gt;smp_list_del()&lt;/code&gt;,
&lt;code&gt;smp_list_splice()&lt;/code&gt;, &lt;code&gt;smp_list_add()&lt;/code&gt;)을 추가했구요.  두번째로, &lt;code&gt;lru_lock&lt;/code&gt; 을
&lt;code&gt;spinlock&lt;/code&gt; 에서 &lt;code&gt;rwlock&lt;/code&gt; 으로 교체했군요.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;will-it-scale/page_fault1&lt;/code&gt; 이라는 마이크로 벤치마크를 사용해서 성능을
비교했는데, 44 코어 시스템에서 최대 73.8% 더 초당 페이지 폴트 처리량을 늘릴 수
있었다고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-09-improve-zone-lock-scalability-using-daniel-jordans-list-work&#34;&gt;[RFC PATCH 0/9] Improve zone lock scalability using Daniel Jordan&amp;rsquo;s list work&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180911053616.6894-1-aaron.lu@intel.com&#34;&gt;https://lkml.kernel.org/r/20180911053616.6894-1-aaron.lu@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;바로 앞에서 설명한, 여러 쓰레드가 동시에 리스트에 접근할 수 있도록 새로
만들어진 메커니즘은 &lt;code&gt;zone lock&lt;/code&gt; 에도 도움이 될 수 있다고 LSF/MM 에서 여럿이
생각했다고 합니다.  이 패치셋은 실제로 이 기능들을 이용해 &lt;code&gt;zone lock&lt;/code&gt; 의
확장성을 개선했습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch--v5-resend-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V5 RESEND 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180912004414.22583-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180912004414.22583-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 를 덩어리째 스왑아웃 / 스왑인 하기 위한 패치, 다섯번째 버전입니다.
생각보다 쉽게 머지되지 못하고 있군요.  리뷰가 많지 않은 것도 한 이유 아닐까
싶습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Kernel Build</title>
      <link>https://sjp38.github.io/ko/post/linux-kernel-build/</link>
      <pubDate>Fri, 07 Sep 2018 16:00:23 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/linux-kernel-build/</guid>
      <description>&lt;p&gt;제가 새 기계에서 리눅스 커널 빌드 환경을 셋업하고 실제 빌드, 설치하는 과정을
정리해 봅니다.  글 작성 과정에서 실제 커맨드를 수행한 환경은 Ubuntu 16.04.3
Server OS 를 설치한 &lt;code&gt;x86_64&lt;/code&gt; 가상머신입니다.&lt;/p&gt;
&lt;h1 id=&#34;install-dependent-packages&#34;&gt;Install Dependent Packages&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt install build-essential libncurses5-dev libssl-dev bc bison flex \
		libelf-dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;커널을 빌드하려면 컴파일러와 라이브러리 등이 필요하겠죠.  위 커맨드는
우분투에서 커널 빌드에 필요한 패키지들을 깔아줍니다.  커널 트리의
&lt;code&gt;Documentation/process/changes.rst&lt;/code&gt; 에도 커널 빌드에 필요한 패키지들이 나열되어
있으므로, 다른 환경이라면 이를 참고해 필요한 패키지를 설치합시다.&lt;/p&gt;
&lt;p&gt;페도라라면 아래와 같이 패키지를 깔면 됩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo dnf install ncurses-devel bison-devel bison flex-devel flex \
		elfutils-libelf-devel openssl-devel
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;fetch-linux-kernel-source-code&#34;&gt;Fetch Linux Kernel Source Code&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;빌드를 하려면 소스코드를 가져와야죠.  위 커맨드를 통해 토발즈의 리눅스
소스코드를 가져올 수 있습니다.  네트워크를 통해 가져오는데, 소스코드는 물론이고
개발 이력 정보를 모두 담고 있으므로 많은 데이터를 가져와야해 시간이 상당히
걸립니다.  이 글을 쓰는 2018년 9월 초 기준, 버전정보만 약 1.2 GiB 군요.&lt;/p&gt;
&lt;p&gt;토발즈는 github 에 [미러] (&lt;a href=&#34;https://github.com/torvalds/linux&#34;&gt;https://github.com/torvalds/linux&lt;/a&gt;) 를 두고 있으므로,
여길 이용하는 것도 생각해 볼 수 있고, 굳이 버전 정보는 필요하지 않다면
[&lt;code&gt;kernel.org&lt;/code&gt;] (&lt;a href=&#34;https://kernel.org&#34;&gt;https://kernel.org&lt;/a&gt;) 에서 tarball 로 소스코드만 받는것도 한
방법입니다.&lt;/p&gt;
&lt;p&gt;저는 아예 &lt;code&gt;.git&lt;/code&gt; 디렉토리를 압축해서 별도 저장소에
보관하기도 합니다.&lt;/p&gt;
&lt;h1 id=&#34;make-configuration-file&#34;&gt;Make Configuration File&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ cd linux
$ cp /boot/config-$(uname -r) ./.config
$ make menuconfig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;리눅스 빌드 설정 파일을 만들어야 합니다.  앞의 커맨드를 통해 배포판에서 제공한
커널을 빌드하는데 사용된 설정 파일을 기반으로 gui 환경에서 필요한 설정을
추가/제거 할 수 있습니다.  별달리 변경할 게 없다면 그냥 저장하고 나오면 됩니다.&lt;/p&gt;
&lt;p&gt;저는 빌드에 많은 시간이 걸리지 않고 저장 공간이 큰 시스템에서는 이 방법을
사용하고, 작은 가상머신 등의 환경에서는 &lt;code&gt;localmodconfig&lt;/code&gt; 빌드 타겟을 사용해
가벼운 설정 파일을 만드는 편입니다.&lt;/p&gt;
&lt;h2 id=&#34;seperated-build-directory&#34;&gt;Seperated Build Directory&lt;/h2&gt;
&lt;p&gt;이렇게 빌드를 하면 컴파일된 파일들이 소스코드와 같은 디렉토리에 위치하게
되는데, &lt;code&gt;grep&lt;/code&gt; 등을 할때 성가시고, 실수로 git 에 이렇게 만들어진 파일들을
추가하는 실수도 흔합니다.  리눅스 커널 빌드 시스템은 &lt;code&gt;make&lt;/code&gt; 커맨드에 &lt;code&gt;O&lt;/code&gt; 옵션을
제공하는데, 이 옵션의 인자로 빌드 디렉토리를 지정할 수 있습니다.  빌드 과정에서
만들어진 파일들은 이 디렉토리로 저장되므로, 소스코드 디렉토리를 깨끗하게 유지할
수 있습니다.  예를 들어 &lt;code&gt;/foo&lt;/code&gt; 라는 디렉토리에 빌드 과정에서 만들어진 파일을
저장하고 싶다면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ make O=/foo menuconfig
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;build&#34;&gt;Build&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ make -j $(grep &amp;quot;^processor&amp;quot; /proc/cpuinfo | wc -l)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 커맨드는 리눅스 커널을 빌드합니다.  이 때 뒤의 &lt;code&gt;-j&lt;/code&gt; 옵션을 통해 빌드 과정
작업을 한순간에 최대 몇개까지 수행해도 되는지 지정해주는데, 이 커맨드에선
빌드를 수행하는 시스템에 장착된 논리적 코어의 갯수를 줬습니다.  커널 빌드엔 긴
시간이 걸립니다.  프로세서 3개를 준 제 가상머신에서는 12분 30초 정도 걸렸군요.
이것도 &lt;code&gt;localmodconfig&lt;/code&gt; 를 해줬기 때문이고, 이런저런 모듈 다 빌드하라고 했다면
훨씬 많이 걸렸을 겁니다.&lt;/p&gt;
&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ sudo make modules_install install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 커맨드는 빌드한 모듈들과 커널 자체를 설치합니다.  커널 빌드 시스템은 이
과정에서 가장 최신의 커널로 grub 의 디폴트 부트 대상도 바꿔줍니다.  이제 기계를
껐다 켜되, grub 등에서 부트할 커널 버전을 해당 버전으로 선택하면 빌드한 커널로
부팅됩니다.  현재 시스템이 사용중인 커널의 버전은 &lt;code&gt;uname -r&lt;/code&gt; 로 알 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;이상으로 Ubuntu 16.04.3 을 기본으로 리눅스 커널을 빌드하고 설치하는 방법을
알아봤습니다.  총 일곱개의 커맨드 뿐.   쉽죠?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc2/</link>
      <pubDate>Mon, 03 Sep 2018 11:34:35 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc2/</guid>
      <description>&lt;h2 id=&#34;linux-419-rc2&#34;&gt;Linux 4.19-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 4.19 두번째 릴리즈 후보 버전의 릴리즈입니다.  첫번째 릴리즈 후보 버전
릴리즈 후엔 사람들이 좀 쉬게 마련이고 버그를 찾기엔 시간이 많지 않았기에 큰
변화는 없었습니다.  유럽사람들의 경우 아직 휴가기간인 사람도 많구요.  미국
OSSummit 이 지난주 진행된 것도 한 영향이겠네요.&lt;/p&gt;
&lt;h2 id=&#34;patch--v5-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V5 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180903072214.24602-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180903072214.24602-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;관심있게 지켜보고 있는, THP swapout/in 패치입니다.  다음 머지 윈도우에선 들어갈 수 있을까요?&lt;/p&gt;
&lt;h2 id=&#34;plumbers-2018---performance-and-scalability-microconference&#34;&gt;Plumbers 2018 - Performance and Scalability Microconference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1dc80ff6-f53f-ae89-be29-3408bf7d69cc@oracle.com&#34;&gt;https://lkml.kernel.org/r/1dc80ff6-f53f-ae89-be29-3408bf7d69cc@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해 Linux Plumbers Conference 에 &amp;lsquo;Performance and Scalability Microconference&amp;rsquo;
가 열립니다.  Huge page, mmap_sem, cpu 병렬화 등등 재밌는 주제가 많네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc1/</link>
      <pubDate>Mon, 27 Aug 2018 17:11:28 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.19-rc1/</guid>
      <description>&lt;h2 id=&#34;linux-419-rc1&#34;&gt;Linux 4.19-rc1&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CA+55aFw9mxNPX6OtOp-aoUMdXSg=gBkQudGGamo__sh_ts_LdQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이주일의 머지 윈도우가 끝나고 리눅스 4.19 버전을 향한 안정화 단계가
시작되었습니다.&lt;/p&gt;
&lt;p&gt;토발즈에겐 결코 즐겁지 않은 머지 윈도우였습니다 (frustrating merge window
였다고 표현하는군요).  일단 머지 윈도우 초기부터 L1TF 취약점 이슈가 나왔죠.
하지만 이슈가 처음 발견된 건 아니고 공식 보고된 거다보니 그 전부터 수정은 하고
있었기에 머지만 하면 됐습니다.  토발즈는 &lt;code&gt;-next&lt;/code&gt; 트리와 다양한 커널 테스트
시스템들이 잘 갖추어져 있다는 증거라고 이야기 합니다.&lt;/p&gt;
&lt;p&gt;또, TLB 슛다운 버그에 대한 보고가 있었군요.  결국은 큰 문제는 아니었다고
결론났음에도 토발즈의 신경을 많이 긁었다고 합니다.  이 과정에서 관련 코드가
매우 복잡하고 디버깅 하기 어렵다고 이야기 되었기에 차후 정리가 필요할 것
같다는군요.&lt;/p&gt;
&lt;p&gt;또한, 이번 릴리즈는 꽤 많은 변경이 있는 편이라고 합니다, 물론 커밋 수
기반으로요.&lt;/p&gt;
&lt;h2 id=&#34;rfcpatch-05-introduce-procpididle_bitmap&#34;&gt;[RFC][PATCH 0/5] introduce /proc/PID/idle_bitmap&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180901112818.126790961@intel.com&#34;&gt;https://lkml.kernel.org/r/20180901112818.126790961@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/sys/kernel/mm/page_idle/bitmap&lt;/code&gt; 을 사용하면 시스템의 실제 워킹셋 페이지가
무엇무엇인지 알 수 있는데요, 이걸 &lt;code&gt;/proc/PID/idle_bitmap&lt;/code&gt; 으로 옮겨서 좀 더
finer-grained 하게 특정 프로세스의 워킹셋을 추적할 수 있게 하려는 RFC
패치입니다.  기존의 글로벌한 비트맵은 아무래도 사용하기에 오버헤드가 있기
때문이죠.  특히 NVIDMM 을 고려하면 수 테라바이트도 쉽게 보인다는 이야기를
하는군요.  저도 해당 bitmap 을 사용해 워킹셋 추적 프로그램을 만들었다가
오버헤드로 고민이 깊어져서 커널을 좀 고치긴 해야겠다 싶었는데, 잘 머지되면
좋겠습니다.&lt;/p&gt;
&lt;p&gt;이와 함께 인텔의 Apache Pass NVDIMM 에 대한 이야기도 하는군요.  옵테인 기반의
NVDIMM 제품인 거 같은데, NVDIMM 도 현물이 나오기 시작하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-lkmm-17-toolsmemory-model-add-extra-ordering-for-locks-and-remove-it-for-ordinary-releaseacquire&#34;&gt;[PATCH RFC LKMM 1/7] tools/memory-model: Add extra ordering for locks and remove it for ordinary release/acquire&lt;/h2&gt;
&lt;p&gt;이 락킹 앞뒤의 액세스 순서를 지켜주는게 LKMM 에는 반영되어 있지 않습니다.
이걸로 몇명의 커널 프로그래머들이 항의했나 보네요.  이런 부분들을 추가하는
패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-06-documentation-updates-for-v420v50&#34;&gt;[PATCH tip/core/rcu 0/6] Documentation updates for v4.20/v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180829211637.GA20980@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180829211637.GA20980@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음 리눅스 머지 윈도우를 겨냥하는 RCU 쪽 문서 업데이트입니다.  다음 버전은
4.20이 될지 5.0이 될지 Paul 도 모르겠나보군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-03-srcu-updates-for-v420v50&#34;&gt;[PATCH tip/core/rcu 0/3] SRCU updates for v4.20/v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180829212036.GA22033@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180829212036.GA22033@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음 리눅스 머지 윈도우를 향한 SRCU 업데이트 입니다.  &lt;code&gt;call_srcu()&lt;/code&gt; 를 부팅
초기부터 사용할 수 있도록 하는군요.  테스트도 작성했습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-024-additional-rcu-consolidation-cleanups-for-v420v50&#34;&gt;[PATCH tip/core/rcu 0/24] Additional RCU-consolidation cleanups for v4.20/v5.0&lt;/h2&gt;
&lt;p&gt;RCU 는 여러 변종 (flavor) 들이 있는데, 이것들을 최대한 합치려 하고 있는 듯
하군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.18/</link>
      <pubDate>Mon, 13 Aug 2018 10:50:27 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.18/</guid>
      <description>&lt;h2 id=&#34;linux-418&#34;&gt;Linux 4.18&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자, 오랫만에 rc 버전을 8개나 내며 긴 안정화 기간을 거친 4.18 버전이 릴리즈
되었습니다.  따라서 지난주는 조용해야 했고 실제로 조용했지만 그럼에도 불구하고
vfs 레이스 컨디션 문제 수정 등의 변경도 있긴 했습니다.  이번 정식 릴리즈로
포함된 기능 중 개인적으로는 Restartable Sequence 가 눈에 띄고 흥미롭군요.  아마
2015년? 인가에 서울에서 커널 서밋 열려서 거기서 발표 들었을 때부터
관심있었거든요.  유저스페이스에서 이 기능을 잘 사용하면 멀티코어 성능확장성에
큰 개선이 가능할 것 같습니다.&lt;/p&gt;
&lt;p&gt;어쨌건, 이로써 4.19 버전을 향한 머지 윈도우가 열렸습니다.  5.x 는 언제
시작되려나요?&lt;/p&gt;
&lt;h2 id=&#34;git-pull-xarray-for-419&#34;&gt;[GIT PULL] XArray for 4.19&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180813161357.GB1199@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20180813161357.GB1199@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 몇번 소개한 XArray 의 개발자, Matthew 가 충분히 리뷰도 받고
수정도 했다고 생각하는 것 같습니다.  4.18 릴리즈와 함께 열린 4.19 머지윈도우에
XArray 풀리퀘스트를 리누스 토발즈에게 던졌군요!&lt;/p&gt;
&lt;p&gt;이 풀리퀘스트는 XArray 의 구현과 &lt;code&gt;pagecache&lt;/code&gt; 가 XArray 를 사용하도록 하는
변경을 담고 있습니다.&lt;/p&gt;
&lt;p&gt;그러나, 리눅스는 이 패치셋을 받아들이지 않기로 결정했습니다.  XArray 자체에
문제가 있어서느 아니고, 이 패치셋이 &lt;code&gt;libnvdimm&lt;/code&gt; 소스트리 위에서 만들어졌기
때문입니다.  &lt;code&gt;-next&lt;/code&gt; 트리 관리자가 그렇게 하자고 조언한 것 같은데, 어쨌든
Mattew 에겐 안됐지만 다음 버전에서 머지되길 기대해야겠군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v3-03-docscore-api-add-memory-allocation-guide&#34;&gt;[PATCH v3 0/3] docs/core-api: add memory allocation guide&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1534517236-16762-1-git-send-email-rppt@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1534517236-16762-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;메모리 관리쪽 커널 문서가 지속적으로 업데이트 되고 있습니다.  개인적으로는
커널을 공부할 때 공식 문서를 선호하는 편이라 반가운 일이군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.18-rc8</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.18-rc8/</link>
      <pubDate>Mon, 06 Aug 2018 17:53:02 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.18-rc8/</guid>
      <description>&lt;h2 id=&#34;linux-418-rc8&#34;&gt;Linux 4.18-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;원래대로라면 오늘 4.18 정식 릴리즈가 있어야 했지만, 지난주 동안 여러 일이
있었고, 결국 여덟번째 rc 버전이 나오고 말았습니다.  VM 쪽 이슈가 큰 이유였고,
그것만 문제였으면 그냥 정식 릴리즈를 하려 했지만 네트워킹 쪽에서도 뒤늦은
문제가 터지고 VFS 쪽에도 이슈가 있었던 관계로 정식 릴리즈를 미루기로 결심했다고
합니다.&lt;/p&gt;
&lt;p&gt;8월에 휴가를 많이 떠나는 유럽 개발자들을 고려해서 토발즈는 휴가가 예정되어
있다면 그냥 원래 예상된 스케쥴대로 이번주부터 머지 윈도우 열렸다고 생각하고
풀리퀘스트 보내고 휴가 가라고 대인배라면 대인배 같은 면모를 보이는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-0010-introduce-lockless-shrink_slab&#34;&gt;[PATCH RFC 00/10] Introduce lockless shrink_slab()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/153365347929.19074.12509495712735843805.stgit@localhost.localdomain&#34;&gt;https://lkml.kernel.org/r/153365347929.19074.12509495712735843805.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 이야기 했던 &amp;ldquo;Improve shrink_slab() scalability&amp;hellip;&amp;rdquo; 패치의 머지
후, 성능 병목 지점이 &lt;code&gt;shrink_lab()&lt;/code&gt; 에서 &lt;code&gt;down_read_trylock()&lt;/code&gt; 으로
넘어갔습니다!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     &amp;gt; I created 255 memcgs, 255 ext4 mounts and made each memcg create a
     &amp;gt; file containing few KiBs on corresponding mount. Then in a separate
     &amp;gt; memcg of 200 MiB limit ran a fork-bomb.
     &amp;gt;
     &amp;gt; I ran the &amp;quot;perf record -ag -- sleep 60&amp;quot; and below are the results:
     &amp;gt; +  47.49%            fb.sh  [kernel.kallsyms]    [k] down_read_trylock
     &amp;gt; +  30.72%            fb.sh  [kernel.kallsyms]    [k] up_read
     &amp;gt; +   9.51%            fb.sh  [kernel.kallsyms]    [k] mem_cgroup_iter
     &amp;gt; +   1.69%            fb.sh  [kernel.kallsyms]    [k] shrink_node_memcg
     &amp;gt; +   1.35%            fb.sh  [kernel.kallsyms]    [k] mem_cgroup_protected
     &amp;gt; +   1.05%            fb.sh  [kernel.kallsyms]    [k] queued_spin_lock_slowpath
     &amp;gt; +   0.85%            fb.sh  [kernel.kallsyms]    [k] _raw_spin_lock
     &amp;gt; +   0.78%            fb.sh  [kernel.kallsyms]    [k] lruvec_lru_size
     &amp;gt; +   0.57%            fb.sh  [kernel.kallsyms]    [k] shrink_node
     &amp;gt; +   0.54%            fb.sh  [kernel.kallsyms]    [k] queue_work_on
     &amp;gt; +   0.46%            fb.sh  [kernel.kallsyms]    [k] shrink_slab_memcg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 패치셋은 계속해서 &lt;code&gt;shrink_slab()&lt;/code&gt; 의 멀티코어 성능 확장성을 위해 lock 을
사용하지 않게끔 경로를 최적화 하고 있습니다.&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;shrink_slab()&lt;/code&gt; 과 &lt;code&gt;unregister_shrinker()&lt;/code&gt; 사이의 동기화에 SRCU 를
사용하고, 그럴 수 없는 경우에는 &lt;code&gt;percpu_rw_semaphore&lt;/code&gt; 를 사용합니다.  그리고
&lt;code&gt;shrinker_rwsem&lt;/code&gt; 을 뮤텍스로 교체합니다.&lt;/p&gt;
&lt;p&gt;SRCU 를 사용함으로 인해 커널 바이너리 사이즈가 커지는 문제가 있는데, 과거에도
비슷한 시도가 이런 이유로 취소된 적 있었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.18-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.18-rc7/</link>
      <pubDate>Mon, 30 Jul 2018 08:49:12 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.18-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-418-rc7&#34;&gt;Linux 4.18-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 릴리즈입니다.  별다른 일 없으면 다음주에 4.18이 릴리즈 되겠다고
토발즈도 이야기 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-06-kmalloc-reclaimable-caches&#34;&gt;[PATCH v4 0/6] kmalloc-reclaimable caches&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180731090649.16028-1-vbabka@suse.cz&#34;&gt;https://lkml.kernel.org/r/20180731090649.16028-1-vbabka@suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;내부적으로 SLAB 할당자를 사용하는 kmem cache 들은 &lt;code&gt;SLAB_RECLAIM_ACCOUNT&lt;/code&gt;
플래그를 가지고 생성될 경우에 시스템 메모리가 부족한 경우 기존에 할당받은
오브젝트들을 회수해도 좋다고 알리게 됩니다.&lt;/p&gt;
&lt;p&gt;일반적인 kmem cache 들은 이 플래그 없이 생성되서는 시스템의 메모리가 부족한
경우에 회수되어도 좋은 오브젝트의 할당에 사용되기도 하는데, 다양한 크기의
오브젝트들은 &lt;code&gt;SLAB_RECLAIM_ACCOUNT&lt;/code&gt; 플래그를 가진 하나의 kmem cache 에서 처리될
수 없기 때문이죠.  &lt;code&gt;dcache&lt;/code&gt; 의 &lt;code&gt;external name&lt;/code&gt; 들이 그 예입니다.&lt;/p&gt;
&lt;p&gt;이와 비슷한 경우들을 해결하기 위해 이 패치셋은 kmalloc cache 에
SLAB_RECLAIM_ACCOUNT  와 비슷한 특성을 갖는 변종을 kmalloc-rcl-x 라는 이름으로
만들었습니다.  kmalloc() 시에 &lt;code&gt;__GFP_RECLAIMABLE&lt;/code&gt; 플래그를 넣으면 이 캐시에서
메모리가 할당됩니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-swap-use-__try_to_reclaim_swap-in-free_swap_and_cache&#34;&gt;&lt;code&gt;[PATCH] swap: Use __try_to_reclaim_swap() in free_swap_and_cache()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180803123014.15431-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180803123014.15431-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;스왑 엔트리를 회수하는 코드 경로는 &lt;code&gt;free_swap_and_cache()&lt;/code&gt; 가 있고
&lt;code&gt;__try_to_reclaim_swap()&lt;/code&gt; 이 있는데, 코딩 스타일 빼고는 실제 하는 일이 거의
똑같습니다.  이 패치는 &lt;code&gt;free_swap_and_cache()&lt;/code&gt; 에서 내부적으로
&lt;code&gt;__try_to_reclaim_cache()&lt;/code&gt; 를 사용하게 함으로써 코드의 가독성을 높이고 잠재적
버그를 줄였습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.18-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.18-rc6/</link>
      <pubDate>Tue, 24 Jul 2018 06:19:53 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.18-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-418-rc6&#34;&gt;Linux 4.18-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 rc는 평소보다 조금 크게 되었는데, 네트워킹 쪽 메인테이너인 David 가 많은
수정사항을 아직 보내지 않았다가 이번에 모아서 보냈기 때문이라는군요.  그렇다
해도 그렇게 큰 양까진 아니라는 토발즈의 설명입니다.&lt;/p&gt;
&lt;p&gt;지난 rc5 작업 주간을 귀찮게 했던 VM 버그에 대한 두줄의 수정이 rc5 에
들어갔었지만 32비트 환경에 대한 고려가 없었기에 이번에 그 수정이
들어갔다는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-07-memory-management-documentation-updates&#34;&gt;[PATCH 0/7] memory management documentation updates&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1532517970-16409-1-git-send-email-rppt@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1532517970-16409-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;메모리 관리 부분 문서화 업데이트입니다.  sphinx 기반 문서화 업데이트를 일부
메인테이너들은 반기지 않는 것도 사실이지만, 확실히 가독성이 좋아진 덕에 이런
문서화 노력이 더 활발해 지는 것 아닌가 하는 생각도 드는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.18-rc4/</link>
      <pubDate>Mon, 09 Jul 2018 10:01:05 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.18-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-418-rc4&#34;&gt;Linux 4.18-rc4&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CA+55aFwXGyZ1Yx+Z8a93gpvb596ZRJ5ppiQL_+-k7gjeQLtcsQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;어느덧 네번째 RC 버전 릴리즈입니다.  지루할 정도로 평범한 릴리즈라는군요.
대부분 드라이버쪽 업데이트이고, bpf, cifs, ext4, 스케쥴러, 그리고 일부 arch
업데이트가 대부분입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v9-0017-improve-shrink_slab-scalability-old-complexity-was-on2-new-is-on&#34;&gt;[PATCH v9 00/17] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/153112469064.4097.2581798353485457328.stgit@localhost.localdomain&#34;&gt;https://lkml.kernel.org/r/153112469064.4097.2581798353485457328.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shrink_slab()&lt;/code&gt; 의 compexity 를 O(n^2) 에서 O(n) 으로 낮춰 확장성을 높인 패치의
아홉번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-cma-remove-unsupported-gfp-mask-parameter&#34;&gt;[PATCH 0/2] CMA: remove unsupported gfp mask parameter&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180709122018eucas1p277147b1e6385d552b5a8930d0a8ba91c~-sqSan6292733527335eucas1p2-@eucas1p2.samsung.com&#34;&gt;https://lkml.kernel.org/r/20180709122018eucas1p277147b1e6385d552b5a8930d0a8ba91c~-sqSan6292733527335eucas1p2-@eucas1p2.samsung.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cma_alloc()&lt;/code&gt; 과 &lt;code&gt;dma_alloc_from_contiguous()&lt;/code&gt; 함수는 gfp mask 패러미터를
받지만 실질적으론 &lt;code&gt;__GFP_NORARN&lt;/code&gt; 플래그만을 지원하고 있습니다.  이 패치는
따라서 해당 패러미터를 &lt;code&gt;no_warn&lt;/code&gt; 이란 이름의 boolean 타입으로 교체합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-mm-page_alloc-double-zones-batchsize&#34;&gt;[RFC PATCH] mm, page_alloc: double zone&amp;rsquo;s batchsize&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180711055855.29072-1-aaron.lu@intel.com&#34;&gt;https://lkml.kernel.org/r/20180711055855.29072-1-aaron.lu@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널 페이지 할당자는 잘 알려진 Buddy allocator 입니다만, 멀티 CPU
환경에서의 컨텐션을 줄이기 위해 per-CPU pageset 이란 걸 존별로 가지고 있어서
Buddy allocator 로부터는 한번에 듬뿍 페이지를 할당받아와 CPU 별 pageset 에
넣어두고서 여기서 한동안 할당받고, 이게 텅 비었을 때 buddy allocator 에게 다시
여러개 page 를 할당받습니다.  이런 형태를 batching 이라고 하죠.&lt;/p&gt;
&lt;p&gt;이 batch 크기, 즉 한번에 buddy allocator 에서 할당받는 페이지의 갯수는 적정해야
합니다.  이 값이 10년전에 두배로 커져 31이 된 후 유지되고 있습니다.  따라서
오늘날에는 이 값이 너무 작다는 생각이 있어 다시 한번 두배로 늘리는 (31에서 63
으로) 패치입니다.&lt;/p&gt;
&lt;p&gt;will-it-scale/page_fault1, ebizzy, oltp, kbuild, pigz, netperf, vm-scalability
등의 벤치마크를 사용했군요.&lt;/p&gt;
&lt;p&gt;전체적으로 성능 향상이 있었지만 batch 크기가 커진만큼 실제 buddy allocator 에게
할당을 요청할 때 반응시간이 느려지는 문제가 있긴 합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-kvmx86-inform-rcu-of-quiescent-state-when-entering-guest-mode&#34;&gt;[PATCH v2] kvm/x86: Inform RCU of quiescent state when entering guest mode&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180711180101.3711464-1-dwmw2@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180711180101.3711464-1-dwmw2@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU reader critical section 은 가능한 빨리 끝나야 합니다.  그렇지 않으면 grace
period 가 길어져 시스템 메모리 사용량이 늘어날 수 있죠.  RCU reader critical
section 내에서의 sleeping 을 하지 못하게 함으로써 리눅스 커널은 이를 가능하게
합니다만, VM 환경에서는 reader critical section 내에서 VM 자체가 CPU 를 놓을 수
있으므로 critical section 이 길어지는 문제가 가능합니다.  이 패치는 guest mode
에 들어갈 때 이에 관한 정보를 알림으로써 이 문제를 해결할 수 있게 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.17/</link>
      <pubDate>Mon, 04 Jun 2018 11:29:16 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.17/</guid>
      <description>&lt;h2 id=&#34;linux-417&#34;&gt;Linux 4.17&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxhx_tKGm02UySguvbyfB_7oTF31QfgOHCK0YkBvmfV0g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxhx_tKGm02UySguvbyfB_7oTF31QfgOHCK0YkBvmfV0g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.17 버전 리눅스 릴리즈입니다.  지난주에 토발즈가 이야기한 것처럼 별다른 지연
없이 릴리즈 되었군요.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git object&lt;/code&gt; 의 갯수라던지 릴리즈를 위한 스크립트 등이 리눅스 5.x 버전으로의
메이저 버전 업데이트가 될 준비가 되었다고 하지만 토발즈는 딱히 5.x 로 아직은
넘어갈 생각이 없군요.  너무 멀지 않은 미래에 넘어가겠지만, 적어도 지금은
아니라고 합니다.&lt;/p&gt;
&lt;p&gt;항상 그렇듯 이 릴리즈는 4.18을 위한 머지 윈도우의 시작이기도 한데, 토발즈는
두번째 주에 여행을 갈거라 가능하면 첫째주에 중요한 머지를 마무리 했으면 한다고
하네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v13-0072-convert-page-cache-to-xarray&#34;&gt;[PATCH v13 00/72] Convert page cache to XArray&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180611140639.17215-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180611140639.17215-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Radix tree 를 대체하기위한 목적으로 Matthew Wilcox 가 개발중인 XArray 의 구현과
Page cache 가 이 자료구조를 사용하도록 변경하는 패치의 13번째 버전입니다.  작년
OSSummit Europe 에서 처음 XArray 에 대한 발표를 들었는데 계속 발전중인 것
같군요.&lt;/p&gt;
&lt;h2 id=&#34;re-417-regression-performance-drop-on-kernel-417-visible-on&#34;&gt;Re: [4.17 regression] Performance drop on kernel-4.17 visible on&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180607110713.GJ32433@dhcp22.suse.cz&#34;&gt;https://lkml.kernel.org/r/20180607110713.GJ32433@dhcp22.suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 대비 4.17 의 NUMA 시스템에서 Stream, Linpack, NAS 벤치마크 성능이 크게
떨어졌다는 레포트입니다.  최대 50% 까지의 성능 하락이 있었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after 4.17-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc7/</link>
      <pubDate>Mon, 28 May 2018 10:41:50 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-417-rc7&#34;&gt;Linux 4.17-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwUqz9z1Rf4Wwr29W7DeKxQ67qKEW5xty+JPyCY3aNQ=A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwUqz9z1Rf4Wwr29W7DeKxQ67qKEW5xty+JPyCY3aNQ=A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 입니다.  지난 몇주보다는 조금 변경사항이 있었지만 그렇다 해도
그렇게 심한 정도는 아니었기에 아마도 이게 마지막 rc 일 거라는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0013-introdue-iolatency-io-controller-for-cgroups&#34;&gt;[PATCH 00/13] Introdue io.latency io controller for cgroups&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180529211724.4531-1-josef@toxicpanda.com&#34;&gt;https://lkml.kernel.org/r/20180529211724.4531-1-josef@toxicpanda.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cgroup 에 응답시간 (latency) 기반의 I/O 컨트롤러를 추가하는 패치셋입니다.
Cgroup 은 용량 기반의 컨트롤러는 많지만 응답시간 기반의 컨트롤러가 부족하다고
느껴왔는데, 역시 추가되어 가는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc6/</link>
      <pubDate>Mon, 21 May 2018 10:19:16 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-v417-rc6&#34;&gt;Linux v4.17-rc6&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CA+55aFxxYQFL3mwsQcC+__R23ZmO8c3F0SThi6r44TdK0ePNDQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;여섯번째 release candidate 버전입니다.  이번 릴리즈에도 특기할 만한 일은
없었습니다.  이제 충분히 안정화 되었을 거라고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch--mm--v3-0021-mm-thp-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -mm -V3 00/21] mm, THP, swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180523082625.6897-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180523082625.6897-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이전에도 이 시리즈로 소개했던, THP 의 swap out 과 swap in 최적화 마지막 단계
패치의 세번째 버전입니다.  마지막 단계 이야기 하니 문득 인피니티워의 오역
논란이 떠오르는군요 ;)  두번째 버전 이후 특정 컨피규레이션에서의 빌드 버그를
수정했고, mmotm/master 브랜치의 5월 18일자 버전으로 rebase 한게 차이점의
전부군요.&lt;/p&gt;
&lt;p&gt;RAM 으로 PMEM 을 시뮬레이션 하는 환경에서 vm-scalability 라는 벤치마크를 사용해
16개 프로세스가 anonymous page 를 상당량 할당받고 반복해서 접근하는 워크로드로
성능 차이를 비교했습니다.  이로 인해 패치 전 대비 워크로드 처리량 (throughput)
이 992.8% 향상되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v3-04-fixes-cleanups-for-rcudev&#34;&gt;[PATCH v3 0/4] fixes, cleanups for rcu/dev&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180521044220.123933-1-joel@joelfernandes.org&#34;&gt;https://lkml.kernel.org/r/20180521044220.123933-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 코드의 주석, 변수 사용, 변수 이름 등의 개선 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;resend-patch-v5-0033-block-support-multipage-bvec&#34;&gt;[RESEND PATCH V5 00/33] block: support multipage bvec&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180525034621.31147-1-ming.lei@redhat.com&#34;&gt;https://lkml.kernel.org/r/20180525034621.31147-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;하나의 &lt;code&gt;struct bio_bvec&lt;/code&gt; 이 물리적으로 연속적인 복수개의 페이지를 가질 수 있게
하는 패치입니다.  시스템의 메모리가 거대해지고 THP 등이 널리 쓰임에 따라 이런
변화가 필요했다는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch--v2--mm-04-mm-huge-page-copy-target-sub-page-last-when-copy-huge-page&#34;&gt;[PATCH -V2 -mm 0/4] mm, huge page: Copy target sub-page last when copy huge page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180524005851.4079-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180524005851.4079-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 의 복사 시에는 source 와 destination page 각각에 접근을 해야 하므로,
2 MiB huge page 를 사용한다 가정하면 총 4 MiB 데이터 액세스가 필요합니다.
예컨대 Xeon E5 v3 2699 CPU 는 18개의 코어, 36개 쓰레드, 그리고 45 MiB Last
Level Cache 를 가지므로 코어별로는 2.5 MiB, 쓰레드별로는 1.25 MiB 의 Last Level
Cache 밖에 갖지 못하므로, 여기서 huge page 복사가 일어나면 자신의 Last Level
Cache 를 모조리 접근해서 데이터가 flooding 나고 이후 데이터 접근은 cache miss
가 날 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 target huge page 의 sub-page 를 마지막에 복사하도록 복사 시의
데이터 접근 순서를 약간 바꿔서 대부분의 경우에는 캐시 미스를 좀 더 줄일 수
있도록 했습니다.&lt;/p&gt;
&lt;p&gt;vm-scalability 의 anon-cow-seq 테스트 케이스를 2 socket Xeon E5 v3 2699
시스템에서 돌려본 결과, 약 16.6% 까지의 성능 향상이 있었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc5/</link>
      <pubDate>Mon, 14 May 2018 10:23:45 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-417-rc5&#34;&gt;Linux 4.17-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxi-Q6hvdHn+JwYSQ9b3feNGoFM3eeAuKNhpkfxVNAGpA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxi-Q6hvdHn+JwYSQ9b3feNGoFM3eeAuKNhpkfxVNAGpA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.17을 향한 다섯번째 rc 릴리즈입니다.  이번 릴리즈도 여느 때와 다름없이
평범하군요.  대부분 드라이버 변경들이고, amd gpu 쪽 변경이 있지만 나머지
부분들은 그렇게 많지 않고 대부분 한두줄 짜리 변경들입니다.  이대로라면 이번
4.17 릴리즈는 꽤 무난무난하게 끝나겠군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v11-0026-speculative-page-faults&#34;&gt;[PATCH v11 00/26] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1526555193-7242-1-git-send-email-ldufour@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1526555193-7242-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 몇차례 소개한, speculative page fault 의 11번째 버전입니다.
지난 LSFMM 에서도 관련해 논의를 한 것 같던데, 아주 긍정적 반응은 아니었던 것
같습니다만, 어쨌든 오랫만에 올라온 새로운 버전의 패치셋이군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v6-0017-rearrange-struct-page&#34;&gt;[PATCH v6 00/17] Rearrange struct page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180518194519.3820-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180518194519.3820-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct page&lt;/code&gt; 의 구조를 좀 더 사용하기 쉽게 개선하는 패치의 여섯번째
버전입니다.  LSFMM 에서는 그 구조를 구글 문서[1]를 사용해 그림으로 그려가며
설명했고, 꽤 괜찮은 반응을 얻었던 것 같더군요.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&#34;&gt;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QEMU 를 사용한 리눅스 커널 디버깅</title>
      <link>https://sjp38.github.io/ko/post/qemu_kernel_debugging/</link>
      <pubDate>Mon, 07 May 2018 18:21:01 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/qemu_kernel_debugging/</guid>
      <description>&lt;p&gt;토발즈는 좋아하지 않지만, 리눅스 커널 프로그래밍에도 디버거를 사용할 수
있습니다.  저도 디버거 사용을 좋아하지는 않는 편이지만, 경우에 따라선 디버거를
사용하는게 좋을 때도 있고 취향은 존중되어야죠. ;)&lt;/p&gt;
&lt;p&gt;커널 디버깅 방법은 여러가지가 있는데, 그 중 하나는 QEMU 등을 이용한 리눅스 가상
머신을 띄워 두고, 호스트 머신에서 해당 가상 머신의 리눅스 커널을 디버깅 하는
방법입니다.  이 글에선 이렇게 디버깅 하는 방법을 간단히 정리해 봅니다.&lt;/p&gt;
&lt;h1 id=&#34;테스트-환경&#34;&gt;테스트 환경&lt;/h1&gt;
&lt;p&gt;글 작성 과정에서 테스트에 사용한 주요 소프트웨어들과 버전은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu 16.04.3 Server&lt;/li&gt;
&lt;li&gt;gdb 7.11.1&lt;/li&gt;
&lt;li&gt;QEMU v2.11.0-dirty&lt;/li&gt;
&lt;li&gt;Linux v4.16&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;커널-빌드&#34;&gt;커널 빌드&lt;/h1&gt;
&lt;p&gt;디버깅할 커널을 빌드합니다.  이 때 &lt;code&gt;CONFIG_GDB_SCRIPTS&lt;/code&gt; 는 켜고
&lt;code&gt;CONFIG_DEBUG_INFO_REDUCED&lt;/code&gt; 는 끄고, 타겟 아키텍쳐가 &lt;code&gt;CONFIG_FRAME_POINTER&lt;/code&gt; 를
지원한다면 켜야 합니다.&lt;/p&gt;
&lt;h1 id=&#34;가상-머신-부팅&#34;&gt;가상 머신 부팅&lt;/h1&gt;
&lt;p&gt;빌드가 완료되면 해당 커널을 사용해 QEMU 가상 머신을 부팅시킵니다.  가상 머신
위에 커널을 설치하는 방법도 있겠고, QEMU 에 &lt;code&gt;-kernel&lt;/code&gt; 과 &lt;code&gt;-append&lt;/code&gt;, &lt;code&gt;-initrd&lt;/code&gt;
등을 사용해서 호스트에서 빌드한 리눅스 커널로 부팅시키는 방법도 있을 겁니다.
이 때, &lt;strong&gt;kaslr&lt;/strong&gt; 을 꺼야 합니다.  커널 패러미터에 &lt;code&gt;nokaslr&lt;/code&gt; 을 추가하는 걸로 끌
수 있습니다.  kaslr 이 켜진 채로 디버깅 해야 한다면 다른 방법이 있는데, 여기선
다루지 않겠습니다.&lt;/p&gt;
&lt;p&gt;QEMU 가상 머신을 시작할 때 QEMU 에 &lt;code&gt;-s&lt;/code&gt; 옵션을 주거나 QEMU monitor console 에서
&lt;code&gt;gdbserver&lt;/code&gt; 라고 명령을 입력해 줍니다.  이 명령은 가상머신에서 gdbserver 를
시작시켜서 gdbserver 가 &lt;code&gt;tcp::1234&lt;/code&gt; 에서 접속을 기다리게 함으로써 QEMU 의 gdb
기능을 활성화 시켜줍니다.  &lt;code&gt;-nographic&lt;/code&gt; 옵션을 주거나 해서 QEMU 를 수행시켰다면
화면에 QEMU monitor console 이 아니라 가상머신의 console 로 연결되었을 텐데,
&lt;code&gt;Ctrl+a c&lt;/code&gt; 키 조합으로 QEMU monitor console 로 이동할 수 있습니다.  여기서
가상머신 콘솔로 돌아가려면 &lt;code&gt;Ctrl+a c &amp;lt;enter&amp;gt;&lt;/code&gt; 를 입력해 줍니다.&lt;/p&gt;
&lt;h1 id=&#34;gdb-시작&#34;&gt;gdb 시작&lt;/h1&gt;
&lt;p&gt;호스트 머신에서 디버깅할 커널의 빌드 디렉토리로 이동해서 &lt;code&gt;gdb vmlinux&lt;/code&gt; 명령어를
입력해 빌드된 리눅스 심볼과 디버깅 정보를 사용해 gdb 가 켜지도록 합니다.
우분투나 일부 배포본에서는 이 때 &lt;code&gt;vmlinux-gdb.py&lt;/code&gt; 를 읽어들이는데 실패할 수
있을 겁니다.  gdb 에서도 에러메세지를 띄워 주겠지만, 홈디렉토리의 &lt;code&gt;.gdbinit&lt;/code&gt;
파일에 다음 한줄을 추가해 주고 앞서 설명한 커맨드로 gdb 를 다시 시작합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;add-auto-load-state-path /path/to/linux-build
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이후, gdb 세션에서 다음과 같은 명령어를 입력해 QEMU 가상머신에 연결합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) target remote :1234
Remote debugging using :1234
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&amp;quot;sti; hlt&amp;quot;: : :&amp;quot;memory&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이와 함께 QEMU 가상 머신은 동작이 멈출 겁니다.  여기서부터 gdb 를 평소에
사용하듯이 사용해 리눅스 커널의 변수를 보거나 중단점 (breakpoint) 를 설정하거나
한단계씩 코드를 수행시키거나 할 수 있습니다.  예를 들어 다음과 같이 특정 함수에
breakpoint 를 설정할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) b cma_alloc
Breakpoint 1 at 0xffffffff81240f10: file /home/sjpark/linux/mm/cma.c, line 399.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;예를 들어 수행이 멈춰 있는 가상머신의 수행을 다시 가능하게 하려면 다음과 같이 c
를 입력해 줍니다.  가상머신의 커널 수행이 재개되며, Breakpoint 가 설정되어 있고
해당 위치 코드가 수행되면 다시 수행이 멈출 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) c
Continuing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다시 멈추려면 gdb 에서 Ctrl+C 를 누릅시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;^C
Thread 1 received signal SIGINT, Interrupt.
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&amp;quot;sti; hlt&amp;quot;: : :&amp;quot;memory&amp;quot;);
(gdb)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;리눅스-gdb-helper-사용하기&#34;&gt;리눅스 gdb helper 사용하기&lt;/h1&gt;
&lt;p&gt;사실은 앞 단계에서 &lt;code&gt;.gdbinit&lt;/code&gt; 를 굳이 수정하지 않아서 gdb가 &lt;code&gt;vmlinux-gdb.py&lt;/code&gt; 를
읽어들이는데 실패하더라도 gdb 를 평범하게 사용할 수 있습니다.  &lt;code&gt;vmlinux-gdb.py&lt;/code&gt;
는 사실 gdb 위에서 리눅스 커널을 디버깅하는걸 편리하게 해줄 수 있는 일부
스크립트, 즉 gdb helper 를 담고 있습니다.  이걸 사용하면 보다 쉽게 커널
디버깅을 할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;helper-스크립트-리스트업&#34;&gt;helper 스크립트 리스트업&lt;/h2&gt;
&lt;p&gt;사용 가능한 helper 스크립트는 lx로 시작하는 규칙을 갖고 있습니다.  다음
명령으로 사용 가능한 스크립트 목록과 간단한 설명을 볼 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) apropos lx
function lx_current -- Return current task
function lx_module -- Find module by name and return the module variable
function lx_per_cpu -- Return per-cpu variable
function lx_task_by_pid -- Find Linux task by PID and return the task_struct variable
function lx_thread_info -- Calculate Linux thread_info from task variable
function lx_thread_info_by_pid -- Calculate Linux thread_info from task variable found by pid
lx-cmdline --  Report the Linux Commandline used in the current kernel
lx-cpus -- List CPU status arrays
lx-dmesg -- Print Linux kernel log buffer
lx-fdtdump -- Output Flattened Device Tree header and dump FDT blob to the filename
lx-iomem -- Identify the IO memory resource locations defined by the kernel
lx-ioports -- Identify the IO port resource locations defined by the kernel
lx-list-check -- Verify a list consistency
lx-lsmod -- List currently loaded modules
lx-mounts -- Report the VFS mounts of the current process namespace
lx-ps -- Dump Linux tasks
lx-symbols -- (Re-)load symbols of Linux kernel and currently loaded modules
lx-version --  Report the Linux Version of the current kernel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;참 쉽죠? ;)&lt;/p&gt;
&lt;h1 id=&#34;참고-자료&#34;&gt;참고 자료&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/v4.11/dev-tools/gdb-kernel-debugging.html&#34;&gt;커널 디버깅 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.alexlambert.com/2017/12/18/kernel-debugging-for-newbies.html&#34;&gt;참고할만한 영문 블로그 글&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/Server.html&#34;&gt;gdbserver 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc4/</link>
      <pubDate>Mon, 07 May 2018 12:12:32 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-417-rc4&#34;&gt;Linux 4.17-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyry0qeZvYjU5pf8a6zvb_ALmP-2T9+HZH2DHK93P6rQg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyry0qeZvYjU5pf8a6zvb_ALmP-2T9+HZH2DHK93P6rQg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어느새 네번째 rc 버전입니다.  v4.17 을 향한 여정이 절반을 넘어가는군요.  이번 릴리즈도 특이사항 없이 평범합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc3/</link>
      <pubDate>Mon, 30 Apr 2018 12:59:19 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-417-rc3&#34;&gt;Linux 4.17-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyu=y0SBesB+vx3JZFGcOhP+tuVG7sjfrkfBhXHTe0Skg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyu=y0SBesB+vx3JZFGcOhP+tuVG7sjfrkfBhXHTe0Skg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;세번째 rc 버전이 나왔습니다.  평소보다 좀 일찍 왔군요.  rc2 에 비해 커다란
릴리즈이긴 한데, 그렇다 해도 평범한 릴리즈라고 리누스는 이야기 합니다.
대부분의 변경 사항이 드라이버 쪽 수정이기 때문이라고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0016-rearrange-struct-page&#34;&gt;[PATCH v4 00/16] Rearrange struct page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180430202247.25220-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180430202247.25220-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 소개했던, Matthew Wilcox 의 &amp;lsquo;struct page&amp;rsquo; 정리 패치의 네번째
버전입니다.  지난주 LSFMM 에서도 소개한 모양인데, 이 변화의 전/후를 google
spread sheet 로 정리한 문서도 여기서 공개했나보군요:
&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&#34;&gt;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-04-interface-for-higher-order-contiguous-allocations&#34;&gt;[PATCH v2 0/4] Interface for higher order contiguous allocations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180503232935.22539-1-mike.kravetz@oracle.com&#34;&gt;https://lkml.kernel.org/r/20180503232935.22539-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mmap(MAP_CONTIG)&lt;/code&gt; 를 추가하자는 아이디어가 있었습니다.  현재 리눅스 커널에서
연속된 메모리 공간 할당에 사용되기 위해 만들어진 인터페이스는 CMA가 있는데, 그
목적이 좀 특수한 상황에 맞춰져 있다보니 좀 더 범용적 인터페이스가 있으면
어떻겠나 하는 이야기가 나와, 그런 인터페이스를 만들어 제시하는 패치입니다.
제안하는 인터페이스는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct page *find_alloc_contig_pages(unsigned long nr_pages, gfp_t gfp,
                                        int nid, nodemask_t *nodemask)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;rfc-distinguish-vmalloc-pages&#34;&gt;[RFC] Distinguish vmalloc pages&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180502152733.GB2737@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20180502152733.GB2737@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VMalloc 페이지는 유저스페이스에 매핑될 수도 있으므로 성능 분석과 memory leak
문제 분석의 편의를 위해  page-&amp;gt;mapping 값에 이를 가리키는 표식과 해당 페이지를
가리키는 &lt;code&gt;vm_struct&lt;/code&gt; 와 그 안에서의 &lt;code&gt;offset&lt;/code&gt; 을 저장하는 RFC 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;introduce-atomic_dec_and_lock_irqsave&#34;&gt;Introduce atomic_dec_and_lock_irqsave()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180504154533.8833-1-bigeasy@linutronix.de&#34;&gt;https://lkml.kernel.org/r/20180504154533.8833-1-bigeasy@linutronix.de&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;local_irq_save()&lt;/code&gt; + &lt;code&gt;atomic_dec_and_lock()&lt;/code&gt; 조합을 써야 하던 코드를 위해 이를
감싸는 새로운 함수, &lt;code&gt;atomic_dec_and_lock_irqsave()&lt;/code&gt; 를 만들고 기존의 코드가
이를 사용하도록 고친 패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc2/</link>
      <pubDate>Mon, 23 Apr 2018 12:03:23 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc2/</guid>
      <description>&lt;h2 id=&#34;linux-v417-rc2&#34;&gt;Linux v4.17-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwzkGuq5ASF-vhYj7mEX26V0K+uZCLWi1BLYq+9F1n-Rw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwzkGuq5ASF-vhYj7mEX26V0K+uZCLWi1BLYq+9F1n-Rw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;두번째 rc 버전의 릴리즈입니다.  &lt;code&gt;perf&lt;/code&gt; 와 테스트 스크립트 쪽에 변경사항이 좀
많긴 하지만 평소와 크게 다르지 않은 추이라는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc1/</link>
      <pubDate>Mon, 16 Apr 2018 10:59:58 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.17-rc1/</guid>
      <description>&lt;h2 id=&#34;linux-v417-rc1&#34;&gt;Linux v4.17-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFx62iBkj+hOmhLksUtvjwTcm_o1dwcyvaNnVpJ-AmvzVQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFx62iBkj+hOmhLksUtvjwTcm_o1dwcyvaNnVpJ-AmvzVQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2주간의 머지 윈도우가 지나고, v4.17-rc1 이 릴리즈 되었습니다.  크게 특별할 것
없이 평범한 머지 윈도우였다고 토발즈는 평하는군요.  그리고 이번에 git objects
mark 가 4백만을 넘겼습니다.  따라서 다음 커널이 v5.0 이어도 될 것 같은데, 꼭
다음 버전에서 그렇게 할지는 모르겠다는군요.  리눅스 커널에서 버전은 그저 시간이
흘렀음을 의미할 뿐, 큰 변화가 있어서 메이저 버전 넘버가 바뀌는게 아니기
때문이죠.  참고로 v3.0 과 v4.0 은 각각 git objects mark 2백만과 4백만에서
이루어졌군요.&lt;/p&gt;
&lt;p&gt;암튼 언젠가는 v5.0 을 릴리즈 하겠지만 너무 큰 의미를 부여하지 말아달라고 이야기 하고 있습니다.&lt;/p&gt;
&lt;p&gt;토발즈는 또한 이번 머지 윈도우에서의 변화로 몇가지를 꼽는데요.
오래된 아키텍쳐인 backfin, cris, frv, m32r, metag, mn10300, score, tile
아키텍쳐의 지원을 끊기로 했고 nds32 라는 새로운 아키텍쳐를 지원하게 되었군요.
해당 아키텍쳐에 지원이 더 필요하다면 언제든 되살려도 좋지만 본인이 잘 관리할 수
있음을 증명해야 함을 한번 더 언급하고 있습니다.&lt;/p&gt;
&lt;p&gt;또한, 이번 머지 윈도우에선 클린업이 꽤 있었습니다.  staging 드라이버들 몇개가
제거되었고, spdx 를 사용함으로써 카피라이트 문구도 많이 줄었습니다.
pre-shipped lexer / parser 파일들도 사라졌구요.&lt;/p&gt;
&lt;p&gt;결국, 이번 릴리즈는 추가된 코드 라인보다 삭제된 코드 라인이 많았던 릴리즈군요.
프로젝트 관리자로써 토발즈가 속시원할 것 같습니다.  이런 경우는 커널 릴리즈
역사상 처음이라는군요.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 13538 files changed, 627723 insertions(+), 818855 deletions(-)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;patch-v10-0025-speculative-page-faults&#34;&gt;[PATCH v10 00/25] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1523975611-15978-1-git-send-email-ldufour@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1523975611-15978-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어느새 열번째 버전의 speculative page faults 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-0012-improve-shrink_slab-scalability-old-complexity-was-on2-new-is-on&#34;&gt;[PATCH v2 00/12] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/152397794111.3456.1281420602140818725.stgit@localhost.localdomain&#34;&gt;https://lkml.kernel.org/r/152397794111.3456.1281420602140818725.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;많은 memort shrinker 들 또는 메모리 cgroups 를 가진 시스템에서는 그 수의 제곱에
비례해 &lt;code&gt;shrink_slab()&lt;/code&gt; 의 수행시간이 증가하는데, 이 문제를 해결하고자 하는
패치셋입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/code&gt; 의 수행시간을 사용해 성능 차이를
측정했군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0021-mm-thp-swap-swapoutswapin-thp-as-a-whole&#34;&gt;[PATCH 00/21] mm, THP, swap: Swapout/swapin THP as a whole&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180417020230.26412-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180417020230.26412-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP (Transparent Huge Page) 는 swap out 되기 전에 regular page 로 쪼개져야
했습니다.  이 작업에 많은 시간이 걸렸기에 한번에 THP 를 swap out 하기 위한
작업을 Huang Ying 이 해왔고 일단 쪼개는 작업은 최후로 미뤄뒀는데 마침내 완전히
THP 단위로 swap out 을 행하는 패치셋을 올렸습니다.&lt;/p&gt;
&lt;p&gt;RAM 으로 PMEM swap device 를 시뮬레이션 해서 vm-scalability 벤치마크의
swap-w-seq 테스트를 16개 프로세스로 실험한 결과, 약 10배의 성능 개선을
보았군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-021-contention-reduction-for-v418&#34;&gt;[PATCH tip/core/rcu 0/21] Contention reduction for v4.18&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180423030258.GA23370@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180423030258.GA23370@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 의 루트 &amp;lsquo;rcu_node&amp;rsquo; 구조체로의 락 컨텐션을 줄이는 Paul McKenney 의
패치셋입니다.  별 문제 없으면 4.18 버전에 들어가겠군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.16/</link>
      <pubDate>Mon, 02 Apr 2018 07:13:40 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.16/</guid>
      <description>&lt;h2 id=&#34;linux-416&#34;&gt;Linux 4.16&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyxn0bu5jOAJvO_63GHaGMkJ0uA=bVBm2T3HVX9SimZzw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyxn0bu5jOAJvO_63GHaGMkJ0uA=bVBm2T3HVX9SimZzw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;릴리즈 마지막 주 치고는 네트워킹 쪽에 조금 변경사항이 있었습니다만, 큰 문제가
될 정도는 아니었습니다.  결과, 4.16이 드디어 릴리즈 되었습니다!  동시에 4.17
머지 윈도우가 시작되는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-move-kfree_rcu-out-of-rcu-code-and-use-kfree_bulk&#34;&gt;[PATCH 0/2] Move kfree_rcu out of rcu code and use kfree_bulk&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522647064-27167-1-git-send-email-rao.shoaib@oracle.com&#34;&gt;https://lkml.kernel.org/r/1522647064-27167-1-git-send-email-rao.shoaib@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kfree_rcu() 대신 kfree_bulk() 라는 새로 만들어진, 더 효율적인 기능을 사용하도록
하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-01-mm-support-multiple-kswapd-threads-per-node&#34;&gt;[RFC PATCH 0/1] mm: Support multiple kswapd threads per node&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522661062-39745-1-git-send-email-buddy.lumpkin@oracle.com&#34;&gt;https://lkml.kernel.org/r/1522661062-39745-1-git-send-email-buddy.lumpkin@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NUMA 아키텍쳐에서 리눅스 커널은 NUMA 노드당 하나의 kswapd 쓰레드를 띄웁니다.
노드당 kswapd 쓰레드 수를 늘려 성능을 높이려는 쓰레드입니다.  결국은 이런
움직임이 있어야 할거라고 봅니다만, 당장 이 패치에 대해서는 수정 요청 의견도 꽤
있군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-group-struct-page-elements&#34;&gt;[RFC] Group struct page elements&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180408142334.GA29357@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20180408142334.GA29357@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널에서 페이지를 관리하는 구조체인 &lt;code&gt;struct page&lt;/code&gt; 는 매우 복잡한 구조로
되어있고, 페이지가 어떤 목적으로 쓰이느냐에 따라 같은 필드가 다른 목적으로
쓰이기도 합니다.
이 RFC 패치는 이 혼란스러운 구조를 좀 개선해 보려는 시도를 담고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-12-slab-__gfp_zero-is-incompatible-with-a-constructor&#34;&gt;[PATCH 1/2] slab: &lt;code&gt;__GFP_ZERO&lt;/code&gt; is incompatible with a constructor&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180410125351.15837-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180410125351.15837-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시작은 김민찬 님의 null pointer dereference 문제에 대한 수정을 담은
패치셋이었습니다
(&lt;a href=&#34;https://lkml.kernel.org/r/20180409015815.235943-1-minchan@kernel.org)&#34;&gt;https://lkml.kernel.org/r/20180409015815.235943-1-minchan@kernel.org)&lt;/a&gt;.
이걸 Matthew 는 근본적인 실수가 있었던 것 같다고 보고 이 패치셋을 내놓았습니다.
메모리 할당 요청에 &lt;code&gt;__GFP_ZERO&lt;/code&gt; 플래그를 넣으면 메모리 영역을 0으로 초기화 해서
할당을 해줍니다.  그런데 constructor 가 있다면 초기화 작업을 constructor 에서
해야 하기에 &lt;code&gt;__GFP_ZERO&lt;/code&gt; 플래그를 여기에 넣는건 뭔가 이상하죠.
이 패치셋은 그런 경우는 모두 실수에 의한 것이라 보고 경고를 표시해 주도록
합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-tiplockinglockdep-v6-2020-lockdepselftest-add-a-test-case-for-srcu&#34;&gt;[RFC tip/locking/lockdep v6 20/20] lockdep/selftest: Add a test case for SRCU&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180411135721.22723-1-boqun.feng@gmail.com&#34;&gt;https://lkml.kernel.org/r/20180411135721.22723-1-boqun.feng@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널의 락킹 관련 문제 추적 기능인 &lt;code&gt;lockdep&lt;/code&gt; 이 SRCU 를 지원하게 하는
패치와 함께 올라온 패치입니다.
&lt;code&gt;lockdep&lt;/code&gt; 을 위한 selftest 에 SRCU 기능 역시 테스트하도록 테스트를
추가했습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc7/</link>
      <pubDate>Mon, 26 Mar 2018 08:45:19 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-416-rc7&#34;&gt;Linux 4.16-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxpxHnWBeTXN+DKqwCMW_=T2cR8UxSBVk_6c8LL7Et5JQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxpxHnWBeTXN+DKqwCMW_=T2cR8UxSBVk_6c8LL7Et5JQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16을 향한 일곱번째 rc 가 릴리즈 되었습니다.  평소대로라면 이게 마지막 rc 여야
할텐데, 평소와 다름없거나 변경사항이 적은 편이던 그동안의 rc와 달리 이번 rc 는
좀 변경사항이 많군요.  그렇다곤 해도 아마도 네트워킹 쪽 코드 머지가 늦었기
때문으로 보이며 rc8을 릴리즈할 생각은 아직은 없다고 토발즈는 이야기 하네요.&lt;/p&gt;
&lt;p&gt;더불어, 토발즈가 rc 릴리즈 때마다 변경 사항들을 정리하기 위해 주로 사용하는 git
사용 스크립트를 공개했습니다.&lt;/p&gt;
&lt;p&gt;다음주는 4.16이 릴리즈 될까요?  아니면, rc8이?&lt;/p&gt;
&lt;h2 id=&#34;patch-mmlist_lru-replace-spinlock-with-rcu-in-__list_lru_count_one&#34;&gt;[PATCH] mm/list_lru: replace spinlock with RCU in &lt;code&gt;__list_lru_count_one&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522137544-27496-1-git-send-email-lirongqing@baidu.com&#34;&gt;https://lkml.kernel.org/r/1522137544-27496-1-git-send-email-lirongqing@baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list_lru_count_one()&lt;/code&gt; 이 스핀락을 잡기 때문에 &lt;code&gt;shrink_slab()&lt;/code&gt; 이 많은 시간을
소모하게 되는데, 이를 스핀락 대신 RCU 를 사용하게 해서 최적화 시킨 패치입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dd&lt;/code&gt; 를 사용해 커다란 메모리를 사용한 후 파일을 제거하고서
&lt;code&gt;/cgroup/memory/test/memory.limit_in_bytes&lt;/code&gt; 의 크기를 작게 잡아 인위적으로
reclaim 을 유발시키고 여기에 걸리는 시간을 측정했군요.  기존 0.415초에서 최적화
후 0.395초로 개선되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v10-0062-convert-page-cache-to-xarray&#34;&gt;[PATCH v10 00/62] Convert page cache to XArray&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180330034245.10462-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180330034245.10462-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XArray 패치 중 일부가 이미 Andrew Morton 의 -next 트리에 들어갔습니다.  Matthew
Wilcox 는 XArray 를 활용하는 패치를 이어서 계속 올리고 있군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-limit-a-process-rss&#34;&gt;[PATCH] mm: limit a process RSS&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522386674-12047-1-git-send-email-lirongqing@baidu.com&#34;&gt;https://lkml.kernel.org/r/1522386674-12047-1-git-send-email-lirongqing@baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ulimit -m&lt;/code&gt; 명령을 이용해 프로세스의 최대 RSS (Resident Set Size) 를 제어할 수
있는 인터페이스가 있지만 실제로 커널이 제한을 하고 있진 않습니다.  제한하도록
구현하는 패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc6/</link>
      <pubDate>Mon, 19 Mar 2018 10:19:34 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-416-rc6&#34;&gt;Linux 4.16-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzV1nffUeriZLksK90noD49T+w+WmgBsYMAO13rTbn3Pg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzV1nffUeriZLksK90noD49T+w+WmgBsYMAO13rTbn3Pg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 여섯번째 rc 버전이 나왔습니다.  4.16을 향한 이번 사이클은 상당히 순탄하게
진행되는군요.  rc7 까진 만들 예정이라고 하는데, 그 후엔 4.16이 안정적으로
나오게 될 것 같습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc5/</link>
      <pubDate>Mon, 12 Mar 2018 10:08:11 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-416-rc5&#34;&gt;Linux 4.16-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxXAMHeD8zz1BLv9r_2rjWJ6xE=cNGVAoWOvQJog7oz9A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxXAMHeD8zz1BLv9r_2rjWJ6xE=cNGVAoWOvQJog7oz9A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여전히 특이사항 없는 한주를 거쳐 다섯번째 rc 버전이 나왔습니다.  이번 릴리즈가
기존의 rc5 단계보단 조금 크지만 특이할 정도는 아닌 모양이군요.  개인적으로 눈에
띈 부분은, overlayfs, xfs 등의 파일시스템의 변경, 그리고 perf 와 selftest 쪽
변경이 있군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v9-0024-speculative-page-faults&#34;&gt;[PATCH v9 00/24] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1520963994-28477-1-git-send-email-ldufour@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1520963994-28477-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Speculative page faults 의 9번째 패치셋입니다.  Michael Hocko 가 이거 너무 자주
올리는 거 아니냐고 한마디 했고, 패치 저자인 Laurent Dufour 도 오케이 했네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0032-docsvm-convert-to-rest-format&#34;&gt;[PATCH 00/32] docs/vm: convert to ReST format&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1521660168-14372-1-git-send-email-rppt@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1521660168-14372-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널 문서의 ReST 화는 많은 사람들이 반기고 있는 변화지만 일부 메인테이너는 썩
반기지 않기도 합니다.  vm/ 쪽 문서를 모두 ReST 로 바꾸는 패치가 올라왔습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc4/</link>
      <pubDate>Mon, 05 Mar 2018 10:50:48 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-416-rc4&#34;&gt;Linux 4.16-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxXg8hi+T_DNCG_OrAotqSheyREw-Njf9XgUD1vXqAyHQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxXg8hi+T_DNCG_OrAotqSheyREw-Njf9XgUD1vXqAyHQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;벌써 개발 단계의 중반이라 할 수 있는 rc4 의 릴리즈입니다.  4.16 버전의 릴리즈도
얼마 남지 않았군요.  여전히 충분히 조용한 한주였습니다.  다만 여기저기에 조금씩
변경사항이 골고루 있군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0034-v3-pti-support-for-x32&#34;&gt;[PATCH 00/34 v3] PTI support for x32&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1520245563-8444-1-git-send-email-joro@8bytes.org&#34;&gt;https://lkml.kernel.org/r/1520245563-8444-1-git-send-email-joro@8bytes.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;x86-32 를 위한 Page Table Isolation 패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.16 Rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc3/</link>
      <pubDate>Mon, 26 Feb 2018 18:38:53 +0100</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-416-rc3&#34;&gt;Linux 4.16-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxk5KBxL9DvRtBivP3hKT-aOAzvSA_B47L1+y0P2GLe_A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxk5KBxL9DvRtBivP3hKT-aOAzvSA_B47L1+y0P2GLe_A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 세번째 rc 버전이 릴리즈 되었습니다.  rc2 보단 변경사항이 많지만, rc2 때
이야기 했듯 rc2 때는 대부분의 경우 고칠 것들을 찾지도 못했기 때문이 크기
때문이죠.  즉, 스펙터와 멜트다운으로 끔찍했던 4.15 때와 달리, 모든게 정상적이고
예상대로라고 합니다.&lt;/p&gt;
&lt;p&gt;대부분의 변경은 드라이버이고, 네트워킹 쪽 변경도 좀 크군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-05-srcu-updates&#34;&gt;[PATCH tip/core/rcu 0/5] SRCU updates&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180226215614.GA31616@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180226215614.GA31616@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU critical section 안에서 sleep 을 할 수 있는 SRCU 의 간단한 업데이트
패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-012-torture-test-updates&#34;&gt;[PATCH tip/core/rcu 0/12] Torture-test updates&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180226220225.GA32136@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180226220225.GA32136@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 등의 동기화 도구의 동시성 버그를 찾는데 사용되는 torture test 의 업데이트
패치셋입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.16 Rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc2/</link>
      <pubDate>Mon, 19 Feb 2018 11:09:15 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc2/</guid>
      <description>&lt;h2 id=&#34;linux-416-rc2&#34;&gt;Linux 4.16-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwDnBq9V6TVbc82DzVYpf-ELF7UcYzHuY0ei1Xjnob+0A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwDnBq9V6TVbc82DzVYpf-ELF7UcYzHuY0ei1Xjnob+0A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 두번째 rc 버전의 릴리즈입니다.  이번 한주는 매우 조용한 한주였군요.  머지
윈도우가 끝나고 사람들이 좀 쉬기 때문일수도, 아직 버그를 찾지 못해서일 수도
있고 일반적으로 rc2 는 조용한 편이지만, 어쨌든 토발즈는 만족스러운 눈치입니다.
4.15 에서의 spectre &amp;amp; meltdown 때문에 더 그럴지도 모르겠지만요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc1/</link>
      <pubDate>Tue, 13 Feb 2018 13:56:47 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.16-rc1/</guid>
      <description>&lt;h2 id=&#34;linux-416-rc1&#34;&gt;Linux 4.16-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzXVqgCMhPL9EaMW_D9E=HCQ9+JSQAbBPe3Oa_iQtky=g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzXVqgCMhPL9EaMW_D9E=HCQ9+JSQAbBPe3Oa_iQtky=g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어느덧 2주일이 지났습니다.  머지 윈도우가 닫히고 4.16 첫번째 rc 버전이
나왔습니다.  4.15는 역시 토발즈에게 고통스러웠던 시간이었던지 이번 머지
윈도우는 4.15 보다 훨씬 나았다는 토발즈의 이야기입니다.&lt;/p&gt;
&lt;p&gt;이번 릴리즈에서는 GPU 쪽 변경 사항이 많고 대부분은 드라이버라 아주 큰 변화는
거의 없지만, 여전히 arch 쪽에도, 네트워킹과 파일시스템 등에도 변경이 없지는
않다고 정리하고 있습니다.
스펙터 / 멜트다운 이슈에 대한 x86 외 아키텍쳐의 변경사항들도 들어왔군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v8-0024-speculative-page-faults&#34;&gt;[PATCH v8 00/24] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1518794738-4186-1-git-send-email-ldufour@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1518794738-4186-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 릴리즈와 함께 4.15 위로 포팅된 Speculative page faults 패치가 계속
올라오고 있습니다.  이 패치셋은 예전부터 제가 관심을 두고 보고 있는 패치인데,
page fault handling 을 speculative 하게 함으로써 병렬성을 높이려는 패치입니다.
아이디어가 시작된 건 오래되었고 그 아이디어를 이어와 다시 제안되고 있는
패치이죠.  이번엔 업데이트 될런지 궁금하네요.&lt;/p&gt;
&lt;h2 id=&#34;patch--mm--v5-resend-mm-swap-fix-race-between-swapoff-and-some-swap-operations&#34;&gt;[PATCH -mm -v5 RESEND] mm, swap: Fix race between swapoff and some swap operations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180213014220.2464-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180213014220.2464-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;swapin 작업과 swapoff 작업 사이를 락으로 보호하지 않고 있기 때문에 segmentation
fault 문제가 있을 수 있습니다.  swapoff 가 자주 불리진 않다보니 이 문제가 크게
불거진 적 없는데, 어쨌건 race 는 race 라 고쳐야 한다는 Huang Ying 의
패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15/</link>
      <pubDate>Mon, 29 Jan 2018 09:20:38 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15/</guid>
      <description>&lt;h2 id=&#34;linux-415&#34;&gt;Linux 4.15&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzARtx-nA=d1j7vLOLf4FHMJLyRiQ-PKkoexJuTUHogdw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzARtx-nA=d1j7vLOLf4FHMJLyRiQ-PKkoexJuTUHogdw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;드디어 4.15 버전이 릴리즈 되었습니다.  지난 한주는 매우 조용하고 변경된 사항이
거의 없었다는군요.&lt;/p&gt;
&lt;p&gt;이렇게 meltdown/spectre 로 시끄럽고 길었던, 평범하지 않았던 릴리즈 사이클이
끝났습니다.
하지만, meltdown/spectre 관련한 일이 아주 끝난 건 아니라고 이야기 하는군요.
특히, indirect bracnh mitigation 을 위한 가장 큰 수정사항을 반영받기 위해선
커널만 업데이트 해선 안되고 컴파일러의 &amp;ldquo;retpoline&amp;rdquo; 지원이 있어야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /sys/devices/system/cpu/vulnerabilities/spectre_v2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;로 컴파일러 지원이 있는지 알 수 있는데, 컴파일러 지원이 없다면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vulnerable: Minimal generic ASM retpoline
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이란 출력이 뜰겁니다.&lt;/p&gt;
&lt;p&gt;한가지 더 이야기 해둬야 할건, 이번 릴리즈에 meltdown/spectre 가 많은 영향을
끼치긴 했지만 그래도 다른 부분들은 평범하게 업데이트가 진행되었다는 겁니다.
즉, 이번 릴리즈는 좀 평범하지 않기 했지만 그렇다고 아주 이상하기만 한 릴리즈도
아니었다는 거죠.&lt;/p&gt;
&lt;p&gt;어쨌든 4.15 버전이 드디어 나왔습니다!&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-addressing-mmap_sem-contention&#34;&gt;[LSF/MM TOPIC] Addressing mmap_sem contention&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/4c20d397-1268-ca0f-4986-af59bb31022c@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/4c20d397-1268-ca0f-4986-af59bb31022c@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널에서 메모리 매핑은 mmap_sem 이라는 reader-writer semaphor 를 이용해
race condition 으로부터 보호되고 있습니다.  당연하게도, 쓰레드가 많은 환경에선
여기 부하가 심하게 걸리고 성능 확장을 저해하게 됩니다.  Peter Zijlstra 의
Speculative Page Fault 패치는 페이지 폴트 시에 메모리 매핑을 할 때 mmap_sem 을
잡지 않고 매핑하려 시도해보고 중간에 동시에 같은 영역을 매핑하려 한 쓰레드가
존재하면 abort &amp;amp; retry 를 하는식으로 이 문제를 완화시킵니다.
해당 패치셋은 최근 Laurent 에 의해 다시 포팅되어 커뮤니티에 올라오기도 했죠.
실제로 ebizzy[1] 와 같이 쓰레드를 많이 쓰는 벤치마크에서는 두배가까이 성능
향상이 있었다고 하구요.&lt;/p&gt;
&lt;p&gt;하지만 Speculative Page Fault 만으로는 모든 문제가 해결되지 않기에 mmap_sem
자체에 대한 논의를 LSFMM 에서 하고 싶다는 메일입니다.&lt;/p&gt;
&lt;p&gt;병렬 프로그래밍에 관심있는 제게도 흥미로운 주제네요.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://ebizzy.sourceforge.net/&#34;&gt;http://ebizzy.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-lru_lock-scalability&#34;&gt;[LSF/MM TOPIC] lru_lock scalability&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/2a16be43-0757-d342-abfb-d4d043922da9@oracle.com&#34;&gt;https://lkml.kernel.org/r/2a16be43-0757-d342-abfb-d4d043922da9@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;최근에 덜 사용된 (Least Recently Used) 페이지를 가려내기 위해 사용되는
&lt;code&gt;lru_lock&lt;/code&gt; 은 메모리 집중적 벤치마크를 돌릴 때 커널에서 가장 뜨거워지는 락들
가운데 하나입니다.
당연히 확장성 문제가 있죠.&lt;/p&gt;
&lt;p&gt;이걸 배칭 또는 페이지 개별적 락킹을 통해 해결해 보자는 안을 내놓고 이에 대해
LSFMM 에서 이야기 해보자는 메일입니다.&lt;/p&gt;
&lt;p&gt;RFC 패치가 벌써 올라왔네요:
&lt;a href=&#34;https://lkml.kernel.org/r/20180131230413.27653-1-daniel.m.jordan@oracle.com&#34;&gt;https://lkml.kernel.org/r/20180131230413.27653-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;git-pull-rcu-changes-for-v416&#34;&gt;[GIT PULL] RCU changes for v4.16&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180129100051.ndq4osy45fz3g26a@gmail.com&#34;&gt;https://lkml.kernel.org/r/20180129100051.ndq4osy45fz3g26a@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Ingo Molnar &lt;a href=&#34;mailto:mingo@kernel.org&#34;&gt;mingo@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 머지 윈도우가 열렸으니 Ingo 가 4.16 을 위한 rcu 쪽 변경사항을 리누스에게
풀리퀘스트 보냈습니다.
사실 이건 별로 흥미로운 메일은 아닐 수 있지만, 4.16 에서 RCU 가 어떻게 변경될지
알 수 있겠죠.
그리고, 제가 작년 프라하와 상해에서 만들어 올렸던, 패치 9개가 있습니다 ;)&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-0064-mm-towards-parallel-address-space-operations&#34;&gt;[RFC PATCH 00/64] mm: towards parallel address space operations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180205012754.23615-1-dbueso@wotan.suse.de&#34;&gt;https://lkml.kernel.org/r/20180205012754.23615-1-dbueso@wotan.suse.de&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lsquo;mmap_sem&amp;rsquo; 은 커널의 메모리 관리에서 자주 사용되는 락으로, 많은 scalability
문제의 중심에 있습니다.  이 패치셋은 mmap_sem 을 range locking 기법을 활용해서
바꿔냄으로써 병렬성을 확보하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch--mm--v2-mm-swap-frontswap-fix-thp-swap-if-frontswap-enabled&#34;&gt;[PATCH -mm -v2] mm, swap, frontswap: Fix THP swap if frontswap enabled&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180207070035.30302-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180207070035.30302-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;zswap 은 THP 를 고려하지 않기 때문에 THP 가 켜진 상태에서 zswap 이 frontswap
으로 동작할 경우 일부 어플리케이션은 segfault 와 memory corruption 을 낼 수
있는 문제가 있었습니다.  커밋 bd4c82c22c367e068 (&amp;ldquo;mm, THP, swap: delay
splitting THP after swapped&amp;rdquo;) 때문에 발생한 문제였구요.  이를 고치기 위한
패치입니다.
out&amp;rdquo;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc9</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc9/</link>
      <pubDate>Tue, 23 Jan 2018 12:16:07 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc9/</guid>
      <description>&lt;h2 id=&#34;not-final-415-this-weekend&#34;&gt;&lt;em&gt;Not&lt;/em&gt; final 4.15 this weekend&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxzQBH5gnG92ah-PREfOqb5_rjWriLH3fWHMWS1=BSQFw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxzQBH5gnG92ah-PREfOqb5_rjWriLH3fWHMWS1=BSQFw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;원래대로라면 4.15 정식 버전의 릴리즈가 될 타이밍이었습니다만&amp;hellip;
아직 충분히 안정화 되지 않은 것 같다는 토발즈의 판단 아래 이번주에도 rc 버전이
나왔습니다.  rc9 입니다.
2011년의 3.1-rc9 이후 처음 나온 rc9 이네요.&lt;/p&gt;
&lt;p&gt;이번 릴리즈는 x86, arm powerpc, mips 쪽의 arch 업데이트, 드라이버, 그리고
네트워킹 핵심부 업데이트가 주된 변경이군요.&lt;/p&gt;
&lt;p&gt;다음주에는 꼭 4.15를 릴리즈 하고 싶다고 하는데, 아마도 다음주에는 4.15 정식
버전이 릴리즈되길 빕니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-cma-and-larger-page-sizes&#34;&gt;[LSF/MM TOPIC] CMA and larger page sizes&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/3a3d724e-4d74-9bd8-60f3-f6896cffac7a@redhat.com&#34;&gt;https://lkml.kernel.org/r/3a3d724e-4d74-9bd8-60f3-f6896cffac7a@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Contiguous Memory Allocator (CMA) 는 할당에 사용되는 메모리 영역을 비트맵으로
관리하는데, 페이지 하나에 비트 하나씩 주면 비트맵을 traverse 하는데 너무 많은
시간이 걸리므로, 하나의 비트가 여러개의 페이지를 담당하도록 되어있습니다.
이게 CMA 의 응답시간에는 큰 도움이 되지만, fragmentation 으로 인한 메모리
낭비가 심합니다.  Laura Abbott 은 이걸 LSFMM 에서 논의해보고 싶어하는군요.&lt;/p&gt;
&lt;h2 id=&#34;git-pull-tools-linux-kernel-memory-model&#34;&gt;[GIT PULL tools] Linux kernel memory model&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180125093440.GA875@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180125093440.GA875@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Paul McKenney 의 리눅스 커널 메모리 모델이 리눅스 커널 소스트리의 &lt;code&gt;tools/&lt;/code&gt;
디렉토리로 머지될 것 같습니다!
이 모델은 &lt;code&gt;cat&lt;/code&gt; 언어로 쓰여져서 &lt;code&gt;herd7&lt;/code&gt; 시뮬레이터로 실행될 수 있어서, 동시성을
갖는 코드가 실제로 어떻게 동작할지 검사할 수 있게 해줍니다.
과장 좀 보태서 자동화된 memory-barriers.txt 라고도 할 수 있죠.&lt;/p&gt;
&lt;p&gt;이미 Ingo Molnar 가 풀 했군요.  별다른 문제 없다면 정식 버전으로는 4.17
버전에서 볼 수 있겠습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc8</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc8/</link>
      <pubDate>Tue, 16 Jan 2018 13:26:26 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc8/</guid>
      <description>&lt;h2 id=&#34;linux-415-rc8&#34;&gt;Linux 4.15-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFz=PcxdARFpCTyQCJKaJcBwVUB9y6XAXM8VyyxnbRD=bw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFz=PcxdARFpCTyQCJKaJcBwVUB9y6XAXM8VyyxnbRD=bw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;마침내 여덟번째 rc 버전의 릴리즈입니다.  스펙터 버그를 성능 저하 없이 막기 위한
구글의 해결책, Retpoline 지원이 들어갔군요.  그 외에는 드라이버 업데이트여서
일단 rc8 에 걸맞는 조용함이긴 하다고 토발즈는 평하네요.  자, 다음주에는 4.15 가
릴리즈될런지?  아니면 rc9 이 나오고 말런지?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc7/</link>
      <pubDate>Sat, 13 Jan 2018 10:30:13 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-415-rc7&#34;&gt;Linux 4.15-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwbmKznuQZe_VemxXJPSmB-9yy8uyWsMZcrkA4T=m8xkw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwbmKznuQZe_VemxXJPSmB-9yy8uyWsMZcrkA4T=m8xkw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Meltdown 과 Spectre 로 떠들썩했던 시간을 지나 4.15 의 일곱번째 rc 버전이 릴리즈
되었습니다.  지난 여섯번째 릴리즈 때도 상당히 안정화에 신경써야 할 시점임에도
x86 pti (page table isolation) 업데이트 패치가 많이 머지되어 의아했는데, 이게
Meltdown 과 Spectre 버그 때문이었음도 밝혀졌죠.
그렇다곤 해도 그 외의 부분은 예상대로 상당히 안정화 되어가고 있다고 합니다.&lt;/p&gt;
&lt;p&gt;더불어, Thomas Geixner 등의 인텔쪽 커널 개발자들의 노력 덕에 pti 등 Meltdown 과
Spectre 버그를 위한 패치가 잘 관리되어 비교적 쉽게 머지될 수 있었음에 리누스가
감사를 표하네요.  욕할땐 욕하고 칭찬할 땐 칭찬하고. ;)&lt;/p&gt;
&lt;p&gt;아무튼, 이때문에 4.15 는 rc8 까지 릴리즈 할 계획이라고 합니다.  4.15 는 2주일
후에나 릴리즈 되겠군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-2018-call-for-proposals&#34;&gt;LSF/MM 2018: Call for Proposals&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180115163952.GB26120@cmpxchg.org&#34;&gt;https://lkml.kernel.org/r/20180115163952.GB26120@cmpxchg.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 스토리지, 파일 시스템, 메모리 관리 쪽 개발자들의 모임인 LSFMM 서밋 2018
을 위한 CFP 가 공개되었습니다.  올해도 4월에 하네요.  장소는 유타입니다.  1월
31일까지 토론하고 싶은 주제를 메일로 보내면 흥미로운 주제를 바탕으로 주제를
꾸미고, 그 외에도 그냥 참가하고 싶은 사람도 메일 보내면 내부적으로 심사 후
초대를 해주는 것 같네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc6/</link>
      <pubDate>Tue, 02 Jan 2018 13:34:11 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-415-rc6&#34;&gt;Linux 4.15-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzU_Q04CVEABo50x24yeTaP-yzzrB1wTPeOiOgAbSKiDA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzU_Q04CVEABo50x24yeTaP-yzzrB1wTPeOiOgAbSKiDA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;한국시간으로는 1월 1일, 토발즈의 현지 시각으로는 2017년의 마지막날, 4.15 의
여섯번째 rc 버전이 릴리즈 되었습니다.&lt;/p&gt;
&lt;p&gt;지난주는 크리스마스 등의 연휴 때문인지 참 조용했죠.  덕분에 이번 릴리즈의
변경사항도 많지 않습니다.
다만 x86 pti 쪽 업데이트가 있었기 때문에 이번엔 rc8 까지 릴리즈 할수도 있을 것
같다고 하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc4/</link>
      <pubDate>Sun, 24 Dec 2017 14:24:13 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-415-rc5&#34;&gt;Linux 4.15-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFy1U+uBLEAoCWU3=BqEbROW6rsbaHUdYJArR6iYQQWo_A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFy1U+uBLEAoCWU3=BqEbROW6rsbaHUdYJArR6iYQQWo_A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 다섯번째 rc 버전이 평소 스케쥴보다 하루 일찍 릴리즈 되었습니다.
원래대로라면 내일일텐데, 미국 시간으로는 크리스마스 이브라서 그냥 오늘 릴리즈
한다는군요.&lt;/p&gt;
&lt;p&gt;이번 rc5 의 변경 사항들도 지난 릴리즈의 rc5 와 비슷했다고 하는데, 다만 x86 의
커널 페이지 테이블 격리화 관련 작업이 진행 중인 게 좀 예외라고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-v3-patch-05-eliminate-zone-lock-contention-for-will-it-scalepage_fault1-and-parallel-free&#34;&gt;[RFC v3 PATCH 0/5] Eliminate zone-&amp;gt;lock contention for will-it-scale/page_fault1 and parallel free&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180509085450.3524-1-aaron.lu@intel.com&#34;&gt;https://lkml.kernel.org/r/20180509085450.3524-1-aaron.lu@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;패치셋 저자는 112개 CPU를 갖는 Intel Skylake 서버에서 will-it-scale/page_fult1
워크로드를 돌려보았고 80% CPU 가 zone-&amp;gt;lock 에서 스핀하며 시간을 보내고 있음을
파악했습니다.  이 문제를 해결하기 위한 RFC 패치의 세번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0013-improve-shrink_slab-scalability-old-complexity-was-on2-new-is-on&#34;&gt;[PATCH v4 00/13] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/152586686544.3048.15776787801312398314.stgit@localhost.localdomain&#34;&gt;https://lkml.kernel.org/r/152586686544.3048.15776787801312398314.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shrink_slab()&lt;/code&gt; 의 복잡도가 O(n^2) 이기 때문에 많은 shrinker 와 메모리 cgroups
를 갖는 기계에서는 확장성의 병목이 될 수 있습니다.  이를 간단한 스크립트로
보이는데요.  먼저 다음과 같이 4000개의 memory cgroup 들을 만들고,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$echo 1 &amp;gt; /sys/fs/cgroup/memory/memory.use_hierarchy
$mkdir /sys/fs/cgroup/memory/ct
$echo 4000M &amp;gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes
$for i in `seq 0 4000`;
        do mkdir /sys/fs/cgroup/memory/ct/$i;
        echo $$ &amp;gt; /sys/fs/cgroup/memory/ct/$i/cgroup.procs;
        mkdir -p s/$i; mount -t tmpfs $i s/$i; touch s/$i/file;
done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;아래와 같이 drop cache 를 다섯번 수행하며 여기 걸리는 시간을 측정했습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$time echo 3 &amp;gt; /proc/sys/vm/drop_caches

0.00user 13.78system 0:13.78elapsed 99%CPU
0.00user 5.59system 0:05.60elapsed 99%CPU
0.00user 5.48system 0:05.48elapsed 99%CPU
0.00user 8.35system 0:08.35elapsed 99%CPU
0.00user 8.34system 0:08.35elapsed 99%CPU
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;반복해서 drop cache 를 할 뿐이기 때문에 뒤따르는 drop cache 들은 실질적으로
cache 를 비우진 않고 그저 shrinker 와 memcg 를 둘러볼 뿐입니다.  그럼에도 최소
5.48초가 걸렸군요.  그만큼 병목이 심하단 이야기죠.&lt;/p&gt;
&lt;p&gt;패치는 shrink_slab() 의 복잡도를 O(n)으로 고쳤고, 이후 다음과 같이 오버헤드가 거의 사라지는 결과를 내놓았습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.00user 1.10system 0:01.10elapsed 99%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;약 548배의 성능 향상이군요!&lt;/p&gt;
&lt;h2 id=&#34;patch--mm--v2-0021-mm-thp-swap-swapoutswapin-thp-as-a-whole&#34;&gt;[PATCH -mm -V2 00/21] mm, THP, swap: Swapout/swapin THP as a whole&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180509083846.14823-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180509083846.14823-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난번에도 소개한, THP 를 2 MiB 그대로 한번에 swap out / swap in 하는
패치입니다.  기존에는 THP 를 regular page 로 쪼개서 swap out / swap in
했었거든요.&lt;/p&gt;
&lt;h2 id=&#34;patch--mm-mm-thp-doc-add-document-for-thp_swpoutthp_swpout_fallback&#34;&gt;[PATCH -mm] mm, THP, doc: Add document for thp_swpout/thp_swpout_fallback&lt;/h2&gt;
&lt;p&gt;https:/lkml.kernel.org/r/20180509082341.13953-1-ying.huang@intel.com&lt;/p&gt;
&lt;p&gt;앞에 설명한 THP swap 관련 최적화는 단계별로 적용되고 있는데, 그와 함께
&lt;code&gt;/proc/vmstat&lt;/code&gt; 에는 &lt;code&gt;thp_swpout&lt;/code&gt; 과 &lt;code&gt;thp_swpout_fallback&lt;/code&gt; 필드가
추가되었습니다.  그에 대한 문서화가 아직 안들어와 있었는데, 이를 추가하는
패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc5/</link>
      <pubDate>Sun, 24 Dec 2017 14:24:13 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-415-rc5&#34;&gt;Linux 4.15-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFy1U+uBLEAoCWU3=BqEbROW6rsbaHUdYJArR6iYQQWo_A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFy1U+uBLEAoCWU3=BqEbROW6rsbaHUdYJArR6iYQQWo_A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 다섯번째 rc 버전이 평소 스케쥴보다 하루 일찍 릴리즈 되었습니다.
원래대로라면 내일일텐데, 미국 시간으로는 크리스마스 이브라서 그냥 오늘 릴리즈
한다는군요.&lt;/p&gt;
&lt;p&gt;이번 rc5 의 변경 사항들도 지난 릴리즈의 rc5 와 비슷했다고 하는데, 다만 x86 의
커널 페이지 테이블 격리화 관련 작업이 진행 중인 게 좀 예외라고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;re-about-the-try-to-remove-cross-release-feature-entirely-by-ingo&#34;&gt;Re: About the try to remove cross-release feature entirely by Ingo&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171229014736.GA10341@X58A-UD3R&#34;&gt;https://lkml.kernel.org/r/20171229014736.GA10341@X58A-UD3R&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lockdep 의 cross release 기능은 너무 느렸고, false positive 가 많다는 이유로,
특히 false positive 가 너무 많다는 이유로 Ingo Molnar 에 의해 제거되려 하고
있습니다.  관련해서 이 블로그에서도 일단 default 로는 disable 되는 변경이 v4.14
에 있었음을 이야기 했죠.&lt;/p&gt;
&lt;p&gt;Cross release 의 개발자인 박병철님께서 이에 대해 다른 의견을 내놓는 메일입니다.&lt;/p&gt;
&lt;h2 id=&#34;re-hang-with-v415-rc-trying-to-swap-back-in&#34;&gt;Re: Hang with v4.15-rc trying to swap back in&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1514407817.4169.4.camel@HansenPartnership.com&#34;&gt;https://lkml.kernel.org/r/1514407817.4169.4.camel@HansenPartnership.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;스왑 레이어를 최적화하는 많은 변경이 최근에 있었는데, 그 중 하나가 시스템 행을
일으키는군요.  관련된 패치들을 발본색원해서 레포팅 한 메일입니다.  충분히 빠른
swap device 에 대해서는 swapcache 를 건너뛰게 한게 원인이 되었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc4</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc4/</link>
      <pubDate>Mon, 18 Dec 2017 17:46:23 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-415-rc4&#34;&gt;Linux 4.15-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFysmVGm_shBvK4kmaS+_PsMEt3Mz_b+Dm0SDrmVtUofbA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFysmVGm_shBvK4kmaS+_PsMEt3Mz_b+Dm0SDrmVtUofbA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 네번째 rc 버전입니다.  지난 rc 버전들이 생각보다 커서 토발즈가 좀
걱정했는데, 이번 릴리즈에 들어서는 평범한 네번째 rc 만큼이나 변화가 많이 없어
충분히 안정화 되기 시작한 것 같다고 하는군요.&lt;/p&gt;
&lt;p&gt;이번에 가장 눈에 띌만한 변화는 suspend/resume 처리를 정리하고 고친 것이라고
합니다.  크로스 락킹 디버깅 기능은 부팅 시간을 늘리는 문제 등도 있어선지 이번에
일단 제거되었네요.  나중에 다시 되살릴 계획은 있는 것 같습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-11-move-kfree_call_rcu-to-slab_commonc&#34;&gt;[PATCH v2 1/1] Move kfree_call_rcu() to slab_common.c&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513895570-28640-1-git-send-email-rao.shoaib@oracle.com&#34;&gt;https://lkml.kernel.org/r/1513895570-28640-1-git-send-email-rao.shoaib@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 의 modularity 를 개선하는 패치입니다.  몇가지 쟁점이 있긴 하지만 기본
아이디어는 받아들여지는 분위기군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc3</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc3/</link>
      <pubDate>Mon, 11 Dec 2017 11:25:13 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-415-rc3&#34;&gt;Linux 4.15-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFz9O9R8u3ori-QNPz4ALU+0B=Es0gd+oWmsce5qxugxXA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFz9O9R8u3ori-QNPz4ALU+0B=Es0gd+oWmsce5qxugxXA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 세번째 rc 버전입니다.  지난주보단 조금 늦게 릴리즈 되었네요.&lt;/p&gt;
&lt;p&gt;일반적으로 rc3 릴리즈는 좀 변경사항이 많지만 이번엔 그중에서도 변경사항이 많은
편이라 걱정된다고 하는군요.  대부분은 드라이버쪽 변경인데 perf 쪽 변경도 꽤
있고 core, networking, kvm, arch, 문서 업데이트도 물론 있습니다.  어쨌든
토발즈는 이제는 정말 안정화가 되어가길 바라는 마음이라는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-mmslab-do-not-hash-pointers-when-debugging-slab&#34;&gt;[PATCH v2] mm/slab: Do not hash pointers when debugging slab&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513179267-2509-1-git-send-email-geert+renesas@glider.be&#34;&gt;https://lkml.kernel.org/r/1513179267-2509-1-git-send-email-geert+renesas@glider.be&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 버전에 들어와 포인터 값을 기반으로 한 예측을 통해 공격이 들어오는 걸
방지하기 위해 &amp;lsquo;%p&amp;rsquo; 가 포인터를 그냥 출력하는게 아니라 hash 한 다음에 출력하도록
바뀌었죠.  때문에 디버깅이 좀 까다로워졌구요.  디버깅을 위해 온전한 포인터가
필요한 곳에선 &amp;lsquo;%pX&amp;rsquo; 를 써야 합니다.  일단 slab 쪽에서도 그게 필요하기에 DEBUG
옵션이 켜졌을 때에는 &amp;lsquo;%pX&amp;rsquo; 를 사용하도록 하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-mm-unclutter-thp-migration&#34;&gt;[RFC PATCH] mm: unclutter THP migration&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171207124815.12075-1-mhocko@kernel.org&#34;&gt;https://lkml.kernel.org/r/20171207124815.12075-1-mhocko@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Transparent Huge Page 를 위한 Michal Hocko 의 패치입니다.&lt;/p&gt;
&lt;p&gt;THP 마이그레이션을 위한 메모리 할당 콜백은 THP 가 한꺼번에 마이그레이션 될 수
있는지 보고, 마이그레이션 될 곳에 메모리가 부족해 불가능하거나 하다면 평범한
페이지를 할당받습니다.  이어서 unmap_and_mov() 가 THP 를 평범한 페이지로
쪼개고, 그사이 THP 의 head page 는 split_huge_page() 를 통해 LRU 리스트에
들어갑니다.  같은 일이 THP 할당에 실패할 때도 이러나는데, 이건 에러가 나기 쉬운
행위라고 Michal 은 봅니다.&lt;/p&gt;
&lt;p&gt;LRU 리스트에 split_huge_page() 를 행하는 것도 잘못된 행위인데, 모든 tail page
들이 마이그레이션 되지 않았기 때문이죠.  이로 인해 발생하는 문제는 사용자가
각각 처리해야 했습니다.&lt;/p&gt;
&lt;p&gt;Michal 은 이 패치를 통해 THP 처리를 위한 특수한 부분들을 migrate_pages() 단계로
올려서 이 상황을 정리하고자 합니다. 여기서 unmap_and_move() 가 ENOMEM 으로
실패하면 THP 페이지를 쪼개고 현재 존재하는 리스트로 옮깁니다.  이렇게 함으로써
우리는 모든 THP 서브페이지들을 항상 마이그레이션 하고 특정한 migrate_pages()
사용자들은 앞서 이야기한 경우를 별도로 처리할 필요가 없어지는 것이죠.&lt;/p&gt;
&lt;h2 id=&#34;patch-lockinglockdep-make-config_lockdep_crossrelease-and-config_lockdep_completions-optional&#34;&gt;[PATCH] locking/lockdep: Make CONFIG_LOCKDEP_CROSSRELEASE and CONFIG_LOCKDEP_COMPLETIONS optional&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513062681-5995-1-git-send-email-byungchul.park@lge.com&#34;&gt;https://lkml.kernel.org/r/1513062681-5995-1-git-send-email-byungchul.park@lge.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아직 락들의 classification 이 잘 되어있지 않아 너무 많은 false positive 가
나오고 있어 lockdep 의 CROSSRELEASE 와 COMPLETIONS 를 기본 활성에서 옵셔널로
바꾸는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-reduce-memory-bloat-with-thp&#34;&gt;[PATCH] mm: Reduce memory bloat with THP&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513301359-117568-1-git-send-email-nitin.m.gupta@oracle.com&#34;&gt;https://lkml.kernel.org/r/1513301359-117568-1-git-send-email-nitin.m.gupta@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 는 굉장히 aggressive 하게 huge page 를 선호하기 때문에 메모리 사용량을
증가시키는 문제가 있습니다.  Redis 등에서는 그런 이유로 THP 를 꺼버리라고
하기도 하죠.&lt;/p&gt;
&lt;p&gt;이 패치는 어플리케이션이 특정 메모리 영역에 MADV_DONTNEED 를 보내면, 이 영역은
&amp;ldquo;space-efficient&amp;rdquo; 로 마크되어서 해당 영역은 항상 huge page 를 사용하는게 아니라
khugepaged 가 해당 영역이 정말로 매핑되어 있고 사용되고 있는지에 따라 huge page
로 승격을 시키도록 합니다.  어플리케이션이 다시 MADV_HUGEPAGE 를 해당 영역에
내면, 해당 영역은 다시 non-space-efficient 로 마크되어 원래대로 동작합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-rcutorture-add-basic-arm64-support-to-run-scripts&#34;&gt;[PATCH v2] rcutorture: Add basic ARM64 support to run scripts&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513070365-13436-1-git-send-email-lianglihao@huawei.com&#34;&gt;https://lkml.kernel.org/r/1513070365-13436-1-git-send-email-lianglihao@huawei.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 를 테스트하는 rcutorture 드라이버의 드라이버 ;) 스크립트에 aarch64 지원을
추가하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v5-0078-xarray-v5&#34;&gt;[PATCH v5 00/78] XArray v5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171215220450.7899-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20171215220450.7899-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Matthew Wilcox 의 XArray 다섯번째 버전 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-08-restructure-struct-page&#34;&gt;[PATCH 0/8] Restructure struct page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171216164425.8703-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20171216164425.8703-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct page&lt;/code&gt; 는 매우 민감한 구조체죠.  요걸 구조를 살짝 바꾸려는 패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc2</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc2/</link>
      <pubDate>Mon, 04 Dec 2017 13:38:11 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc2/</guid>
      <description>&lt;h2 id=&#34;linux-415-rc2&#34;&gt;Linux 4.15-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxPBszFBt91KRNBrsQdJ10b+6fh9ySNzSKSX7JOq4WRPw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxPBszFBt91KRNBrsQdJ10b+6fh9ySNzSKSX7JOq4WRPw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 두번째 rc 버전이 나왔습니다.&lt;/p&gt;
&lt;p&gt;동부 지방을 여행 중인가 보군요.  평소보다 좀 이른 시간에 릴리즈가 됐습니다.
원하던 것보단 큰 릴리즈가 되어버렸지만 대부분 fixup 이기에 큰 문제는 없는 것
같다는군요.  Kernel ASLR leak 을 막기 위해 모든 &amp;ldquo;%P&amp;rdquo; 로 프린트되는 어드레스
주소를 해시해 버린다고 하네요.  이럼 디버깅할 때 좀 짜증날 수 있긴 하겠지만
다른 방법이 별로 없었다고&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v3-07-ktask-multithread-cpu-intensive-kernel-work&#34;&gt;[RFC PATCH v3 0/7] ktask: multithread CPU-intensive kernel work&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171205195220.28208-1-daniel.m.jordan@oracle.com&#34;&gt;https://lkml.kernel.org/r/20171205195220.28208-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CPU-intensive 한 작업을 커널 내에서 병렬로 진행하도록 도와주는 새로운 프레임웍,
ktask 의 RFC 패치입니다.  예를 들어, 부팅 시에 &lt;code&gt;struct page&lt;/code&gt; 들을 초기화 하는
작업은 현재 하나의 쓰레드가 처리하게 되어 booting 시간이 길어지는데, 멀티코어
시스템이라면 ktask 를 이용해 이 작업을 자동으로 병렬화 할 수 있다는 겁니다.
기존에도 workqueue, kthread_worker 와 같이 병렬 작어을 위한 커널 기능들이
존재하지만, workqueue 는 작업을 쓰레드별로 나누는 걸 대신 해주지는 않고,
kthread_worker 는 하나의 쓰레드만 지원하기 때문에 ktask 를 새로 만들었다고
하네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0073-xarray-version-4&#34;&gt;[PATCH v4 00/73] XArray version 4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171206004159.3755-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20171206004159.3755-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XArray 네번째 버전의 패치가 올라왔습니다.  LinuxCon Europe 에서도 관련 발표를
재밌게 들었었는데요.  XArray 는 Radix tree 의 API 를 대체할 목적으로 만들어진
새로운 자료구조 인터페이스입니다.  이번 버전의 패치를 통해 page cache 가 완전히
Radix tree 에서 XArray 로 갈아타게 했다는군요.  하지만 여전히 문제들도 많아서
바로 머지되진 않을 것 같다고 패치의 작성자도 이야기하네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc1</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc1/</link>
      <pubDate>Mon, 27 Nov 2017 11:09:15 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.15-rc1/</guid>
      <description>&lt;h2 id=&#34;linux-415-rc1&#34;&gt;Linux 4.15-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzcudOPSwbD9XfVxBgFsQOhBjyncyYnGDYwZUEHOGUwcw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzcudOPSwbD9XfVxBgFsQOhBjyncyYnGDYwZUEHOGUwcw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;예정대로 2주만에 4.15 의 첫번째 rc 버전이 나왔습니다.&lt;/p&gt;
&lt;p&gt;지난주는 추수감사절이라 다들 휴가인 사람이 많았기에 첫번째 주에 최대한 많이
풀리퀘스트를 받았고 지난주는 좀 더 까다롭게 풀리퀘스트를 검사했군요.  토발즈는
두번째 주 동안 랩톱 들고 여행중이었고, 랩톱에서는 전체 모듈 빌드를 하지 않기
때문이라 합니다.  메인테이너들도 가능한 첫번째 주에 중요 플리퀘스트를 보내는
식으로 협조를 해줬다고 합니다.  그네들도 두번째주는 휴가가고 싶었을테니&amp;hellip; ;)&lt;/p&gt;
&lt;p&gt;4.14 가 LTS 였기에 이번 머지윈도우에는 변화가 크지 않을 것으로 예상했는데
생각보다 많은 풀리퀘스트가 있었다고 합니다.  4.9 때와는 다른 경향인데, 4.9 에
비해 4.14 가 변화가 크지 않았기 때문 아니겠냐고 토발즈는 생각하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v3-04-introduce-get_user_pages_longterm&#34;&gt;[PATCH v3 0/4] introduce get_user_pages_longterm()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/151197872943.26211.6551382719053304996.stgit@dwillia2-desk3.amr.corp.intel.com&#34;&gt;https://lkml.kernel.org/r/151197872943.26211.6551382719053304996.stgit@dwillia2-desk3.amr.corp.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널스페이스에서 꽤 오랜시간 페이지를 잡아둬야 하는 경우를 위한, 예를 들어
dma-to-dax vs truncate 문제를 위한, get_user_pages() 의 변종의 추가입니다.
실제 이를 사용하는 패치는 나중에 올라올 것 같군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0018-introduce-a-new-tool-valid-access-checker&#34;&gt;[PATCH 00/18] introduce a new tool, valid access checker&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1511855333-3570-1-git-send-email-iamjoonsoo.kim@lge.com&#34;&gt;https://lkml.kernel.org/r/1511855333-3570-1-git-send-email-iamjoonsoo.kim@lge.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Valid access checker (Vchecker) 라는 이름의 새로운 메모리 에러 탐색 도구의
소개입니다.  Out of bound access, use after free 같은, 의도되지 않은 메모리
접근을 잡아낼 수 있게 해준다고 하는군요.  Kernel Address SANitizer (KASAN) 의
기능에 많이 의존하고 있기 때문에 KASAN 메인테이너 중 하나인 Dmitry 는 이게
별도의 도구로 머지되어야 할지 의문스럽다며 머지될 예정이면 한번 더 이야기
해달라고 하네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-03-mmcma-manage-the-memory-of-the-cma-area-by-using-the-zone_movable&#34;&gt;[PATCH v2 0/3] mm/cma: manage the memory of the CMA area by using the ZONE_MOVABLE&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1512114786-5085-1-git-send-email-iamjoonsoo.kim@lge.com&#34;&gt;https://lkml.kernel.org/r/1512114786-5085-1-git-send-email-iamjoonsoo.kim@lge.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CMA 를 위한 영역은 하나의 zone 내에 위치하게 되는데, 이 zone 내에 다양한 특성의
페이지들이 혼재되어있다보니 이런저런 문제가 생깁니다.  CMA 영역을 MOVABLE zone
만 쓰도록 함으로써 이 문제를 해결하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-021-de-emphasize-smp_read_barrier_depends&#34;&gt;[PATCH tip/core/rcu 0/21] De-emphasize {smp_,}read_barrier_depends&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171201195053.GA23494@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171201195053.GA23494@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 패치는 일단 Paul 의 트리에 머지된 후, tip 트리로 머지되고 나서야 토발즈의
트리에 들어갑니다.  이번에도 tip 트리로 머지되기 위한 패치들이 올라왔습니다.
그중에서도 이 시리즈는 READ_ONCE() 에 들어간 smp_read_barrier_depends() 의
architecture independent 한 코드로부터의 제거를 담고 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.14/</link>
      <pubDate>Mon, 13 Nov 2017 17:07:44 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.14/</guid>
      <description>&lt;h2 id=&#34;linux-414&#34;&gt;Linux 4.14&lt;/h2&gt;
&lt;p&gt;htpps://lkml.kernel.org/r/CA+55aFwqXh4rgJJ3T98k8wa-JYF7t8mWuwUjdxkbZyOyDEcGzQ@mail.gmail.com&lt;/p&gt;
&lt;p&gt;드디어 v4.14 의 릴리즈입니다.  이번 버전은 또하나의 LTS 커널이 될 예정이군요.&lt;/p&gt;
&lt;p&gt;동시에, v4.15 를 위한 머지 윈도우가 열렸습니다.  이번 머지 윈도우는 thanks
giving 이랑 겹치게 되었는데, 이때문에 머지 윈도우를 연장할지 아니면 아예 1주일
줄일지 토발즈는 고민중인 것 같네요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v11-for-415-0124-restartable-sequences-system-call&#34;&gt;[RFC PATCH v11 for 4.15 01/24] Restartable sequences system call&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171114200414.2188-2-mathieu.desnoyers@efficios.com&#34;&gt;https://lkml.kernel.org/r/20171114200414.2188-2-mathieu.desnoyers@efficios.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;몇년전부터 올라오고 있으나 아직 머지되지 못한, restartable sequence 패치의 최신
버전이 또 올라왔습니다.  유저스페이스의 크리티컬 섹션을 커널에게 제어할 수
있도록 도와주는 기능입니다.  이번엔 머지될런지?&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-selftestvm-add-test-case-for-mmap-across-128tb-boundary&#34;&gt;[PATCH V2] selftest/vm: Add test case for mmap across 128TB boundary.&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171123030313.6418-1-aneesh.kumar@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171123030313.6418-1-aneesh.kumar@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;128TB mmap() 에 대한 테스트 케이스가 kselftest 에 추가되었습니다.  x86_64 와
powerpc64 를 지원하는군요.&lt;/p&gt;
&lt;p&gt;이후 몇가지 코멘트를 받고 v3 도 올라왔습니다:
&lt;a href=&#34;https://lkml.kernel.org/r/20171123165226.32582-1-aneesh.kumar@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171123165226.32582-1-aneesh.kumar@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;xarray-documentation&#34;&gt;XArray documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171124011607.GB3722@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20171124011607.GB3722@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난 ossummit europe 에서 흥미롭게 발표를 들었던 XArray 의 문서입니다.  radix
tree 를 대체할 만한 인터페이스를 목표로 하고있다고 하더군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-do-not-stall-register_shrinker&#34;&gt;[PATCH] mm: Do not stall register_shrinker&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1511481899-20335-1-git-send-email-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/1511481899-20335-1-git-send-email-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;메모리가 부족할 때 깨어나 일을 하게 되는 shrinker 의 등록 시 메모리가 부족해서
다른 것들에 의해 shink_slab() 에서 시간을 보내느라 register_shrinker() 에서
수십초씩이나 시스템을 멈춰있게 만드는 문제가 있었는데, shrink_slab() 에서
shrinker 등록 여부를 rwsem 에 대한 contention 확인으로 파악하고 slab shrinking
을 멈춰주도록 수정했습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc8</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc8/</link>
      <pubDate>Wed, 08 Nov 2017 04:19:47 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc8/</guid>
      <description>&lt;h2 id=&#34;linux-414-rc8&#34;&gt;Linux 4.14-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/738207/&#34;&gt;https://lwn.net/Articles/738207/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v4.14 를 향한 (아마도) 마지막 rc 버전의 릴리즈입니다.&lt;/p&gt;
&lt;p&gt;정말로 별다른 일 없었다면 그냥 이번에 v4.14 릴리즈를 할 계획이었지만 그정도는
아니었다고 하는군요.
어쨌든 rc8 덕분에 v4.15 merge window 는 thanksgiving week 를 포함하게 되었는데
토발즈는 이때 가족과 휴가를 갈 계획이라 랩톱 가지고 휴가다니는 동안에도 머지를
잘 할 수 있길 바라지만 문제가 생기면 merge window 를 연장할 수도 있겠다고
하네요.  일단 어떻게 될지 두고보자는군요.&lt;/p&gt;
&lt;p&gt;이번 릴리즈에 포함된 변경은 대부분 드라이버 쪽 변경이고, SPDK 관련 소스코드에
라이센스 추가 등을 한 사소하지만 커다란 양의 변경이 있습니다.  또 하나, 4.13
버전에서 /proc/cpuinfo 가 CPU frequency 를 부정확하게 표시하게 하는 중대한
버그가 있었는데, 다행히 이번에 고쳐졌군요.&lt;/p&gt;
&lt;h2 id=&#34;page-allocator-bottleneck&#34;&gt;Page allocator bottleneck&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/cef85936-10b2-5d76-9f97-cb03b418fd94@mellanox.com&#34;&gt;https://lkml.kernel.org/r/cef85936-10b2-5d76-9f97-cb03b418fd94@mellanox.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;차세대 고속 NIC 에 의해 두각이 드러나는 소프트웨어쪽 bottleneck 을 찾다보니
page allocator 쪽에 오버헤드가 있다는 이야기로 시작된 쓰레드로, 9월부터 시작된
쓰레드인데 요즘 다시 답변이 활기차게 붙고 있습니다.&lt;/p&gt;
&lt;p&gt;ConnectX-5 100 Gbps NIC, Xeon CPU E5-2680 v3 @ 2.50GHz CPU 의 시스템에서
super_netperf 를 사용, 128개 TCP 스트림을 RX queue 갯수 바꿔가며 돌려가며 BW 를
측정했습니다.  mlx5 드라이버를 다음과 같이 수정, 사용했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1) RX page cache disabled, 2 packets per page.
2) RX page cache disabled, one packet per page.
3) Huge RX page cache, one packet per page.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;두번째 드라이버는 200Gbps NIC 을 시뮬레이션 하기 위한 변경입니다.
첫번째, 세번째 드라이버는 RX queue
갯수에 따라 BW 가 증가, line rate 까지 도달하는데 두번째 드라이버는 그렇지
못하고 8개 RX queue 부터는 오히려 BW 가 줄어들었습니다.
이때 perf top 은
&lt;code&gt;85.58% [kernel] [k] queued_spin_lock_slowpath&lt;/code&gt; 를 보여, 페이지 할당 메커니즘의
자체적 성능도 문제고, 확장성도 문제라고 이슈를 최초 제기했습니다.&lt;/p&gt;
&lt;p&gt;PCP (per-CPU) allocator 를 사용해 성능이 좋아지는 걸 확인하고 쓰레드가 닫히는
것 같았는데, 11월 2일자로 다시 새로운 실험 결과를 가지고 왔습니다.
PCP allocator 내의 페이지가 남아있을 동안은 문제가 없지만, 이후부터는 페이지가
할당된 코어와 해제되는 코어가 달라서 buddy allocator 에 부담을 주더란
이야기입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-x86selftests-add-test-for-mapping-placement-for-5-level-paging&#34;&gt;[PATCH] x86/selftests: Add test for mapping placement for 5-level paging&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171108102250.38609-1-kirill.shutemov@linux.intel.com&#34;&gt;https://lkml.kernel.org/r/20171108102250.38609-1-kirill.shutemov@linux.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;x86 의 5-level paging 을 위한 selftest 가 추가되었네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc7</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc7/</link>
      <pubDate>Fri, 03 Nov 2017 14:51:35 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-414-rc7&#34;&gt;Linux 4.14-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwhgxivTE3k88nshbrH9nd-4nhmhXGzw-MxRVGxf-R8Eg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwhgxivTE3k88nshbrH9nd-4nhmhXGzw-MxRVGxf-R8Eg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 버전의 릴리즈입니다.&lt;/p&gt;
&lt;p&gt;OSSE 와 kernel summit 으로 프라하를 방문했던 토발즈인데, 집에 잘
돌아왔다는군요.  이번 rc 버전은 기존의 rc7 보다도 작은 편에 가깝다고 합니다만,
다음 한주간이 정말 조용하지 않는한은 rc8 릴리즈를 할 생각이라는군요.&lt;/p&gt;
&lt;h2 id=&#34;re-page-allocator-bottleneck&#34;&gt;Re: Page allocator bottleneck&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1c218381-067e-7757-ccc2-4e5befd2bfc3@mellanox.com&#34;&gt;https://lkml.kernel.org/r/1c218381-067e-7757-ccc2-4e5befd2bfc3@mellanox.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;멜라녹스의 빠른 네트워크 카드를 사용하는 환경에서는 page allocator 의 속도가
bottleneck 이 된다는 이야기에 대한 업데이트입니다.  여전히 해당 부분이
bottleneck 이며, queued_spin_lock_slowpath() 가 85 % 가까이 CPU 를 차지하고
있군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-swap-readahead-clean-up&#34;&gt;[PATCH 0/2] swap readahead clean up&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1509514103-17550-1-git-send-email-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/1509514103-17550-1-git-send-email-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Swap layer 는 swap in 시에, 연속된 물리 주소의 페이지들을 한번에 읽어들이는
read-ahead 기법을 사용하고 있습니다.  후에 근접한 페이지도 접근될 확률이 높다는
거죠.  하지만 fragmentation 이 심한 환경에서는 꼭 그렇지 않을 수 있습니다.
때문에 virtual address space 에서 연속된 페이지들을 read ahead 하는 패치가
최근에 들어왔는데, 이에 대한 코드 정리 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-ftracedocs-add-documentation-on-how-to-use-ftrace-from-within-the-kernel&#34;&gt;[PATCH v2] ftrace/docs: Add documentation on how to use ftrace from within the kernel&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171031100705.573531cd@gandalf.local.home&#34;&gt;https://lkml.kernel.org/r/20171031100705.573531cd@gandalf.local.home&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;jprobe 가 사라지고 ftrace 가 대신 사용될 예정입니다.  이를 위한 문서의 추가
패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc6</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc6/</link>
      <pubDate>Wed, 25 Oct 2017 12:56:27 +0200</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-414-rc6&#34;&gt;Linux 4.14-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxSJGeN=2X-uX-on1Uq2Nb8+v1aiMDz5H1+tKW_N5Q+6g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxSJGeN=2X-uX-on1Uq2Nb8+v1aiMDz5H1+tKW_N5Q+6g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여섯번째 rc 버전의 릴리즈입니다.&lt;/p&gt;
&lt;p&gt;토발즈 집 인터넷 문제로 평소보다 늦은 릴리즈였군요.
이번 rc 버전은 기대보다는 좀 많은 내용이 추가되었는데, 때문에 어쩌면 rc8 까지
나올지도 모르겠다고 하는군요.  물론 확정되거나 한건 아니라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;re-git-pull-rcunext-rcu-commits-for-415&#34;&gt;Re: [GIT PULL rcu/next] RCU commits for 4.15&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171023204502.GA2776@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171023204502.GA2776@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 에 들어가야 할 RCU 쪽 커밋들의 풀리퀘스트 입니다.&lt;/p&gt;
&lt;p&gt;문서, RCU CPU Stall warning 업데이트, rcutorture 쪽 업데이트가 포함되었네요.&lt;/p&gt;
&lt;h2 id=&#34;git-pull-de-alpha-make-core-code-not-need-to-know-about-alpha-for-v415&#34;&gt;[GIT PULL de-alpha] Make core code not need to know about Alpha for v4.15&lt;/h2&gt;
&lt;p&gt;코어 커널 코드에서 Alpha 를 위한 예외 케이스를 제거하기 위한 작업의 첫번째
결과물이 v4.15 를 향합니다.&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;ACCESS_ONCE()&lt;/code&gt; 를 모두 &lt;code&gt;READ_ONCE()&lt;/code&gt; 와 &lt;code&gt;WRITE_ONCE()&lt;/code&gt; 로 변경하고,
&lt;code&gt;READ_ONCE()&lt;/code&gt; 와 Alpha 의 값을 리턴하는 &lt;code&gt;_release&lt;/code&gt; 와 &lt;code&gt;_relaxed&lt;/code&gt; atomic RMW
오퍼레이션들에 &lt;code&gt;smp_read_barrier_depends()&lt;/code&gt; 를 내장시키며, 따라서 필요없어진
&lt;code&gt;lockless_dereference()&lt;/code&gt; 는 수정된 &lt;code&gt;READ_ONCE()&lt;/code&gt; 로 대체되게 했습니다
(lockless_dereference() 는 사실 READ_ONCE() 플러스 smp_read_barrier_depends()
였는데 smp_read_barrier_depends() 는 Alpha 외의 아키텍쳐에서는 NOOP 이라 Alpha
만을 위해 괜히 복잡했거든요).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc5</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc5/</link>
      <pubDate>Tue, 17 Oct 2017 20:54:24 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_v4.14-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-414-rc5&#34;&gt;Linux 4.14-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyKgEL3dj7XGYsPQd8y_z0GWx91TLZPSQAxjrua1aWOLw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyKgEL3dj7XGYsPQd8y_z0GWx91TLZPSQAxjrua1aWOLw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다섯번째 rc 버전의 릴리즈입니다.&lt;/p&gt;
&lt;p&gt;Lazy TLB flushing 변경은 지나치게 게으르게 TLB flushing 을 해서 AMD 칩 일부에서
문제를 일으키기도 했었다는군요.&lt;/p&gt;
&lt;p&gt;일부 서브시스템에서 fuzzing 을 통한 문제 발견과 수정이 있었는데 좋은
현상이라고도 언급합니다.&lt;/p&gt;
&lt;p&gt;전체적으로 x86, powerpc, mips 에의 arch 업데이트, gpu, networking, usb, sound,
misc 드라이버 업데이트, lockdep, networking, mm 쪽 코어 커널 업데이트, 그리고
perf 와 selftest 에의 업데이트가 있었다고 이번 릴리즈를 정리하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-mm-thp-introduce-dedicated-transparent-huge-page&#34;&gt;[PATCH 0/2] mm, thp: introduce dedicated transparent huge page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1508145557-9944-1-git-send-email-changbin.du@intel.com&#34;&gt;https://lkml.kernel.org/r/1508145557-9944-1-git-send-email-changbin.du@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 의 메모리 할당은 좀 복잡하게 여기저기 코드 복사로 구현되어 있습니다.
HugeTLB 는 별도 인터페이스가 있구요. THP 에도 HugeTLB 처럼 별도 인터페이스를
사용하도록 제안한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-12-lockdep-introduce-crossreleasestacktrace-and-make-it&#34;&gt;[PATCH 1/2] lockdep: Introduce CROSSRELEASESTACKTRACE and make it&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1508318006-2090-1-git-send-email-byungchul.park@lge.com&#34;&gt;https://lkml.kernel.org/r/1508318006-2090-1-git-send-email-byungchul.park@lge.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난번 Johan Hovold 가 이야기한 lockdep crossrelease 에 의한 성능 문제 (부팅
시간이 17초에서 35초까지 늘어났죠)에 대한 해결책입니다.&lt;/p&gt;
&lt;p&gt;stack unwind 를 너무 자주 해서 생긴 문제이므로 이를 선택적으로 할 수 있게 하고
그 디폴트 값을 자주 하지 않도록 수정했네요.&lt;/p&gt;
&lt;p&gt;작은 qemu 머신에서 부팅시간이 lockdep disabled 시 1.543 초, lockdep enabled 시
1.570 초, lockdep + crossrelease enabled 시 1.870 초를 보였는데, 이 패치를
적용한 후 마지막 환경에서 부팅시간이 1.574 초로 줄었습니다.&lt;/p&gt;
&lt;p&gt;패치를 보낸 박병철 님은 커널 로그의 타임스탬프를 통해 부팅 시간을 측정했는데,
Ingo Molnar 는 부팅 시간 테스트에 qemu 시작 스크립트에 init=/bin/true 과 같은
kernel parameter 를 줘서 부팅 완료와 함께 종료되게 하고서 perf &amp;ndash;null &amp;ndash;repeat
옵션을 사용해서 부팅 시간을 측정할 것을 제안했습니다. 유용한 팁 같습니다!&lt;/p&gt;
&lt;p&gt;Linux-kernel examples for LKMM recipes
&lt;a href=&#34;https://lkml.kernel.org/r/20171011223229.GA31650@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171011223229.GA31650@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널에서의 메모리 순서 규칙을 위한 리트머스 테스트들이 실제로 비슷한
패턴으로 사용된 예를 Linux Plumbers Conference 에서 요청받은 Paul E. Mckenney
가 이에 대한 내용을 문서로 만들어 업데이트 했습니다.&lt;/p&gt;
&lt;p&gt;해당 문서는 다음 링크에서도 얻을 수 있습니다:
&lt;a href=&#34;https://github.com/aparri/memory-model/blob/master/Documentation/recipes-LKcode.txt&#34;&gt;https://github.com/aparri/memory-model/blob/master/Documentation/recipes-LKcode.txt&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News - Intro</title>
      <link>https://sjp38.github.io/ko/post/lkml_news_0000/</link>
      <pubDate>Tue, 10 Oct 2017 18:37:00 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/lkml_news_0000/</guid>
      <description>&lt;p&gt;LKML 을 모니터링 하면서 흥미가는 패치나 토론을 &lt;code&gt;lkml news&lt;/code&gt; 라는 카테고리로
묶어서 비정기적, 비형식적으로 간략히 정리하고 관련 소식을 업데이트 해보고자
합니다.  주로 모니터링 하는 메일은 메모리 매니지먼트 쪽과 rcu 관련 메일들이
될겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kernel text addresses removed from calltrace</title>
      <link>https://sjp38.github.io/ko/post/kernel-text-addresses-removed-from-calltrace/</link>
      <pubDate>Fri, 16 Jun 2017 16:46:09 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/kernel-text-addresses-removed-from-calltrace/</guid>
      <description>&lt;p&gt;최근 커널은 stakc dump 에서 콜 트레이스(Call Trace) 에 각 코드의 메모리
어드레스를 찍어주지 않습니다.  이에 대해 포스팅을 해봅니다.&lt;/p&gt;
&lt;h1 id=&#34;call-trace&#34;&gt;Call Trace&lt;/h1&gt;
&lt;p&gt;커널은 문제가 발생하거나 하면 문제의 원인을 찾을 수 있는 다양한 정보를 담고
있는 stack dump 를 로그로 뿌려 줍니다.  문제의 원인을 찾는데 매우 소중한
정보입니다.  그 정보 중에서도 중요한 것 중 하나가 콜 트레이스로, 이 문제의
순간에 오기까지 어느 함수의 어느 지점에서 어느 함수를 호출해서 여기까지
왔는가를 담는 정보입니다.&lt;/p&gt;
&lt;p&gt;디버깅 정보를 담아 빌드된 커널이라면 다음과 같이 사람 눈으로 곧바로 어느정도 알
수 있는 수준의 콜 트레이스가 나옵니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Call Trace:
 [&amp;lt;c12ba080&amp;gt;] ? dump_stack+0x44/0x64
 [&amp;lt;c103ed6a&amp;gt;] ? __warn+0xfa/0x120
 [&amp;lt;c109e8a7&amp;gt;] ? module_put+0x57/0x70
 [&amp;lt;c109e8a7&amp;gt;] ? module_put+0x57/0x70
 [&amp;lt;c103ee33&amp;gt;] ? warn_slowpath_null+0x23/0x30
 [&amp;lt;c109e8a7&amp;gt;] ? module_put+0x57/0x70
 [&amp;lt;f80ca4d0&amp;gt;] ? gp8psk_fe_set_frontend+0x460/0x460 [dvb_usb_gp8psk]
 [&amp;lt;c109f617&amp;gt;] ? symbol_put_addr+0x27/0x50
 [&amp;lt;f80bc9ca&amp;gt;] ? dvb_usb_adapter_frontend_exit+0x3a/0x70 [dvb_usb]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;콜 트레이스는 어떻게 이 순간에 이르게 되었는가를 역순으로 보여줍니다.  즉,
dvd_usb_adapter_frontend_exit() 에서 symbol_put_addr() 를 호출했고, 여기서
gp8psk_fe_set_frontend() 를 호출했고, &amp;hellip; 반복되어 dump_stack() 함수에 의해 이
메세지가 뜬 것이죠.  함수 이름 옆의 &lt;code&gt;0xaa/0xbb&lt;/code&gt; 와 같은 숫자들은 각각 함수
내에서 해당 순간 코드까지의 오프셋, 그리고 해당 함수의 전체 크기를 나타냅니다.&lt;/p&gt;
&lt;p&gt;이것만으로도 많은 정보를 알 수 있지만 해당 함수의 정확히 몇번째 라인에서 문제가
났는지는 이것만으로 알수가 없습니다.  코드를 한줄한줄 눈으로 보고 로그를
추가해보고 하면서 찾을 수도 있겠지만 복장이 터지겠죠.  가장 왼쪽 &lt;code&gt;[&amp;lt;&lt;/code&gt; 와 &lt;code&gt;&amp;gt;]&lt;/code&gt;
사이의 16진수는 메모리 상에서 해당 코드의 주소를 의미합니다.  따라서 디버깅
정보가 있다면 이 주소를 가지고 해당 코드가 어느 파일의 몇번째 라인인지 파악할
수 있습니다.&lt;/p&gt;
&lt;p&gt;이 작업을 위한 도구가 여럿 있는데, &lt;code&gt;addr2line&lt;/code&gt;[1] 도 많이 사용되는 도구 중
하나입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ addr2line -e ../linux.out/vmlinux 0xffffffff810e91f0
linux/arch/x86/include/asm/rwsem.h:83
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;-e&lt;/code&gt; 옵션을 통해 커널 디버깅 정보를 담고 있는 커널 이미지가 위치한 경로를
넘겨주고 마지막 인자로 앞의 콜 트레이스에서 얻어온 주소를 주면 어느 파일의
몇번째 라인을 가리키는지 쉽게 알 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;text-address-removed-from-stack-dump&#34;&gt;Text Address Removed from Stack Dump&lt;/h1&gt;
&lt;p&gt;그런데, 2016년 말 후에 릴리즈된 x86 용 커널은 콜 트레이스에서 위의 addr2line
에 넘겨줘야 할, 어드레스 정보가 더이상 콜 트레이스에 없습니다.  해당되는
커널에서는 다음과 같은 콜 트레이스가 나올 겁니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Call Trace:
 dump_stack+0x85/0xc2
 bad_page+0xc1/0x120
 free_pages_check_bad+0x7a/0x80
 __free_pages_ok+0x32a/0x3e0
 __free_pages+0x19/0x30
 shrink_huge_zero_page_scan+0x50/0x60
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이는 2016년 10월 25일자로 Josh Poimboeuf 에 의해 만들어진 커밋[2] 에 의한
겁니다.  코드의 메모리상 어드레스가 추측 가능할 경우엔 해당 영역에 코드를
바꾼다거나 하는 여러 공격이 들어올 수 있어 보안상 좋지 않습니다.  때문에 최근
시스템은 동일한 프로그램이라 하더라도 메모리에 적재될 때마다 코드의 위치가
바뀌거나 하도록 하는 기능을 갖추고 있습니다.  Address randomization[3] 이 한
예입니다.  따라서 Address randomization 이 가줘져 있다고는 하지만 해당
어드레스를 누구나 볼 수 있는 커널 로그에 뿌리는 것도 좋은 행위는 아닐 뿐더러,
이렇게 나온 정보는 시스템에 따라 무효할 것이기 때문에 적어도 커밋 메세지에는
존재할 필요가 없는데 버그 레포팅 할때 사람들이 뿌려대서 귀찮기만 하다는 것이죠.&lt;/p&gt;
&lt;h2 id=&#34;how-to-find-out-the-line-now&#34;&gt;How to find out the Line, now?&lt;/h2&gt;
&lt;p&gt;문제는, 이렇게 되니 기존의 addr2line 을 이용해 한방에 해결되던 위치 찾기가 좀
복잡해진다는 겁니다.  먼저 해당 함수의 메모리 상 위치를 찾아내고, 그 다음
오프셋을 더해서 해당 코드의 메모리 상 주소를 찾아내어서 다시 addr2line 등을
사용해야 하는 것이죠.&lt;/p&gt;
&lt;p&gt;이게 귀찮다면 만능 도구 &lt;code&gt;gdb&lt;/code&gt; 를 사용할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gdb ../linux.out/vmlinux

...

(gdb) list *(free_pages_check_bad+0x7a)
0xffffffff811daf1a is in free_pages_check_bad (/home/sjpark/linux/mm/page_alloc.c:941).
936     #ifdef CONFIG_MEMCG
937             if (unlikely(page-&amp;gt;mem_cgroup))
938                     bad_reason = &amp;quot;page still charged to cgroup&amp;quot;;
939     #endif
940             bad_page(page, bad_reason, bad_flags);
941     }
942
943     static inline int free_pages_check(struct page *page)
944     {
945             if (likely(page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;하지만 이 방법은 동일한 이름의 심볼이 두개 존재하는 경우 첫번째 심볼에 대해서만
보여줍니다.  따라서 사려 깊은 Josh Poimboeuf 는 저처럼 addr2line 을 좋아하는
사람들을 위해 대체할 도구를 만들었습니다.  그 이름은 faddr2line 으로, 커널
소스의 &lt;code&gt;scripts/&lt;/code&gt; 디렉토리 아래에 있습니다.  다음과 같이 사용할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./scripts/faddr2line ../linux.out/vmlinux free_pages_check_bad+0x7a
free_pages_check_bad+0x7a/0x80:
free_pages_check_bad at mm/page_alloc.c:941
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;두번째 인자로 디버깅 정보 담긴 이미지파일 경로, 그 뒤로 찾고자 하는 코드의
함수와 함수로부터 해당 코드까지의 오프셋을 주면 됩니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;보안적 이유와 쓸모없음으로 인해 2016년 말 후의 커널은 콜 트레이스에서 각 코드의
메모리 어드레스를 제거하고 &lt;code&gt;func_name+0x123/0x456&lt;/code&gt; 포맷으로만 코드 위치를
제공하게 되었습니다.  이로 인해 해당 코드의 파일 내에서의 위치를 찾는데에
예전처럼 &lt;code&gt;addr2line&lt;/code&gt; 을 더 사용할 수는 없게 되었지만 커널 모드의
&lt;code&gt;scripts/faddr2line&lt;/code&gt; 도구를 사용해 예전처럼 쉽게 콜 트레이스의 각 위치의 파일
내에서의 위치를 파악할 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://www.skrenta.com/rt/man/addr2line.1.html&#34;&gt;http://www.skrenta.com/rt/man/addr2line.1.html&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;http://lkml.kernel.org/r/69329cb29b8f324bb5fcea14d61d224807fb6488.1477405374.git.jpoimboe@redhat.com&#34;&gt;http://lkml.kernel.org/r/69329cb29b8f324bb5fcea14d61d224807fb6488.1477405374.git.jpoimboe@redhat.com&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://en.wikipedia.org/wiki/Address_space_layout_randomization&#34;&gt;https://en.wikipedia.org/wiki/Address_space_layout_randomization&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fetching linux kernel source code</title>
      <link>https://sjp38.github.io/ko/post/fetching-linux-source-code/</link>
      <pubDate>Mon, 20 Mar 2017 22:37:03 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/fetching-linux-source-code/</guid>
      <description>&lt;p&gt;리눅스 커널은 오픈 소스 소프트웨어이므로 그 소스코드가 공개되어 있어 누구나
인터넷을 통해 쉽게 얻을 수 있습니다.  이 글에서는 리눅스 커널 소스코드를 받아올
수 있는 몇가지 방법을 설명합니다.&lt;/p&gt;
&lt;h1 id=&#34;kernelorg&#34;&gt;kernel.org&lt;/h1&gt;
&lt;p&gt;리눅스 커널 소스 코드를 받아오기 위한 기본적 공식 사이트는
[kernel.org] (&lt;a href=&#34;https://www.kernel.org&#34;&gt;https://www.kernel.org&lt;/a&gt;) 라 할 수 있겠는데, 이 사이트에는 소스
코드를 포함해 리눅스 커널을 위한 다양한 리소스가 정리되어 있습니다.  이
사이트에 웹브라우저를 통해 들어가보면 첫페이지에서부터 가장 최근에 릴리즈된
버전의 소스코드, 가장 최근의 안정화된 버전의 소스코드 등을 &lt;code&gt;tar.xz&lt;/code&gt; 포맷의 압축
파일 또는 &lt;code&gt;patch&lt;/code&gt; 등 다양한 형태로 다운받을 수 있는 링크가 있습니다.&lt;/p&gt;
&lt;p&gt;한가지 유의할 것은 kernel.org 는 공식적 사이트일 뿐으로 비슷하게 소스코드를
호스팅 하는 사이트는 github 을 포함해 여럿 있을 수 있다는 점입니다.  또한,
특정한 회사나 개인이 수정한 버전의 커널의 소스코드는 kernel.org 에서 받을 수
없을 수 있습니다.  하지만, 리눅스 커널의 라이센스가 GPL 인만큼, 그들도 자신이
수정한 버전을 상품 등으로 배포하고 있다면 소스코드를 공개해야 하므로, 해당
버전을 만든 사람 또는 회사에 문의해 보면 그 소스코드를 받을 수 있을 겁니다.
예를 들어 안드로이드의 경우 자신들이 수정한 커널을 사용하며, 그렇게 수정된
커널의 소스코드를 자신들의 소스코드 [호스팅 사이트]
(&lt;a href=&#34;https://android.googlesource.com/&#34;&gt;https://android.googlesource.com/&lt;/a&gt;) 에 공개하고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;specific-version&#34;&gt;Specific Version&lt;/h2&gt;
&lt;p&gt;kernel.org 첫 페이지에는 몇가지 버전의 소스코드만 존재하므로 찾고 있는 버전은
해당 페이지에 링크가 존재하지 않을 수 있습니다.  특정 버전을 찾기 위한 페이지
역시 kernel.org 는 제공하는데, &lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/&#34;&gt;https://www.kernel.org/pub/linux/kernel/&lt;/a&gt; 주소로
들어가면 특정 버전의 커널 소스코드를 받을 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 4.2.1 버전을 받고 싶다면, 다음 커맨드를 셸에서 수행해 받아올 수
있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.2.1.tar.xz
$ tar xvf linux-4.2.1.tar.xz
$ ls linux-4.2.1
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;git-repository-cloning&#34;&gt;Git Repository Cloning&lt;/h1&gt;
&lt;p&gt;주요 리눅스 개발자들은 각자의 git repository 로 자신이 개발중인 버전의 리눅스
커널 소스코드를 관리하는데, 이 역시 남들이 볼 수 있게 공유해 두고 있습니다.
따라서, 원한다면 특정 리눅스 개발자의 개발중인 리눅스 커널 소스코드를 git 으로
clone 해올 수 있습니다.  많은 주요 개발자들이 kernel.org 위에 자신의 git
repository 를 호스팅 하고 있으며, github 을 사용하는 사람들도 많습니다.  예를
들어 리누스 토발즈는 kernel.org 위에 자신의 git repository 를 호스팅 하면서
github 에 미러링도 하고 있습니다.  각각의 repository 의 주소는 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux.git&#34;&gt;https://github.com/torvalds/linux.git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음과 같은 명령을 통해 리누스 토발즈의 개발중인 리눅스 커널 소스코드를 clone
해올 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
$ ls linux
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;개발자의 repository 를 클론해 오는 방식의 장점은, 일단 아직 릴리즈 되지 않은
따끈따끈한 버전의 소스코드를 그 commit history 와 함께 볼 수 있다는 점일
겁니다.  리눅스 커널 개발에 참여하고 싶다면 현재 어떤 기능이 구현되고 있고 어떤
버그가 아직 고쳐지지 않았는지 등을 알 수 있으므로 필수적입니다.  또하나의
장점은 git repository 에는 그동안 해당 repository 에서 릴리즈한 버전들이 모두
포함되어 있어, 해당 버전을 언제든지 &lt;code&gt;checkout&lt;/code&gt; 할 수 있다는 점입니다.&lt;/p&gt;
&lt;p&gt;단점은, commit history 와 개발중인 코드를 원하는게 아니라면 불필요하게 많은
용량의 데이터를 다운로드 받아야 한다는 것입니다.  현재 소스코드를 필요로 하는
목적에 맞춰, 특정 버전의 코드가 필요할 뿐이라면 압축 파일을, 그렇지 않다면 git
repository 를 사용한 접근을 하는 편이 옳을 겁니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;리눅스 커널의 소스코드를 얻어오는 몇가지 방법을 알아봤습니다.  리눅스 커널은
오픈소스 형태라 그 소스코드를 쉽게 구할 수 있으며, kernel.org 또는 github 등의
호스팅 사이트에서 압축 파일, 패치, 또는 git repository 의 형태로 얻을 수
있습니다.  개발중인 repository 의 clone 을 통한 형태는 commit history 와
개발중인 코드의 정보를 알 수 있다는 장점이 있지만 그만큼 다운로드 받아야 하는
데이터의 양이 크다는 단점도 존재합니다.  자신이 현재 소스코드를 얻고자 하는
목적에 맞춰 적합한 방법으로 소스코드를 얻어오는 것이 좋을 겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>uninstall kernel</title>
      <link>https://sjp38.github.io/ko/post/uninstall-kernel/</link>
      <pubDate>Fri, 20 Jan 2017 13:18:56 +0900</pubDate>
      <guid>https://sjp38.github.io/ko/post/uninstall-kernel/</guid>
      <description>&lt;p&gt;테스트 등을 위해 소스코드로부터 커널을 직접 빌드, 설치하기 시작하면 어느새
수많은 커널이 설치되어 있는 것을 확인할 수 있다.  삭제를 위해선 &lt;code&gt;make install&lt;/code&gt;
로 만들어진 파일들을 직접 제거하고 grub 을 업데이트 해줘야 한다.&lt;/p&gt;
&lt;p&gt;예를 들어 시스템이 현재 부팅되어 있는 버전의 커널을 언인스톨하고자 한다면
다음의 일련의 커맨드를 입력하면 된다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# rm /boot/vmlinuz-$(uname -r)
# rm /boot/initrd.img-$(uname -r)
# rm /boot/System.map-$(uname -r)
# rm /boot/config-$(uname -r)
# rm -fr /lib/modules/$(uname -r)
# rm /var/lib/initramfs-tools/$(uname -r)
# update-grub2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다른 버전의 설치되어있는 커널을 제거하고 싶다면 위의 &lt;code&gt;$(uname -r)&lt;/code&gt; 부분을
제거하고자 하는 커널 버전으로 대체하면 된다.&lt;/p&gt;
&lt;h2 id=&#34;참고-문서&#34;&gt;참고 문서&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://askubuntu.com/questions/594443/how-can-i-remove-compiled-kernel&#34;&gt;http://askubuntu.com/questions/594443/how-can-i-remove-compiled-kernel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
