<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hacklog on Hacklog</title>
    <link>https://sjp38.github.io/</link>
    <description>Recent content in Hacklog on Hacklog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Your Name</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Unit test for the Linux kernel using Kunit</title>
      <link>https://sjp38.github.io/post/kunit_intro/</link>
      <pubDate>Wed, 20 Mar 2019 15:32:29 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/kunit_intro/</guid>
      <description>

&lt;p&gt;지난 2월 말에 FAST&amp;rsquo;19 학회를 다녀왔는데요, &lt;a href=&#34;https://thunk.org/tytso/&#34; target=&#34;_blank&#34;&gt;Ted Tso&lt;/a&gt;
도 왔더군요.  심지어 구글 부스를 지키고 계시더라구요.  어쩌다보니
식사자리에서 합석하고 잡담 나눈 레드햇 개발자 분들이랑 이야기를 하고 있길래
껴서 좀 이야기를 했는데, 이야기 중 테스트에 대한 이야기가 나왔고, 이에 Ted 가
KUnit 이라는 도구를 소개해 줬습니다.  잠깐 사용해 보니 매우 매력적인 것 같아서
이 블로그에서도 소개해 볼까 합니다.&lt;/p&gt;

&lt;p&gt;KUnit 은 이름에서 짐작했겠지만 리눅스 커널을 위한 유닛 테스트 프레임웍입니다.
구글의 Brendan Higgins 라는 분이 개발하고 있고, 커널 내에 머지되는 걸 목표로
해서 LKML 에도 &lt;a href=&#34;https://lkml.org/lkml/2019/2/14/1144&#34; target=&#34;_blank&#34;&gt;RFC 패치&lt;/a&gt;를 보내고
있습니다.
구글러다 보니 구글에서 호스팅 되는
&lt;a href=&#34;https://kunit.googlesource.com/linux/&#34; target=&#34;_blank&#34;&gt;소스트리&lt;/a&gt; 위에서 개발을 하고 있고,
&lt;a href=&#34;https://google.github.io/kunit-docs/third_party/kernel/docs/&#34; target=&#34;_blank&#34;&gt;문서화&lt;/a&gt; 도 잘
해뒀군요.&lt;/p&gt;

&lt;p&gt;이 글은 이런 KUnit 을 사용하는 법을 간단히 정리해 봅니다.  글 내의 테스트에
사용된 환경은 Ubuntu 16.04 서버 버전입니다.&lt;/p&gt;

&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;

&lt;p&gt;Kunit 개발 커널은 &lt;a href=&#34;https://kunit.googlesource.com&#34; target=&#34;_blank&#34;&gt;https://kunit.googlesource.com&lt;/a&gt; 에서 받을 수 있습니다.  간단히
아래 명령으로 커널 코드를 땡겨옵시다.  여기선 가장 최근에 RFC 패치를 보냈던
5.0-rc5 위의 버전으로 가져오겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone -b kunit/rfc/5.0-rc5/v4 https://kunit.googlesource.com/linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;물론, &lt;a href=&#34;https://lore.kernel.org/patchwork/project/lkml/list/?series=383391&#34; target=&#34;_blank&#34;&gt;Patchwork&lt;/a&gt; 을 통해
KUnit 패치만 직접 받아와 사용중인 커널에 적용하실 수도 있습니다.  전 v5.0 버전
위에도 적용해 봤는데 문제 없이 잘 적용되더군요.&lt;/p&gt;

&lt;p&gt;이어서 KUnit 을 위한 패키지를 깔아야 할텐데요, 커널 빌드에 필요한 패키지만 깔면
됩니다.  커널 빌드에 필요한 패키지에 대한 정보는 이 블로그의 커널 빌드 및
설치에 대한 &lt;a href=&#34;https://sjp38.github.io/post/linux-kernel-build/&#34; target=&#34;_blank&#34;&gt;포스트&lt;/a&gt; 를 참고해 주세요.&lt;/p&gt;

&lt;h1 id=&#34;test&#34;&gt;Test&lt;/h1&gt;

&lt;p&gt;커널 빌드 종속성 패키지까지 다 설치했다면 준비가 거의 끝났습니다.  잘 돌아가는지 확인해 보기 위해 kunit 에서 제공하는 예제 테스트들을 돌려봅시다.&lt;/p&gt;

&lt;p&gt;KUnit 을 돌리기 위해선 configuration 을 커널 트리 루트에 &lt;code&gt;kunitconfig&lt;/code&gt; 라는
이름의 파일로 써줘야 합니다.  이 설정은 어떤 테스트를 돌릴지 등을 지정합니다.
일단 아래 내용으로 해당 파일을 써줍시다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd linux
$ echo CONFIG_KUNIT=y &amp;gt; kunitconfig
$ echo CONFIG_KUNIT_TEST=y &amp;gt;&amp;gt; kunitconfig
$ echo CONFIG_KUNIT_EXAMPLE_TEST=y &amp;gt;&amp;gt; kunitconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 다음의 간단한 명령만으로 KUnit 예제 테스트를 돌릴 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./tools/testing/kunit/kunit.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래와 같은 결과가 터미널에 뜰겁니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[11:31:47] Building KUnit Kernel ...
[11:32:12] Starting KUnit Kernel ...
[11:32:12] ==============================
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_init_resources
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_alloc_resource
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_free_resource
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_cleanup_resources
[11:32:13] ==============================
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_try_catch_successful_try_no_catch
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_try_catch_unsuccessful_try_does_catch
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_generic_try_catch_successful_try_no_catch
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_generic_try_catch_unsuccessful_try_does_catch
[11:32:13] ==============================
[11:32:13] [PASSED] string-stream-test:string_stream_test_get_string
[11:32:13] [PASSED] string-stream-test:string_stream_test_add_and_clear
[11:32:13] ==============================
[11:32:13] [PASSED] example:example_simple_test
[11:32:13] ==============================
[11:32:13] Testing complete. 11 tests run. 0 failed. 0 crashed.
[11:32:13] Elapsed time: 26.005s total, 0.000s configuring, 25.736s building, 0.268s running.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;kunit-resource-test, kunit-try-catch-test, string-stream-tets, example&lt;/code&gt; 등의
예제 테스트가 돌아갔고, 모두 테스트를 통과해서 문제가 없음을 보여줍니다.&lt;/p&gt;

&lt;p&gt;KUnit 은 테스트를 위해 커널도 빌드하기 때문에 빌드 시간이 조금 길긴 합니다.  이
경우엔 26초 정도 걸렸네요.  하지만 이건 처음 빌드라 그렇고, 기존에 빌드를
해두고 파일 하나만 수정하는 경우엔 약 10초 정도 걸리는 것 같습니다.  하지만
이후 실제 테스트를 돌리는건 매우 짧은 시간을 필요로 합니다.  이 경우 0.27초
가량 걸렸군요!  따라서 테스트가 늘어나도 많은 시간을 요하지 않습니다.&lt;/p&gt;

&lt;p&gt;스스로를 위한 유닛 테스트를 추가하는 법은 Kunit 공식 문서[1] 를 참고하시기
바랍니다.  어렵지 않습니다 :)&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://google.github.io/kunit-docs/third_party/kernel/docs/start.html#writing-your-first-test&#34; target=&#34;_blank&#34;&gt;https://google.github.io/kunit-docs/third_party/kernel/docs/start.html#writing-your-first-test&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;리눅스 커널을 위한 Unit test framework 인 KUnit 에 대한 간단한 소개와 사용법을
설명했습니다.  저도 최근 개발에 활용하고 있는데, TDD 의 장점을 오랫만에 느낄 수
있었습니다.  하루 빨리 업스트림에도 머지되었으면 좋겠네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gitlab docker install</title>
      <link>https://sjp38.github.io/post/gitlab_docker_install/</link>
      <pubDate>Tue, 19 Mar 2019 16:39:48 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/gitlab_docker_install/</guid>
      <description>

&lt;p&gt;연구실 내부 사용을 위한 Gitlab 을 Docker 를 사용해서 구축하고 사용하고
있습니다만, 하도 예전이라 Gitlab official docker image 가 아니었고, docker
버전도 2.x 대라서 최신 버전으로 바로 업그레이드가 불가능하군요.&lt;/p&gt;

&lt;p&gt;지금은 gitlab 에서 자체적으로 정식 docker 이미지를 제공합니다.
이 포스트에서는 Ubuntu 18.04 서버 위에 gitlab 정식 docker 이미지를 사용해
설치하는 방법을 기록합니다.&lt;/p&gt;

&lt;h1 id=&#34;docker-설치&#34;&gt;Docker 설치&lt;/h1&gt;

&lt;p&gt;먼저 Docker 를 설치해야죠.  문서[1]를 참고해서 설치를 진행해 봅니다.&lt;/p&gt;

&lt;p&gt;먼저 apt 업데이트 후 종속 패키지들을 깔아줍니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 최신 docker 를 깔기 위해 docker repository 를 apt 에 추가해 주고요:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&amp;quot;
sudo apt update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설치합시다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install docker-ce
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;잘 깔렸는지 확인해 봅시다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run hello-world
Unable to find image &#39;hello-world:latest&#39; locally
latest: Pulling from library/hello-world
1b930d010525: Pull complete 
Digest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 &lt;code&gt;Hello from Docker!&lt;/code&gt; 가 나오면 된겁니다.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04&#34; target=&#34;_blank&#34;&gt;https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;gitlab-설치&#34;&gt;Gitlab 설치&lt;/h1&gt;

&lt;h2 id=&#34;일단-시작&#34;&gt;일단 시작&lt;/h2&gt;

&lt;p&gt;이제 Gitlab docker image 를 가져오고 돌려보죠.  Gitlab 쪽 문서[1]를 참고합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd $HOME; mkdir data
$ sudo docker run --detach --hostname gitlab.example.com \
		--publish 30443:443 --publish 30480:80 --publish 30422:22 \
		--name gitlab --restart always \
		--volume $HOME/data/srv/gitlab/config:/etc/gitlab \
		--volume $HOME/data/srv/gitlab/logs:/var/log/gitlab \
		--volume $HOME/data/srv/gitlab/data:/var/opt/gitlab \
		gitlab/gitlab-ce:11.8.2-ce.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 글 작성 시점 기준으로 가장 마지막 정식 릴리즈가 11.8 이므로 11.8.2 버전을
골랐고, 기존에 웹서버와 ssh 가 깔려있는 관계로 별도의 포트를 사용하게 했습니다.&lt;/p&gt;

&lt;p&gt;조금 기다렸다가 &lt;a href=&#34;http://gitlab.example.com:30480&#34; target=&#34;_blank&#34;&gt;http://gitlab.example.com:30480&lt;/a&gt; 으로 들어가면 로그인 됩니다.
&lt;code&gt;$ sudo docker ps -a&lt;/code&gt; 명령을 통해 만든 컨테이너의 status 가 &lt;code&gt;starting&lt;/code&gt; 을
넘어갈 때까지만 기다리면 됩니다.
최초 로그인 시에는 관리자 패스워드를 바로 설정할 수 있습니다.
이후 root 계정에 지금 설정한 패스워드를 입력해 접속할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;설정-변경&#34;&gt;설정 변경&lt;/h2&gt;

&lt;p&gt;몇가지 설정을 추가해야 합니다.  설정은 아래 명령으로 지금 띄운 컨테이너에
들어가 설정 파일을 수정하는 것으로 가능합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker exec -it gitlab /bin/bash
# vi /etc/gitlab/gitlab.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--volume&lt;/code&gt; 으로 &lt;code&gt;$HOME/data/srv/gitlab/config&lt;/code&gt; 아래로 파일이 링크되어 있으므로
여기서 수정해도 괜찮습니다.&lt;/p&gt;

&lt;p&gt;해당 파일을 변경한 후에는 docker 를 재시작 해야 변경된 설정이 적용됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker restart gitlab
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;포트-변경-적용&#34;&gt;포트 변경 적용&lt;/h2&gt;

&lt;p&gt;호스트의 80 포트, 22 포트, 443 포트를 점유할 수 없는 상황이므로 우린 30480,
30422, 30443 포트를 대신 사용하도록 했습니다.
이 경우 추가적인 설정이 필요합니다.
&lt;code&gt;gitlab.rb&lt;/code&gt; 파일에 아래 네줄을 추가합시다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;external_url &#39;http://gitlab.example.com:30480&#39;
nginx[&#39;listen_port&#39;] = 80
nginx[&#39;listen_https&#39;] = false
gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] = 30422
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두번째, 세번째 줄을 추가 안해주면 동작 안합니다[3].&lt;/p&gt;

&lt;h2 id=&#34;gmail-smtp-설정&#34;&gt;gmail smtp 설정&lt;/h2&gt;

&lt;p&gt;이어서 smtp 설정을 해야 합니다.&lt;/p&gt;

&lt;p&gt;우린 gmail smtp 를 사용하겠습니다.  이 설정 파일에 다음과 같은 내용을
추가합니다.  이 내용은 공식 문서의 예제[2]에서 가져왔습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gitlab_rails[&#39;smtp_enable&#39;] = true
gitlab_rails[&#39;smtp_address&#39;] = &amp;quot;smtp.gmail.com&amp;quot;
gitlab_rails[&#39;smtp_port&#39;] = 587
gitlab_rails[&#39;smtp_user_name&#39;] = &amp;quot;my.email@gmail.com&amp;quot;
gitlab_rails[&#39;smtp_password&#39;] = &amp;quot;my-gmail-password&amp;quot;
gitlab_rails[&#39;smtp_domain&#39;] = &amp;quot;smtp.gmail.com&amp;quot;
gitlab_rails[&#39;smtp_authentication&#39;] = &amp;quot;login&amp;quot;
gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true
gitlab_rails[&#39;smtp_tls&#39;] = false
gitlab_rails[&#39;smtp_openssl_verify_mode&#39;] = &#39;peer&#39; # Can be: &#39;none&#39;, &#39;peer&#39;, &#39;client_once&#39;, &#39;fail_if_no_peer_cert&#39;, see http://api.rubyonrails.org/classes/ActionMailer/Base.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;my.email&lt;/code&gt; 과 &lt;code&gt;my-gmail-password&lt;/code&gt; 는 당연히 실제 gmail 계정으로
바꿔야겠죠?  해당 gmail 계정도 gmail 설정에서 smtp 를 사용할 수 있게 설정해
줘야 합니다.&lt;/p&gt;

&lt;h2 id=&#34;가입-기능-제거&#34;&gt;가입 기능 제거&lt;/h2&gt;

&lt;p&gt;gitlab 첫페이지는 &lt;code&gt;sign in&lt;/code&gt; 과 &lt;code&gt;register&lt;/code&gt; 기능이 있습니다.  처음 사용하는
유저는 &lt;code&gt;register&lt;/code&gt; 를 사용하면 되는거죠.&lt;/p&gt;

&lt;p&gt;하지만 우린 폐쇄적으로 운영할 꺼라 계정을 관리자 통해서만 만들 수 있게 하고
싶습니다.  Admin area -&amp;gt; Settings -&amp;gt; General -&amp;gt; Sign-up restrictions 메뉴에서
Sign-up enabled 를 비활성화 시키고 변경사항 저장 버튼을 누릅니다.
이제 gitlab 첫페이지에 &lt;code&gt;register&lt;/code&gt; 기능이 사라져 있을 겁니다.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://docs.gitlab.com/omnibus/docker/&#34; target=&#34;_blank&#34;&gt;https://docs.gitlab.com/omnibus/docker/&lt;/a&gt;
[2] &lt;a href=&#34;https://docs.gitlab.com/omnibus/settings/smtp.html&#34; target=&#34;_blank&#34;&gt;https://docs.gitlab.com/omnibus/settings/smtp.html&lt;/a&gt;
[3] &lt;a href=&#34;https://gitlab.com/gitlab-org/omnibus-gitlab/issues/3535&#34; target=&#34;_blank&#34;&gt;https://gitlab.com/gitlab-org/omnibus-gitlab/issues/3535&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.1-rc1/</link>
      <pubDate>Mon, 04 Mar 2019 13:07:30 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.1-rc1/</guid>
      <description>

&lt;p&gt;Linux v5.0 릴리즈 (2019-03-03) 부터 v5.1-rc1 릴리즈 (2019-03-17) 사이의 머지
윈도우 기간 LKML 에 올라온 흥미로운 메일들을 소개합니다.&lt;/p&gt;

&lt;h2 id=&#34;cma-allocation-failure&#34;&gt;CMA allocation failure&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/57e0bc63-0be9-498b-8ffc-3b073e01e299@email.android.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/57e0bc63-0be9-498b-8ffc-3b073e01e299@email.android.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;제게도 GCMA 레이턴시 관련 문의를 보냈던 분인데, LKML 에도 관련 도움을 요청하는
메일을 보냈군요.&lt;/p&gt;

&lt;p&gt;왜 CMA 가 할당에 실패하는지 이유를 묻는 메일인데요, 답은 없습니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-using-xarray-to-manage-the-vma&#34;&gt;[LSF/MM TOPIC] Using XArray to manage the VMA&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/7da20892-f92a-68d8-4804-c72c1cb0d090@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/7da20892-f92a-68d8-4804-c72c1cb0d090@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;MM 의 오랜 숙원 중 하나는 &lt;code&gt;mmap_sem&lt;/code&gt; 으로 인한 확장성 문제 해결이죠.  기존의 RB
tree 대신 XArray 를 사용하는 것으로 새로운 시도를 시작해 보는건 어떨지 LSFMM
에서 토의해보자는, speculative page fault 의 최근 메인테이너인 Laurent 의
메일입니다.
곧바로 XArray 메인테이너인 Matthew 의 답장이 오는군요.
꼭 해보려는 의지가 강력해 보입니다.&lt;/p&gt;

&lt;h2 id=&#34;mm-cma-c-high-latency-for-cma-allocation&#34;&gt;mm/cma.c: High latency for cma allocation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/SG2PR02MB3098E44824F5AA69BC04F935E8470@SG2PR02MB3098.apcprd02.prod.outlook.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/SG2PR02MB3098E44824F5AA69BC04F935E8470@SG2PR02MB3098.apcprd02.prod.outlook.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이어지는 CMA 레이턴시에 대한 문의입니다.  제게 GCMA 레이턴시에 대해 온 문의에
대해서는 제 실험 환경을 보내주고 그쪽 환경에서 돌려본 후 결과를 알려달라
했는데, 아직 답이 없군요.
좀 더 자세한 분석 결과를 달라는 Michal 의 답변이 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-1-rc1&#34;&gt;Linux 5.1-rc1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wj1c_Tb-wwM6qaPLdggXtW3rOh1JzYUOs+O7PsHt-=+jg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wj1c_Tb-wwM6qaPLdggXtW3rOh1JzYUOs+O7PsHt-=+jg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;v5.1 머지 윈도우가 종료되고 v5.1-rc1 이 릴리즈 되었습니다.  이번 릴리즈도 크게
다른 건 없고 매우 평범했다고 합니다.  좋은 징조인데요, 변경사항의 60%를 차지한
드라이버 가운데 habanalab 의 AI 가속기 칩 드라이버를 조금 특별한 변경사항으로
토발즈는 꼽네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0/</link>
      <pubDate>Mon, 25 Feb 2019 13:16:39 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0/</guid>
      <description>

&lt;p&gt;Linux v5.0-rc8 릴리즈 (2019-02-24) 부터 Linux v5.0 릴리즈 (2019-03-03) 사이
기간에 LKML 에 올라온 흥미로운 메일들을 소개합니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-5-v5-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;&lt;code&gt;[PATCH 0/5] [v5] Allow persistent memory to be used like normal RAM&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190225185727.BCBD768C@viggo.jf.intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190225185727.BCBD768C@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앞서 몇번 소개했던, persistent memory 를 좀 많이 느린 numa node 인 것처럼 해서
시스템이 사용할 수 있게 하는 접근법의 패치 다섯번째 버전입니다.
이제 개선은 어느정도 된 것 같으니 슬슬 머지되야하지 않겠냐고 주장하는군요.&lt;/p&gt;

&lt;h2 id=&#34;linux-v5-0&#34;&gt;Linux v5.0&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjuG6HiGbD7DCGfvDvhr_1WZUR-eYF2qWGbYyn9k6unvg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjuG6HiGbD7DCGfvDvhr_1WZUR-eYF2qWGbYyn9k6unvg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;마침내 5.0 릴리즈입니다!  제 랩톱에도 바로 받아다가 설치했습니다! ;)  물론 5.0
릴리즈에 특별한 기능 추가라던지 하는건 없고 그저 시간이 꽤 지나서 이렇게
된거라곤 하지만 어쨌든 느낌은 새롭군요.&lt;/p&gt;

&lt;p&gt;rc8 릴리즈 후에도 양은 크게 줄었지만 패치가 좀 있었습니다.  그렇게 고쳐진 버그
중 하나로는 uninitialized variable 문제가 있었는데, gcc 가 알아서 초기화를
시켜주다보니 워닝이 안떴었군요.  물론 다른 컴파일러를 사용하면 문제가 생기게
되니 무쓸모한 변경은 아니었다 자평합니다.&lt;/p&gt;

&lt;p&gt;어쨌든, 이렇게 v5.0 커널이 정식으로 나왔고, v5.1 을 향한 여정이 시작되었습니다!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc8</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc8/</link>
      <pubDate>Tue, 19 Feb 2019 08:33:37 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc8/</guid>
      <description>

&lt;p&gt;Linux v5.0-rc7 릴리즈 (2019년 2월 17일) 부터 v5.0-rc8 릴리즈 (2019년 2월 24일)
사이의 기간에 LKML 에 올라온 흥미로운 메일들을 소개합니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-attend-mm-track-numa-thp-locality-reclaim&#34;&gt;[LSF/MM ATTEND] MM track: NUMA, THP locality, reclaim&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190218143203.GW9565@techsingularity.net&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190218143203.GW9565@techsingularity.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mel Gorman 의 LSF/MM 참여 메일입니다.  NUMA remote THP vs NUMA local non-THP,
NUMA, 메모리 계층 그리고 디바이스 메모리, NUMA rebalancing 과 메모리 reclaim 에
참여하고 싶다고 이야기 하는군요.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-lsf-mm-attend-read-only-mapping-of-program-text&#34;&gt;&lt;code&gt;[LSF/MM TOPIC ][LSF/MM ATTEND] Read-only Mapping of Program Text&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/379F21DD-006F-4E33-9BD5-F81F9BA75C10@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/379F21DD-006F-4E33-9BD5-F81F9BA75C10@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;THP 를 활용해 read-only text 를 매핑함으로써 성능을 높이려는 시도를 해오고
있는데, 하나의 base page 를 먼저 읽고 이어서 추가적인 page 를 읽는게 진짜로
사용될지 모르는 readahead 때문에 의논을 해보고 싶다고 하네요.
또, 파일시스템에게 컨텐츠가 큰 청크를 필요로 할지 알려주는 인터페이스가 있으면
좋겠다는군요.&lt;/p&gt;

&lt;h2 id=&#34;linux-v5-0-rc8&#34;&gt;Linux v5.0-rc8&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgtNhecfn_nOi0Yuy7XQSswfozz0CvRMn0WsQhk0YZfyw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgtNhecfn_nOi0Yuy7XQSswfozz0CvRMn0WsQhk0YZfyw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;rc8 이 나올지 바로 v5.0 이 나올지 궁금했는데, 결국 v5.0 릴리즈는 한주 더
미뤄지게 되었습니다.  rc7 때보다도 많은 패치가 이번 기간에 들어왔다는군요.&lt;/p&gt;

&lt;p&gt;그렇다고 아주 특별한 변경이 있었던 건 아니지만 그렇다고 서두를 것도 없으므로
그냥 rc8 을 릴리즈하기로 결정했다고 하네요.&lt;/p&gt;

&lt;p&gt;어쨌건 다음주에는 분명 v5.0 이 나오겠죠!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc7/</link>
      <pubDate>Mon, 18 Feb 2019 12:30:24 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc7/</guid>
      <description>

&lt;h2 id=&#34;patch-v15-00-18-block-support-multi-page-bvec&#34;&gt;[PATCH V15 00/18] block: support multi-page bvec&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190215111324.30129-1-ming.lei@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190215111324.30129-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;시스템의 RAM 이 커지고 huge page 가 널리 사용되면서 물리적으로 연속된
페이지들의 I/O 가 흔해지고 있습니다.  이를 위해 &lt;code&gt;struct bio_bvec&lt;/code&gt; 이 물리적으로
연속된 여러 페이지를 다룰 수 있게 해주는 패치의 15번째 버전입니다.&lt;/p&gt;

&lt;h2 id=&#34;memory-management-facing-a-400gpbs-network-link&#34;&gt;Memory management facing a 400Gpbs network link&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/01000168e2f54113-485312aa-7e08-4963-af92-803f8c7d21e6-000000@email.amazonses.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/01000168e2f54113-485312aa-7e08-4963-af92-803f8c7d21e6-000000@email.amazonses.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;올해 내로 400Gbps 인피니밴드가 가능해질 거라고 합니다!  이건 프로세서-메모리
사이의 밴드위쓰를 넘길 수 있는 스피드죠!  단일 하드웨어 쓰레드는 20GB/s 이기
때문입니다.  이 재미있는 트렌드를 커널은 어떻게 대처해야 할 것인가 하는
메일입니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-generating-physically-contiguous-memory&#34;&gt;[LSF/MM TOPIC] Generating physically contiguous memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CEDBC792-DE5A-42CB-AA31-40C039470BD0@nvidia.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CEDBC792-DE5A-42CB-AA31-40C039470BD0@nvidia.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GPU, FPGA, NIC, RDMA 같은 고성능 디바이스들에게 있어 물리적 연속 메모리는 매우
중요합니다.  이 디바이스들은 내부적으로 고밀도의 computation 을 하는데 tlb miss
와 이어지는 page table walk 로 인한 성능 문제가 CPU 에 비해서도 매우 크기
때문이라는군요.&lt;/p&gt;

&lt;p&gt;Boot time reservation 도, THP 도 유연성이 부족하기 때문에 새로운 패치도 만들고,
관련해서 LSF/MM 에서 논의해 보자는군요.&lt;/p&gt;

&lt;h2 id=&#34;rfc-v4-00-17-kunit-introduce-kunit-the-linux-kernel-unit-testing-framework&#34;&gt;[RFC v4 00/17] kunit: introduce KUnit, the Linux kernel unit testing framework&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190214213729.21702-1-brendanhiggins@google.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190214213729.21702-1-brendanhiggins@google.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 커널은 다양한 테스트를 가지고 있지만 unit test framework 은 아직 없었죠.
그걸 만든 패치입니다!&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc7&#34;&gt;Linux 5.0-rc7&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgvF18PqBch4=56DFwCamYpy+owngTZXGnjVbFgKq467g@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgvF18PqBch4=56DFwCamYpy+owngTZXGnjVbFgKq467g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;휴일을 끼고 시작된 머지 윈도우로 이래저래 걱정도 있던 5.0 릴리즈들이었습니다만
이번 rc 릴리즈는 정말 별다른 게 없네요.  매우 고요한 릴리즈였다고 합니다.
아마도 다음주에 5.0 정식 릴리즈가 될 걸로 보이네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc6/</link>
      <pubDate>Mon, 11 Feb 2019 12:40:20 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc6/</guid>
      <description>

&lt;h2 id=&#34;patch-v4-1-1-psi-introduce-psi-monitor&#34;&gt;[PATCH v4 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;] psi: introduce psi monitor&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190206023446.177362-1-surenb@google.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190206023446.177362-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;시스템의 메모리 부족 등의 현상이 어떻게 일어나고 있는지 쉽게 파악할 수 있는
장치를 추가하는 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-address-space-isolation-inside-the-kernel&#34;&gt;[LSF/MM TOPIC] Address space isolation inside the kernel&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190207072421.GA9120@rapoport-lnx&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190207072421.GA9120@rapoport-lnx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스의 어드레스 스페이스 기능은 유저스페이스 프로그램들이 서로에게 영향을
끼치지 못하게 해줘서 컨테이너 등에 쓰이고 있죠.  하지만 커널은 공유하기 때문에
커널 버그는 여전히 영향을 끼칠 수 있습니다.  커널 코드도 어드레스 스페이스를
어느정도 인식하고 코드 분류를 시킴으로써 그 문제를 줄여보자는 LSF/MM 토론 주제
제안입니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-2019-call-for-proposals-updated&#34;&gt;LSF/MM 2019: Call for Proposals (UPDATED!)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/4f5a15c1-4f9e-acae-5094-2f38c8eebd96@kernel.dk&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/4f5a15c1-4f9e-acae-5094-2f38c8eebd96@kernel.dk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;올해 LSF/MM 에는 BPF 트랙이 있을 거라는군요.  이에 따른 공지 업데이트입니다.
BPF 의 상승세가 올해도 계속될 것 같군요!&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-bpf-for-block-devices&#34;&gt;[LSF/MM TOPIC] BPF for Block Devices&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/40D2EB06-6BF2-4233-9196-7A26AC43C64E@raithlin.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/40D2EB06-6BF2-4233-9196-7A26AC43C64E@raithlin.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LSF/MM 에 BPF 라면 당연히 block device 와 BPF 의 결합을 이야기 해야하지
않겠냐는 LSF/MM 토론 제안입니다.  Computational Storage 개념을 이야기 하는데요,
I/O 레이어에서 간단한 연산을 처리해 줌으로써 성능을 높이자는 거죠.  그러기 위한
연산 요청에 BPF 를 쓰자는 것 같습니다.  말 되네요!&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc6&#34;&gt;Linux 5.0-rc6&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whuSY_-hAU8ugVR7a=xz3uZeRrAPdhsoMZHmZ_7Qc49YQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whuSY_-hAU8ugVR7a=xz3uZeRrAPdhsoMZHmZ_7Qc49YQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이제 리눅스 5.0 정식 릴리즈가 얼마 남지 않았네요, 여섯번째 rc 가 나왔습니다.
그런데 이번 rc 는 토발즈가 바랬던 것보다는 조금 변경사항이 많았군요.  대부분
네트워킹 쪽 변경이었다고 합니다만, 그래도 나머지는 큰 문제 없어 보인다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc5/</link>
      <pubDate>Mon, 04 Feb 2019 09:18:08 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc5/</guid>
      <description>

&lt;h2 id=&#34;lsf-mm-topic-page-flags-can-we-free-up-space&#34;&gt;[LSF/MM TOPIC] Page flags, can we free up space ?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190122201744.GA3939@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190122201744.GA3939@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 커널의 page 정보는 &lt;code&gt;PG_&lt;/code&gt; 로 시작하는 플래그를 사용해 현재 상태를
알리는데요, 이걸 저장하는데 사용되는 공간을 더 줄일 수 있을지에 대한 논의를
해보고 싶다는 LSF/MM 제안입니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-use-nvdimm-as-numa-node-and-numa-api&#34;&gt;[LSF/MM TOPIC] Use NVDIMM as NUMA node and NUMA API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/f0d66b0c-c9b6-a040-c485-1606041a70a2@linux.alibaba.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/f0d66b0c-c9b6-a040-c485-1606041a70a2@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;알리바바에서는 NVDIMM 을 클라우드 고객들에게 싼 비용의 메모리로 제공하려
한다는군요.  이를 위해 여러 필요성이 있고, 현재 NUMA API 로는 모든 경우를
커퍼하기가 어렵다고 합니다.  때문에, LSFMM 에서 어떤 use-case 와 needs 가
있는지 공유하고 더 나은 NUMA API 에 대해 논의하고자 하는군요.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-memory-reclaim-with-numa-rebalancing&#34;&gt;[LSF/MM TOPIC] memory reclaim with NUMA rebalancing&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190130174847.GD18811@dhcp22.suse.cz&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190130174847.GD18811@dhcp22.suse.cz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;NVDIMM 을 싸고 무척 느린 NUMA 노드로 인식되고 사용되게끔 하고자 하는 노력들이
있습니다.  이게 완벽하게 동작하려면 hot page 는 가깝고 빠른 NUMA node 에, cold
page 는 멀고 느린 NUMA node 에 위치되도록 커널이 조정해줄 필요가 있겠죠.  NUMA
balancing 기능이 있긴 하지만 cold page 를 멀고 느린 NUMA node 로 보내는 기능은
현재까지는 없습니다.  이에 대한 논의를 LSF/MM 에서 시작해 보자고 하네요.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc5&#34;&gt;Linux 5.0-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjoGOgYFCbpazT2Fyv=zHaiagU5PhmiAfrZ5DOmE-y0rg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjoGOgYFCbpazT2Fyv=zHaiagU5PhmiAfrZ5DOmE-y0rg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아무래도 이번 릴리즈들은 머지 윈도우가 길고 연휴와 함께 있었던 탓인지
전체적으로 뭔가 변경사항이 줄지 않는듯 보였는데, 드디어 변경사항이 줄어들고
있다고 합니다.  좋은 신호죠.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the FAST&#39;19</title>
      <link>https://sjp38.github.io/post/fast2019_talk/</link>
      <pubDate>Sat, 02 Feb 2019 11:13:29 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/fast2019_talk/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.usenix.org/conference/fast19/wips&#34; target=&#34;_blank&#34;&gt;FAST&amp;rsquo;19 Work-in-progress 세션&lt;/a&gt;
에서 현재 진행중인 연구에 대해 발표하게 되었습니다.  발표 제목은 &amp;ldquo;Automated
Data Access Pattern Hint Instrumentation for System Performance and Durability
of Swap Storage&amp;rdquo; 입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc4/</link>
      <pubDate>Mon, 28 Jan 2019 09:21:25 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc4/</guid>
      <description>

&lt;h2 id=&#34;patch-0-5-v4-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;&lt;code&gt;[PATCH 0/5] [v4] Allow persistent memory to be used like normal RAM&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190124231441.37A4A305@viggo.jf.intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190124231441.37A4A305@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PMEM 을 평범한 RAM 처럼 접근할 수 있게 해주는 드라이버를 소개하는 패치셋의
네번째 버전입니다.  인터페이스적 측면에서 개선이 많이 됐고, 패치에 대한 소개도
많이 좋아졌네요.&lt;/p&gt;

&lt;p&gt;이 패치셋이 의도하는 PMEM 은 Intel Optane DC persistent memory 와 같은 NVDIMM
입니다.  휘발성이 없고, flash 보다 빠르고, RAM 에 비해 가격 경쟁력이 좋죠.&lt;/p&gt;

&lt;p&gt;RAM-based NVDIMM 은 의도한 대상이 아닙니다.  그것들은 RAM 대비 가격 경쟁력이
없기 때문이라는군요.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-numa-remote-thp-vs-numa-local-non-thp-under-madv-hugepage&#34;&gt;[LSF/MM TOPIC] NUMA remote THP vs NUMA local non-THP under MADV_HUGEPAGE&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190129234058.GH31695@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190129234058.GH31695@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;제목 그대로입니다.  NUMA remote THP 를 쓰는게 나을까요?  THP 를 포기하고 NUMA
local regular page 를 쓰는게 나을까요?  이에 대해서 LSF/MM 에서 이야기 하고
싶다는군요.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc4&#34;&gt;Linux 5.0-rc4&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgNph26eD1zhP91LQLrwB91QPy4=d82SPfvYmSexV7UpQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgNph26eD1zhP91LQLrwB91QPy4=d82SPfvYmSexV7UpQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;어느새 네번째 rc.  이제 5.0 이 그리 멀지 않았네요.  주말 쯤에 갑자기 많은
패치가 밀려왔다고 하지만 큰 문제는 없었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc3</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc3/</link>
      <pubDate>Mon, 21 Jan 2019 09:21:14 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc3/</guid>
      <description>

&lt;h2 id=&#34;lsf-mm-2019-call-for-proposals&#34;&gt;LSF/MM 2019: Call for Proposals&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/51b4b263-a0f2-113d-7bdc-f7960b540929@kernel.dk&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/51b4b263-a0f2-113d-7bdc-f7960b540929@kernel.dk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;올해의 LSF/MM 을 위한 발표 모집입니다.  올해는 푸에르토리코에서 4월 30일부터
5월 2일까지 열리는군요.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-numa-memory-hierarchy-and-device-memory&#34;&gt;[LSF/MM TOPIC] NUMA, memory hierarchy and device memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190118174512.GA3060@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190118174512.GA3060@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LSF/MM 을 위한 발표 지원입니다.
NUMA API 가 다계층 메모리에 적용될 때의 단점에 대해서 이야기 해보겠다는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-00-22-increase-success-rates-and-reduce-latency-of-compaction-v3&#34;&gt;[PATCH 00/22] Increase success rates and reduce latency of compaction v3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190118175136.31341-1-mgorman@techsingularity.net&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190118175136.31341-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mel Gorman 의 compaction 개선 패치셋 세번째 버전입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc3&#34;&gt;Linux 5.0-rc3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whS=6Z_UxzoMjLANupOk3u-8ycERLPnaZxShMTviW0jkQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whS=6Z_UxzoMjLANupOk3u-8ycERLPnaZxShMTviW0jkQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.0 세번째 릴리즈입니다.  지난 릴리즈에서 여행 중이지만 항상 그렇듯 일요일
릴리즈를 하려 한다고 했는데, 이번에도 성공적이군요.  더불어 어디 여행 중인지도
나왔습니다, LCA 2019 여행 중이었군요.  여담이지만 올해 LCA 도 재밌는 발표가
많은 것 같습니다.&lt;/p&gt;

&lt;p&gt;지난 rc2 에서 머지하는 걸 빼먹은 네트워킹 쪽 풀리퀘스트를 이번에 머지했기
때문에 이번 rc3 는 조금 크다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc2</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc2/</link>
      <pubDate>Tue, 15 Jan 2019 09:06:44 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc2/</guid>
      <description>

&lt;h2 id=&#34;patch-v11-00-26-speculative-page-faults&#34;&gt;[PATCH v11 00/26] Speculative page faults&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/8b0b2c05-89f8-8002-2dce-fa7004907e78@codeaurora.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/8b0b2c05-89f8-8002-2dce-fa7004907e78@codeaurora.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SPF 패치에서 발견된 버그 레포트입니다.  ARM 위에서 데드락 문제가 발견되었군요.
버그 발견자가 패치도 같이 내놓았는데, 이에 대한 토론은 아직도 계속되고 있네요.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-v7-00-16-add-support-for-exclusive-page-frame-ownership&#34;&gt;[RFC PATCH v7 00/16] Add support for eXclusive Page Frame Ownership&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/cover.1547153058.git.khalid.aziz@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/cover.1547153058.git.khalid.aziz@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;lsquo;ret2dir&amp;rsquo; 보안 공격[1]에 대비하기 위한 패치입니다.  하지만 이로 인해 tlb 를 좀
많이 flush 해야 하는 문제가 있었고, 이 패치셋은 그에 대한 해결책도 의논하고
있습니다.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf&#34; target=&#34;_blank&#34;&gt;http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;patch-0-4-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;[PATCH 0/4] Allow persistent memory to be used like normal RAM&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190116181859.D1504459@viggo.jf.intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190116181859.D1504459@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PMEM 을 사용하기 위해선 현재로썬 어플리케이션 코드를 수정해야 합니다.  그냥
평범한, 조금 느린 RAM 처럼 어플리케이션이 기존에 RAM 접근하듯 접근할 수 있게
하면 안될까요?  이 패치셋은 그런 경우를 위한 드라이버를 소개합니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-0-5-psi-pressure-stall-monitors-v2&#34;&gt;[PATCH v2 0/5] psi: pressure stall monitors v2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190110220718.261134-1-surenb@google.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190110220718.261134-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LWN 에서도 소개된 pressure stall monitor 의 두번째 버전입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc2&#34;&gt;Linux 5.0-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wicCXd7nALwEz+022iNesJV3DUmejS+dzVRE0D3UGzs_g@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wicCXd7nALwEz+022iNesJV3DUmejS+dzVRE0D3UGzs_g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.x 로 나아가는 두번째 릴리즈 후보가 나왔습니다.  이번 머지 윈도우가 휴일이
섞여 있었기 때문에 두번째 rc 를 위한 과정에 문제가 있지 않을까 싶었지만 별 문제
없었다는군요.  그리고 지금 토발즈는 여행중이라 현지시간으로는 항상 하는 일요일
릴리즈가 아니라 월요일 릴리즈라 합니다만, 뭐&amp;hellip; 큰 이슈는 아니죠 ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc1/</link>
      <pubDate>Mon, 07 Jan 2019 11:18:50 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc1/</guid>
      <description>

&lt;h2 id=&#34;rfc-v3-0-3-test-driver-to-analyse-vmalloc-allocator&#34;&gt;[RFC v3 0/3] test driver to analyse vmalloc allocator&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190102085924.14145-1-urezki@gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190102085924.14145-1-urezki@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;vmalloc 의 성능과 스트레스 테스트를 위한 모듈을 구현한 패치입니다.  Selftests
에도 테스트 스크립트를 추가했군요.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-0-1-mm-add-a-warning-about-high-order-allocations&#34;&gt;[RFC PATCH 0/1] mm: add a warning about high order allocations&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181225153927.2873-1-khorenko@virtuozzo.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181225153927.2873-1-khorenko@virtuozzo.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;특정 노드의 메모리에 접근이 많이 되고 있는 상황에서 해당 메모리가 fragment 되어
있고 이 시점에서 high order allocation 이 요청되면 이걸 위해 compaction 등이
작동하니까 다른 태스크의 latency 가 떨어질 수 있습니다.  이런 상황을 모니터링
할 수 있게끔, 이 패치는 &lt;code&gt;vm.war_high_order&lt;/code&gt; 라는 값을 sysctl 통해 설정하면 이
값을 넘는 order 의 allocation 이 요청되었을 때 워닝을 뱉어 줍니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-mm-introduce-page-size&#34;&gt;[PATCH] mm: Introduce page_size()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181231134223.20765-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181231134223.20765-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Huge page 의 존재로 인해 페이지의 실제 크기는 모두 똑같지가 않기 때문에 이를
판별할 방법이 필요하죠.  이 패치는 단순히 기존에 좀 복잡하게 직접 페이지 크기를
구하던 것을 별도의 wrapper function 으로 대체하기 위한 준비 작업입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc1&#34;&gt;Linux 5.0-rc1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wgKYnrL3LjhVkH2Fp+ecmWhLqezT9zmR6CzfcpwcJX0qA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/wgKYnrL3LjhVkH2Fp+ecmWhLqezT9zmR6CzfcpwcJX0qA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 커널 버전의 숫자가 큰 의미 없게 된지도 오래이긴 합니다만 그래도 메이저
버전 변경은 항상 뭔가 들뜨게 마련이죠.
드디어 5.x 커널의 시대가 시작되었습니다.&lt;/p&gt;

&lt;p&gt;연말/연처 휴일이 섞여 있는 덕에 꽤 오랫만의 릴리즈가 되었고, 그덕에 좀 늦게
풀리퀘스트가 온 것들도 있었지만 큰 문제는 없었다고 하네요.&lt;/p&gt;

&lt;p&gt;메이저 버전이 4.x 에서 5.x 로 바뀌긴 했지만 손가락 발가락 다 써도 4.21 의
버전은 셀수가 없기 때문에 5.x 로 바뀌었을 뿐 특별한 변경이나 새로운 기능은
없다는 점도 한번 더 공지합니다.
하지만 많은 기능들이 추가된 것도 사실이니 원하면 하나 꼽아들고 이거 때문에 5.x
로 업데이트 되었다고 생각해도 좋다고 하는군요.&lt;/p&gt;

&lt;p&gt;이번 릴리즈는 총 11000여개의 커밋을 받아들인 긴 머지 윈도우를 거쳤지만,
그렇다고 유별날 건 없다는군요.  절반 가량이 드라이버, 20%는 아키텍쳐, 10% 툴링,
나머진 여기저기.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perf symbol problem on Linux 4.19</title>
      <link>https://sjp38.github.io/post/perf_symbol_problem_4.19/</link>
      <pubDate>Fri, 21 Dec 2018 17:00:22 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/perf_symbol_problem_4.19/</guid>
      <description>&lt;p&gt;4.19 커널에서 오랫만에 perf 를 다시 빌드하고 써보려고 하니, &lt;code&gt;perf report&lt;/code&gt; 가
아래와 같이 제대로 된 symbol name 을 찾질 못합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo perf record -g ls
arch                     builtin-ftrace.c    builtin-report.c     Documentation       perf.data.old
bench                    builtin.h           builtin-sched.c      examples            perf.h
Build                    builtin-help.c      builtin-script.c     include             perf-read-vdso.c
builtin-annotate.c       builtin-inject.c    builtin-stat.c       jvmti               perf-sys.h
builtin-bench.c          builtin-kallsyms.c  builtin-timechart.c  Makefile            perf-with-kcore.sh
builtin-buildid-cache.c  builtin-kmem.c      builtin-top.c        Makefile.config     pmu-events
builtin-buildid-list.c   builtin-kvm.c       builtin-trace.c      Makefile.perf       python
builtin-c2c.c            builtin-list.c      builtin-version.c    MANIFEST            scripts
builtin-config.c         builtin-lock.c      check-headers.sh     perf-archive.sh     tests
builtin-data.c           builtin-mem.c       command-list.txt     perf.c              trace
builtin-diff.c           builtin-probe.c     CREDITS              perf-completion.sh  ui
builtin-evlist.c         builtin-record.c    design.txt           perf.data           util
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.025 MB perf.data (21 samples) ]
sjpark@hydra:~/linux/tools/perf$ sudo perf report --stdio
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 21  of event &#39;cycles:ppp&#39;
# Event count (approx.): 2712237
#
# Children      Self  Command  Shared Object      Symbol
# ........  ........  .......  .................  .................................
#
    59.39%     0.00%  ls       [unknown]          [k] 0xffffffffa8a00088
            |
            ---0xffffffffa8a00088
               |
               |--51.91%--0xffffffffa8004185
               |          |
               |          |--17.13%--0xffffffffa8212c8b
               |          |          0xffffffffa8212afe
               |          |          0xffffffffa821274a
               |          |          0xffffffffa81bb3c5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;왜이러지 하고 삽질하다가 알고보니 perf 쪽 최신 커밋인 edeb0c90df35 (&amp;ldquo;perf
tools: Stop fallbacking to kallsyms for vdso symbols lookup&amp;rdquo;) 이 만든 버그군요.
해당 커밋만 revert 하고 perf 를 다시 빌드하면 다시 잘 됩니다.&lt;/p&gt;

&lt;p&gt;저만 겪는 문제는 아닌지 버그질라에도 이에 대한 이슈가 올라와 있네요:
&lt;a href=&#34;https://bugzilla.kernel.org/show_bug.cgi?id=201551&#34; target=&#34;_blank&#34;&gt;https://bugzilla.kernel.org/show_bug.cgi?id=201551&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News for v4.20</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20/</link>
      <pubDate>Fri, 21 Dec 2018 08:35:03 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20/</guid>
      <description>

&lt;h2 id=&#34;patch-v5-0-3-mm-kvm-vfio-ppc64-migrate-compound-pages-out-of-cma&#34;&gt;[PATCH V5 0/3] mm/kvm/vfio/ppc64: Migrate compound pages out of CMA&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181219034047.16305-1-aneesh.kumar@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181219034047.16305-1-aneesh.kumar@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ppc64 에서는 guest os page table 을 CMA area 내에 할당하는데, VFIO 를 쓰는 경우
이게 pinning 되어 있다 보니 CMA area 밖으로 migrate 하는데 실패해, guest os
page table 할당에 실패하고, 이로 인해 guest 시작조차 불가능하게 되는 문제가
있었습니다.&lt;/p&gt;

&lt;p&gt;이 패치는 compound page 에 대해서도 CMA area 밖으로의 migration 이 가능하게
합니다.&lt;/p&gt;

&lt;h2 id=&#34;resend-patch-v3-0-5-arm64-mm-enable-hugetlb-migration&#34;&gt;[RESEND PATCH V3 0/5] arm64/mm: Enable HugeTLB migration&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1545121450-1663-1-git-send-email-anshuman.khandual@arm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1545121450-1663-1-git-send-email-anshuman.khandual@arm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;HugeTLB 를 통째로 migrate 할 수 있게 하는 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-0-2-hugetlbfs-use-i-mmap-rwsem-for-better-synchronization&#34;&gt;[PATCH v2 0/2] hugetlbfs: use i_mmap_rwsem for better synchronization&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181218223557.5202-1-mike.kravetz@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181218223557.5202-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hugetlbfs 와 truncation 사이에 race conditional bug 가 존재해 왔는데, 이 패치는
&lt;code&gt;i_mmap_rwsem&lt;/code&gt; 을 사용해 동기화를 적용함으로써 이 race bug 를 제거합니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-1-2-mm-swap-check-if-swap-backing-device-is-congested&#34;&gt;[RFC PATCH &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;] mm: swap: check if swap backing device is congested&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1545115948-25467-1-git-send-email-yang.shi@linux.alibaba.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1545115948-25467-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Swap readahead 기능이 이미 다른 요청으로 바쁜 storage device 에 행해진다면 swap
자체 성능도 떨어지고 storage 를 더욱 바빠지게 해서 남들에게도 민폐가 됩니다.
&lt;code&gt;vma_cluster_radahead()&lt;/code&gt; 에서 먼저 storage 의 congestion 을 체크해 보게 하는
패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-4-20-released&#34;&gt;Linux 4.20 released..&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wg0zF4wa87Q5rAhFe2es0t0eExX2UjvKD7-Pghvcbt5Vw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wg0zF4wa87Q5rAhFe2es0t0eExX2UjvKD7-Pghvcbt5Vw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;예정대로 4.20 이 정식 릴리즈 되었습니다.  원했던 것보단 조금 시끄러운
주간이었지만 어쨌건 연말 휴일을 방해하고 싶진 않고 정말 큰 문제가 있는 것 같아
보이진 않기에 릴리즈 했다고 합니다.&lt;/p&gt;

&lt;p&gt;이번 정식 릴리즈에서 개인적으로 눈길 가는건 XArray 입니다.  앞으로도 많은
영역에 쓰이고자 하는 것 같던데, 향후 행보도 궁금합니다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
