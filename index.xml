<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Happy Hacking</title>
    <link>https://sjp38.github.io/</link>
    <description>Recent content on Happy Hacking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>sj38.park@gmail.com (SeongJae Park)</managingEditor>
    <webMaster>sj38.park@gmail.com (SeongJae Park)</webMaster>
    <lastBuildDate>Tue, 17 Oct 2017 20:54:24 +0900</lastBuildDate>
    
	<atom:link href="https://sjp38.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LKML News after v4.14-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.14-rc5/</link>
      <pubDate>Tue, 17 Oct 2017 20:54:24 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/lkml_news_v4.14-rc5/</guid>
      <description>Linux 4.14-rc5 https://lkml.kernel.org/r/CA+55aFyKgEL3dj7XGYsPQd8y_z0GWx91TLZPSQAxjrua1aWOLw@mail.gmail.com
다섯번째 rc 버전의 릴리즈입니다.
Lazy TLB flushing 변경은 지나치게 게으르게 TLB flushing 을 해서 AMD 칩 일부에서 문제를 일으키기도 했었다는군요.
일부 서브시스템에서 fuzzing 을 통한 문제 발견과 수정이 있었는데 좋은 현상이라고도 언급합니다.
전체적으로 x86, powerpc, mips 에의 arch 업데이트, gpu, networking, usb, sound, misc 드라이버 업데이트, lockdep, networking, mm 쪽 코어 커널 업데이트, 그리고 perf 와 selftest 에의 업데이트가 있었다고 이번 릴리즈를 정리하는군요.
[PATCH 0/2] mm, thp: introduce dedicated transparent huge page https://lkml.</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.14-rc6/</link>
      <pubDate>Sat, 14 Oct 2017 12:54:27 +0200</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/lkml_news_v4.14-rc6/</guid>
      <description>Linux 4.14-rc6 https://lkml.kernel.org/r/CA+55aFxSJGeN=2X-uX-on1Uq2Nb8+v1aiMDz5H1+tKW_N5Q+6g@mail.gmail.com
여섯번째 rc 버전의 릴리즈입니다.
토발즈 집 인터넷 문제로 평소보다 늦은 릴리즈였군요. 이번 rc 버전은 기대보다는 좀 많은 내용이 추가되었는데, 때문에 어쩌면 rc8 까지 나올지도 모르겠다고 하는군요. 물론 확정되거나 한건 아니라고 합니다.
Re: [GIT PULL rcu/next] RCU commits for 4.15 https://lkml.kernel.org/r/20171023204502.GA2776@linux.vnet.ibm.com
4.15 에 들어가야 할 RCU 쪽 커밋들의 풀리퀘스트 입니다.
문서, RCU CPU Stall warning 업데이트, rcutorture 쪽 업데이트가 포함되었네요.
[GIT PULL de-alpha] Make core code not need to know about Alpha for v4.</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.14-rc4/</link>
      <pubDate>Tue, 10 Oct 2017 18:42:24 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/lkml_news_v4.14-rc4/</guid>
      <description>Linux 4.14-rc4 https://lkml.kernel.org/r/CA+55aFwnCrWANr01O3piPc1mwhx13nZU3J+e97ksQC1oN0OnXA@mail.gmail.com
리눅스 4.14 의 네번째 -rc 버전이 나왔습니다. 평소보다 좀 더 작업량이 컸던 -rc4 이지만 슬슬 정리가 되어가는 것 같다고 토발즈는 이야기 하네요
[PATCH RFC tip/core/rcu 0/15] Remove to-be-unneeded smp_read_barrier_depends() https://lkml.kernel.org/r/20171010001951.GA6476@linux.vnet.ibm.com
smp_read_barrier_depends() 가 READ_ONCE() 에 들어갈 것을 Will Deacon 이 제안했고, 이 제안이 받아들여지면 불필요한 중복이 될 코드들을 커널 코드에서 제거하는 패치를 Paul E. McKenney 가 제안했습니다.
smp_read_barrier_depends() 는 Alpha 외의 아키텍쳐에서는 모두 noop 인만큼, 이에 관련된 변경이 모두 머지된다면 core kernel 코드에서는 더이상 Alpha 만을 위한 코드가 사라지게 됩니다.</description>
    </item>
    
    <item>
      <title>LKML News - Intro</title>
      <link>https://sjp38.github.io/post/lkml_news_0000/</link>
      <pubDate>Tue, 10 Oct 2017 18:37:00 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/lkml_news_0000/</guid>
      <description>LKML 을 모니터링 하면서 흥미가는 패치나 토론을 lkml news 라는 카테고리로 묶어서 비정기적, 비형식적으로 간략히 정리하고 관련 소식을 업데이트 해보고자 합니다. 주로 모니터링 하는 메일은 메모리 매니지먼트 쪽과 rcu 관련 메일들이 될겁니다.</description>
    </item>
    
    <item>
      <title>Idle Page Tracking Tools</title>
      <link>https://sjp38.github.io/post/idle_page_tracking/</link>
      <pubDate>Wed, 13 Sep 2017 13:46:00 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/idle_page_tracking/</guid>
      <description>idle_page_tracking[1] is a simple, stupid toolbox for idle pages tracking. It can be used to get real working set size of a process.
Tools This section describes two tools in the box though more tools exists. You can get more description about each tool from the README in the repository[1].
userprog userprog is a sample synthetic workload for test of other tools. It interactively allocates and access specified pages in the allocated pages.</description>
    </item>
    
    <item>
      <title>TPC-H on MariaDB (MySQL)</title>
      <link>https://sjp38.github.io/post/tpch-on-mariadb/</link>
      <pubDate>Sun, 10 Sep 2017 10:54:24 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/tpch-on-mariadb/</guid>
      <description>Database 를 위해 사용되는 벤치마크는 크게 OLTP vs OLAP 로 나뉩니다[1]. OLTP 계열의 대표주자는 TPC-C 이고, OLAP 계열의 대표주자 중 하나로 TPC-H[2] 가 있습니다. 이 글에서는 TPC-H 를 MariaDB 에서 돌리는 방법에 대해 설명합니다.
Environment Setup 이 글을 작성하면서 사용한 운영체제와 소프트웨어들의 버전은 다음과 같습니다. - Ubuntu 16.04.2 Server - MariaDB 10.2.8 - TPC-H toolkit 2.17.2
Automated Scripts 아래 설명할 모든 내용을 자동화 해서 손쉽게 TPC-H 를 돌릴 수 있도록 소스코드 변경부터 빌드, 수행까지 정리한 스크립트들을 github 에 올려 두었습니다: https://github.</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 Server 위에 MariaDB 설치/사용하기</title>
      <link>https://sjp38.github.io/post/mariadb_setup/</link>
      <pubDate>Thu, 31 Aug 2017 14:37:07 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/mariadb_setup/</guid>
      <description>악의 조직 Oracle 에서 Sun 을 인수한 후 이어진 반 open source 적 행보에 MySQL 개발자는 MySQL 을 fork 해서 MariaDB 를 개발하고 있습니다. 저작권을 악용해 중요한 기능은 천천히 릴리즈 하거나 유료 라이센스로만 공개하기도 하는 Oracle 의 MySQL 과 달리 MariaDB 는 예전 MySQL 처럼 공개적으로 개발되고 있어 새롭고 진보적인 기능도 많이 있는 편인 것 같습니다.
이 글에서는 Ubuntu 16.04 서버에 MariaDB 를 소스코드부터 가져와서 설치하고 사용하는 간단한 사용법을 정리해 봅니다.</description>
    </item>
    
    <item>
      <title>Golang 1.9 install on Fedora 26</title>
      <link>https://sjp38.github.io/post/golang1.9_fedora26/</link>
      <pubDate>Sat, 26 Aug 2017 10:54:24 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/golang1.9_fedora26/</guid>
      <description>현재 사용중인 랩탑에 설치한 OS 는 Fedora 24 였는데, 너무 오래되었고 지원도 얼마전 끝났기에[0] 이번에 Fedora 26 으로 새로 설치했습니다. 마침 go 언어도 1.9 가 최근에 릴리즈 되었기에 개인적으로 go 언어를 설치하는 방법을 기록해 둡니다.
여기선 소스 코드만 가지고 빌드, 설치하는 방법을 기록합니다.
Get Source Code go 언어는 오픈소스입니다. 다음 커맨드를 통해 구글로부터 소스코드를 받아올 수 있습니다.
$ git clone https://go.googlesource.com/go  기다리면 go/ 디렉토리에 소스코드가 딸려옵니다.
golang 1.4 Build &amp;amp; Install go 언어를 빌드한다는 건 go 언어 컴파일러와 기본 라이브러리 등과 같은, go 언어로 짠 프로그램을 빌드하고 수행하는데 필요한 도구들을 빌드한다는 이야기입니다.</description>
    </item>
    
    <item>
      <title>Kernel text addresses removed from calltrace</title>
      <link>https://sjp38.github.io/post/kernel-text-addresses-removed-from-calltrace/</link>
      <pubDate>Fri, 16 Jun 2017 16:46:09 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/kernel-text-addresses-removed-from-calltrace/</guid>
      <description>최근 커널은 stakc dump 에서 콜 트레이스(Call Trace) 에 각 코드의 메모리 어드레스를 찍어주지 않습니다. 이에 대해 포스팅을 해봅니다.
Call Trace 커널은 문제가 발생하거나 하면 문제의 원인을 찾을 수 있는 다양한 정보를 담고 있는 stack dump 를 로그로 뿌려 줍니다. 문제의 원인을 찾는데 매우 소중한 정보입니다. 그 정보 중에서도 중요한 것 중 하나가 콜 트레이스로, 이 문제의 순간에 오기까지 어느 함수의 어느 지점에서 어느 함수를 호출해서 여기까지 왔는가를 담는 정보입니다.</description>
    </item>
    
    <item>
      <title>lkml livestream</title>
      <link>https://sjp38.github.io/post/lkml_go/</link>
      <pubDate>Sun, 28 May 2017 17:51:43 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/lkml_go/</guid>
      <description>I wrote a simple, stupid program[1] that showing LKML[2] mails in terminal briefly like twitter livestream in Go language. It is just an early version and so many things to be complemented exists, though. Nevertheless, now it just works as I wanted at first.
쏟아지는 LKML[2] 의 메일들을 트위터 라이브스트림처럼 터미널에 보여주는 간단한 프로그램[1] 을 go 언어로 만들어 봤습니다. 아직 보완할 점 투성이지만 이제 최초의 목적대로는 동작하는군요.
References [1] https://github.</description>
    </item>
    
    <item>
      <title>Parsec 3.0 설치 / 사용법</title>
      <link>https://sjp38.github.io/post/parsec_3_howto/</link>
      <pubDate>Fri, 19 May 2017 06:23:15 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/parsec_3_howto/</guid>
      <description>PARSEC 은 멀티쓰레드 프로그램들로 구성된 benchmark suite 입니다. 멀티쓰레드로 구성되어 있기 때문에 멀티코어 시스템에서의 multi core scalability 를 테스트 하기에도 적합합니다. 이 글에선 현재 최신 버전인 3.0 버전의 PARSEC 을 Ubuntu 16.04 server 에 설치하면서 겪는 문제의 해결법과 간단한 사용법을 정리해 봅니다.
Toolbox for PARSEC 3.0 on Ubuntu Xenial 아래의 내용을 하나하나 읽어가면서 따라하는 것도 귀찮은 일입니다. 그래서 아래에서 설명하는, Ubuntu Xenial 에서 PARSEC 3.0 을 돌리기 위해 필요한 작업을 대부분 자동으로 해주는 도구들을 만들어 두었습니다.</description>
    </item>
    
    <item>
      <title>원격 데스크탑의 clipboard 를 ssh 와 xclip 으로 복사해오기</title>
      <link>https://sjp38.github.io/post/xclip_copy_remote_clipboard/</link>
      <pubDate>Fri, 31 Mar 2017 13:53:54 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/xclip_copy_remote_clipboard/</guid>
      <description>여러개의 리눅스 데스크탑 PC 를 한 책상 위에서 사용하는 경우가 있다. 이 때, 한 PC 에서 Ctrl-C 해서 clipboard 에 복사한 내용을 다른쪽 PC 에서 Ctrl-V 로 붙여넣고 싶은 경우가 있다. 여러가지 해결책이 있겠으나, 다음과 같이 ssh 와 xclip 을 사용해서 해결할 수도 있다:
$ ssh &amp;lt;username&amp;gt;@&amp;lt;remote host&amp;gt; &#39;DISPLAY=:0 xclip -o -selection clipboard&#39; | \ xclip -i -selection clipboard  참고: http://askubuntu.com/questions/513442/can-two-pcs-with-ubuntu-share-the-clipboard-buffer</description>
    </item>
    
    <item>
      <title>spec cpu2006 벤치마크 설치 / 실행하기</title>
      <link>https://sjp38.github.io/post/spec_cpu2006_install/</link>
      <pubDate>Wed, 29 Mar 2017 05:10:55 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/spec_cpu2006_install/</guid>
      <description>SPEC 은 벤치마크를 위한 협력기구 [0] 로, 다양한 벤치마크 suite 들을 만들고 공유합니다. SPEC CPU 2006 은 여기서 만든 벤치마크 도구집합 중 하나 [1] 로 계산 작업 집중적인 워크로드에 대한 성능을 측정을 목표로 만들어졌으며, 많은 곳에서 사용되고 있습니다. 2006년 1.0 버전이, 2008년에 1.1 버전이, 그리고 2011년에 1.2 버전이 나왔습니다. 본 글은 Ubuntu 16.04 서버 위에서의 SPEC CPU 2006 v1.1 의 설치와 실행 방법에 대해 간단히 설명합니다.
Automated Toolbox 아래 내용들을 하나하나 읽고 따라하기엔 시간이 부족할 분들을 위해, 한방에 설치 / 수행이 가능하도록 스크립트를 짜서 Github 에 올려뒀습니다[1].</description>
    </item>
    
    <item>
      <title>Fetching linux kernel source code</title>
      <link>https://sjp38.github.io/post/fetching-linux-source-code/</link>
      <pubDate>Mon, 20 Mar 2017 22:37:03 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/fetching-linux-source-code/</guid>
      <description>리눅스 커널은 오픈 소스 소프트웨어이므로 그 소스코드가 공개되어 있어 누구나 인터넷을 통해 쉽게 얻을 수 있습니다. 이 글에서는 리눅스 커널 소스코드를 받아올 수 있는 몇가지 방법을 설명합니다.
kernel.org 리눅스 커널 소스 코드를 받아오기 위한 기본적 공식 사이트는 kernel.org 라 할 수 있겠는데, 이 사이트에는 소스 코드를 포함해 리눅스 커널을 위한 다양한 리소스가 정리되어 있습니다. 이 사이트에 웹브라우저를 통해 들어가보면 첫페이지에서부터 가장 최근에 릴리즈된 버전의 소스코드, 가장 최근의 안정화된 버전의 소스코드 등을 tar.</description>
    </item>
    
    <item>
      <title>Updating Google Chrome on Fedora 23</title>
      <link>https://sjp38.github.io/post/fedora-chrome-update/</link>
      <pubDate>Mon, 20 Mar 2017 22:24:26 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/fedora-chrome-update/</guid>
      <description>I am using Fedora 23 laptop and installed stable version Google Chrome from its official website [0]. In this case, just using Updates of Fedora Software program doesn&amp;rsquo;t update Chrome automatically. For the case, follow below commands to update your Chrome:
$ sudo dnf update google-chrome-stable ... $ sudo killall chrome $ google-chrome-stable  The second killall command is necessary because Chrome doesn&amp;rsquo;t kill its process by just cliking Close button.</description>
    </item>
    
    <item>
      <title>Golang kakaotalk chat bot making</title>
      <link>https://sjp38.github.io/post/kakaobot/</link>
      <pubDate>Wed, 15 Mar 2017 22:40:32 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/kakaobot/</guid>
      <description>I have developed a chat bot [1] for Kakaotalk [2] using Go language because I have been curious about the process of Kakaotalk chat bot development process. Implementation to major version has consumed only two hours owing to power of Go language, simpleness of Kakaotalk auto-reply API, and simple simple functionality requirement of my bot. It has coded really simply and in brute-force manner, do only simple echoing. However, for the reason, the code could be helpful for beginner of Kakaotalk chat bot or Go language Restful API server programmer.</description>
    </item>
    
    <item>
      <title>Using arping to know ip-MAC mapping</title>
      <link>https://sjp38.github.io/post/arping-howto/</link>
      <pubDate>Tue, 07 Mar 2017 19:41:16 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/arping-howto/</guid>
      <description>You can use arping to know IP address to MAC address mapping of your local network. Usage is simple:
arping [-AbDfhqUV] [-c count] [-w deadline] [-s source] -I interface destination  For example, you may use the command as below:
$ arping -I eth0 10.0.0.1 ARPING 10.0.0.1 from 10.0.0.2 eth0 Unicast reply from 10.0.0.1 [11:22:33:44:55:66] 0.123ms Unicast reply from 10.0.0.1 [11:22:33:44:55:66] 0.251ms ...  Secret of the tool is ARP protocol [1].</description>
    </item>
    
    <item>
      <title>Starting &#39;Linux Kernel Hack&#39; series</title>
      <link>https://sjp38.github.io/post/001_linux_dev_intro/</link>
      <pubDate>Sat, 04 Mar 2017 15:53:08 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/001_linux_dev_intro/</guid>
      <description>많은 영역에서 사용되고 있는 리눅스 커널. 그렇기에 만져볼수록 재밌고 뜯어볼수록 신기합니다. 아마도 이게 hack 의 재미가 아닐까요.
리눅스 커널을 hack 하는데에 필요한 기본적인 내용부터 몇가지 팁들, 소스 코드는 어떻게 가져오고 어떻게 빌드해서 시스템에 설치를 하는지, 패치는 어떻게 보내면 되는지와 같은 것들을 정리해 볼까 합니다.
So many environments and users are using Linux kernel. That&amp;rsquo;s why it is so fun and mysterious to touch and analyze it. Maybe it is the fun of hack.</description>
    </item>
    
    <item>
      <title>beautifulhugo 테마 tags 기능 구현</title>
      <link>https://sjp38.github.io/post/beautifulhugo_contribute/</link>
      <pubDate>Fri, 24 Feb 2017 22:58:25 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/beautifulhugo_contribute/</guid>
      <description>꽤 맘에 드는 hugo 테마[1]를 찾았다. 하지만 tag 기능이 빠져있어 너무 아쉬워하다가 이대로 포기하기엔 너무 맘에 들어 이래저래 찾아보니 과거에 tag 기능 관련 이슈가 올라왔지만 close 처리된 상태. 이대로는 암만 기다려도 tag 기능을 구현해주진 않겠구나 싶어서 이것저것 보고 낑낑대며 서툴고 간단하게나마 tag 기능을 구현[2]. Pull request[3] 도 보냈는데 과연 받아들여줄런지.
업데이트: 별다른 discussion 없이 머지됐다 ;)
[1] http://themes.gohugo.io/beautifulhugo/
[2] https://github.com/sjp38/beautifulhugo-sj
[3] https://github.com/halogenica/beautifulhugo/pull/15</description>
    </item>
    
    <item>
      <title>1990년대의 palmtop, HP 95LX 를 득템</title>
      <link>https://sjp38.github.io/post/hp_95lx/</link>
      <pubDate>Thu, 02 Feb 2017 16:24:02 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/hp_95lx/</guid>
      <description>이사로 생긴 쓰레기 정리를 돕다가 보니 한 물건이 유난히 눈에 띄었다. 자그마한 크기에 왠지 모르게 90년대 감성. 자세히 살펴 보니 전자사전 같이 생겼는데 왠지 옛날에 유행하던 palmtop[1] 같은 느낌. 어차피 버릴 물건이기에 따로 챙겨두고 컴퓨터로 검색을 해보았다.
모델명인 HP 95LX 로 검색해보니[2] 한때 스프레드시트 프로그램의 대명사였던 Lotus 123 을 탑재한 것으로 유명한 palmtop PC 로, MS-DOS 를 장착한 모델이다. 당연하게도 바로는 안켜지지만 잘 살펴보니 전용 배터리가 아니라 2A 건전지를 사용하고 있기에 건전지를 끼고 파워 버튼을 눌러봤지만 역시 잠잠.</description>
    </item>
    
    <item>
      <title>uninstall kernel</title>
      <link>https://sjp38.github.io/post/uninstall-kernel/</link>
      <pubDate>Fri, 20 Jan 2017 13:18:56 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/uninstall-kernel/</guid>
      <description>테스트 등을 위해 소스코드로부터 커널을 직접 빌드, 설치하기 시작하면 어느새 수많은 커널이 설치되어 있는 것을 확인할 수 있다. 삭제를 위해선 make install 로 만들어진 파일들을 직접 제거하고 grub 을 업데이트 해줘야 한다.
예를 들어 시스템이 현재 부팅되어 있는 버전의 커널을 언인스톨하고자 한다면 다음의 일련의 커맨드를 입력하면 된다:
# rm /boot/vmlinuz-$(uname -r) # rm /boot/initrd.img-$(uname -r) # rm /boot/System.map-$(uname -r) # rm /boot/config-$(uname -r) # rm -fr /lib/modules/$(uname -r) # rm /var/lib/initramfs-tools/$(uname -r) # update-grub2  다른 버전의 설치되어있는 커널을 제거하고 싶다면 위의 $(uname -r) 부분을 제거하고자 하는 커널 버전으로 대체하면 된다.</description>
    </item>
    
    <item>
      <title>donate mozilla</title>
      <link>https://sjp38.github.io/post/donate-mozilla/</link>
      <pubDate>Thu, 19 Jan 2017 18:06:54 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/donate-mozilla/</guid>
      <description>나는 보통의 경우 크롬으로 웹브라우징을 한다. 하지만 몇달 전부터 몇가지 예외에 대해서는 파이어폭스를 함께 쓰고 있다.
부족한 하드웨어 스펙 나의 데스크탑 환경은 모니터 세대를 연결한 PC 하나로 구성되어 있었는데, FHD 모니터 세대를 돌리기는 벅찼는지 간헐적 입력 랙이 자주 발생했다. 또, 모니터를 한대 정도 더 늘리고 싶었다. 해서 집에서 놀고있던 5년된 HP 랩탑에 모니터 하나를 연결시키고 이 랩탑과 PC 를 키보드/마우스 하나로 제어하는 환경을 구축했다. PC 에 연결되는 모니터는 두대로 줄어드니까 입력 랙도 줄어들 것이라 생각한것.</description>
    </item>
    
    <item>
      <title>us sues oracle</title>
      <link>https://sjp38.github.io/post/us-sues-oracle/</link>
      <pubDate>Thu, 19 Jan 2017 10:17:09 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/us-sues-oracle/</guid>
      <description>오라클이 백인 남성에게 더 많은 월급을 지불하고 아시아인, 그중에서도 인도 사람을 많이 개발직에 채용했다는 이유로 미국 정부가 오라클을 고소.
http://www.reuters.com/article/us-oracle-usa-labor-idUSKBN1522O6?il=0</description>
    </item>
    
    <item>
      <title>GCMA: Guaranteed Contiguous Memory Allocator</title>
      <link>https://sjp38.github.io/post/gcma/</link>
      <pubDate>Sat, 14 Jan 2017 23:11:23 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/gcma/</guid>
      <description>GCMA (Guaranteed Contiguous Memory Allocator) is a contiguous memory allocator for Linux kernel that guarantees fast latency, success of allocation, and reasonable system memory utilization. Our evaluation on Raspberry Pi 2 shows 15 to 130 times faster and more predictable allocation latency without system performance degradation compared to Linux v3.18 default CMA.
The project has been introduced by Linux Foundation Korea Forum 2014[1] and Embedded Operating Systems Workshop 2015[2]. A paper about the project has been published by proceeding of Embedded Operating Systems Workshop 2015 and 45th issue of ACM SIGBED Review.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://sjp38.github.io/post/about/</link>
      <pubDate>Sat, 14 Jan 2017 04:51:08 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/about/</guid>
      <description>Bio SeongJae Park is a programmer who loves to analyse and develop systems just for fun.
Contacts  sjpark@dcslab.snu.ac.kr sj38.park@gmail.com  Education  Ph.D Candiates, Computer Science and Engineering at Seoul National University,
Sep 2012 - Present B.S., Electrical Engineering / Information and Computer Engineering (dual degree) at Ajou University, Jan 2009  Experiance  Graduate Research Assistant at DCSLAB, Seoul National University,
Sep 2012 - Present
 Part-time Linux Kernel Hacker at Korea Open Source Software Lab,</description>
    </item>
    
    <item>
      <title>&#34;Is Parallel Programming Hard, And, If So, What Can You Do About It?&#34; Translation</title>
      <link>https://sjp38.github.io/post/perfbook-kokr/</link>
      <pubDate>Tue, 10 Jan 2017 13:46:00 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/perfbook-kokr/</guid>
      <description>&amp;ldquo;Is Parallel Programming is Hard, And, If So, What Can You Do About It?&amp;rdquo;[1] 은 parallel programming 분야에서 대가라 불릴만한 분으로, 이쪽 분야에서 매우 중요한 동기화 메커니즘인 RCU[2] 를 개발했으며 리눅스 커널의 RCU 메인테이너로 활동하고 있는 Paul E. McKenney[3] 가 오픈소스 방식으로 저술하고 있는, parallel programming 에 대한 책입니다.
개인적으로 이 책의 한국어 번역을 오픈소스[4]로 진행하고 있습니다. 이 프로젝트는 원저작자인 Paul 에게 공식 한국어 번역으로 인증받았습니다[5].
컨트리뷰션에 대해서도 열려 있으니, 이에 관심 있는 분은 repository 내의 README 문서의 Contribution 섹션[6] 을 참고 바랍니다.</description>
    </item>
    
  </channel>
</rss>