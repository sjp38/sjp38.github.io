<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Happy Hacking</title>
    <link>https://sjp38.github.io/index.xml</link>
    <description>Recent content on Happy Hacking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>sj38.park@gmail.com (SeongJae Park)</managingEditor>
    <webMaster>sj38.park@gmail.com (SeongJae Park)</webMaster>
    <lastBuildDate>Mon, 20 Mar 2017 22:37:03 +0900</lastBuildDate>
    <atom:link href="https://sjp38.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Fetching linux kernel source code</title>
      <link>https://sjp38.github.io/post/fetching-linux-source-code/</link>
      <pubDate>Mon, 20 Mar 2017 22:37:03 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/fetching-linux-source-code/</guid>
      <description>

&lt;p&gt;리눅스 커널은 오픈 소스 소프트웨어이므로 그 소스코드가 공개되어 있어 누구나
인터넷을 통해 쉽게 얻을 수 있습니다.  이 글에서는 리눅스 커널 소스코드를 받아올
수 있는 몇가지 방법을 설명합니다.&lt;/p&gt;

&lt;h1 id=&#34;kernel-org&#34;&gt;kernel.org&lt;/h1&gt;

&lt;p&gt;리눅스 커널 소스 코드를 받아오기 위한 기본적 공식 사이트는
&lt;a href=&#34;https://www.kernel.org&#34;&gt;kernel.org&lt;/a&gt; 라 할 수 있겠는데, 이 사이트에는 소스
코드를 포함해 리눅스 커널을 위한 다양한 리소스가 정리되어 있습니다.  이
사이트에 웹브라우저를 통해 들어가보면 첫페이지에서부터 가장 최근에 릴리즈된
버전의 소스코드, 가장 최근의 안정화된 버전의 소스코드 등을 &lt;code&gt;tar.xz&lt;/code&gt; 포맷의 압축
파일 또는 &lt;code&gt;patch&lt;/code&gt; 등 다양한 형태로 다운받을 수 있는 링크가 있습니다.&lt;/p&gt;

&lt;p&gt;한가지 유의할 것은 kernel.org 는 공식적 사이트일 뿐으로 비슷하게 소스코드를
호스팅 하는 사이트는 github 을 포함해 여럿 있을 수 있다는 점입니다.  또한,
특정한 회사나 개인이 수정한 버전의 커널의 소스코드는 kernel.org 에서 받을 수
없을 수 있습니다.  하지만, 리눅스 커널의 라이센스가 GPL 인만큼, 그들도 자신이
수정한 버전을 상품 등으로 배포하고 있다면 소스코드를 공개해야 하므로, 해당
버전을 만든 사람 또는 회사에 문의해 보면 그 소스코드를 받을 수 있을 겁니다.
예를 들어 안드로이드의 경우 자신들이 수정한 커널을 사용하며, 그렇게 수정된
커널의 소스코드를 자신들의 소스코드 &lt;a href=&#34;https://android.googlesource.com/&#34;&gt;호스팅 사이트&lt;/a&gt; 에 공개하고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;specific-version&#34;&gt;Specific Version&lt;/h2&gt;

&lt;p&gt;kernel.org 첫 페이지에는 몇가지 버전의 소스코드만 존재하므로 찾고 있는 버전은
해당 페이지에 링크가 존재하지 않을 수 있습니다.  특정 버전을 찾기 위한 페이지
역시 kernel.org 는 제공하는데, &lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/&#34;&gt;https://www.kernel.org/pub/linux/kernel/&lt;/a&gt; 주소로
들어가면 특정 버전의 커널 소스코드를 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어 4.2.1 버전을 받고 싶다면, 다음 커맨드를 셸에서 수행해 받아올 수
있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.2.1.tar.xz
$ tar xvf linux-4.2.1.tar.xz
$ ls linux-4.2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;git-repository-cloning&#34;&gt;Git Repository Cloning&lt;/h1&gt;

&lt;p&gt;주요 리눅스 개발자들은 각자의 git repository 로 자신이 개발중인 버전의 리눅스
커널 소스코드를 관리하는데, 이 역시 남들이 볼 수 있게 공유해 두고 있습니다.
따라서, 원한다면 특정 리눅스 개발자의 개발중인 리눅스 커널 소스코드를 git 으로
clone 해올 수 있습니다.  많은 주요 개발자들이 kernel.org 위에 자신의 git
repository 를 호스팅 하고 있으며, github 을 사용하는 사람들도 많습니다.  예를
들어 리누스 토발즈는 kernel.org 위에 자신의 git repository 를 호스팅 하면서
github 에 미러링도 하고 있습니다.  각각의 repository 의 주소는 다음과 같습니다:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux.git&#34;&gt;https://github.com/torvalds/linux.git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음과 같은 명령을 통해 리누스 토발즈의 개발중인 리눅스 커널 소스코드를 clone
해올 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
$ ls linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;개발자의 repository 를 클론해 오는 방식의 장점은, 일단 아직 릴리즈 되지 않은
따끈따끈한 버전의 소스코드를 그 commit history 와 함께 볼 수 있다는 점일
겁니다.  리눅스 커널 개발에 참여하고 싶다면 현재 어떤 기능이 구현되고 있고 어떤
버그가 아직 고쳐지지 않았는지 등을 알 수 있으므로 필수적입니다.  또하나의
장점은 git repository 에는 그동안 해당 repository 에서 릴리즈한 버전들이 모두
포함되어 있어, 해당 버전을 언제든지 &lt;code&gt;checkout&lt;/code&gt; 할 수 있다는 점입니다.&lt;/p&gt;

&lt;p&gt;단점은, commit history 와 개발중인 코드를 원하는게 아니라면 불필요하게 많은
용량의 데이터를 다운로드 받아야 한다는 것입니다.  현재 소스코드를 필요로 하는
목적에 맞춰, 특정 버전의 코드가 필요할 뿐이라면 압축 파일을, 그렇지 않다면 git
repository 를 사용한 접근을 하는 편이 옳을 겁니다.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;리눅스 커널의 소스코드를 얻어오는 몇가지 방법을 알아봤습니다.  리눅스 커널은
오픈소스 형태라 그 소스코드를 쉽게 구할 수 있으며, kernel.org 또는 github 등의
호스팅 사이트에서 압축 파일, 패치, 또는 git repository 의 형태로 얻을 수
있습니다.  개발중인 repository 의 clone 을 통한 형태는 commit history 와
개발중인 코드의 정보를 알 수 있다는 장점이 있지만 그만큼 다운로드 받아야 하는
데이터의 양이 크다는 단점도 존재합니다.  자신이 현재 소스코드를 얻고자 하는
목적에 맞춰 적합한 방법으로 소스코드를 얻어오는 것이 좋을 겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Updating Google Chrome on Fedora 23</title>
      <link>https://sjp38.github.io/post/fedora-chrome-update/</link>
      <pubDate>Mon, 20 Mar 2017 22:24:26 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/fedora-chrome-update/</guid>
      <description>&lt;p&gt;I am using Fedora 23 laptop and installed stable version Google Chrome from its
official website [0].  In this case, just using &lt;code&gt;Updates&lt;/code&gt; of Fedora &lt;code&gt;Software&lt;/code&gt;
program doesn&amp;rsquo;t update Chrome automatically.  For the case, follow below
commands to update your Chrome:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo dnf update google-chrome-stable
...
$ sudo killall chrome
$ google-chrome-stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second &lt;code&gt;killall&lt;/code&gt; command is necessary because Chrome doesn&amp;rsquo;t kill its
process by just cliking &lt;code&gt;Close&lt;/code&gt; button.  Or, you may reboot your computer but
you wouldn&amp;rsquo;t like that.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;랩톱에 Fedora 23 을 깔고 크롬을 공식 홈페이지 [0] 에서 다운받아 메인 브라우저로
사용하고 있습니다.  그런데 이렇게 설치한 경우에는 단순히 Fedora &lt;code&gt;Software&lt;/code&gt;
프로그램의 &lt;code&gt;Updates&lt;/code&gt; 기능을 통해 업데이트가 되지 않더군요.  이런 경우에는
다음의 커맨드를 통해 직접 업데이트를 할 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo dnf update google-chrome-stable
...
$ sudo killall chrome
$ google-chrome-stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두번째의 &lt;code&gt;killall&lt;/code&gt; 커맨드는 Chrome 프로세스들이 &lt;code&gt;닫기&lt;/code&gt; 버튼을 누르는 것만으로는
모두 종료되지 않기 때문에 명시적으로 종료시키기 위해 필요합니다.  컴퓨터를 아예
리붓 하는 방법도 있겠지만 별로 그러고 싶지는 않을테지요.  이후에 크롬을 다시
시작하면 업데이트된 버전으로 시작됩니다.&lt;/p&gt;

&lt;p&gt;[0] &lt;a href=&#34;https://www.google.com/chrome/browser/desktop/index.html?brand=CHBD&amp;amp;gclid=CKiMjdqX5dICFYcGKgodqZIM2Q&#34;&gt;https://www.google.com/chrome/browser/desktop/index.html?brand=CHBD&amp;amp;gclid=CKiMjdqX5dICFYcGKgodqZIM2Q&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang kakaotalk chat bot making</title>
      <link>https://sjp38.github.io/post/kakaobot/</link>
      <pubDate>Wed, 15 Mar 2017 22:40:32 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/kakaobot/</guid>
      <description>

&lt;p&gt;I have developed a chat bot [1] for Kakaotalk [2] using Go language because I
have been curious about the process of Kakaotalk chat bot development process.
Implementation to major version has consumed only two hours owing to power of
Go language, simpleness of Kakaotalk auto-reply API, and simple simple
functionality requirement of my bot.  It has coded really simply and in
brute-force manner, do only simple echoing.  However, for the reason, the code
could be helpful for beginner of Kakaotalk chat bot or Go language Restful API
server programmer.  That&amp;rsquo;s why I am introducing it here.  You can get the code
from below link:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sjp38/kakaobot&#34;&gt;https://github.com/sjp38/kakaobot&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Kakaotalk [1] chat bot [2] 은 어떻게 만드는지 궁금해져서 Go 언어로 간단한
Kakaotalk chat bot 을 만들어 봤습니다.  Go 언어의 강력함과 Kakaotalk auto-reply
API 의 단순성, 그리고 echo 서버 역할 정도만 하자는 심플하다 못해 썰렁한 기능
목표 덕에 최초 목표한 데까지는 두시간 만에 만들어졌습니다.  매우 단순히 echo
서버 정도의 역할만 하고 있지만, 매우 단순하게 짜여져 있기 때문에 Kakaotalk chat
bot 을 만들고자 할 때, 또는 Restful API 를 사용하는 서버를 Go 언어로 짜고자 할
때 시작용으로 참고할 만 하지 않을까 싶어 소개합니다.  아래 링크를 통해 코드를
얻을 수 있습니다:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sjp38/kakaobot&#34;&gt;https://github.com/sjp38/kakaobot&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://en.wikipedia.org/wiki/Chatbot&#34;&gt;https://en.wikipedia.org/wiki/Chatbot&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;http://www.kakao.com/services/8&#34;&gt;http://www.kakao.com/services/8&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using arping to know ip-MAC mapping</title>
      <link>https://sjp38.github.io/post/arping-howto/</link>
      <pubDate>Tue, 07 Mar 2017 19:41:16 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/arping-howto/</guid>
      <description>&lt;p&gt;You can use &lt;code&gt;arping&lt;/code&gt; to know IP address to MAC address mapping of your local
network.  Usage is simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arping  [-AbDfhqUV]  [-c count] [-w deadline] [-s source] -I interface destination
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, you may use the command as below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arping -I eth0 10.0.0.1
ARPING 10.0.0.1 from 10.0.0.2 eth0
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.123ms
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.251ms
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Secret of the tool is ARP protocol [1].  To know the MAC address of the machine
that has a specific IP address, IP protocol layer uses the protocol.  MAC
address that found in this way can be used to communicate with Ethernet
protocol layer.  &lt;code&gt;arping&lt;/code&gt; just sends the ARP REQUEST to local network
neighbour.&lt;/p&gt;

&lt;p&gt;It could be useful in case of internet connection problem if IP duplication is
suspicious.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;로컬 네트워크에서 어떤 IP 주소가 어떤 MAC 어드레스에 매핑되는지 알기 위해
&lt;code&gt;arping&lt;/code&gt; 을 사용할 수 있습니다. 사용법은 간단합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arping  [-AbDfhqUV]  [-c count] [-w deadline] [-s source] -I interface destination
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들면, 다음과 같습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arping -I eth0 10.0.0.1
ARPING 10.0.0.1 from 10.0.0.2 eth0
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.123ms
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.251ms
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 툴의 동작 원리는 ARP 프로토콜 [1] 입니다.  IP 프로토콜 레이어는 이
프로토콜을 사용해 특정 IP 주소를 사용하는 기계의 MAC 어드레스를 파악하고 이
주소를 아랫단의 Ethernet 레이어에 보냅니다.  &lt;code&gt;arping&lt;/code&gt; 은 단지 ARP REQUEST 를
로컬 네트워크의 컴퓨터들에게 보내는 일을 합니다.&lt;/p&gt;

&lt;p&gt;인터넷 연결 문제가 발생했을 때, IP 중복이 의심된다면 유용하게 사용될 수
있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html&#34;&gt;http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Starting &#39;Linux Kernel Hack&#39; series</title>
      <link>https://sjp38.github.io/post/001_linux_dev_intro/</link>
      <pubDate>Sat, 04 Mar 2017 15:53:08 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/001_linux_dev_intro/</guid>
      <description>&lt;p&gt;많은 영역에서 사용되고 있는 리눅스 커널.  그렇기에 만져볼수록 재밌고 뜯어볼수록
신기합니다.  아마도 이게 hack 의 재미가 아닐까요.&lt;/p&gt;

&lt;p&gt;리눅스 커널을 hack 하는데에 필요한 기본적인 내용부터 몇가지 팁들, 소스 코드는
어떻게 가져오고 어떻게 빌드해서 시스템에 설치를 하는지, 패치는 어떻게 보내면
되는지와 같은 것들을 정리해 볼까 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;So many environments and users are using Linux kernel.  That&amp;rsquo;s why it is so fun
and mysterious to touch and analyze it.  Maybe it is the fun of &lt;code&gt;hack&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I will organize some basic informations and tips about linux kernel hacking,
for example, how to get the source code, how to build it, how to install it,
and how the patch can be submitted to &lt;code&gt;Linus Torvalds&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>beautifulhugo 테마 tags 기능 구현</title>
      <link>https://sjp38.github.io/post/beautifulhugo_contribute/</link>
      <pubDate>Fri, 24 Feb 2017 22:58:25 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/beautifulhugo_contribute/</guid>
      <description>&lt;p&gt;꽤 맘에 드는 hugo 테마[1]를 찾았다.  하지만 tag 기능이 빠져있어 너무
아쉬워하다가 이대로 포기하기엔 너무 맘에 들어 이래저래 찾아보니 과거에 tag 기능
관련 이슈가 올라왔지만 close 처리된 상태.  이대로는 암만 기다려도 tag 기능을
구현해주진 않겠구나 싶어서 이것저것 보고 낑낑대며 서툴고 간단하게나마 tag
기능을 구현[2].  Pull request[3] 도 보냈는데 과연 받아들여줄런지.&lt;/p&gt;

&lt;p&gt;업데이트: 별다른 discussion 없이 머지됐다 ;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;http://themes.gohugo.io/beautifulhugo/&#34;&gt;http://themes.gohugo.io/beautifulhugo/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;https://github.com/sjp38/beautifulhugo-sj&#34;&gt;https://github.com/sjp38/beautifulhugo-sj&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://github.com/halogenica/beautifulhugo/pull/15&#34;&gt;https://github.com/halogenica/beautifulhugo/pull/15&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>1990년대의 palmtop, HP 95LX 를 득템</title>
      <link>https://sjp38.github.io/post/hp_95lx/</link>
      <pubDate>Thu, 02 Feb 2017 16:24:02 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/hp_95lx/</guid>
      <description>

&lt;p&gt;이사로 생긴 쓰레기 정리를 돕다가 보니 한 물건이 유난히 눈에 띄었다.  자그마한
크기에 왠지 모르게 90년대 감성.  자세히 살펴 보니 전자사전 같이 생겼는데 왠지
옛날에 유행하던 palmtop[1] 같은 느낌.  어차피 버릴 물건이기에 따로 챙겨두고
컴퓨터로 검색을 해보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://sjp38.github.io/img/hp95lx/1.jpg&#34; alt=&#34;HP 95LX&#34; /&gt;&lt;/p&gt;

&lt;p&gt;모델명인 HP 95LX 로 검색해보니[2] 한때 스프레드시트 프로그램의 대명사였던
&lt;code&gt;Lotus 123&lt;/code&gt; 을 탑재한 것으로 유명한 palmtop PC 로, MS-DOS 를 장착한 모델이다.
당연하게도 바로는 안켜지지만 잘 살펴보니 전용 배터리가 아니라 2A 건전지를
사용하고 있기에 건전지를 끼고 파워 버튼을 눌러봤지만 역시 잠잠.  시무룩.
하지만 또 여기저기 살펴보니 충전지 비슷한 물건이 있다.  배터리 교체 시에
in-memory 데이터가 날아가지 않도록 해당 충전지를 충전 후 동작하는 형태가 아닐까
싶어 잠시 동안 놔두었다 켜봤더니, 켜진다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://sjp38.github.io/img/hp95lx/2.jpg&#34; alt=&#34;HP 95LX boot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;몇가지 주요 어플리케이션을 통해 주요 기능들을 제공한다.
파일 탐색, 약속 관리, 전화번호부 관리, 메모, 계산기, 그리고 Lotus 123 을 통한
스프레드 시트 관리가 가능하다.3&lt;/p&gt;

&lt;p&gt;파일 탐색 기능.  실행 파일의 실행도 가능한 듯 하다.
&lt;img src=&#34;https://sjp38.github.io/img/hp95lx/4.jpg&#34; alt=&#34;HP 95LX filer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;약속 관리 기능.  2017년 달력도 존재.
&lt;img src=&#34;https://sjp38.github.io/img/hp95lx/5.jpg&#34; alt=&#34;HP 95LX appointment book&#34; /&gt;&lt;/p&gt;

&lt;p&gt;전화번호부.
&lt;img src=&#34;https://sjp38.github.io/img/hp95lx/6.jpg&#34; alt=&#34;HP 95LX phone book&#34; /&gt;&lt;/p&gt;

&lt;p&gt;메모.
&lt;img src=&#34;https://sjp38.github.io/img/hp95lx/7.jpg&#34; alt=&#34;HP 95LX memo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그리고, 시대를 풍미한 스프레드시트, Lotus 123.
&lt;img src=&#34;https://sjp38.github.io/img/hp95lx/8.jpg&#34; alt=&#34;HP 95LX lotus 123&#34; /&gt;&lt;/p&gt;

&lt;p&gt;한참 가지고 놀다가 뒤늦게야 시간과 사용자를 설정.  연도 설정이 두자리라 혹시나
Y2K 문제가 있진 않을까 걱정했지만 2017 년으로 잘 인식한다.  잘 짜여진
프로그램이란 이리도 멋지다.
&lt;img src=&#34;https://sjp38.github.io/img/hp95lx/9.jpg&#34; alt=&#34;HP 95LX boot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;요즘 나오는 스마트폰에 비교하자면 보잘것없지만 그 시절에도 이만한 휴대성과
완성도의 물건을 아직도 동작할 만큼 튼튼하게 제품으로 만들어냈다는 사실에
경외로움을 숨길 수 없거니와, 여전히 텍스트 기반 UI 를 즐겨 사용하는 내
입장에서는 이 UI 도 여전히 멋지다.  물론 Unix 계열 셸을 제공했다면
완벽했겠지만&amp;hellip;  과거의 물건이 유난한 감동을 준 하루였다.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://en.wikipedia.org/wiki/Palmtop_PC&#34;&gt;https://en.wikipedia.org/wiki/Palmtop_PC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;https://en.wikipedia.org/wiki/HP_95LX&#34;&gt;https://en.wikipedia.org/wiki/HP_95LX&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>uninstall kernel</title>
      <link>https://sjp38.github.io/post/uninstall-kernel/</link>
      <pubDate>Fri, 20 Jan 2017 13:18:56 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/uninstall-kernel/</guid>
      <description>

&lt;p&gt;테스트 등을 위해 소스코드로부터 커널을 직접 빌드, 설치하기 시작하면 어느새
수많은 커널이 설치되어 있는 것을 확인할 수 있다.  삭제를 위해선 &lt;code&gt;make install&lt;/code&gt;
로 만들어진 파일들을 직접 제거하고 grub 을 업데이트 해줘야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어 시스템이 현재 부팅되어 있는 버전의 커널을 언인스톨하고자 한다면
다음의 일련의 커맨드를 입력하면 된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# rm /boot/vmlinuz-$(uname -r)
# rm /boot/initrd.img-$(uname -r)
# rm /boot/System.map-$(uname -r)
# rm /boot/config-$(uname -r)
# rm -fr /lib/modules/$(uname -r)
# rm /var/lib/initramfs-tools/$(uname -r)
# update-grub2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 버전의 설치되어있는 커널을 제거하고 싶다면 위의 &lt;code&gt;$(uname -r)&lt;/code&gt; 부분을
제거하고자 하는 커널 버전으로 대체하면 된다.&lt;/p&gt;

&lt;h2 id=&#34;참고-문서&#34;&gt;참고 문서&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://askubuntu.com/questions/594443/how-can-i-remove-compiled-kernel&#34;&gt;http://askubuntu.com/questions/594443/how-can-i-remove-compiled-kernel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>donate mozilla</title>
      <link>https://sjp38.github.io/post/donate-mozilla/</link>
      <pubDate>Thu, 19 Jan 2017 18:06:54 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/donate-mozilla/</guid>
      <description>

&lt;p&gt;나는 보통의 경우 크롬으로 웹브라우징을 한다.  하지만 몇달 전부터 몇가지 예외에
대해서는 파이어폭스를 함께 쓰고 있다.&lt;/p&gt;

&lt;h2 id=&#34;부족한-하드웨어-스펙&#34;&gt;부족한 하드웨어 스펙&lt;/h2&gt;

&lt;p&gt;나의 데스크탑 환경은 모니터 세대를 연결한 PC 하나로 구성되어 있었는데, FHD
모니터 세대를 돌리기는 벅찼는지 간헐적 입력 랙이 자주 발생했다.  또, 모니터를
한대 정도 더 늘리고 싶었다.  해서 집에서 놀고있던 5년된 HP 랩탑에 모니터 하나를
연결시키고 이 랩탑과 PC 를 키보드/마우스 하나로 제어하는 환경을 구축했다.  PC
에 연결되는 모니터는 두대로 줄어드니까 입력 랙도 줄어들 것이라 생각한것.
여기까지는 계산대로였는데, HP 랩탑이 5년전 모델이라 램이 2 GB.  난 크롬에서 탭
10여개를 띄워두는데, 가뜩이나 메모리 많이 먹는 크롬이라 도무지 무리.  램 2 GB
를 사서 추가로 달아줬지만 그래도 영 버벅였다.  기존 환경으로 돌아가긴 싫은데&amp;hellip;
싶던 와중 파이어폭스를 떠올렸고, 파이어폭스는 역시 적당한 메모리 사용량으로 내
워크로드를 충족해 주었다.&lt;/p&gt;

&lt;h2 id=&#34;일부-성급한-최적화가-이루어진-사이트&#34;&gt;일부 성급한 최적화가 이루어진 사이트&lt;/h2&gt;

&lt;p&gt;리눅스용 크롬에서의 페이스북은 한글 입력 문제가 있다.  뭐라 설명하기도
짜증나는데 한마디로 한글로 글을 입력하려 하면 사람을 짱나게 만드는 문제가
존재한다.  모바일 페이지에선 안그러는 것 같은데, 암튼 짜증난다.  크롬 문제인지
페이스북 문제인지 리눅스 문제인지 모르겠지만 암튼 이불킥할 글을 좀 덜 쓰게
해주는 장점도 있지만 여간 불편한게 아니다.  파이어폭스에서는 문제가 없다.&lt;/p&gt;

&lt;h2 id=&#34;모질라에-감사의-마음을-금전으로&#34;&gt;모질라에 감사의 마음을 금전으로&lt;/h2&gt;

&lt;p&gt;파이어폭스를 만들고 있는 모질라는 세상에 많은 것을 기여하는 훌륭한 곳인데 돈이
항상 부족하다.  대안적 도구의 중요성을 되새기고 감사의 마음을 담아 소액이나마
기부해 보았다.  기부를 하고 싶다면 다음 링크를 사용하면 된다:
&lt;a href=&#34;https://donate.mozilla.org/ko/&#34;&gt;https://donate.mozilla.org/ko/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;뱀발&#34;&gt;뱀발&lt;/h2&gt;

&lt;p&gt;w3m 같은 CLI 웹브라우저들도 훌륭한 대안 웹브라우저다 ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>us sues oracle</title>
      <link>https://sjp38.github.io/post/us-sues-oracle/</link>
      <pubDate>Thu, 19 Jan 2017 10:17:09 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/us-sues-oracle/</guid>
      <description>&lt;p&gt;오라클이 백인 남성에게 더 많은 월급을 지불하고 아시아인, 그중에서도 인도 사람을
많이 개발직에 채용했다는 이유로 미국 정부가 오라클을 고소.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.reuters.com/article/us-oracle-usa-labor-idUSKBN1522O6?il=0&#34;&gt;http://www.reuters.com/article/us-oracle-usa-labor-idUSKBN1522O6?il=0&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GCMA: Guaranteed Contiguous Memory Allocator</title>
      <link>https://sjp38.github.io/post/gcma/</link>
      <pubDate>Sat, 14 Jan 2017 07:11:23 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/gcma/</guid>
      <description>&lt;p&gt;GCMA (Guaranteed Contiguous Memory Allocator) is a contiguous memory allocator
for Linux kernel that guarantees fast latency, success of allocation, and
reasonable system memory utilization.  Our evaluation on Raspberry Pi 2 shows
&lt;strong&gt;15 to 130 times faster&lt;/strong&gt; and more predictable allocation latency without
system performance degradation compared to Linux v3.18 default CMA.&lt;/p&gt;

&lt;p&gt;The project has been introduced by Linux Foundation Korea Forum 2014[1] and
Embedded Operating Systems Workshop 2015[2].  A paper about the project has
been published by proceeding of Embedded Operating Systems Workshop 2015 and
45th issue of ACM SIGBED Review.  The source code has been submitted to LKML[4]
for discussion.  It is also available at Github[6].&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;GCMA (Guaranteed Contiguous Memory Allocator) 는 리눅스 커널을 위한 물리적으로
연속적인 메모리 영역 할당자로, 빠른 응답시간과 할당의 성공, 그리고 합리적인
시스템 메모리 활용을 보장합니다.  Raspberry Pi 2 위에서의 저희의 성능 평가
실험은 Linux v3.18 의 기본 CMA 대비 &lt;strong&gt;15 배에서 130배 빠른&lt;/strong&gt;, 그리고 더 예측
가능한 응답시간을 보임을 보였습니다.&lt;/p&gt;

&lt;p&gt;이 프로젝트는 Linux Foundation Korea Forum 2014[1] 와 Embedded Operating
Systems Workshop 2015[2] 에서 발표되었습니다.  이 프로젝트에 대한 논문은
Embedded Operating System Workshop 2015 proceeding 과 ACM SIGBED Review 45th
issue 에 출판되었습니다.  소스코드는 LKML에 토론을 위해 공개되었으며[4] Github
에서도 받아보실 수 있습니다[6].&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://korealinuxforum2014.sched.com/event/1qZcBAO/gcma-guaranteed-contiguous-memory-allocator-seongjae-park-seoul-national-university-minchan-kim-lg&#34;&gt;https://korealinuxforum2014.sched.com/event/1qZcBAO/gcma-guaranteed-contiguous-memory-allocator-seongjae-park-seoul-national-university-minchan-kim-lg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;http://ceur-ws.org/Vol-1464/&#34;&gt;http://ceur-ws.org/Vol-1464/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;http://sigbed.seas.upenn.edu/vol13_num1.html#issue&#34;&gt;http://sigbed.seas.upenn.edu/vol13_num1.html#issue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[4] &lt;a href=&#34;https://lkml.org/lkml/2015/2/23/480&#34;&gt;https://lkml.org/lkml/2015/2/23/480&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[5] &lt;a href=&#34;https://github.com/sjp38/linux.gcma&#34;&gt;https://github.com/sjp38/linux.gcma&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>https://sjp38.github.io/post/about/</link>
      <pubDate>Sat, 14 Jan 2017 04:51:08 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/about/</guid>
      <description>

&lt;p&gt;SeongJae Park is a programmer who loves to analyse and develop systems just for
fun.&lt;/p&gt;

&lt;h2 id=&#34;contact-information&#34;&gt;Contact information&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;mailto:sjpark@dcslab.snu.ac.kr&#34;&gt;sjpark@dcslab.snu.ac.kr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;mailto:sj38.park@gmail.com&#34;&gt;sj38.park@gmail.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;linkedin&#34;&gt;LinkedIn&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.linkedin.com/in/seongjae-park-1a5b9954&#34;&gt;https://www.linkedin.com/in/seongjae-park-1a5b9954&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;github&#34;&gt;Github&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sjp38&#34;&gt;https://github.com/sjp38&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;openhub&#34;&gt;Openhub&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.openhub.net/accounts/sjpark&#34;&gt;https://www.openhub.net/accounts/sjpark&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>