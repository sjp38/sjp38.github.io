<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hacklog on Hacklog</title>
    <link>https://sjp38.github.io/</link>
    <description>Recent content in Hacklog on Hacklog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Your Name</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LKML News v5.4-rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.4-rc1/</link>
      <pubDate>Sat, 21 Sep 2019 10:00:48 +0200</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.4-rc1/</guid>
      <description>

&lt;h2 id=&#34;patch-0-2-introduce-new-perf-script-page-reclaim&#34;&gt;[PATCH 0/2] introduce new perf-script page-reclaim&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1568817522-8754-1-git-send-email-laoar.shao@gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1568817522-8754-1-git-send-email-laoar.shao@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Page reclaim 관련 성능 메트릭을 분석하기 위한 perf script 커맨드를 추가하는
패치입니다.  Direct reclaim 으로 인한 응답시간 폭증, page reclaim 이 왜
일어났는지, page reclaim 의 효과는 어땠는지 등을 알 수 있다는군요.&lt;/p&gt;

&lt;p&gt;구체적으로는 direct reclaim 이 몇번 일어났는지, 그 latency 분포는 어땠는지,
file / anon page 별로 reclaim, scan, sync write, async write 이 몇번
일어났는지, kswapd 는 몇번 일어났는지, kswapd latency 는 어땠는지 등등을
보입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ perf script report page-reclaim
    Direct reclaims: 4924
    Direct latency (ms)        total         max         avg         min
                          177823.211    6378.977      36.114       0.051
    Direct file reclaimed 22920
    Direct file scanned 28306
    Direct file sync write I/O 0
    Direct file async write I/O 0
    Direct anon reclaimed 212567
    Direct anon scanned 1446854
    Direct anon sync write I/O 0
    Direct anon async write I/O 278325
    Direct order      0     1     3
                   4870    23    31
    Wake kswapd requests 716
    Wake order      0     1
                  715     1

    Kswapd reclaims: 9
    Kswapd latency (ms)        total         max         avg         min
                           86353.046   42128.816    9594.783     120.736
    Kswapd file reclaimed 366461
    Kswapd file scanned 369554
    Kswapd file sync write I/O 0
    Kswapd file async write I/O 0
    Kswapd anon reclaimed 362594
    Kswapd anon scanned 693938
    Kswapd anon sync write I/O 0
    Kswapd anon async write I/O 330663
    Kswapd order      0     1     3
                      3     1     5
    Kswapd re-wakes 705

    Per process latency (ms):
         pid[comm]             total         max         avg         min
               timestamp  latency(ns)
           1[systemd]        276.764     248.933       21.29       0.293
           3406860552338: 16819800
           3406877381650: 5532855
           3407458799399: 929517
           3407459796042: 916682
           3407460763220: 418989
           3407461250236: 332355
           3407461637534: 401731
           3407462092234: 449219
           3407462605855: 292857
           3407462952343: 372700
           3407463364947: 414880
           3407463829547: 949162
           3407464813883: 248933444
         163[kswapd0]      86353.046   42128.816    9594.783     120.736
           3357637025977: 1026962745
           3358915619888: 41268642175
           3400239664127: 42128816204
           3443784780373: 679641989
           3444847948969: 120735792
           3445001978784: 342713657
           ...
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Richard Stallman Resigns</title>
      <link>https://sjp38.github.io/post/rms_resigns/</link>
      <pubDate>Thu, 19 Sep 2019 21:57:01 +0200</pubDate>
      
      <guid>https://sjp38.github.io/post/rms_resigns/</guid>
      <description>&lt;p&gt;몇일 전, 리차드 스톨만이 FSF 회장은 물론이고 의장직에서도 사임한다는 소식이
전해졌습니다.  무슨 일이 있었는지 아래의 reddit 코멘트가 가장 잘 설명하고
있다는 LWN 코멘트[1] 를 참고해, 해당 reddit 코멘트를 번역해 봅니다.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://lwn.net/Articles/799391/&#34; target=&#34;_blank&#34;&gt;https://lwn.net/Articles/799391/&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;최근 공개된 한 여성의 증언에 따르면 그녀가 17세 때, Epstein 이 그녀에게 Marvin
Minsky 와 성관계를 가지라고 했습니다.
Minsky 는 MIT Media Lab 창시자이자 A.I 선도자였으며, 2016년에 사망했습니다.
스톨만은 한 메일링 리스트에서 (Minsky 를 성폭행으로 비난하는 어느 시위 주도자의
주장에 대한 답변으로) 이렇게 주장했습니다, 자신도 Epstein 은 비난하지만, Minsky
는 그녀가 강요당한 걸 몰랐을 가능성이 있다구요:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;많은 시나리오를 상상해 볼 수 있겠습니다만, 가장 그럴싸한 시나리오는 그에게는
그녀가 스스로 원해서 그러는듯 보였을 거라는 겁니다.
Epstein 이 그녀를 강요했다면, 그는 그가 연관된 것을 그녀가 감추도록 해야 했을
겁니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일부 SJW 는 &amp;ldquo;Remove Richard Stallman&amp;rdquo; 이라는 Medium 포스트를 작성했습니다.
Vice 와 The Daily Beast 와 같은 미디어 직판장은 Stallman 이 그 여성이 &amp;ldquo;완전히
원했다&amp;rdquo; 그리고 &amp;ldquo;Epstein 을 방어하고 있다&amp;rdquo; 라고 했다고 거짓말하고 그의 발언을
잘못된 의미로 인용했습니다.
Stallman 은 이제 MIT 에서 사퇴하라는 압력을 받고 있습니다.&lt;/p&gt;

&lt;p&gt;더 나아가서 이 증언에 그녀가 Minsky 와 성관계를 가졌다는 이야기는 없고, Epstein
이 그녀에게 그러라 했을 뿐이라는 이야기만 있습니다, 그리고 물리학자 Greg
Benford 에 따르면 그녀가 Minsky 를 유혹했고 그는 그녀를 거절했다고 합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;내가 알죠, 내가 거기 있었습니다.
Minsky 는 그녀를 거절했고, 제게 그 이야기를 했습니다.
그녀는 우리가 이야기 하는걸 보았고 제게 다가오지 않았습니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이는 Stallman 의 생각에 대한 완전한 검증 같습니다.
Minsky 가 무엇을 알았는지가 중요치 않다면, &amp;ldquo;Minsky 가 한 여성을 성폭행 했다&amp;rdquo; 와
&amp;ldquo;Epstein 이 17살 여성에게 그의 강요를 Minsky 에게 알리지 않은 채 성행위를
가지라 했다&amp;rdquo; 사이에 차이가 없다면, 왜 그는 그녀를 거절했을까요?&lt;/p&gt;

&lt;p&gt;추가 수정: 그는 그가 설립한 Free Software Foundation 에서도 사임했습니다.
자유 소프트웨어에의 우울한 소식입니다, 저는 Stallman 같은 순수한 믿음을 가진
사람이 다양한 종류의 피해야할 선택을 막는데 필수적이라 생각하거든요.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Context: In a recently unsealed deposition a woman testified that, at the age
of 17, Epstein told her to have sex with Marvin Minsky. Minsky was a founder of
the MIT Media Lab and pioneer in A.I. who died in 2016. Stallman argued on a
mailing list (in response to a statement from a protest organizer accusing
Minsky of sexual assault) that, while he condemned Epstein, Minsky likely did
not know she was being coerced:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;We can imagine many scenarios, but the most plausible scenario is that she
presented herself to him as entirely willing. Assuming she was being coerced by
Epstein, he would have had every reason to tell her to conceal that from most
of his associates.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some SJW responded by writing a Medium post called &amp;ldquo;Remove Richard Stallman&amp;rdquo;.
Media outlets like Vice and The Daily Beast then lied and misquoted Stallman as
saying that the woman was likely &amp;ldquo;entirely willing&amp;rdquo; and as &amp;ldquo;defending Epstein&amp;rdquo;.
He has now been pressured to resign from MIT&lt;/p&gt;

&lt;p&gt;Furthermore the deposition doesn&amp;rsquo;t say she had sex with Minsky, only that
Epstein told her to do so, and according to physicist Greg Benford she
propositioned Minsky and he turned her down:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I know; I was there. Minsky turned her down. Told me about it. She saw us
talking and didn’t approach me.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seems like a complete validation of the distinction Stallman was making.
If what Minsky knew doesn&amp;rsquo;t matter, if there&amp;rsquo;s no difference between &amp;ldquo;Minsky
sexually assaulted a woman&amp;rdquo; and &amp;ldquo;Epstein told a 17-year-old to have sex with
Minsky without his knowledge or consent&amp;rdquo;, then why did he turn her down?&lt;/p&gt;

&lt;p&gt;Edit: He has also resigned from the Free Software Foundation, which he founded.
Grim news for free software, since I think true-believing purists like Stallman
are vital to prevent various kinds of co-option.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.3/</link>
      <pubDate>Thu, 12 Sep 2019 17:59:25 +0200</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.3/</guid>
      <description>

&lt;h2 id=&#34;patch-x86-mm-enable-5-level-paging-support-by-default&#34;&gt;[PATCH] x86/mm: Enable 5-level paging support by default&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190913095452.40592-1-kirill.shutemov@linux.intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190913095452.40592-1-kirill.shutemov@linux.intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5 레벨 페이지 테이블 기능이 들어간지도 어느덧 시간이 지났죠.
인텔 내부적 테스트 상으론 이 기능을 켰을 때 4 레벨 페이지 테이블 기계에서도
딱히 리그레션 등은 나타나지 않았고, 주요 배포판들은 5 레벨 페이지 테이블
서포트를 기본으로 켤것으로 보인다고 합니다.
따라서 이 기능을 아예 디폴트로 켜져있게 하는 패치입니다.&lt;/p&gt;

&lt;p&gt;v5.4 에 들어가기엔 좀 늦은 관계로, v5.5 에 들어갈 것 같다는군요.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-3&#34;&gt;Linux 5.3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiP4K8DRJWsCo=20hn_6054xBamGKF2kPgUzpB5aMaofA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiP4K8DRJWsCo=20hn_6054xBamGKF2kPgUzpB5aMaofA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LPC 와 커널 서밋 등으로 인해 한주 늦춰진 5.3 릴리즈가 이뤄졌습니다.
지난 일주일은 고요했을 뿐더러, 이 늦춰진 일정 덕에 몇가지 수정도 더 이뤄질 수
있었다고 토발즈는 평하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc8</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.3-rc8/</link>
      <pubDate>Wed, 04 Sep 2019 23:56:59 +0200</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.3-rc8/</guid>
      <description>

&lt;h2 id=&#34;patch-rfc-00-14-the-new-slab-memory-controller&#34;&gt;[PATCH RFC 00/14] The new slab memory controller&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190905214553.1643060-1-guro@fb.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190905214553.1643060-1-guro@fb.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;슬랩 할당자의 실제 메모리 활용률이 대부분 45-65 퍼센트에 불과했다고 합니다.
이는 슬랩 페이지가 각 메모리 cgroup 마다 배타적으로 사용되기 때문입니다.  적은
메모리만 사용하는 cgroup 여러개가 존재하면 슬랩에서 크게 받아놓은 메모리에서
조금씩만 실제 사용되니까 전체 활용률은 낮게 되는거죠.  이 RFC 패치셋은 서로
다른 cgroup 들이 슬랩 페이지를 공유할 수 있게 함으로써 이 문제를 해결합니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-3-rc8&#34;&gt;Linux 5.3-rc8&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whBQ+6c-h+htiv6pp8ndtv97+45AH9WvdZougDRM6M4VQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whBQ+6c-h+htiv6pp8ndtv97+45AH9WvdZougDRM6M4VQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;평소대로라면 5.3 정식 릴리즈가 되었을테고 별다른 문제는 없었지만, rc7
릴리즈에서 이야기된대로 LPC 와 커널 서밋도 있고 한 이유로, -rc8 이 릴리즈
되었습니다.
그렇다보니 특기할 만한 사항은 없습니다만, 정식 릴리즈를 늦춘 덕에 stable 트리로
넘어갈 뻔한 수정사항 몇가지를 이번 릴리즈 내에 넣을 수 있게 되었다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.3-rc7/</link>
      <pubDate>Mon, 02 Sep 2019 10:57:44 +0200</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.3-rc7/</guid>
      <description>&lt;p&gt;평소보다 늦은 월요일 아침 릴리즈가 이뤄졌습니다.  일요일에 토발즈가
컴퓨터로부터 떨어져 있었다는군요.&lt;/p&gt;

&lt;p&gt;늦어진 릴리즈 덕분에 뒤늦게 들어온 풀리퀘스트를 더 받을 수 있었고, 이로 인해
이번 rc 릴리즈는 평소보다 좀 사이즈가 큽니다.
따라서 이번 릴리즈의 크기가 불안정성을 의미하는 게 아니라 5.3 정식 릴리즈를 늦출 필요는 없습니다만, 공교롭게도 또한 다음주는 LPC 와 커널 서밋이 있죠.
토발즈도 그렇고 많은 다른 개발자들도 이때 LPC 와 커널 서밋에 참가할 거라, rc7
을 마지막으로 5.3 릴리즈를 하면 5.4 머지 윈도우의 많은 시간을 여행에 보내게
되므로, 그냥 rc8 을 릴리즈 하겠다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.3-rc6/</link>
      <pubDate>Thu, 22 Aug 2019 15:30:54 +0200</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.3-rc6/</guid>
      <description>

&lt;h2 id=&#34;linux-5-3-rc6&#34;&gt;Linux 5.3-rc6&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgAKCTq+t5YnG6HzrF62=rr9H=q3LqokEP0_bQRHLwYNw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgAKCTq+t5YnG6HzrF62=rr9H=q3LqokEP0_bQRHLwYNw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘은 리눅스의 28번째 생일입니다.  따라서 오늘 rc6 릴리즈는 28년만의
릴리즈이기도 하군요.  토발즈도 감회가 깊었는지 오늘의 릴리즈 메일엔 최초 릴리즈
메일에 적었던 내용과 비슷하게 시작 부분을 꾸몄네요.
감회 깊은 날, 감회 깊은 릴리즈입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;리눅스를 사용하는 여러분들 안녕하세요,

저는 486 AT 클론과 그외의 많은 다른 하드웨어를 위한 (자유) 운영체제를 (취미보단
더 진지하게) 만들고 있습니다.  이 일은 28년째 지속되고 있고, 아직도 끝나지
않았습니다.  이 릴리즈에 의해 만들어진 (또는 그보다 오래된) 모든 버그에 대한
피드백을 부탁드립니다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어쨌건, 아주 특별할 건 없는 릴리즈였습니다만, 토발즈가 원하던 것에 비하면
변경사항이 좀 많았다는군요.  다음주에 확실히 변경사항이 줄지 않는다면 rc8 을
만들어야 할 것 같다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.3-rc5/</link>
      <pubDate>Mon, 19 Aug 2019 14:19:58 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.3-rc5/</guid>
      <description>

&lt;h2 id=&#34;rfc-patch-0-2-add-predictive-memory-reclamation-and-compaction&#34;&gt;[RFC PATCH 0/2] Add predictive memory reclamation and compaction&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190813014012.30232-1-khalid.aziz@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190813014012.30232-1-khalid.aziz@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;커널의 page reclamation 과 compaction 등은 기본적으로 시스템 메모리 잔여량이
부족할 때 시작됩니다.  하지만 이땐 이미 때가 늦었습니다.  reclamation 과
compaction 을 열심히 하긴 하지만 어플리케이션은 이미 메모리 부족으로 인한
응답시간 폭증 등을 겪게 됩니다.&lt;/p&gt;

&lt;p&gt;이 패치셋은 시스템의 메모리 부족을 미리 예측하고 reclamation 과 compaction 을
시작하기 위한 패치셋입니다.  시간축에 따라 메모리 사용량 변화 추세를 보면 이걸
예측할 수 있지 않겠냐는 것이죠.&lt;/p&gt;

&lt;p&gt;이 패치셋은 이런 아이디어에 기반해 시스템의 메모리 부족을 예측하고 kswapd 를
깨울지 재울지를 결정합니다.  간단한 dd 기반의 테스트를 통해 그 성능을 측정한
결과도 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-kbuild-change-fallthrough-comments-to-attributes&#34;&gt;[PATCH] kbuild: Change fallthrough comments to attributes&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190812214711.83710-1-nhuck@google.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190812214711.83710-1-nhuck@google.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;C 언의 &lt;code&gt;switch&lt;/code&gt; 구문의 fall-through 기능은 복잡한 기능을 구현하기 좋긴 한데
암묵적으로 이루어지는 fall-through 를 방지하기 위해 &lt;code&gt;break;&lt;/code&gt; 를 추가하는 걸
깜박하곤 하는 경우가 많습니다.  GCC 는 주석으로 이 부분은 fall-through 가 맞다,
라는걸 지정할 수 있게 하고 이 주석이 없는 경우는 모두 fall-through 를
막아버림으로써 &lt;code&gt;switch&lt;/code&gt; 의 명시적 fall-through 기능이 가능하게 합니다.&lt;/p&gt;

&lt;p&gt;리눅스 커널 역시 이런 방식으로 암묵적 fall-through 에 의한 버그를 극복하려
노력하는데요, clang 은 이걸 주석 형태가 아니라 attribute 형태로 지원합니다.  이
패치는 이런 차이를 어드레스 하기 위한 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-mm-proactive-compaction&#34;&gt;[RFC] mm: Proactive compaction&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190816214413.15006-1-nigupta@nvidia.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190816214413.15006-1-nigupta@nvidia.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Huge page 등의 할당 시간은 fragmentation 이 심한 메모리에선 길어지거나 아예
실패할 수 있죠.  Huge page 에 성능이 의존적인 어플리케이션에겐 큰 문제입니다.&lt;/p&gt;

&lt;p&gt;이 패치는 page order 별 fragmentation threshold 를 두고 이에 맞춰 page order
별로 다른 compaction 을 수행하자는 겁니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-3-rc5&#34;&gt;Linux 5.3-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiO5-puMa30fCwtgze57MH2JOzedVcEVotEviYmmQNihQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiO5-puMa30fCwtgze57MH2JOzedVcEVotEviYmmQNihQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다섯번째 rc 릴리즈입니다.  노드 로컬 할당 대 huge page 할당 관련 커밋 일부가
리버트 시키지 않는 등의 몇가지 문제를 제외하면 조용한 릴리즈 주간이었다는군요.
잘 안정화 되어가고 있다는 증거겠지요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.3-rc4/</link>
      <pubDate>Mon, 12 Aug 2019 01:40:13 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.3-rc4/</guid>
      <description>

&lt;h2 id=&#34;rfc-patch-v6-00-92-vm-introspection&#34;&gt;[RFC PATCH v6 00/92] VM introspection&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190809160047.8319-1-alazar@bitdefender.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190809160047.8319-1-alazar@bitdefender.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;호스트 또는 별도 VM 에서 돌아가는 어플리케이션이 다른 VM들을 제어하거나 상태를
알아보거나 shadow 페이지 테이블을 조정하거나 특정 이벤트 발생시 알림을 받거나
할 수 있게 해주는 KVM introspection 서브시스템을 제안하는 패치입니다.  무려
92개짜리의 거대한 패치군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v4-1-5-mm-page-idle-add-per-pid-idle-page-tracking-using-virtual-indexing&#34;&gt;[PATCH v4 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;] &lt;code&gt;mm/page_idle&lt;/code&gt;: Add per-pid idle page tracking using virtual indexing&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190805170451.26009-1-joel@joelfernandes.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190805170451.26009-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;페이지 액세스 여부를 알아볼 수 있는 &lt;code&gt;page_idle&lt;/code&gt; 기능을 프로세스별로 트래킹 하기
편하게 만들어 주는 패치의 네번째 버전입니다.  저자는 구글 직원으로,
안드로이드의 heap profiler 가 이 기능을 쓰나봅니다.  이전 버전과의 차이는&amp;hellip;
Swap pte 처리가 추가되었군요.&lt;/p&gt;

&lt;p&gt;다섯번째 버전도 바로 올라왔습니다만, 큰 차이는 없어 보이는군요:
&lt;a href=&#34;https://lkml.kernel.org/r/20190807171559.182301-1-joel@joelfernandes.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190807171559.182301-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;linux-5-3-rc4&#34;&gt;Linux 5.3-rc4&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whWJ7Dv9yZBZpxWd1zcAMwokjt7c8YOp-FOf1PXDKGrmQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whWJ7Dv9yZBZpxWd1zcAMwokjt7c8YOp-FOf1PXDKGrmQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;세번째 rc 는 어째선지 작은 크기였다 말했었죠, 그냥 pull request 들이 천천히
왔기 때문이 맞는 것 같다고 합니다.  이번 rc 릴리즈는 평소 크기에 rc3 에
안들어간 내용이 들어간 만큼 크다고 합니다.
덕분에 최근 2년 사이의 rc4 중 가장 크다고 하네요.
rc3 에 안들어갔다가 rc4 에 뒤늦게 들어온 변경사항은 대부분 network 쪽
코드라는군요.&lt;/p&gt;

&lt;p&gt;이번 변경 중 개인적으로 눈에 띄는건 &lt;code&gt;switch-case&lt;/code&gt; 구문의 fall-through 코멘트
업데이트입니다.
LWN 에도 관련 글이 올라왔으니 한번 읽어보는 것도 좋을 겁니다:
&lt;a href=&#34;https://lwn.net/Articles/794944/&#34; target=&#34;_blank&#34;&gt;https://lwn.net/Articles/794944/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번 rc 릴리즈 개발 과정 시각화 동영상을 아래 링크에서 보실 수 있습니다:
&lt;a href=&#34;https://youtu.be/EB3i8iBuuHM&#34; target=&#34;_blank&#34;&gt;https://youtu.be/EB3i8iBuuHM&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc3</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.3-rc3/</link>
      <pubDate>Wed, 31 Jul 2019 08:40:48 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.3-rc3/</guid>
      <description>

&lt;h2 id=&#34;patch-v5-00-14-provide-generic-top-down-mmap-layout-functions&#34;&gt;[PATCH v5 00/14] Provide generic top-down mmap layout functions&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190730055113.23635-1-alex@ghiti.fr&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190730055113.23635-1-alex@ghiti.fr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아키텍쳐별로 다르게 구현되어 있던 mmap 레이아웃 함수들을 범용화 시키는 패치셋,
다섯번째 버전입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v10-00-22-generic-page-walk-and-ptdump&#34;&gt;[PATCH v10 00/22] Generic page walk and ptdump&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190731154603.41797-1-steven.price@arm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190731154603.41797-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;역시 아키텍쳐별로 다르게 구현되어 있던 page table walk 과 page table dump
기능을 범용화 시키는 패치입니다.  벌써 10번째 버전이군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-3-address-hugetlb-page-allocation-stalls&#34;&gt;[PATCH 0/3] address hugetlb page allocation stalls&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190802223930.30971-1-mike.kravetz@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190802223930.30971-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sysctl&lt;/code&gt; 이나 &lt;code&gt;procfs&lt;/code&gt; 를 통한 hugetlb 페이지 할당은 수분이나 수시간까지도 오래
걸릴 수 있습니다.  이 패치셋은 이렇게 느린 할당시간 문제를 유발하는 reclaim 과
compaction 쪽 문제를 해결할 수 있는 수정사항들을 담고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-3-rc3&#34;&gt;Linux 5.3-rc3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiW+q32YcUL62XWjAme8giZDo-=kmB9=f_JEgyEgV7eaA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiW+q32YcUL62XWjAme8giZDo-=kmB9=f_JEgyEgV7eaA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;보통 머지 윈도우가 지난 후에는 사람들이 숨을 고르고 넘어가기 때문에 보통 rc2 가
작고 rc3 부터 변경이 많아집니다.  하지만 이번 릴리즈는 이상하게도 rc2 보다
작았다는군요.&lt;/p&gt;

&lt;p&gt;커밋 기반으로 그린 rc3 개발 시각화 동영상을 다음 링크에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/V1qUa2QXZes&#34; target=&#34;_blank&#34;&gt;https://youtu.be/V1qUa2QXZes&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Memory: the flat, the discontiguous, and the sparse (Korean)</title>
      <link>https://sjp38.github.io/post/lwn_memory_flat_discontiguous_sparse/</link>
      <pubDate>Wed, 31 Jul 2019 07:45:17 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lwn_memory_flat_discontiguous_sparse/</guid>
      <description>

&lt;p&gt;LWN 의 &amp;ldquo;Memory: the flat, the discontiguous, and the sparse&amp;rdquo; 라는 제목의 글의
한글 번역입니다.  원문은 LWN 에서 볼 수 있습니다:
&lt;a href=&#34;https://lwn.net/Articles/789304/&#34; target=&#34;_blank&#34;&gt;https://lwn.net/Articles/789304/&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;May 27, 2019&lt;/p&gt;

&lt;p&gt;이 기사는 Mike Rapoport 에 의해 기여되었습니다.&lt;/p&gt;

&lt;p&gt;컴퓨터 시스템에서 물리 메모리는 소중한 자원이어서, 이를 효율적으로 관리하기
위한 많은 노력이 기울여져왔습니다.
이 일은 현대의 시스템에서의 메모리 구조가 복잡해짐에 따라 더 어려워졌습니다.
물리 메모리가 실제로 어떻게 위치해 있는가를 다루기 위한 여러 계층의 추상화가
존재합니다; 그런 추상화 중 하나는 &amp;ldquo;메모리 모델&amp;rdquo; 이라고 불립니다.
커널은 세개의 모델을 지원하고 있는데, 그 중 하나는 지원이 멈춰져 가고 있습니다.
이 변경을 이해하기 위한 방법으로, 이 기사는 커널의 메모리 모델들의 진화, 현재
상태, 그리고 있을 법한 미래에 대해 자세히 들여다 봅니다.&lt;/p&gt;

&lt;h2 id=&#34;flatmem&#34;&gt;FLATMEM&lt;/h2&gt;

&lt;p&gt;리눅스가 처음 나왔을 때, 메모리는 평평했습니다: 메모리는 0 부터 수 메가바이트의
물리 주소를 갖는 단순한 선형적 배열일 뿐이었습니다.
각 물리 페이지 프레임은 커널의 &lt;code&gt;mem_map&lt;/code&gt; 배열에 하나의 원소와 연관되었으며, 이
당시에 이 배열은 해당 페이지가 가진 레퍼런스의 갯수를 세는 하나의 &lt;code&gt;unsigned
short&lt;/code&gt; 원소로 이루어져 있었습니다.
하지만, 얼마 있지 않아서, 이 &lt;code&gt;mem_map&lt;/code&gt; 의 원소들은 스왑 관리를 위한 &lt;code&gt;age&lt;/code&gt; 와
&lt;code&gt;dirty counter&lt;/code&gt; 를 포함하도록 커졌습니다.
Linux 1.3.50 에서 &lt;code&gt;mem_map&lt;/code&gt; 의 원소들은 마침내 &lt;code&gt;struct page&lt;/code&gt; 로
이름지어졌습니다.&lt;/p&gt;

&lt;p&gt;이 평평한 메모리 매핑은 물리 페이지 프레임 번호 (page-frame number : PFN) 와
그에 대응되는 &lt;code&gt;struct page&lt;/code&gt; 사이의 쉽고 빠른 변환을 제공했습니다; 이 변환
작업은 간단한 배열 인덱스 계산 문제였습니다.
이후 &lt;code&gt;struct page&lt;/code&gt; 의 레이아웃 변경이 있었는데, 새로운 사용처 (예컨대, page
cache) 들과 &lt;code&gt;struct page&lt;/code&gt; 의 캐시 성능 최적화를 위한 것이었습니다.
메모리 매핑은 깔끔하고 효율적인 평평한 배열로 유지되었습니다만, 이는 중요한
단점을 가지고 있었습니다: 물리 주소 공간 상의 큰 공백을 처리할 수 없었습니다.
이 메모리 매핑 가운데 공백에 연관된 부분은 낭비되어지거나, ARM 에서처럼, 메모리
매핑 자체가 공백을 가질 수 있었습니다.&lt;/p&gt;

&lt;h2 id=&#34;discontigmem&#34;&gt;DISCONTIGMEM&lt;/h2&gt;

&lt;p&gt;상당히 비연속적인 물리 메모리를 효율적으로 처리하기 위한 지원이 리눅스를 NUMA
기계들 위에서 잘 동작하도록 하기 위한 노력의 일환으로 1999년에 메모리 관리
서브시스템으로 들어왔습니다.
이 코드는 &lt;code&gt;CONFIG_DISCONTIGMEM&lt;/code&gt; 설정 옵션에 종속적이어서, 이 메모리 모델은
&lt;code&gt;DISCONTIGMEM&lt;/code&gt; 이라 이름지어진 첫번째 모델이었습니다.&lt;/p&gt;

&lt;p&gt;이 &lt;code&gt;DISCONTIGMEM&lt;/code&gt; 모델은 메모리 노드 (memory node) 라는 개념을 소개했는데, 이
개념은 여전히 NUMA 메모리 관리의 기본으로 남아있습니다.
각 노드는 free-page lists, in-use page lists, least-recently-used (LRU) 정보,
사용 통계 등을 포함한, (대부분) 독립적인 메모리 관리 서브시스템을 갖습니다.
이런 것들 가운데, &lt;code&gt;struct pglist_data&lt;/code&gt; (또는 짧게 &lt;code&gt;pg_data_t&lt;/code&gt;) 로 표현되는 노드
데이터는 하나의 노드에 대한 메모리 매핑 정보를 가지고 있습니다.
각 노드가 연속적인 물리 메모리를 가지고 있다는 가정 하에, 노드당 하나의 &lt;code&gt;struct
page&lt;/code&gt; 배열을 갖는 것은 평평한 메모리 매핑 안의 거대한 공백 문제를 해결했습니다.&lt;/p&gt;

&lt;p&gt;하지만 이게 공짜로 된 건 아닙니다.
&lt;code&gt;DISCONTIGMEM&lt;/code&gt; 에서는, 예를 들면 어떤 PFN 을 그에 연관된 &lt;code&gt;struct page&lt;/code&gt; 로
변환하기 위해 특정 페이지를 어떤 노드가 가지고 있는지를 알 수 있어야 합니다.
비슷하게, 페이지를 가지고 PFN 을 구하기 위해 어떤 노드의 메모리 맵이 해당
&lt;code&gt;struct page&lt;/code&gt; 를 가지고 있는지도 알 수 있어야 합니다.
긴 진화의 끝에, &lt;code&gt;KVADDR_TO_NID()&lt;/code&gt;, &lt;code&gt;LOCAL_MAP_BASE()&lt;/code&gt;, &lt;code&gt;ADDR_TO_MAPBASE()&lt;/code&gt;,
그리고 &lt;code&gt;LOCAL_BASE_ADDR()&lt;/code&gt; 매크로를 처음 정의한 &lt;code&gt;mips64&lt;/code&gt; 부터 시작해서 PFN 의
&lt;code&gt;struct page&lt;/code&gt; 로의 변환과 그 반대 작업은 &lt;code&gt;include/asm-generic/memory_model.h&lt;/code&gt;
안에 정의된, 비교적 간단한 &lt;code&gt;pfn_to_page()&lt;/code&gt; 와 &lt;code&gt;page_to_pfn()&lt;/code&gt; 매크로로 수행되게
되었습니다.&lt;/p&gt;

&lt;p&gt;하지만, DISCONTIGMEM 은 약점이 있었습니다: 메모리 핫플러그 (hotplug) 와
핫리무브 (hot remove) 입니다.
실제 NUMA 노드는 실제 핫플러그를 지원하기엔 너무 굵은 크기였고, 노드를 쪼개는
것은 불필요한게 많은 단편화와 오버헤드를 가져올 것이었습니다.
각 노드가 독립적인 메모리 관리 구조체들을 연관된 비용과 함께 가짐을 기억해
보세요; 노드를 쪼개는 것은 그런 비용을 상당히 증가시킬 겁니다.&lt;/p&gt;

&lt;h2 id=&#34;sparsemem&#34;&gt;SPARSEMEM&lt;/h2&gt;

&lt;p&gt;이 한계는 SPARSEMEM 을 통해 해결되었습니다.  이 모델은 메모리 매핑을
아키텍쳐별로 정의된 임의의 크기의 섹션들의 집합으로 추상화 했습니다.
각 섹션은 &lt;code&gt;struct mem_section&lt;/code&gt; 으로 표현되며, (코드에 설명된 바에 따르면):
&amp;ldquo;논리적으로, &lt;code&gt;struct page&lt;/code&gt; 의 배열로의 포인터입니다.  하지만, 다른 마술을 통해
저장됩니다&amp;rdquo;.
이 섹션들의 배열은 &lt;code&gt;SECTION_SIZE&lt;/code&gt; 크기로 효율적으로 쪼개질 수 있는 메타 메모리
매핑입니다.
PFN 과 &lt;code&gt;struct page&lt;/code&gt; 사이의 효율적인 변환을 위해, PFN 의 상위 비트 몇개는 이
섹션 배열로의 인덱스로 사용됩니다.
반대 방향 변환을 위해선, 이 섹션 넘버가 page 의 flag 로 인코딩 됩니다.&lt;/p&gt;

&lt;p&gt;이 모델이 리눅스 커널에 소개되고 몇달 후, SPARSEMEM 은 &lt;code&gt;SPARSEMEM_EXTREME&lt;/code&gt; 으로
확장되었는데, 이 모델은 산재하는 물리 주소 공간을 갖는 시스템에 적합합니다.
&lt;code&gt;SPARSEMEM_EXTREME&lt;/code&gt; 에서는, 첫번째 레벨은 &lt;code&gt;mem_section&lt;/code&gt; 구조체들로의 포인터가
되고, 실제 &lt;code&gt;mem_section&lt;/code&gt; 객체는 실제로 꽂힌 물리 메모리에 기반해서 동적으로
할당됩니다.&lt;/p&gt;

&lt;p&gt;2007년에 SPARSEMEM 의 또다른 개선이 이루어졌습니다; 이는 SPARSEMEM 의 일반적인
가상 메모리 매핑 지원 또는 &lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 이라고 불렸습니다.
&lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 의 아이디어는 전체 메모리 매핑이 가상 연속 공간에 매핑되어
있지만, 활성화된 섹션들만이 물리 페이지로 연결되어 있도록 하자는 것입니다.
이 모델은 32-bit 시스템에서는 물리 메모리의 크기가 가상 주소 공간을 넘을 수
있기 때문에 잘 동작하지 못할 수 있습니다.
하지만, 64-bit 시스템에서 &lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 은 확실히 우수합니다.
추가적인 페이지 테이블 엔트리 사용이라는 비용 아래, &lt;code&gt;page_to_pfn()&lt;/code&gt; 과
&lt;code&gt;pfn_to_page()&lt;/code&gt; 는 평평한 모델만큼이나 간단해 졌습니다.&lt;/p&gt;

&lt;p&gt;SPARSEMEM 메모리 모델의 마지막 확장은 꽤 최근 (2016) 이었습니다; 이는
persistent 메모리 디바이스의 사용 증가로 인해 이루어졌습니다.
메모리 매핑을 메인 메모리가 아니라 그런 디바이스들 내에 직접 저장하는 걸
지원하기 위해, 이 가상 메모리 매핑은 &lt;code&gt;struct vmem_altmap&lt;/code&gt; 을 사용할 수 있게
되었는데, 이 구조체는 persistent 메모리 안의 페이지 구조체를 제공합니다.&lt;/p&gt;

&lt;p&gt;2005년으로 돌아가보면, SPARSEMEM 은 &amp;ldquo;새로운, 그리고 실험적인 &lt;code&gt;discontiguous
memory&lt;/code&gt; 의 대체재&amp;rdquo; 로 설명되었습니다.
&lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 을 추가한 커밋은 그것을 &amp;ldquo;우리가 SPARSEMEM 을 대부분의
시스템에 기본 (그리고 유일한) 옵션이 되게 할 가능성이 있다&amp;rdquo; 고 했습니다.
그리고 실제로, 일부 아키텍쳐는 DISCONTIGMEM 에서 SPARSEMEM 으로 옮겨탔습니다.
2008년, &lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 은 x86-64 를 위한 유일한 메모리 모델이 되었는데,
FLATMEM 보단 조금 비싸지만 DISCONTIGMEM 보다는 효율적이기 때문입니다.&lt;/p&gt;

&lt;p&gt;메모리 핫플러그, persistent 메모리 지원, 다양한 성능 최적화와 같은 최근의
메모리 관리 분야 개발은 모두 SPARSEMEM 모델을 타겟으로 하고 있습니다.
하지만 과거의 모델들은 여전히 존재해서, 아키텍쳐와 메모리 관리 코드 상의 많은
&lt;code&gt;#ifdef&lt;/code&gt; 블록의 존재와, 관련된 구성 옵션의 특별한 미로의 존재라는 추가비용을
유발하고 있습니다.
남아있는 &lt;code&gt;DISCONTIGMEM&lt;/code&gt; 사용자들을 &lt;code&gt;SPARSEMEM&lt;/code&gt; 으로 완전히 바꿔타게 하려는
노력들이 있습니다만, ia64 나 mips64 와 같은 아키텍쳐들을 그렇게 변화시키기는
쉬운 작업이 아닐 겁니다.
그리고 ARC 아키텍쳐의 DISCONTIGMEM 사용은 &amp;ldquo;normal&amp;rdquo; 메모리 아래 &amp;ldquo;high memory&amp;rdquo;
영역의 존재를 갖는데, 이는 분명 변경하기 어려울 겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc2</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.3-rc2/</link>
      <pubDate>Fri, 26 Jul 2019 08:41:19 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.3-rc2/</guid>
      <description>

&lt;h2 id=&#34;patch-v6-0-5-introduce-madv-cold-and-madv-pageout&#34;&gt;[PATCH v6 0/5] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190723062539.198697-1-minchan@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190723062539.198697-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;어플리케이션의 메모리를 좀 더 적극적으로 reclaim 시킴으로써 반응성을 높이기
위한 패치셋의 일부를 따로 떼어낸, &lt;code&gt;MADV_COLD&lt;/code&gt; 와 &lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 힌트를
&lt;code&gt;madvise()&lt;/code&gt; 에 추가하는 패치의 여섯번째 버전입니다.&lt;/p&gt;

&lt;p&gt;일곱번째 버전도 빠르게 올라왔군요:
&lt;a href=&#34;https://lkml.kernel.org/r/20190726023435.214162-1-minchan@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190726023435.214162-1-minchan@kernel.org&lt;/a&gt;
단순히 mmotm 최신 버전 위로 리베이스 한 것 같네요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v9-00-21-generic-page-walk-and-ptdump&#34;&gt;[PATCH v9 00/21] Generic page walk and ptdump&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190722154210.42799-1-steven.price@arm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190722154210.42799-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;x86 과 arm64 가 범용적 페이지 테이블 워킹을 하도록 했던 해치셋을 조금 더 확장한
버전입니다.  기존 대비 페이지 테이블 덤프 기능도 일반화 시킨게 차이군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v1-1-2-mm-page-idle-add-support-for-per-pid-page-idle-using-virtual-indexing&#34;&gt;[PATCH v1 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;] mm/page_idle: Add support for per-pid page_idle using virtual indexing&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190722213205.140845-1-joel@joelfernandes.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190722213205.140845-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 커널은 &lt;code&gt;page_idle&lt;/code&gt; 이라는 인터페이스를 통해 특정 페이지의 액세스 여부를
파악할 수 있게 합니다.  저도 이걸 통해서 wss 를 재거나 하는데 쓸 수 있는
&lt;a href=&#34;https://github.com/sjp38/idle_page_tracking&#34; target=&#34;_blank&#34;&gt;도구&lt;/a&gt;를 만들었었죠.&lt;/p&gt;

&lt;p&gt;문제는 이 인터페이스는 쓰기가 조금 복잡합니다.  PFN 을 가지고 페이지를 지목할
수 있게 되어 있기 때문에 특정 프로세스의 데이터 액세스를 추적하려면 해당
프로세스가 사용하고 있는 가상 메모리가 어떤 PFN 으로 매핑되어 있는지 알아야
하기 때문이죠.  달리 말하면 &lt;code&gt;page_idle&lt;/code&gt; 인터페이스가 글로벌하기 때문에 생기는
문제입니다.&lt;/p&gt;

&lt;p&gt;이 패치셋은 &lt;code&gt;/proc/&amp;lt;pid&amp;gt;/page_idle&lt;/code&gt; 파일을 생성하고 이를 통해 프로세스 단위로
virtual page frame number (VFN) 을 통해 페이지 트랙킹을 할 수 있게 합니다.
이로써 이 인터페이스를 사용하는 유저스페이스 도구의 코드가 간단해질 뿐더러 보안
이슈도 좀 더 편리해지죠.  구글에선 내부적으로 이를 통해 heap profiler
(heapprofd) 를 좀 더 쉽게 만들었나보군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-rfc-mm-page-idle-simple-idle-page-tracking-for-virtual-memory&#34;&gt;[PATCH RFC] mm/page_idle: simple idle page tracking for virtual memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/156388286599.2859.5353604441686895041.stgit@buzz&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/156388286599.2859.5353604441686895041.stgit@buzz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앞에서 소개한 패치와 비슷하게 &lt;code&gt;page_idle&lt;/code&gt; 을 간편화 시키는 패치셋입니다.  특정
pid 의 모든 mapped page frame 의 access bit 을 한번에 clear 할 수 있게 합니다.
인터페이스는 &lt;code&gt;echo 6 &amp;gt; /proc/&amp;lt;pid&amp;gt;/clear_refs&lt;/code&gt; 같은 형태군요.  이후,
&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/smaps&lt;/code&gt; 파일을 이용해 현재 idle 한 페이지들의 갯수를 알 수
있습니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-3-rc2&#34;&gt;Linux 5.3-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiiKRJprQDJqJzdcjdaGs73UtVPTM2+jOHWdMgu5Sp2HQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiiKRJprQDJqJzdcjdaGs73UtVPTM2+jOHWdMgu5Sp2HQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;두번째 rc 버전이 예정대로 나왔습니다.  변경사항이 많은 머지윈도우였던 만큼 rc2
도 꽤 수정사항이 많은 것 같습니다.  전체적으로 문서, arch 코드, 그리고 드라이버
쪽 수정사항이 대부분인 듯 하군요.&lt;/p&gt;

&lt;p&gt;앞선 rc1 릴리즈부터 이번 릴리즈 사이의 변경 사항의 시각화 비디오를 아래
링크에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/yxtq3-lhebQ&#34; target=&#34;_blank&#34;&gt;https://youtu.be/yxtq3-lhebQ&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NASA&#39;s Power of 10 Coding Rules (Korean)</title>
      <link>https://sjp38.github.io/post/nasa_coding_rules/</link>
      <pubDate>Sun, 21 Jul 2019 10:22:56 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/nasa_coding_rules/</guid>
      <description>&lt;p&gt;우연히 발견한
&lt;a href=&#34;https://dev.to/xowap/10-rules-to-code-like-nasa-applied-to-interpreted-languages-40dd?fbclid=IwAR1OA1FluREjWhd_1s93WBLtix8wrJZU6tOa5YLC-G9YxVu3iPeOOu09dzQ&#34; target=&#34;_blank&#34;&gt;글&lt;/a&gt;
을 통해 &lt;a href=&#34;http://spinroot.com/gerard/pdf/P10.pdf&#34; target=&#34;_blank&#34;&gt;NASA 의 코딩 규칙 10가지&lt;/a&gt; 를
알게 되었습니다.
너무 깐깐한 규칙 아닌가 싶기도 하지만 &lt;code&gt;ping&lt;/code&gt; 하나 날리는데 40분이 걸리고
물리적으로는 접근할 수 없는 화성에 로봇을 보내야 한다면 이런 규칙은 합리적이라
볼 수 있겠죠.
제가 참고한 저 글은 이걸 파이썬이나 자바스크립트와 같은 곳에서도 어떻게 적용해
볼 수 있을지를 고찰해 보고 있습니다.
이 포스트에선 단순히 이 10개의 규칙을 번역해 봅니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;goto&lt;/code&gt; 또는 재귀호출과 같은 복잡한 수행 흐름을 피하라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;원문: 모든 코드를 매우 간단한 수행 흐름으로 제한하라 - &lt;code&gt;goto&lt;/code&gt; 문, &lt;code&gt;setjmp`
또는&lt;/code&gt;longjmp`` 명령, 그리고 직/간접적 재귀 호출을 사용하지 말라.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Avoid complex flow constructs, such as goto and recursion.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Restrict all code to very simple control flow constructs – do not use goto
statements, setjmp or longjmp constructs, and direct or indirect recursion.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;모든 루프 (반복문) 은 고정된 최대 반복 횟수를 가져야 한다.  이는 무한반복
코드를 방지한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모든 루프는 고정된 최대 반복 횟수를 가져야 한다.  코드 체크 도구가 정적으로
어떤 루프의 반복 횟수가 미리 설정된 최대 횟수를 넘는지를 쉽게 검사할 수 있어야
한다.  이 반복 한계가 정적으로 검증될 수 없다면, 이 규칙이 깨어진 것으로
간주한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;All loops must have fixed bounds. This prevents runaway code.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All loops must have a fixed upper-bound. It must be trivially possible for a
checking tool to prove statically that a preset upper-bound on the number of
iterations of a loop cannot be exceeded. If the loop-bound cannot be proven
statically, the rule is considered violated.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;힙 메모리 할당을 피하라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;초기화 단계 후에는 동적 메모리 할당을 사용하지 말라.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Avoid heap memory allocation.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Do not use dynamic memory allocation after initialization.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;함수의 크기를 한장의 종이에 적힐 수 있게 제한하라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;어떤 함수도 명령문당 한줄, 선언당 한줄을 갖는 표준 레퍼런스 포맷을 지킨 채로
한장의 종이에 프린트 될 수 있는 길이 이상을 가져선 안된다.  보통, 이는 함수당
60줄 이상의 코드를 가져선 안된다는 것을 의미한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Restrict functions to a single printed page.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;No function should be longer than what can be printed on a single sheet of
paper in a standard reference format with one line per statement and one line
per declaration. Typically, this means no more than about 60 lines of code per
function.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;최소 함수당 두개의 런타임 단정문을 사용하라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;평균적으로 함수당 최소 두개의 단정문이 있어야 한다.  단정문은 실제 수행 중에
일어나선 안되는 문제가 있는 조건을 검사하는데 사용되어야 한다.  단정문은 항상
사이드 이펙트로부터 자유로워야 하고 Boolean 테스트로 정의되어야 한다.  단정문이
실패한다면 명시적인 복구 동작이 행해져야 하는데, 예를 들면 이 실패한 단정문을
수행한 함수를 호출한 측에 에러 정보를 리턴하는 것이다.  정적 검사 도구가 절대
실패할 수 없거나 항상 성공한다고 증명해내는 단정문은 모두 이 규칙을 어기는
것이다. (예를 들어, 전혀 도움 되지 않을 &lt;code&gt;assert(true)&lt;/code&gt; 문을 추가함으로써 이
규칙을 만족시킬 순 없다.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Use a minimum of two runtime assertions per function.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The assertion density of the code should average to a minimum of two assertions
per function. Assertions are used to check for anomalous conditions that should
never happen in real-life executions. Assertions must always be side-effect
free and should be defined as Boolean tests. When an assertion fails, an
explicit recovery action must be taken, e.g., by returning an error condition
to the caller of the function that executes the failing assertion. Any
assertion for which a static checking tool can prove that it can never fail or
never hold violates this rule. (I.e., it is not possible to satisfy the rule by
adding unhelpful &amp;ldquo;assert(true)&amp;rdquo; statements.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;데이터의 사용 영역을 가능한 작게 잡아라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;데이터 객체는 가능한 가장 작은 단계의 영역에서 선언되어야만 한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Restrict the scope of data to the smallest possible.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Data objects must be declared at the smallest possible level of scope.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;리턴 타입이 &lt;code&gt;void&lt;/code&gt; 가 아닌 (non-void) 모든 함수의 리턴값은 검사되거나
리턴값이 무의미하다는 걸 알리기 위해 &lt;code&gt;void&lt;/code&gt; 로 캐스팅 되어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;non-void&lt;/code&gt; 함수의 리턴값은 각 호출 함수에 의해 체크되어야 하며, 패러미터의
유효성은 각 함수 안에서 검사되어야 한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Check the return value of all non-void functions, or cast to void to
indicate the return value is useless.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The return value of non-void functions must be checked by each calling
function, and the validity of parameters must be checked inside each function.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;전처리기를 아껴 사용하라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;전처리기의 사용은 헤더 파일을 포함하는 용도와 간단한 매그로 정의로 국한되어야만
한다.  토큰 붙이기, 유동적 갯수의 인자 리스트, 그리고 재귀적 매크로 호출은
허용되지 않는다.  모든 매크로는 완전한 구문적 단위로 확장되어야만 한다.  조건적
컴파일 지시어의 사용은 많은 경우 모호하지만, 항상 금지될 수는 없다.  이는
거대한 소프트웨어 개발 노력이 든다 하더라도 동일한 헤더 파일의 중복 포함을
방지하는 상용문 외의 한두개의 조건적 컴파일 지시어를 위한 정당화가 필요하다는
것을 의미한다.  그런 모든 경우에는 도구 기반의 검사를 통한 플래그가 붙어있거나
코드 안에 사용의 정당성에 대한 설명이 있어야 한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Use the preprocessor sparingly.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The use of the preprocessor must be limited to the inclusion of header files
and simple macro definitions. Token pasting, variable argument lists
(ellipses), and recursive macro calls are not allowed. All macros must expand
into complete syntactic units. The use of conditional compilation directives is
often also dubious, but cannot always be avoided. This means that there should
rarely be justification for more than one or two conditional compilation
directives even in large software development efforts, beyond the standard
boilerplate that avoids multiple inclusion of the same header file. Each such
use should be flagged by a tool-based checker and
justified in the code.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;포인터의 사용을 한단계 디레퍼런스로 제한하고, 함수 포인터는 사용하지 말라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;포인터의 사용은 제한되어야 한다.  구체적으로, 두단계 이상의 디레퍼런스는
허용되지 않는다.  포인터 디레퍼런스 오퍼레이션이 매크로 정의나 &lt;code&gt;typedef&lt;/code&gt; 선언
안에 숨겨져선 안된다.  함수 포인터는 허용되지 않는다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Limit pointer use to a single dereference, and do not use function pointers.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The use of pointers should be restricted. Specifically, no more than one level
of dereferencing is allowed. Pointer dereference operations may not be hidden
in macro definitions or inside typedef declarations. Function pointers are not
permitted.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;모든 가능한 경고를 활성화 한 채 컴파일 하라; 그리고 모든 경고는 해당
소프트웨어의 배포 전에 해결되어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모든 코드는 개발을 시작한 첫날부터 모든 컴파일러 경고가 가장 엄중한 설정으로
활성화 된 채 컴파일 되어야만 한다.  모든 코드는 이 설정 아래 아무런 경고 없이
컴파일 되어야 한다.  모든 코드는 최소 하루에 한번, 그러나 가급적 한번 넘게,
최신의 정적 소스 코드 분석도구를 통해 검사되어야 하며 이 검사를 어떤 경고도
없이 통과해야만 한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Compile with all possible warnings active; all warnings should then be
addressed before release of the software.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All code must be compiled, from the first day of development, with allcompiler
warnings enabled at the compiler’s most pedantic setting. All code must compile
with these setting without any warnings. All code must be checked daily with at
least one, but preferably more than one, state-of-the-art static source code
analyzer and should pass the analyses with zero warnings.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the Linux Kernel Summit 2019</title>
      <link>https://sjp38.github.io/post/kernelsummit2019_talk/</link>
      <pubDate>Sat, 20 Jul 2019 02:41:46 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/kernelsummit2019_talk/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.linuxplumbersconf.org/blog/2019/&#34; target=&#34;_blank&#34;&gt;Linux Plumbers Conference 2019&lt;/a&gt; 와 함께 열리는 올해의
&lt;a href=&#34;https://lwn.net/Articles/788378/&#34; target=&#34;_blank&#34;&gt;Linux Kernel Summit&lt;/a&gt; 에 제안한 발표
주제가 accept 되어 9월에 리스본에서 이에 대한 내용을 발표하게
되었습니다.  발표 제목은 &amp;ldquo;Tracing Data Access Pattern with Bounded
Overhead and Best-effort Accuracy&amp;rdquo; 입니다.&lt;/p&gt;

&lt;p&gt;티켓이 너무 일찍 팔려버리는 바람에 올해는 들으러도 못가나 걱정했는데 갈 수 있게
됐네요, 다행입니다! :D&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;My talk proposal to the Linux Kernel Summit of this year which is co-located
with the Linux Plumbers has accepted!  Hope to see you in Lisbon.  The title of
the talk is, &amp;ldquo;Tracing Data Access Pattern with Bounded Overhead and Best-effort
Accuracy&amp;rdquo;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.3-rc1/</link>
      <pubDate>Thu, 11 Jul 2019 02:42:22 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.3-rc1/</guid>
      <description>

&lt;h2 id=&#34;patch-v5-0-5-introduce-madv-cold-and-madv-pageout&#34;&gt;[PATCH v5 0/5] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190714233401.36909-1-minchan@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190714233401.36909-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MADV_COLD&lt;/code&gt; 와 &lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 을 구현하는 패치, 어느새 다섯번째 버전입니다.  큰
변경은 없는 것 같군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-0-3-make-working-with-compound-pages-easier&#34;&gt;[PATCH v2 0/3] Make working with compound pages easier&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190721104612.19120-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190721104612.19120-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Huge page 를 다루기 쉽게끔 &lt;code&gt;page_size()&lt;/code&gt;, &lt;code&gt;page_shift()&lt;/code&gt;, 그리고
&lt;code&gt;compound_nr()&lt;/code&gt; 이라는 세개의 helper 함수를 추가하고 이 함수들을 사용하게끔
기존 코드를 다듬는 패치셋입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PAGE_SIZE &amp;lt;&amp;lt; compound_order(page)&lt;/code&gt; 는 &lt;code&gt;page_size(page)&lt;/code&gt; 가,
&lt;code&gt;PAGE_SHIFT + compound_order(page)&lt;/code&gt; 는 &lt;code&gt;page_shift(page)&lt;/code&gt; 가, 그리고
&lt;code&gt;1 &amp;lt;&amp;lt; compound_order(page)&lt;/code&gt; 는 &lt;code&gt;compound_nr(page)&lt;/code&gt; 가 되는 것이죠.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-3-rc1&#34;&gt;Linux 5.3-rc1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wiVjkTqzP6OppBuLQZ+t1mpRQC4T+Ho4Wg2sBAapKd--Q@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/wiVjkTqzP6OppBuLQZ+t1mpRQC4T+Ho4Wg2sBAapKd--Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번 릴리즈 사이의 변경 사항을 시각화 한 비디오를 아래 링크에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/vx_BUvs00u8&#34; target=&#34;_blank&#34;&gt;https://youtu.be/vx_BUvs00u8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2주일이 지나고 5.3 을 향한 첫번째 rc 릴리즈가 이루어졌습니다.&lt;/p&gt;

&lt;p&gt;이번 rc 릴리즈는 커밋 갯수로 볼 때 꽤 큰 릴리즈입니다.  4.12, 4.15, 4.19 때의
머지 윈도우와 비슷한 정도라는군요.  참고로 가장 큰 머지윈도우는 아직 4.9 의
것이었습니다.&lt;/p&gt;

&lt;p&gt;이번 머지 윈도우는 초기에 두개의 버그가 나와서 토발즈를 괴롭게 했다고 하는데요.
하나는 토발즈의 커널 컨피규레이션이 너무 간단하게 되어 있어 어떤 코드가 테스트
되지 않아 토발즈가 만들어낸 버그였고, 다른 하나는 패치 자체에 존재하는
버그였다고 합니다.  토발즈가 유발한 버그는 토발즈가 고쳤고, 두번째 버그를
일으킨 패치는 그냥 리버트 시켰다고 하는군요.&lt;/p&gt;

&lt;p&gt;그렇다고는 해도 이번 머지 윈도우의 후반부는 충분히 스무스하게 이뤄졌다고
합니다.&lt;/p&gt;

&lt;p&gt;그리고 이번 머지 윈도우에 이름을 올린 개발자는 총 1600명이었다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.2/</link>
      <pubDate>Mon, 01 Jul 2019 15:48:04 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.2/</guid>
      <description>

&lt;h2 id=&#34;patch-v5-00-12-s-a-r-a-a-new-stacked-lsm&#34;&gt;[PATCH v5 00/12] S.A.R.A. a new stacked LSM&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1562410493-8661-1-git-send-email-s.mesoraca16@gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1562410493-8661-1-git-send-email-s.mesoraca16@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다양한 보안 측정을 위한 공용 인터페이스를 제공하는 스택 기반의 리눅스 보안
모듈입니다.  이름이 재밌네요. S.A.R.A 는 S.A.R.A is Another Recursive Acronym
의 약자라고 합니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-2&#34;&gt;Linux 5.2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whtW3FdruS-q2zehJPSan1SKtHoFHKX28A3J_1gfTFUMw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whtW3FdruS-q2zehJPSan1SKtHoFHKX28A3J_1gfTFUMw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번 릴리즈 중간엔 토발즈의 여행이 있었죠.  초반엔 예상 외로 큰 rc 릴리즈도
있었구요.  해서 이번주는 rc8 이 릴리즈 될지 5.2가 릴리즈 될지 저도 좀
궁금했는데, 최종적으로 5.2 릴리즈가 되었습니다.  토발즈도 rc8 을 릴리즈 할까
망설였다고 하네요.  하지만 그래야 할만한 문제가 전혀 없었기에 5.2를 릴리즈
했다고 합니다.&lt;/p&gt;

&lt;p&gt;더불어, 토발즈는 이번 여행 중에도 스쿠버다이빙을 즐겼나보네요.  더크 혼델이
찍은 사진도 공유했습니다:
&lt;a href=&#34;https://hohndel.name/palau-2019&#34; target=&#34;_blank&#34;&gt;https://hohndel.name/palau-2019&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
