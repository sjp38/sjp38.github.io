<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hacklog on Hacklog</title>
    <link>https://sjp38.github.io/</link>
    <description>Recent content in Hacklog on Hacklog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Your Name</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Chromebook Plus Purchase (크롬북 플러스 구매 결정기)</title>
      <link>https://sjp38.github.io/post/chromebook-plus-purchase/</link>
      <pubDate>Mon, 03 Sep 2018 13:52:00 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/chromebook-plus-purchase/</guid>
      <description>

&lt;p&gt;&lt;em&gt;크롬북을 구매했습니다.  구매 결정 과정부터 사용기까지 내용을 정리해볼까 합니다.
이번 글에서는 크롬북을 구매하기까지의 고민과 과정을 정리합니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기본적으로 저는 글을 읽는걸 좋아하기도 하고 읽어야만 하기도 합니다.  그러다보니
여행을 가더라도 항상 어떤 책을 들고갈까 고르는게 설레기도 하지만 짜증나기도
하고, 마음만 앞서서 캐리어 무게를 책으로 꽉 채우기도 합니다.  그래서 예전부터
이북을 고려해 봤지만 너무 반응속도가 느리기도 하고 인쇄된 것에 비해선 가독성도
떨어지고 그 특유의 책을 넘겨가며 보는 반응은 아닌 것 같아 구매하지 않고
있었습니다.  하지만 슬슬 매번 책을 들고 다니는게 오히려 불편하다는 생각이 점점
늘어나고 있었습니다.&lt;/p&gt;

&lt;p&gt;한편으로는 랩톱만 들고 다니기에는 불편하다는 생각이 들었습니다.  저는 구글
핵페어에 출품을 하면서 넥서스7 1세대와 2세대를 얻게 되어 이 기기들을 사용해
왔습니다.  태블릿의 휴대성은 랩톱과 비교할 수 없는 것이었습니다.  특히 넥서스7
2세대는 해상도가 높아져 글을 읽기에도 편리했습니다.  다만, 7인치의 좁은, 특히
가로대비 세로가 매우 짧게 비디오에 특화된 화면비율은 많이 불편했습니다.  그래도
침대위 인터넷에는 쓸만했는데 작년 프라하에서 숙소에서 떨어뜨렸고, 디스플레이에
금이 가고 터치가 먹통이 되었습니다.&lt;/p&gt;

&lt;p&gt;있을 땐 그렇게 소중한지 몰랐지만 7인치짜리라도 태블릿이 없어지니 랩톱의 불편이
느껴졌습니다.  특히, 컨퍼런스 등에 가서 책상이 없는 자리에 앉을 때, 전원
플러그가 없을때 그렇습니다.  전력 등을 고려해 안쓰고 있을 때엔 랩톱을 닫고
있어야 하는데, 발표를 듣다가 뭔가 흥미로운 사이트 소개 등이 있어 잠시 인터넷을
하고 싶을때 랩톱을 열어야 합니다.  열고 나면 패스워드를 입력하거나 지문 인식을
해야 하는데, 이 짧은 인터럽트가 매우 불쾌하고 생각의 흐름을 끊어버립니다.&lt;/p&gt;

&lt;p&gt;한편, 최신 태블릿과 아이패드들을 만져보니 많이 발전되었다는 생각이 들었습니다.
그래서 하나 사는게 좋겠다 싶어 물건들을 알아보았습니다.  하지만 동시에 단점도
많이 눈에 띄더군요.&lt;/p&gt;

&lt;h1 id=&#34;요구사항&#34;&gt;요구사항&lt;/h1&gt;

&lt;p&gt;가격은 30만원선을 원합니다. 40을 넘어가면 지갑이 버티지 못합니다.&lt;/p&gt;

&lt;p&gt;랩톱과 함께 쓸만한 서브 디바이스를 원합니다.  따라서 커널을 빌드하거나 할
생각은 없으니 컴퓨팅 파워는 크게 중요하지 않습니다.  저장공간도 너무 클 필요
없습니다.  인터넷만 원활한 정도면 되겠습니다.&lt;/p&gt;

&lt;p&gt;책을 보고 싶고, 특히 논문도 볼 수 있길 바라기 때문에 화면이 크고 해상도가
높아야 합니다.  가로 비율이 너무 길어서 비디오에만 최적화 되어 있는 화면은 원치
않습니다.  적당한 pdf 뷰어도 지원이 되어야 합니다.&lt;/p&gt;

&lt;p&gt;오픈소스 운영체제로 돌아가는 기기면 좋겠습니다.  커널은 리눅스여야 합니다.
업스트림 커널을 설치할 수 있어 커널 테스트용으로 사용할 수 있다면 가산점이 크게
올라갑니다.  사실 가장 원하는건 데비안이나 우분투, 페도라 등이 깔린 리눅스 순정
태블릿이지만 적당한 기기가 없어 보입니다.&lt;/p&gt;

&lt;p&gt;리눅스 셸이 제공되면 좋겠습니다.  사실상 거의 모든 일을 거기서 할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;아이패드&#34;&gt;아이패드&lt;/h1&gt;

&lt;p&gt;결코 살 수 없습니다.  폐쇄성 때문입니다.  사용자 레벨에서도 폐쇄적이지만 독점
소프트웨어로 돌아가는 기기를 사고 싶지 않았습니다.&lt;/p&gt;

&lt;h1 id=&#34;안드로이드-태블릿&#34;&gt;안드로이드 태블릿&lt;/h1&gt;

&lt;p&gt;안드로이드 태블릿은 하이엔드 제품의 경우 아이패드와 비슷한 성능이고, 일단은
오픈소스인 안드로이드 운영체제를 사용하고 있습니다.  리눅스 커널 기반이고,
수많은 안드로이드 앱중에는 적절한 pdf 뷰어 앱도 있습니다.  Termux 등을 사용하면
셸도 원활하게 사용할 수 있습니다.  업스트림 리눅스 커널을 직접 빌드해
설치하려면 까다롭긴 하지만 불가능한 것도 아니긴 합니다.&lt;/p&gt;

&lt;p&gt;한가지 치명적인 건 운영체제 업데이트가 원활치 않아 보이는군요.  가격을 생각해야
하니 나온지 오래된 모델들을 알아봤는데 하나같이 운영체제 업데이트가 되지 않고
있는 듯 했습니다.&lt;/p&gt;

&lt;h1 id=&#34;크롬북&#34;&gt;크롬북&lt;/h1&gt;

&lt;p&gt;그렇게 이번에도 아이쇼핑만 하고 그만두려던 차에 크롬북이 눈에 들어왔습니다.
크롬북은 안드로이드보다 훨씬 개방적인 정책을 취한 오픈소스 운영체제인 크롬 OS
를 사용하고 있습니다.  리눅스 커널 기반이고, 최근들어 안드로이드 앱과 리눅스
네이티브 앱을 공식 지원하고 있습니다.  구글 정책상 대부분의 크롬 OS 디바이스가
최신 OS로 업데이트 됩니다.  과거에 잠시 셋업만 해봤는데 crouton 등을 사용하면
Ubuntu 등의 리눅스 배포판을 설치할 수 있고 Chrome OS 와의 전환도 키 하나만
누르면 되어서 매우 간편했던 기억이 있습니다.  문제라면 폼팩터가 랩톱의
폼팩터라는 것인데, 요즘 나오는 크롬북은 디스플레이를 360도 전환할 수 있어
태블릿 모드와 텐트 모드를 사용할 수 있는 제품이 대부분입니다.  가격도 매우
저렵한게 특징입니다.&lt;/p&gt;

&lt;p&gt;이거다 싶었습니다!&lt;/p&gt;

&lt;h1 id=&#34;크롬북-플러스&#34;&gt;크롬북 플러스&lt;/h1&gt;

&lt;p&gt;그렇게 크롬북 모델들을 찾아보니 삼성 크롬북 플러스[1] 가 눈에 들어왔습니다.
12.3인치 화면에 2400x1600 해상도.  책 읽기에 딱 적절해 보입니다.  스타일러스
펜도 있고, 6코어 프로세서는 ARM 프로세서지만 제게는 차고 넘쳐 보이더군요.
한가지 걸리는건 브랜드와 가격.  삼성에 대해 안좋은 인식이 있습니다.  그리고
가격이 약 450 달러.  한국에서 사려면 대략 50만원을 넘습니다.  40만원 미만을
원하던 걸 생각하면 가격이 조금 셉니다.  그래도 혹시나 하고 아마존에서 검색을
해봤습니다.  오잉? 250불에 핫딜이 있네요.  잘 보니 중고 물품입니다.  어차피
보조 디바이스니 큰 상관 없겠다 싶군요.  질렀습니다!!!&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://www.samsung.com/us/computing/chromebooks/12-14/xe513c24-k01us-xe513c24-k01us/&#34; target=&#34;_blank&#34;&gt;https://www.samsung.com/us/computing/chromebooks/12-14/xe513c24-k01us-xe513c24-k01us/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc2</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.19-rc2/</link>
      <pubDate>Mon, 03 Sep 2018 11:34:35 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.19-rc2/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19-rc2&#34;&gt;Linux 4.19-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 4.19 두번째 릴리즈 후보 버전의 릴리즈입니다.  첫번째 릴리즈 후보 버전
릴리즈 후엔 사람들이 좀 쉬게 마련이고 버그를 찾기엔 시간이 많지 않았기에 큰
변화는 없었습니다.  유럽사람들의 경우 아직 휴가기간인 사람도 많구요.  미국
OSSummit 이 지난주 진행된 것도 한 영향이겠네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Paper about GCMA Accepted to TC</title>
      <link>https://sjp38.github.io/post/gcma_accepted_to_tc/</link>
      <pubDate>Wed, 29 Aug 2018 21:53:56 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/gcma_accepted_to_tc/</guid>
      <description>&lt;p&gt;A paper about &lt;a href=&#34;https://sjp38.github.io/post/gcma/&#34; target=&#34;_blank&#34;&gt;GCMA project&lt;/a&gt; has accepted to a top-level computer science journal, Transactions on Computers[1].  It will be published soon.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://sjp38.github.io/post/gcma/&#34; target=&#34;_blank&#34;&gt;GCMA&lt;/a&gt; 에 대한 논문이 컴퓨터 과학계의 최고 수준 저널인
Transactions on Computers[1] 에 Accept 되었습니다.  조만간 이를 통해 출간될
예정입니다.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://www.computer.org/web/tc&#34; target=&#34;_blank&#34;&gt;https://www.computer.org/web/tc&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git Origin Story in Korean</title>
      <link>https://sjp38.github.io/post/git_origin_story_ko/</link>
      <pubDate>Wed, 29 Aug 2018 21:15:13 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/git_origin_story_ko/</guid>
      <description>&lt;hr /&gt;

&lt;p&gt;최근 흥미롭게 보았던 &lt;code&gt;Git Origin Story&lt;/code&gt; 라는 제목의 LinuxJournal.com 기사를
번역해 봅니다.  원본 기사는
&lt;a href=&#34;https://www.linuxjournal.com/content/git-origin-story&#34; target=&#34;_blank&#34;&gt;https://www.linuxjournal.com/content/git-origin-story&lt;/a&gt; 에서 보실 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;수년간 리눅스 커널 개발자들이 사용해온 다양한 리비전 컨트롤 방법, Linus
Torvalds가 Bit keeper 를 사용하기로 한 결정과 그에 뒤따른 논쟁, 그리고 어떻게 Git
이 만들어졌는가에 대한 글입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;처음에, Linus Torvalds는 리비전 컨트롤을 아예 사용하지 않았습니다.  커널에
코드를 기여하고자 하는 사람은 Usenet 그룹에, 나중에는 메일링 리스트에 패치를
올렸고, Linus는 자신의 소스 트리에 그걸 적용했습니다.  나중에 Linus는
릴리즈를 통해 패치들 사이의 구분 없이 전체 소스 트리를 공개하는 식이었습니다.
Torvalds의 작업 이력을 알아낼 수 있는 유일한 방법은 전체 릴리즈 버전 사이의
거대한 diff 를 통하는 것 뿐이었습니다.&lt;/p&gt;

&lt;p&gt;이는 오픈소스 리비전 컨트롤 시스템이 없기 때문은 아니었습니다.  1980년대부터
CVS 가 있었고, 그 당시에도 가장 유명한 시스템이었습니다.  그 핵심 기능을
사용해서 기여자들이 패치를 중앙 저장소에 보낼 수 있었고 그 저장소로 들어가는
패치의 기록을 조사할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;하지만 CVS 에 대한 많은 불만이 있었습니다.  그 중 하나는 변경 사항을 파일별로
제공하고 커다란 패치는 하나의 버전으로 인식할 수 없어서, 다른 개발자들로부터의
과거의 기여를 해석하기가 어려웠습니다.  또한, 두개의 같은 파일을 수정하는
패치가 동시에 보내졌을 때 발생하는 레이스 컨디션 같은 고치기 어려운 버그들도
일부 있었습니다.&lt;/p&gt;

&lt;p&gt;Linus는 CVS 를 좋아하지 않았는데, 부분적으로는 다른 사람들의 불만과 같은 이유
때문이었고 부분적으로는 후에야 명확해진 그만의 이유 때문이었습니다.  그는 CVS
의 버그와 이상한 기능들을 해결하려는 목표를 가지고 2000년대 초부터 발전되어온
오픈소스 프로젝트인 SVN 도 좋아하지 않았습니다.&lt;/p&gt;

&lt;p&gt;많은 리눅스 커널 개발자들이 적당한 리비전 컨트롤의 부재에 불만족스러 했으며,
따라서 Linus가 사용 가능한 리비전 컨트롤 중에서 뭐든 하나를 고르길 바라는
커뮤니티로부터의 압력이 항상 있었습니다.  그리고, 2002년, Linus는 그렇게
했습니다.  충격적이고 당황스럽게도, Linus는 Larry McVoy 에 의해 운영되는
BitMover 라는 회사에 의해 개발된, 소스코드가 공개되어있지 않은 상업용 시스템인
BitKeeper 를 선택했습니다.&lt;/p&gt;

&lt;p&gt;리눅스 커널은 역사상 가장 중요한 오픈소스 프로젝트였고, Linus 그 스스로가
수십년간 다른 오픈소스 프로젝트들이 따라하게 되었고 지금까지도 그렇게 하고 있는
오픈소스 개발 방법을 처음으로 발견한 사람이었습니다.  Linus가 무슨 생각을 하는
거지?  어떻게 그가 그의 커뮤니티와 오픈소스 세계를 이렇게 배신할수가 있지?
이게 Linus가 처음 커널 개발에 BitKeeper 를 사용했을 때 대부분의
반응이었습니다.&lt;/p&gt;

&lt;p&gt;또한, BitMover 는 돈을 받지 않고 BitKeeper 를 사용할 수 있는 라이센스를
제공하는데 대한 대가로 리눅스 커뮤니티에 제한을 걸었습니다.  첫째, 리눅스
개발자들은 BitKeeper 를 사용하는 동안 다른 경쟁 리비전 컨트롤 시스템 개발
프로젝트에 참여할 수 없었습니다.  둘째, BitMover 는 라이센스에 대한 악용을 막기
위해 커널 프로젝트에 관계된 일부 메타데이터를 제어할 수 있었습니다.  이
메타데이터에 대한 접근이 불가능하면, 커널 개발자들은 다른 리비전 컨트롤
시스템에서의 중요한 표준적 기능인, 과거의 커널 버전들 사이의 비교를 할 수
없었습니다.&lt;/p&gt;

&lt;p&gt;Linus가 BitKeeper 를 사용한지 수년이 지나도 논쟁은 줄어들지 않았습니다.  그의
기본적 주장은, 그는 프리 소프트웨어 (Free Software) 광신도가 아니라는
것이었습니다.  그는 오픈소스 도구들이 같은 일을 하는 상업용 도구들에 비해
낫다면 그걸 사용할 거라고 했습니다.  하지만 상업용 도구가 더 낫다면, 그는 다른
도구를 고려하지 않을 거라고요.&lt;/p&gt;

&lt;p&gt;하지만, 많은 커널 개발자들이 실제로 프리 소프트웨어 광신도였습니다.  커뮤니티에
손상을 입히고 리눅스 커널 프로젝트의 fork 를 일으킬 만큼은 아니지만 Linus와
다른 개발자들간의 분노와 긴장이 심해졌습니다.  Alan Cox, Al Viro, David Miller,
Andrea Arcangeli, Andrew Morton 과 많은 수의 다른 사람들이 경쟁 프로젝트를
이끌만한 기술력을 가지고 있음이 분명했고, 심지어 일부는 상당수 커널 개발자들을
그들 쪽으로 끌어갈 명성을 가지고 있었습니다.  하지만 아무도 그러지 않았습니다.
이 긴장과 적대는 계속 유지되었습니다.&lt;/p&gt;

&lt;p&gt;BitKeeper 의 무엇이 그리 대단했을까요?  BitKeeper 에서 자랑한 건 분산시스템을
제공한다는 것으로, 모든 저장소가 쉽게 fork 되고 merge 될 수 있었습니다.  이게
핵심이었습니다.  이를 통해, 특정 하위 그룹의 커널 개발자들은 리비전 컨트롤의
이득을 얻으면서 그룹끼리 독자적으로 협업하고, 준비된 다음에 그들의 변경 사항을
Linus에게 전달할 수 있었습니다.  이를 통해, 전에는 Linus 한명의 어깨에 완전히
매여있던 수많은 작업이 Linus가 믿는 개발자들, 또는 그렇게 작업하기로 한
그룹들에게 분산될 수 있었습니다.  아키텍쳐별 코드, 드라이버, 그리고 커널의 하위
시스템들이 모두 어떻게든 독립적으로 개발되고, 이후 적절한 시점에 한번에 메인
커널에 병합될 수 있었습니다.&lt;/p&gt;

&lt;p&gt;슬슬 하는 이야기가 익숙하게 들릴 겁니다만, 2002년에 이건 새로운
아이디어였습니다.  CVS 와 Subversion 같은 당시 존재하던 프로젝트들에서 fork 와
merge 는 주인만 할 수 있고, 죽고 싶도록 시간이 오래 걸리는 작업이었습니다.
BitKeeper 를 통해, 이게 사소한 작업이 되었습니다.&lt;/p&gt;

&lt;p&gt;커널 개발 도구의 핵심부에 독점 소프트웨어를 사용하려는 Linus의 의지는 많은
사람들이 대안을 만드는데 더욱 노력하게 만들었습니다.  CVS 와 Subversion
프로젝트는 너무 많은 기초적 설계 오류가 있었고, 이미 너무 많이 개발이 진행되어
변경하기가 쉽지 않았습니다.  다른 프로젝트들 모두 마찬가지였습니다.  하지만
이제 그들은 Linus가 정말 원하는걸 알거나 안다고 생각했으므로, 정말로 코딩을
시작할 수 있었습니다.  그 결과 분산 개발 기능을 제공하는 많은 수의 리비전
컨트롤 시스템이 나왔습니다.&lt;/p&gt;

&lt;p&gt;그런 시스템들 중에 arch, darcs, 그리고 monotone 등이 있었습니다.  그들은
Bitkeeper 를 경쟁 상대라고 함으로써, Linus가 Bitkeeper 에 대한 대안으로 그들을
선택하라고 설득했습니다.&lt;/p&gt;

&lt;p&gt;많은 사람들이 시도했지만, 아무도 성공하지 못했습니다.  이는 부분적으로는
Linus가 CVS 와 Subversion 에 뭐가 빠져있는지 모두 이야기 하지 않았듯, 그
프로젝트들에 Linus가 더 필요로 하는 것이 무엇인지 모두 말하지 않았기
때문입니다.  그리고, Linus가 소스가 폐쇄된 도구를 사용하는것도 개의치 않는 것
같았으므로, 어떤 대안이 그에게 받아들여질만 하려면 그 대안은 BitKeeper 보다
훨씬 기술적으로 향상되어 있어야만 할 것이었습니다.  따라서, BitKeeper 전에도
오픈소스 툴의 기능은 충분하지 않았지만, BitKeeper 가 나타남으로써 오픈소스 툴이
맞춰야 할 기능의 목표가 더욱 높아진 셈입니다.&lt;/p&gt;

&lt;p&gt;수년간의 많은 노력 후에도, 어떤 오픈소스 대안도 Linus의 필요를 맞추기엔 CVS 나
Subversion 보다도 크게 나아지지 못했습니다.  만약 Samba 를 만들었고 rsync 의
공동 창시자인 Andrew Tridgell 이 아니었더라면 이 상황은 훨씬 오래 지속될 수
있었을 겁니다.  2005년, Andrew는 프리 소프트웨어인 대안을 만들기 위해 BitKeeper
네트워킹 프로토콜을 리버스 엔지니어링 하려 했습니다.  그가 아니었더라도,
누군가는 시도했을 겁니다 - 그건 그저 시간 문제였습니다.  Larry McVoy 는 누구든
이 시도를 했다면 당장 지원을 끊겠다고 리눅스 개발자들에게 경고했고, 실제로
그렇게 했습니다.  결국, 급작스럽게 BitKeeper 를 커널 개발에 사용될 수 없게
되었습니다.  전체 개발 도구와 분산 버전 컨트롤로부터 생겨난 개발 문화는 앞날을
알 수 없는 상황에 놓였습니다.&lt;/p&gt;

&lt;p&gt;이게 무슨 의미일까요?  Linus는 그의 과거 방식의 개발로 돌아가서 모든 패치를 그
자신에게 보내라고 했을까요?  그렇지 않다면, BitKeeper 의 오픈소스 대안들 가운데
하나를 선택했을까요?  만약 그가 그랬다면, 어떤 대안을 골랐을까요?&lt;/p&gt;

&lt;p&gt;이 시점에서, 놀라운 일이 발생했습니다.  Linus가 리눅스 커널 개발을 1991년
시작한 후 처음으로 작업을 완전히 멈췄습니다.  현존하는 어떤 도구도 그가 원하는
일을 해주지 못했으므로, 그는 자신의 것을 만들기로 결정했습니다.&lt;/p&gt;

&lt;p&gt;Linus의 주요 관심은, 사실 속도였습니다.  이것이 그가 기존에는 완전히, 적어도
현존하는 프로젝트들이 이해할 수 있는 방식으로는 이야기하지 않은 부분이었습니다.
전세계에서 전력을 다해 패치를 보내오는 수천명의 커널 개발자들을 위해, 그는
기존에는 상상할 수 없는 속도로 동작하는 무언가가 필요했습니다.  그는 가장
거대하고 가장 복잡한 작업이라 해도 완료하는데 몇초 이상 기다리는 걸 참을 수
없었습니다.  Arch 도, darcs, monotone 도, 그리고 어떤 다른 프로젝트도 이
요구사항을 맞추지 못했습니다.&lt;/p&gt;

&lt;p&gt;Linus는 잠시 은둔한 채 코딩을 했고, 그 후에 그의 새로운 계획을 세상에
알렸습니다.  2005년 6월에 그 프로젝트를 시작한 이래 몇일만에, Linus의 git
리비전 컨트롤 시스템은 git 소스코드의 리비전 컨트롤을 완전히 할 수 있게
되었습니다.  몇주 후, git 은 리눅스 커널 개발의 리비전 컨트롤을 맡을 준비가
되었습니다.  몇달 후, 완전한 기능을 갖추었습니다.  이 시점에서, Linus는 이
프로젝트의 관리 권한을 해당 프로젝트의 가장 열정적인 기여자, Junio C. Hamano
에게 넘기고 리눅스 개발에 다시 전념했습니다.&lt;/p&gt;

&lt;p&gt;이 도구에 놀란 프리 소프트웨어 개발자 커뮤니티는 이 괴상한 작업물을 이해하려
노력했습니다.  이것은 리비전 컨트롤 소프트웨어의 어떤 것도 닮지 않았습니다.
사실, 이것은 리비전 컨트롤 시스템보다는 낮은 단계의 파일시스템 오퍼레이션들의
집합에 가까워 보였습니다.  그리고 다른 시스템들이 패치를 저장하는 것과 달리,
이것은 각각의 변경된 파일의 버전을 모두 저장했습니다.  어떻게 이런 방식이
괜찮을 수 있을까요?  하지만, 이 도구는 fork 와 merge 를 번개같은 속도로 처리할
수 있고, 패치를 요청하자마자 만들어낼 수 있었습니다.&lt;/p&gt;

&lt;p&gt;점진적으로, Junio는 CVS 와 Subversion 의 것들을 닮은 높은 수준의 커맨드 집합을
만들었습니다.  Git 의 원래 커맨드들이 &amp;ldquo;배관&amp;rdquo; 이었다면, 새로운 커맨드들은
&amp;ldquo;도자기 제품&amp;rdquo; 이었습니다.  그리고, 결국 사용되게 되었습니다.&lt;/p&gt;

&lt;p&gt;BitKeeper 에 대한 논쟁과 분노가 있었던 만큼이나, git 의 계속된 개발을 향한
열망과 참여 의지가 많았습니다.  포팅, 확장 기능, 그리고 웹사이트들이 모든 것을
현재 상태로 끌어올렸습니다.  몇년만에, 거의 모든 사람들이 git 을 사용하게
되었습니다.  리눅스처럼, git 이 세상을 집어삼켰습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi 3 Serial Connection</title>
      <link>https://sjp38.github.io/post/rasp3-serial/</link>
      <pubDate>Mon, 27 Aug 2018 17:16:35 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/rasp3-serial/</guid>
      <description>

&lt;p&gt;라즈베리 파이를 메인 컴퓨터로 사용하려는게 아니라면, 라즈베리 파이에 모니터와
키보드, 마우스를 연결하고 사용하는게 아무래도 번거롭습니다.  ssh 로 붙어서
작업하는 것도 한 방법이지만, 그게 여의치 않은 상황도 있습니다.  그저 터미널만
연결되면 되는 상황이라면, 가장 간단한 건 UART Serial 통신을 사용하는 겁니다.&lt;/p&gt;

&lt;p&gt;라즈베리 파이는 UART 통신을 지원하고 있는데, GPIO 핀 중 14번과 15번이[2] 각각
TX, RX 입니다.  호스트 컴퓨터와 이 두개의 핀을 연결하면 UART 통신을 할 수
있어서 라즈베리 파이의 터미널에 바로 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;호스트 머신에 핀을 연결하는게 번거로울 수 있는데, 시리얼-USB 젠더를 여기저기서
저렴한 가격에 팝니다[1].  이걸 이용해 TX/RX 핀을 라즈베리 파이의 GPIO 14, 15번에
각각 연결하고 USB 를 호스트 머신에 연결합니다.&lt;/p&gt;

&lt;p&gt;이제 호스트 머신의 &lt;code&gt;/dev/&lt;/code&gt; 디렉토리에 &lt;code&gt;ttyUSB&lt;/code&gt; 로 시작하는 파일이 생겼을
겁니다.  제 경우 &lt;code&gt;ttyUSB0&lt;/code&gt; 라는 이름의 파일이 생겼군요.  이제, 시리얼 통신
프로그램인 &lt;code&gt;minicom&lt;/code&gt; 을 사용해서 이 포트로 연결해서 UART 통신을 합시다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo minicom -D /dev/ttyUSB0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 라즈베리 파이를 부팅 시키면 부팅 로그부터 터미널에 나오고, 로그인 화면까지
뜹니다.&lt;/p&gt;

&lt;h1 id=&#34;라즈베리파이3-시리얼-문제와-해결법&#34;&gt;라즈베리파이3 시리얼 문제와 해결법&lt;/h1&gt;

&lt;p&gt;하지만, 라즈베리 파이 3 에서는 내장으로 블루투스와 WiFi 가 들어가면서 GPIO 핀이
겹치게 되어 앞의 과정만으로는 시리얼 통신을 할 수 없습니다.  블루투스를 끄고
시리얼을 켜줘야 합니다.&lt;/p&gt;

&lt;p&gt;먼저, 다음과 같이 &lt;code&gt;/boot/config.txt&lt;/code&gt; 파일에 다음 두줄을 추가합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo echo &amp;quot;enable_uart=1&amp;quot; &amp;gt;&amp;gt; /boot/config.txt
$ sudo echo &amp;quot;dtoverlay=pi3-miniuart-bt&amp;quot; &amp;gt;&amp;gt; /boot/config.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 /boot/cmdline.txt 를 열어서 &lt;code&gt;console=tty1&lt;/code&gt; 이라는 내용을 추가해줍니다.&lt;/p&gt;

&lt;p&gt;준비가 끝났습니다.  재부팅 하면 &lt;code&gt;minicom&lt;/code&gt; 에 라즈비안 콘솔이 연결됩니다.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://www.devicemart.co.kr/29565&#34; target=&#34;_blank&#34;&gt;https://www.devicemart.co.kr/29565&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&#34;https://www.raspberrypi.org/documentation/usage/gpio/&#34; target=&#34;_blank&#34;&gt;https://www.raspberrypi.org/documentation/usage/gpio/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.19-rc1/</link>
      <pubDate>Mon, 27 Aug 2018 17:11:28 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.19-rc1/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19-rc1&#34;&gt;Linux 4.19-rc1&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CA+55aFw9mxNPX6OtOp-aoUMdXSg=gBkQudGGamo__sh_ts_LdQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이주일의 머지 윈도우가 끝나고 리눅스 4.19 버전을 향한 안정화 단계가
시작되었습니다.&lt;/p&gt;

&lt;p&gt;토발즈에겐 결코 즐겁지 않은 머지 윈도우였습니다 (frustrating merge window
였다고 표현하는군요).  일단 머지 윈도우 초기부터 L1TF 취약점 이슈가 나왔죠.
하지만 이슈가 처음 발견된 건 아니고 공식 보고된 거다보니 그 전부터 수정은 하고
있었기에 머지만 하면 됐습니다.  토발즈는 &lt;code&gt;-next&lt;/code&gt; 트리와 다양한 커널 테스트
시스템들이 잘 갖추어져 있다는 증거라고 이야기 합니다.&lt;/p&gt;

&lt;p&gt;또, TLB 슛다운 버그에 대한 보고가 있었군요.  결국은 큰 문제는 아니었다고
결론났음에도 토발즈의 신경을 많이 긁었다고 합니다.  이 과정에서 관련 코드가
매우 복잡하고 디버깅 하기 어렵다고 이야기 되었기에 차후 정리가 필요할 것
같다는군요.&lt;/p&gt;

&lt;p&gt;또한, 이번 릴리즈는 꽤 많은 변경이 있는 편이라고 합니다, 물론 커밋 수
기반으로요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi 3 Model B Setup</title>
      <link>https://sjp38.github.io/post/rasp3-modelb-setup/</link>
      <pubDate>Mon, 27 Aug 2018 16:03:42 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/rasp3-modelb-setup/</guid>
      <description>&lt;p&gt;OSSE 2016 에서 받아온 라즈베리 파이3 셋업을 해봅니다.
셋업에 사용된 호스트 환경은 Ubuntu 16.04 데스크탑입니다.&lt;/p&gt;

&lt;p&gt;라즈베리 파이는 SD 카드를 저장소로 사용합니다.  따라서 여기에 운영체제를 깔아야
합니다.  다만, 라즈베리 파이를 구매하면 SD 카드는 따라오지 않습니다.  각자
알아서 사야 합니다.  전 예전에 사둔 16 GiB 짜리 SD 카드를 사용하겠습니다.&lt;/p&gt;

&lt;p&gt;라즈베리 파이를 지원하는 운영체제는 여러가지 있는데, 데비안 계열의 Raspbian 이
공식 운영체제입니다.  &lt;a href=&#34;https://www.raspberrypi.org/downloads/&#34; target=&#34;_blank&#34;&gt;다운로드 페이지&lt;/a&gt;
에서 Raspbian stretch lite 를 다운받고 압축을 풀어줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
2018-06-27-raspbian-stretch-lite.zip
$ unzip 2018-06-27-raspbian-stretch-lite.zip 
Archive:  2018-06-27-raspbian-stretch-lite.zip
  inflating: 2018-06-27-raspbian-stretch-lite.img  

$ ls
2018-06-27-raspbian-stretch-lite.img  2018-06-27-raspbian-stretch-lite.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;압축 파일이 350 MiB, 압축 푼 이미지는 1.8 GiB 나 하는군요.&lt;/p&gt;

&lt;p&gt;이제 요걸 SD 카드에 써야하는데요, 일단 SD 카드를 데스크탑에 연결하고, &lt;code&gt;df&lt;/code&gt; 명령을 이용해 이게 어떤 디바이스 파일로 인식되었는지 봅시다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            7.8G     0  7.8G   0% /dev
tmpfs           1.6G  174M  1.4G  11% /run
/dev/sda1       222G  127G   84G  61% /
tmpfs           7.8G  161M  7.7G   3% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           7.8G     0  7.8G   0% /sys/fs/cgroup
tmpfs           1.6G   68K  1.6G   1% /run/user/1000
/dev/sdb        917G  541G  330G  63% /media/sjpark/47f422d0-445f-4dfc-86ca-559b801eb9d3
/dev/sdc2        15G  4.7G  9.3G  34% /media/sjpark/f24a4949-f4b2-4cad-a780-a138695079ec
/dev/sdc1        56M   24M   33M  42% /media/sjpark/boot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;제가 사용한 SD 카드는 기존에 라즈베리파이2 모델 B+ 운영체제가 설치되어
있었습니다.  /&lt;code&gt;dev/sdc&lt;/code&gt; 로 SD 카드가 잡혔고, &lt;code&gt;/dev/sdc1&lt;/code&gt; 으로 부팅 파티션이,
&lt;code&gt;/dev/sdc2&lt;/code&gt; 로 데이터 파티션이 잡힌 것 같군요.&lt;/p&gt;

&lt;p&gt;이제 마운트된 파티션들을 언마운트하고, &lt;code&gt;dd&lt;/code&gt; 명령으로 이미지를 덮어씌웁시다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo umount /media/sjpark/f24a4949-f4b2-4cad-a780-a138695079ec
$ sudo umount /media/sjpark/boot
$ sudo dd bs=4M if=./2018-06-27-raspbian-stretch-lite.img of=/dev/sdc
444+0 records in
444+0 records out
1862270976 bytes (1.9 GB, 1.7 GiB) copied, 199.44 s, 9.3 MB/s
$ sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음 두개 커맨드가 언마운트를 하고, 세번째 커맨드가 이미지를 덮어씌우는
커맨드입니다.  혹시 모르니 네번째 커맨드에서 &lt;code&gt;sync&lt;/code&gt; 해서 데이터가 확실히
씌워지게 했습니다.&lt;/p&gt;

&lt;p&gt;이제 라즈베리 파이의 HDMI 단자에 모니터를 연결하고 micro USB 포트에 스마트폰
충전하듯이 USB 를 연결해 전원을 인가해주면 라즈베리 파이가 라즈비안으로
부팅됩니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18/</link>
      <pubDate>Mon, 13 Aug 2018 10:50:27 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18&#34;&gt;Linux 4.18&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;자, 오랫만에 rc 버전을 8개나 내며 긴 안정화 기간을 거친 4.18 버전이 릴리즈
되었습니다.  따라서 지난주는 조용해야 했고 실제로 조용했지만 그럼에도 불구하고
vfs 레이스 컨디션 문제 수정 등의 변경도 있긴 했습니다.  이번 정식 릴리즈로
포함된 기능 중 개인적으로는 Restartable Sequence 가 눈에 띄고 흥미롭군요.  아마
2015년? 인가에 서울에서 커널 서밋 열려서 거기서 발표 들었을 때부터
관심있었거든요.  유저스페이스에서 이 기능을 잘 사용하면 멀티코어 성능확장성에
큰 개선이 가능할 것 같습니다.&lt;/p&gt;

&lt;p&gt;어쨌건, 이로써 4.19 버전을 향한 머지 윈도우가 열렸습니다.  5.x 는 언제
시작되려나요?&lt;/p&gt;

&lt;h2 id=&#34;git-pull-xarray-for-4-19&#34;&gt;[GIT PULL] XArray for 4.19&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180813161357.GB1199@bombadil.infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180813161357.GB1199@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 블로그에서도 몇번 소개한 XArray 의 개발자, Matthew 가 충분히 리뷰도 받고
수정도 했다고 생각하는 것 같습니다.  4.18 릴리즈와 함께 열린 4.19 머지윈도우에
XArray 풀리퀘스트를 리누스 토발즈에게 던졌군요!&lt;/p&gt;

&lt;p&gt;이 풀리퀘스트는 XArray 의 구현과 &lt;code&gt;pagecache&lt;/code&gt; 가 XArray 를 사용하도록 하는
변경을 담고 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.18-rc8</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc8/</link>
      <pubDate>Mon, 06 Aug 2018 17:53:02 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc8/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc8&#34;&gt;Linux 4.18-rc8&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;원래대로라면 오늘 4.18 정식 릴리즈가 있어야 했지만, 지난주 동안 여러 일이
있었고, 결국 여덟번째 rc 버전이 나오고 말았습니다.  VM 쪽 이슈가 큰 이유였고,
그것만 문제였으면 그냥 정식 릴리즈를 하려 했지만 네트워킹 쪽에서도 뒤늦은
문제가 터지고 VFS 쪽에도 이슈가 있었던 관계로 정식 릴리즈를 미루기로 결심했다고
합니다.&lt;/p&gt;

&lt;p&gt;8월에 휴가를 많이 떠나는 유럽 개발자들을 고려해서 토발즈는 휴가가 예정되어
있다면 그냥 원래 예상된 스케쥴대로 이번주부터 머지 윈도우 열렸다고 생각하고
풀리퀘스트 보내고 휴가 가라고 대인배라면 대인배 같은 면모를 보이는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-rfc-00-10-introduce-lockless-shrink-slab&#34;&gt;[PATCH RFC 00/10] Introduce lockless shrink_slab()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/153365347929.19074.12509495712735843805.stgit@localhost.localdomain&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/153365347929.19074.12509495712735843805.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 블로그에서도 이야기 했던 &amp;ldquo;Improve shrink_slab() scalability&amp;hellip;&amp;rdquo; 패치의 머지
후, 성능 병목 지점이 &lt;code&gt;shrink_lab()&lt;/code&gt; 에서 &lt;code&gt;down_read_trylock()&lt;/code&gt; 으로
넘어갔습니다!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     &amp;gt; I created 255 memcgs, 255 ext4 mounts and made each memcg create a
     &amp;gt; file containing few KiBs on corresponding mount. Then in a separate
     &amp;gt; memcg of 200 MiB limit ran a fork-bomb.
     &amp;gt;
     &amp;gt; I ran the &amp;quot;perf record -ag -- sleep 60&amp;quot; and below are the results:
     &amp;gt; +  47.49%            fb.sh  [kernel.kallsyms]    [k] down_read_trylock
     &amp;gt; +  30.72%            fb.sh  [kernel.kallsyms]    [k] up_read
     &amp;gt; +   9.51%            fb.sh  [kernel.kallsyms]    [k] mem_cgroup_iter
     &amp;gt; +   1.69%            fb.sh  [kernel.kallsyms]    [k] shrink_node_memcg
     &amp;gt; +   1.35%            fb.sh  [kernel.kallsyms]    [k] mem_cgroup_protected
     &amp;gt; +   1.05%            fb.sh  [kernel.kallsyms]    [k] queued_spin_lock_slowpath
     &amp;gt; +   0.85%            fb.sh  [kernel.kallsyms]    [k] _raw_spin_lock
     &amp;gt; +   0.78%            fb.sh  [kernel.kallsyms]    [k] lruvec_lru_size
     &amp;gt; +   0.57%            fb.sh  [kernel.kallsyms]    [k] shrink_node
     &amp;gt; +   0.54%            fb.sh  [kernel.kallsyms]    [k] queue_work_on
     &amp;gt; +   0.46%            fb.sh  [kernel.kallsyms]    [k] shrink_slab_memcg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 패치셋은 계속해서 &lt;code&gt;shrink_slab()&lt;/code&gt; 의 멀티코어 성능 확장성을 위해 lock 을
사용하지 않게끔 경로를 최적화 하고 있습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code&gt;shrink_slab()&lt;/code&gt; 과 &lt;code&gt;unregister_shrinker()&lt;/code&gt; 사이의 동기화에 SRCU 를
사용하고, 그럴 수 없는 경우에는 &lt;code&gt;percpu_rw_semaphore&lt;/code&gt; 를 사용합니다.  그리고
&lt;code&gt;shrinker_rwsem&lt;/code&gt; 을 뮤텍스로 교체합니다.&lt;/p&gt;

&lt;p&gt;SRCU 를 사용함으로 인해 커널 바이너리 사이즈가 커지는 문제가 있는데, 과거에도
비슷한 시도가 이런 이유로 취소된 적 있었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Kernel Performance (LKP) Tests</title>
      <link>https://sjp38.github.io/post/lkp-tests/</link>
      <pubDate>Thu, 02 Aug 2018 17:20:10 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkp-tests/</guid>
      <description>

&lt;p&gt;리눅스 커널의 개발은 커뮤니티 주도입니다.  개발의 한 부분인 테스트 역시
커뮤니티 주도적입니다.  여러 개인 또는 단체가 커널을 각자의 방식으로 테스트
하고 그 결과를 공유합니다.  인텔에서는 0-day 서비스[1] 라는 서비스를 자체적으로
돌리는데, 이 서비스는 최신 리눅스 커널을 가져다가 빌드하고 다양한 기능 / 성능
테스트를 돌리고 그 결과 발견된 regression 을 LKML 에 메일로 보내주는 일을
합니다.  말하자면 Continuous Integration (CI) 이죠.&lt;/p&gt;

&lt;p&gt;Linux Kernel Performance (LKP) Tests[2] 는 0-day 서비스에서 기능 / 성능 테스트를
수행하는데 사용되는 도구입니다.  다양한 테스트를 돌리기 위한 시스템 환경 구성,
테스트 프로그램과 그 종속 프로그램 / 라이브러리의 설치와 환경 구성, 테스트
수행과 결과 정리, 그리고 테스트 진행 사이의 시스템 상태 프로파일링 및
프로파일링 결과 정리를 대신해 줍니다.  0-day 서비스에 연결되어 있지만 lkp-tests
와 0-day 서비스 사이의 종속성이 없으며, 오픈소스 프로젝트로 개발이 진행되고
있어 그 소스코드를 누구나 사용할 수 있으며 개인이 사용하기에도 편리하게 되어
있어서 개인 개발자가 자신의 패치를 테스트할 목적으로 사용하기에도 좋습니다.  이
글에서는 이러한 lkp-tests 의 구조와 사용법을 간단히 설명합니다.  전체적으로
인텔의 관련 블로그 글[3] 을 참고했습니다.&lt;/p&gt;

&lt;h1 id=&#34;설치&#34;&gt;설치&lt;/h1&gt;

&lt;p&gt;먼저 다음 커맨드로 lkp-tests 소스코드를 얻어옵니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/intel/lkp-tests
$ cd lkp-tests
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 lkp-tests 자체를 설치.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 커맨드는 단순히 지금 소스코드를 땡겨온 lkp-tests 소스코드 디렉토리의
&lt;code&gt;bin/lkp&lt;/code&gt; 파일을 링크하는 &lt;code&gt;/usr/local/bin/lkp&lt;/code&gt; 심볼릭 링크를 만들 뿐입니다.
따라서 셸에서 &lt;code&gt;lkp&lt;/code&gt; 커맨드를 쓸 수 있게 해주죠.  이 &lt;code&gt;lkp&lt;/code&gt; 파일이 결국 lkp-tests
의 대부분의 일을 해주는 핵심 커맨드입니다.  이 프로그램의 간단한 사용법은
다음과 같이 확인할 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lkp
Usage: lkp &amp;lt;command&amp;gt; [options]

INSTALLATION

        install JOB                     install binary dependencies for JOB

JOB

        split JOB                       split JOB matrix
        compile JOB                     compile JOB into shell script

TESTING

        run JOB                         run test JOB locally
        qemu JOB                        run test JOB in QEMU virtual machine

RESULT

        result|rt|_rt|__rt PATTERNs     show result dirs
        ls|ll PATTERNs                  ls result dirs
        rm-path result                  remove result dirs
        _rm PATTERNs                    remove _result dirs

        stat [options]                  show result stats
        compare [options]               compare result stats

DEBUG

        irb                             run irb with lib/*.rb loaded
        pry                             run pry with lib/*.rb loaded

More commands can be found in /home/sjpark/lkp-tests/{bin,sbin,tools}/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 는 lkp-tests 소스코드 디렉토리 아래 &lt;code&gt;bin/&lt;/code&gt;, &lt;code&gt;sbin/&lt;/code&gt;,
&lt;code&gt;tools/&lt;/code&gt;, 또는 &lt;code&gt;lkp-exec/&lt;/code&gt; 아래 위치한 실행파일로, &lt;code&gt;lkp&lt;/code&gt; 는 단순히 그
실행파일을 수행하면서 인자를 넘길 뿐입니다.&lt;/p&gt;

&lt;h1 id=&#34;테스트에-필요한-소프트웨어-설치&#34;&gt;테스트에 필요한 소프트웨어 설치&lt;/h1&gt;

&lt;p&gt;다음 커맨드는 lkp-tests 가 의존하고 있는 기본적 소프트웨어 패키지들을 모두
설치합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lkp install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntu 16.04 에서는 다음 패키지들을 까는군요:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bc gawk gzip kmod time automake bison bsdtar build-essential bzip2
ca-certificates cpio fakeroot flex gcc git libc6-dev libc6-dev:i386
libklibc-dev libtool linux-libc-dev linux-libc-dev:i386 linux-tools-generic
make openssl patch rsync ruby ruby-dev wget
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;lkp-tests-내부-벤치마크-실행&#34;&gt;lkp-tests 내부 벤치마크 실행&lt;/h1&gt;

&lt;p&gt;이제 lkp-tests 에서 지원하는 벤치마크를 실제로 돌려봅시다.&lt;/p&gt;

&lt;h2 id=&#34;테스트-수행에-필요한-환경-설정&#34;&gt;테스트 수행에 필요한 환경 설정&lt;/h2&gt;

&lt;p&gt;실제 테스트를 돌리기 위해선 벤치마크를 깔고, 그 벤치마크가 사용하는 패키지를
깔고, 테스트에 사용될 도구들을 깔고, 여러 설정을 하는등의 작업이 필요합니다.&lt;/p&gt;

&lt;p&gt;다음 명령은 lkp-tests 에서 ebizzy 라는 벤치마크를 사용하는 테스트를 위해
필요한 프로그램들을 설치하고 수행 환경을 준비합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lkp install jobs/ebizzy.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;job&#34;&gt;job&lt;/h2&gt;

&lt;p&gt;lkp-tests 에서 테스트 수행의 기본 단위는 &lt;code&gt;job&lt;/code&gt; 이라고 이야기 하는데, &lt;code&gt;jobs/&lt;/code&gt;
디렉토리 아래에 각 job 을 설명한 yaml 파일이 있습니다.  위의 커맨드에서 인자로
넣은 &lt;code&gt;ebizzy.yaml&lt;/code&gt; 은 ebizzy 를 사용한 테스트에 필요한 사항들이 들어있습니다.
이 커맨드는 내부적으로 이 테스트에 필요한 패키지를 설치하고 ebizzy 벤치마크도
소스코드를 인터넷에서 받아다가 컴파일해 설치합니다.&lt;/p&gt;

&lt;p&gt;Job 파일은 또한 해당 테스트가 어떤 시스템 환경들에서 어떤 벤치마크를 어떤
인자를 줘가며 수행해야할지 등에 대한 내용을 담고 있습니다.  예컨대
&lt;code&gt;jobs/aim7-fs-1brd.yaml&lt;/code&gt; job 은 &lt;code&gt;xfs&lt;/code&gt;, &lt;code&gt;ext4&lt;/code&gt;, &lt;code&gt;btrfs&lt;/code&gt;, &lt;code&gt;f2fs&lt;/code&gt; 파일 시스템
각각에 대해 aim7 을 돌려보도록 되어 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;테스트-수행&#34;&gt;테스트 수행&lt;/h2&gt;

&lt;p&gt;다음 명령은 ebizzy job 으로 기술된 테스트를 실제 수행시킵니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lkp run jobs/ebizzy.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;job-쪼개기&#34;&gt;job 쪼개기&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ebizzy.yaml&lt;/code&gt; 은 시스템 소유 CPU 코어 갯수 2배 갯수의 쓰레드를 사용해 ebizzy 를
10초간 돌리는 실험을 100번 반복하도록 되어 있습니다.  즉, 실험의 경우의 수가
하나입니다.  그러나, 앞서 설명한 &lt;code&gt;aim7-fs-1brd&lt;/code&gt; 와 같이 다양한 구성을 사용하게
되어 있는 경우, 한가지 구성에 대해서만 반복 실험을 하고 싶을 수 있을 겁니다.
이런 경우 다음 명령으로 job 을 쪼갤 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo lkp split jobs/ebizzy.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 커맨드는 인자로 넣은 job 파일을 쪼개서 현재 디렉토리에 쪼개진 job 파일들을
저장합니다.  어떤 구성이 쪼개졌는지는 파일 이름으로 볼 수 있습니다.
&lt;code&gt;ebizzy.yaml&lt;/code&gt; 을 쪼개면 &lt;code&gt;ebizzy-200%-100x-10s.yaml&lt;/code&gt; 라는 이름의 한개의 job
파일이 생성됩니다.  앞서 이야기한 &lt;code&gt;aim7-fs-1brd.yaml&lt;/code&gt; 을 쪼개면 다음과 같이
많은 수의 job 이 생성됩니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aim7-fs-1brd-1BRD_48G-btrfs-creat-clo-4.yaml
aim7-fs-1brd-1BRD_48G-f2fs-creat-clo-1500.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_cp-1500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_cp-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_rd-9000.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_rd-9000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_rr-1500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_rr-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_rw-1500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_rw-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_src-500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_src-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_wrt-1500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_wrt-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-sync_disk_rw-10.yaml
aim7-fs-1brd-1BRD_48G-f2fs-sync_disk_rw-600.yaml
aim7-fs-1brd-1BRD_48G-ext4-creat-clo-1000.yaml
aim7-fs-1brd-1BRD_48G-xfs-creat-clo-1500.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_cp-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_cp-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_rd-9000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_rd-9000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_rr-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_rr-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_rw-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_rw-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_src-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_src-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_wrt-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_wrt-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-sync_disk_rw-600.yaml
aim7-fs-1brd-1BRD_48G-xfs-sync_disk_rw-600.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;테스트-결과-확인&#34;&gt;테스트 결과 확인&lt;/h1&gt;

&lt;p&gt;테스트에 사용된 벤치마크 수행의 결과와 테스트 동안의 시스템 프로파일링 결과는
&lt;code&gt;/lkp/result/&lt;/code&gt; 디렉토리 밑에 &lt;code&gt;&amp;lt;job name&amp;gt;/&amp;lt;configuration&amp;gt;/&amp;lt;host name&amp;gt;/&amp;lt;os
distribution name&amp;gt;/&amp;lt;kernel config&amp;gt;/&amp;lt;gcc version&amp;gt;/&amp;lt;kernel version&amp;gt;/&amp;lt;unique id&amp;gt;&lt;/code&gt;
의 계층 구조로 저장됩니다.  또한, 이 실험 결과를 parsing 할 수 있는 경우엔
&lt;code&gt;.json&lt;/code&gt; 파일을 만들어 줘서 parsing 된 결과 값도 보여줍니다.&lt;/p&gt;

&lt;p&gt;또한, 최근의 테스트 결과는 테스트 돌린 디렉토리에 &lt;code&gt;result/&lt;/code&gt; 라는 이름의,
&lt;code&gt;/lkp/result/&lt;/code&gt; 아래 해당 디렉토리로의 심볼릭 링크를 만들어 줍니다.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;이렇게 lkp-tests 가 무엇인지, 그리고 어떻게 사용할 수 있는지 알아봤습니다.
이제, 리눅스 커널 개발 커뮤니티에서 사용하는 리그레션 테스트를 여러분의
환경에서도 손쉽게 돌려볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://01.org/lkp/documentation/0-day-test-service&#34; target=&#34;_blank&#34;&gt;https://01.org/lkp/documentation/0-day-test-service&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&#34;https://github.com/intel/lkp-tests&#34; target=&#34;_blank&#34;&gt;https://github.com/intel/lkp-tests&lt;/a&gt;&lt;br /&gt;
[3] &lt;a href=&#34;https://01.org/blogs/jdu1/2017/lkp-tests-linux-kernel-performance-test-and-analysis-tool&#34; target=&#34;_blank&#34;&gt;https://01.org/blogs/jdu1/2017/lkp-tests-linux-kernel-performance-test-and-analysis-tool&lt;/a&gt;&lt;br /&gt;
[4] &lt;a href=&#34;https://wiki.archlinux.org/index.php/makepkg&#34; target=&#34;_blank&#34;&gt;https://wiki.archlinux.org/index.php/makepkg&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Release History</title>
      <link>https://sjp38.github.io/post/linux_release_history/</link>
      <pubDate>Mon, 30 Jul 2018 09:14:08 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/linux_release_history/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19-rc2&#34;&gt;Linux 4.19-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018-09-02 14:45 PDT&lt;/p&gt;

&lt;h2 id=&#34;linux-4-19-rc1&#34;&gt;Linux 4.19-rc1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw9mxNPX6OtOp-aoUMdXSg=gBkQudGGamo__sh_ts_LdQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFw9mxNPX6OtOp-aoUMdXSg=gBkQudGGamo__sh_ts_LdQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018-08-26 14:49 PDT&lt;/p&gt;

&lt;h2 id=&#34;linux-4-18&#34;&gt;Linux 4.18&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018-08-12 14:10:49 PDT&lt;/p&gt;

&lt;h2 id=&#34;linux-4-18-rc8&#34;&gt;Linux 4.18-rc8&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018-08-05 12:58 PDT&lt;/p&gt;

&lt;h2 id=&#34;linux-4-18-rc7&#34;&gt;Linux 4.18-rc7&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018-07-29 22:09 UTC&lt;/p&gt;

&lt;h2 id=&#34;linux-4-18-rc6&#34;&gt;Linux 4.18-rc6&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018-07-23 20:46 UTC&lt;/p&gt;

&lt;h2 id=&#34;linux-4-18-rc5&#34;&gt;Linux 4.18-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018-07-15 20:28 UTC&lt;/p&gt;

&lt;h2 id=&#34;linux-4-18-rc4&#34;&gt;Linux 4.18-rc4&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;https://lore.kernel.org/lkml/CA+55aFwXGyZ1Yx+Z8a93gpvb596ZRJ5ppiQL_+-k7gjeQLtcsQ@mail.gmail.com/T/#u&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2018-07-08 23:57 UTC&lt;/p&gt;

&lt;h2 id=&#34;linux-4-18-rc3&#34;&gt;Linux 4.18-rc3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwGk-pWKKCtp+kQUN_hov9tW+vUo6Wgob91bewwBL17fA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFwGk-pWKKCtp+kQUN_hov9tW+vUo6Wgob91bewwBL17fA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018-07-01 23:46 UTC&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.18-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc7/</link>
      <pubDate>Mon, 30 Jul 2018 08:49:12 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc7/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc7&#34;&gt;Linux 4.18-rc7&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;일곱번째 rc 릴리즈입니다.  별다른 일 없으면 다음주에 4.18이 릴리즈 되겠다고
토발즈도 이야기 하는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v4-0-6-kmalloc-reclaimable-caches&#34;&gt;[PATCH v4 0/6] kmalloc-reclaimable caches&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180731090649.16028-1-vbabka@suse.cz&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180731090649.16028-1-vbabka@suse.cz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;내부적으로 SLAB 할당자를 사용하는 kmem cache 들은 &lt;code&gt;SLAB_RECLAIM_ACCOUNT&lt;/code&gt;
플래그를 가지고 생성될 경우에 시스템 메모리가 부족한 경우 기존에 할당받은
오브젝트들을 회수해도 좋다고 알리게 됩니다.&lt;/p&gt;

&lt;p&gt;일반적인 kmem cache 들은 이 플래그 없이 생성되서는 시스템의 메모리가 부족한
경우에 회수되어도 좋은 오브젝트의 할당에 사용되기도 하는데, 다양한 크기의
오브젝트들은 &lt;code&gt;SLAB_RECLAIM_ACCOUNT&lt;/code&gt; 플래그를 가진 하나의 kmem cache 에서 처리될
수 없기 때문이죠.  &lt;code&gt;dcache&lt;/code&gt; 의 &lt;code&gt;external name&lt;/code&gt; 들이 그 예입니다.&lt;/p&gt;

&lt;p&gt;이와 비슷한 경우들을 해결하기 위해 이 패치셋은 kmalloc cache 에
SLAB_RECLAIM_ACCOUNT  와 비슷한 특성을 갖는 변종을 kmalloc-rcl-x 라는 이름으로
만들었습니다.  kmalloc() 시에 &lt;code&gt;__GFP_RECLAIMABLE&lt;/code&gt; 플래그를 넣으면 이 캐시에서
메모리가 할당됩니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-swap-use-try-to-reclaim-swap-in-free-swap-and-cache&#34;&gt;&lt;code&gt;[PATCH] swap: Use __try_to_reclaim_swap() in free_swap_and_cache()&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180803123014.15431-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180803123014.15431-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;스왑 엔트리를 회수하는 코드 경로는 &lt;code&gt;free_swap_and_cache()&lt;/code&gt; 가 있고
&lt;code&gt;__try_to_reclaim_swap()&lt;/code&gt; 이 있는데, 코딩 스타일 빼고는 실제 하는 일이 거의
똑같습니다.  이 패치는 &lt;code&gt;free_swap_and_cache()&lt;/code&gt; 에서 내부적으로
&lt;code&gt;__try_to_reclaim_cache()&lt;/code&gt; 를 사용하게 함으로써 코드의 가독성을 높이고 잠재적
버그를 줄였습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.18-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc6/</link>
      <pubDate>Tue, 24 Jul 2018 06:19:53 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc6/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc6&#34;&gt;Linux 4.18-rc6&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번 rc는 평소보다 조금 크게 되었는데, 네트워킹 쪽 메인테이너인 David 가 많은
수정사항을 아직 보내지 않았다가 이번에 모아서 보냈기 때문이라는군요.  그렇다
해도 그렇게 큰 양까진 아니라는 토발즈의 설명입니다.&lt;/p&gt;

&lt;p&gt;지난 rc5 작업 주간을 귀찮게 했던 VM 버그에 대한 두줄의 수정이 rc5 에
들어갔었지만 32비트 환경에 대한 고려가 없었기에 이번에 그 수정이
들어갔다는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-7-memory-management-documentation-updates&#34;&gt;[PATCH 0/7] memory management documentation updates&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1532517970-16409-1-git-send-email-rppt@linux.vnet.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1532517970-16409-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;메모리 관리 부분 문서화 업데이트입니다.  sphinx 기반 문서화 업데이트를 일부
메인테이너들은 반기지 않는 것도 사실이지만, 확실히 가독성이 좋아진 덕에 이런
문서화 노력이 더 활발해 지는 것 아닌가 하는 생각도 드는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Alpine for LKML</title>
      <link>https://sjp38.github.io/post/alpine-for-lkml/</link>
      <pubDate>Wed, 18 Jul 2018 21:09:54 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/alpine-for-lkml/</guid>
      <description>

&lt;p&gt;리눅스 커널 커뮤니티는 버그 레포팅, 패치 업로드, 리뷰, 릴리즈, 토론 등등 모든
활동은 이메일을 통해 이루어집니다.  이 포스트에서는 리누스 토발즈도 쓰는 이메일
클라이언트인 Alpine 을 gmail 과 연동하는 방법을 알아봅니다.&lt;/p&gt;

&lt;p&gt;먼저 alpine 설치는 대부분 리눅스 배포판의 패키지 시스템에 등록되어 있으므로
해당 패키지 시스템을 사용해 쉽게 설치할 수 있습니다.  데비안 계열이면 &lt;code&gt;apt
install alpine&lt;/code&gt;, 페도라 계열이면 &lt;code&gt;dnf install alpine&lt;/code&gt; 이죠.&lt;/p&gt;

&lt;h1 id=&#34;gmail-imap-정보-입력&#34;&gt;gmail imap 정보 입력&lt;/h1&gt;

&lt;p&gt;S (Settings) -&amp;gt; L (collectionLists) -&amp;gt; A (Add Cltn)&lt;/p&gt;

&lt;p&gt;Nickname: gmail or anything
Server: imap.gmail.com/ssl/user=sj@gmail.com&lt;/p&gt;

&lt;p&gt;^X (Commit change)
E (Exit Setup)&lt;/p&gt;

&lt;h1 id=&#34;smtp-서버-설정&#34;&gt;SMTP 서버 설정&lt;/h1&gt;

&lt;p&gt;S (Setup) -&amp;gt; C (config)&lt;/p&gt;

&lt;p&gt;SMTP server: smtp.gmail.com/tls/user=sj@gmail.com&lt;/p&gt;

&lt;h2 id=&#34;쓰레드-기반-소팅&#34;&gt;쓰레드 기반 소팅&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[Sort key]&lt;/code&gt;: tHread (enter)&lt;/p&gt;

&lt;h2 id=&#34;리눅스-커널-커뮤니티에서-요구하는-설정&#34;&gt;리눅스 커널 커뮤니티에서 요구하는 설정&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[Sending Preferences]&lt;/code&gt;: Do Not Send Flowed Text, Strip Whitespace Before Sending&lt;/p&gt;

&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://harbhag.wordpress.com/2010/07/14/configure-alpine-to-sendreceive-emails-from-gmail/&#34; target=&#34;_blank&#34;&gt;https://harbhag.wordpress.com/2010/07/14/configure-alpine-to-sendreceive-emails-from-gmail/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc5/</link>
      <pubDate>Mon, 16 Jul 2018 06:07:33 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc5/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc5&#34;&gt;Linux 4.18-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다섯번째 rc 릴리즈입니다.  토발즈 개인적으로는 조금 바쁘단 느낌이 있었지만
숫자로 보면 평범한 rc 릴리즈 주간이었다는 평입니다.&lt;/p&gt;

&lt;p&gt;토발즈를 귀찮게 만들었던 건 VM 쪽 버그로, 단 두줄의 수정으로 고쳐졌다는데,
아무래도 아래 패치인 것 같군요:
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bce73e4842390f7b7309c8e253e139db71288ac3&#34; target=&#34;_blank&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bce73e4842390f7b7309c8e253e139db71288ac3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그리고 repeatable sequence 에 대한 cleanup 도 있었군요.&lt;/p&gt;

&lt;h2 id=&#34;git-pull-rcu-next-rcu-commits-for-4-19&#34;&gt;[GIT PULL rcu/next] RCU commits for 4.19&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180716175125.GA4287@linux.vnet.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180716175125.GA4287@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.19 리눅스 릴리즈를 위한 RCU 쪽 변경사항들 pull request 입니다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
