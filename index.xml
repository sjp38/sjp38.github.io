<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hacklog on Hacklog</title>
    <link>https://sjp38.github.io/</link>
    <description>Recent content in Hacklog on Hacklog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Your Name</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Lkml_news_v4.18 Rc2</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc2/</link>
      <pubDate>Mon, 25 Jun 2018 08:45:22 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc2/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc2&#34;&gt;Linux 4.18-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/alpine.LFD.2.21.999.1806242116240.20621@xps13.linux-foundation.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/alpine.LFD.2.21.999.1806242116240.20621@xps13.linux-foundation.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번주도 지난주처럼 평소보단 빠른 릴리즈입니다.  토발즈가 여전히
여행중이라는군요.  지난주엔 일본이었고, 이번주는 중국이라는군요.  그런고로 중국
시간으로 일요일 저녁의 rc 릴리즈입니다.&lt;/p&gt;

&lt;p&gt;이번 rc 에서도 큰 변경은 없고 평범한 rc 입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc1/</link>
      <pubDate>Sun, 17 Jun 2018 11:59:59 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc1/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc1&#34;&gt;Linux 4.18-rc1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw34Dh6p0qAZ_Ja=fjuJ89ojZZTWtmrRPKmB1QuP3C7hw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFw34Dh6p0qAZ_Ja=fjuJ89ojZZTWtmrRPKmB1QuP3C7hw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;평소보다 많이 빠르게 4.18 머지윈도우가 닫혔습니다.  토발즈가 지금 일본에 있기 때문에 자기는 이미 일요일이고, 오후엔 뱃놀이 하러 갈거라서 일찍 릴리즈 한다네요.&lt;/p&gt;

&lt;p&gt;전체적으로 크기에서도 한 일에 있어서도 평범한 릴리즈입니다.  4.17 에서 더이상 사용되지 않는 과거 코드 삭제를 많이 했던 것처럼 이번에도 미사용 코드 제거가 좀 있군요, 하지만 4.17 때만큼 큰 변화는 아닙니다.&lt;/p&gt;

&lt;p&gt;제거된 컴포넌트들 가운데 특이할만한 점은 Lustre 의 제거군요.  Staging 트리에서 머물던 Lustre 는 계속 out of tree 로 개발이 진행되어왔고, Staging 딱지를 떼지 못한채 커널 소스트리에서 제거되게 되었습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v7-rebased-00-17-improve-shrink-slab-scalability-old-complexity-was-o-n-2-new-is-o-n&#34;&gt;[PATCH v7 REBASED 00/17] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/152931465724.27697.12828290733260370115.stgit@localhost.localdomain&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/152931465724.27697.12828290733260370115.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;지난번에도 소개한 패치의 v7 입니다.  시스템에 여러 shrinker 들과 memcg cgroup
이 등록되어 있는 경우 이 shrinker 의 갯수를 n 이라 할 때 O(n^2) 의 time
complexity 로 &lt;code&gt;shrink_slab()&lt;/code&gt; 수행시간이 늘어나게 되어있는데 이 문제를 해결한
패치입니다.  이 문제를 보기 위해 다음과 같은 테스트를 사용했습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$echo 1 &amp;gt; /sys/fs/cgroup/memory/memory.use_hierarchy
$mkdir /sys/fs/cgroup/memory/ct
$echo 4000M &amp;gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes
$for i in `seq 0 4000`;
        do mkdir /sys/fs/cgroup/memory/ct/$i;
        echo $$ &amp;gt; /sys/fs/cgroup/memory/ct/$i/cgroup.procs;
        mkdir -p s/$i; mount -t tmpfs $i s/$i; touch s/$i/file;
done
$time echo 3 &amp;gt; /proc/sys/vm/drop_caches
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ct/0 부터 ct/4000 까지 4001개의 메모리 cgroup 들을 만들어 놓고 tmpfs 를 만든 후
거기 파일을 만들어 메모리를 소모하게 한 후 &lt;code&gt;drop_caches&lt;/code&gt; 를 통해
&lt;code&gt;shrink_slab()&lt;/code&gt; 이 발동되게 했군요.  패치 저자의 환경에서의 테스트 결과는
다음과 같습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0.00user 13.78system 0:13.78elapsed 99%CPU
0.00user 5.59system 0:05.60elapsed 99%CPU
0.00user 5.48system 0:05.48elapsed 99%CPU
0.00user 8.35system 0:08.35elapsed 99%CPU
0.00user 8.34system 0:08.35elapsed 99%CPU
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 패치셋은 time complexity 가 O(n) 이 되도록 합니다.  패치셋이 적용된 후의
테스트 결과는 다음과 같이 548배 이상 개선되었습니다!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0.00user 1.10system 0:01.10elapsed 99%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;patch-00-11-docs-mm-add-boot-time-memory-management-docs&#34;&gt;[PATCH 00/11] docs/mm: add boot time memory management docs&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1529341199-17682-1-git-send-email-rppt@linux.vnet.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1529341199-17682-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;초기 부팅 시점에서의 메모리 관리에 대한 문서화를 개선하고 이에 대한 문서를
추가하는 패치입니다.  추가된 문서는 Documentation/core-api/boot-time-mm.rst 에
있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17/</link>
      <pubDate>Mon, 04 Jun 2018 11:29:16 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17&#34;&gt;Linux 4.17&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxhx_tKGm02UySguvbyfB_7oTF31QfgOHCK0YkBvmfV0g@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFxhx_tKGm02UySguvbyfB_7oTF31QfgOHCK0YkBvmfV0g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.17 버전 리눅스 릴리즈입니다.  지난주에 토발즈가 이야기한 것처럼 별다른 지연
없이 릴리즈 되었군요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git object&lt;/code&gt; 의 갯수라던지 릴리즈를 위한 스크립트 등이 리눅스 5.x 버전으로의
메이저 버전 업데이트가 될 준비가 되었다고 하지만 토발즈는 딱히 5.x 로 아직은
넘어갈 생각이 없군요.  너무 멀지 않은 미래에 넘어가겠지만, 적어도 지금은
아니라고 합니다.&lt;/p&gt;

&lt;p&gt;항상 그렇듯 이 릴리즈는 4.18을 위한 머지 윈도우의 시작이기도 한데, 토발즈는
두번째 주에 여행을 갈거라 가능하면 첫째주에 중요한 머지를 마무리 했으면 한다고
하네요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v13-00-72-convert-page-cache-to-xarray&#34;&gt;[PATCH v13 00/72] Convert page cache to XArray&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180611140639.17215-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180611140639.17215-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Radix tree 를 대체하기위한 목적으로 Matthew Wilcox 가 개발중인 XArray 의 구현과
Page cache 가 이 자료구조를 사용하도록 변경하는 패치의 13번째 버전입니다.  작년
OSSummit Europe 에서 처음 XArray 에 대한 발표를 들었는데 계속 발전중인 것
같군요.&lt;/p&gt;

&lt;h2 id=&#34;re-4-17-regression-performance-drop-on-kernel-4-17-visible-on&#34;&gt;Re: [4.17 regression] Performance drop on kernel-4.17 visible on&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180607110713.GJ32433@dhcp22.suse.cz&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180607110713.GJ32433@dhcp22.suse.cz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.16 대비 4.17 의 NUMA 시스템에서 Stream, Linpack, NAS 벤치마크 성능이 크게
떨어졌다는 레포트입니다.  최대 50% 까지의 성능 하락이 있었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>머신러닝 학습/실습 환경 (Jupyter Notebook &amp; Google Colab)</title>
      <link>https://sjp38.github.io/post/ml-study-env/</link>
      <pubDate>Mon, 28 May 2018 19:51:49 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/ml-study-env/</guid>
      <description>

&lt;p&gt;이 글은 머신러닝 학습 환경으로도 널리 사용되는 Jupyter Notebook 과 Google Colab
에 대해 간단히 설명합니다.&lt;/p&gt;

&lt;h1 id=&#34;jupyter-notebook&#34;&gt;Jupyter Notebook&lt;/h1&gt;

&lt;p&gt;Jupyter Notebook [1] 은 대화형으로 프로그래밍 언어를 공부하고 실습해 볼 수
있도록 만들어진 개발 / 학습 환경입니다.  이 환경은 크게 노트북 문서, Jupyter
Notebook App, Notebook kernel, 그리고 Notebook Dashboard 로 구성됩니다.&lt;/p&gt;

&lt;h2 id=&#34;노트북-문서&#34;&gt;노트북 문서&lt;/h2&gt;

&lt;p&gt;노트북 문서는 프로그램 코드 조각들과 Rich text (이걸 한글로 뭐라 해야 할지&amp;hellip;),
그리고 각 코드 조각의 수행 결과 로 구성됩니다.  백문이 불여일견, 이
&lt;a href=&#34;https://colab.research.google.com/github/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&#34; target=&#34;_blank&#34;&gt;링크&lt;/a&gt;
를 따라가 보시기 바랍니다.  링크는 간단한 파이썬 교육을 위해 만들어진 노트북
문서로,  코드를 수정하고 수행해 볼 수 있습니다.  텍스트도 수정할 수 있습니다.
문서에 코드 또는 텍스트 셀을 추가해 코드 셀에는 코드를, 텍스트 셀에는 텍스트를
작성할 수 있으며, 텍스트 셀에 작성할 수 있는 텍스트는 단순한 평문이 아니라
강조, 이탤릭 등의 효과를 포함할 수 있습니다.  Jupyter Notebook 환경은 노트북
문서들을 읽어들여 Rich Text 를 저자가 의도한 모습대로 렌더링 해주고, 코드 셀을
사용자가 원하면 셀별로 수행시켜줍니다.  코드 셀의 좌측에 수행 버튼이 떠서, 이를
클릭하면 해당 셀을 수행하는 형태입니다.  문서 상의 모든 코드 셀의 일괄 수행
역시 가능합니다.  이 때, 앞서 수행된 코드 셀의 수행 결과는 다음에 수행되는 코드
셀에 영향을 끼칩니다.  예를 들어 특정 셀에서 전역 변수의 값을 변경했다면 다음에
수행하는 셀에 변경된 전역 변수의 값이 보입니다.&lt;/p&gt;

&lt;p&gt;이를 통해 Jupyter Notebook 사용자는 노트북 문서를 사용해 타인에게 학습시킬
문서를 작성하고 학습자가 곧바로 하나씩 수행해 볼 수 있게 해줄 수 있으며, 스스로
공부하는 사람도 자신이 공부한 내용을 쉽게 정리할 수 있게 해줍니다.&lt;/p&gt;

&lt;h2 id=&#34;jupyter-notebook-app&#34;&gt;Jupyter Notebook App&lt;/h2&gt;

&lt;p&gt;Jupyter Notebook App 은 Jupyter 노트북 문서를 읽어들여 작성자가 원한 모습으로
보여주고 코드의 수행 등을 대신해 주고, 또한 노트북 문서를 새로 작성할 수 있는
에디터 역할을 합니다.  서버-클라이언트 구조로 되어 있어 로컬 컴퓨터에 서버를
띄우고 웹브라우저로 접속해서 작업할 수도, 다른 컴퓨터에 띄워진 서버에
웹브라우저로 접속해 작업할 수도 있습니다.  일부 공개 Jupyter Notebook 서버도
서비스 되고 있습니다.  Google Colab 역시 그런 형태입니다.&lt;/p&gt;

&lt;p&gt;Github 은 웹인터페이스 상에서 Notebook 문서를 렌더링 해 보여주는 기능을
제공하고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;notebook-kernel-과-notebook-dashboard&#34;&gt;Notebook kernel 과 Notebook Dashboard&lt;/h2&gt;

&lt;p&gt;실제 코드의 수행을 담당하는게 Notebook kernel, 각 노트북 문서의 관리를 담당해
주는 인터페이스가 Dashboard 입니다.  커널은 프로그램이 언어별로 존재하며,
Jupyter Notebook 에서는 다양한 언어의 커널을 지원하고 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;google-colab&#34;&gt;Google Colab&lt;/h1&gt;

&lt;p&gt;Jupyter Notebook 은 앞서 설명했듯 자신의 컴퓨터에 설치하고 서버를 띄울수도,
다른 컴퓨터에 설치하고 서버를 띄울 수도 있습니다.  &lt;code&gt;...  as a Service&lt;/code&gt; 의
시대인 만큼, Jupyter Notebook Server 를 서비스하는 회사들이 많습니다.  Google
Colab[2] 은 그런 서비스 중 하나입니다.  이 프로젝트는 머신러닝 교육과 연구를
돕기 위해 만들어진 Google 의 연구 프로젝트로, 결국은 하나의 Jupyter notebook
환경일 뿐인데, 어떠한 셋업도 필요 없고 구글 클라우드 위에서 동작합니다.&lt;/p&gt;

&lt;p&gt;노트북 문서는 구글 드라이브에 저장하고 불러올 수 있으며, Github 에 있는 노트북
문서도 읽어올 수 있습니다.  참고로 노트북 문서는 &lt;code&gt;.ipynb&lt;/code&gt; 라는 확장자를
사용하는 텍스트 파일입니다.  Colab 에서 작성한 노트북 문서를 &lt;code&gt;.ipynb&lt;/code&gt; 확장자
파일로 곧바로 다운받을 수 있으므로 구글 드라이브로 공유하기 부담스러운 경우는
github 을 통해 공유해도 좋겠습니다.  뿐만 아니라 읽기만 하므로 다른 사람의
Jupyter Notebook 문서도 공개되어 있다면 얼마든지 불러올 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;github-의-노트북-문서-불러오기&#34;&gt;Github 의 노트북 문서 불러오기&lt;/h2&gt;

&lt;p&gt;Github 의 노트북 파일을 불러오는 방법은 간단합니다.  먼저 Github 웹
인터페이스에 들어가 Google Colab 에서 읽고자 하는 문서의 github 상에서의 주소를
파악합니다.  대략
&lt;a href=&#34;https://github.com/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&#34; target=&#34;_blank&#34;&gt;https://github.com/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&lt;/a&gt; 와
같은 형태가 될겁니다.  여기서 &lt;code&gt;https://&lt;/code&gt; 를 제거하고 &lt;code&gt;github.com&lt;/code&gt; 에서 &lt;code&gt;./com&lt;/code&gt;
을 제거한 후, &lt;a href=&#34;https://colab.research.google.com/&#34; target=&#34;_blank&#34;&gt;https://colab.research.google.com/&lt;/a&gt; 뒤에 붙여줍니다.  그러면 대략
&lt;a href=&#34;https://colab.research.google.com/github/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&#34; target=&#34;_blank&#34;&gt;https://colab.research.google.com/github/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&lt;/a&gt;
같은 모습이 되겠죠.  이 주소를 웹브라우저에 입력하면, Colab 에 해당 노트북이
열리고 수행도 해볼 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;머신러닝 학습에 많이 사용되는 Jupyter Notebook 과 머신러닝을 위한 Jupyter
Notebook 서비스 중 하나인 Google Colab 에 대해 알아봤습니다.  저도 최근에야
알게 된 프로젝트인데, 코드와 그에 대한 설명을 정말 쉽고 효과적으로 공유할 수
있는 획기적 방법 같습니다.  다른 분야에도 널리 퍼지면 좋겠군요.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html&#34; target=&#34;_blank&#34;&gt;http://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&#34;https://colab.research.google.com/notebooks/welcome.ipynb&#34; target=&#34;_blank&#34;&gt;https://colab.research.google.com/notebooks/welcome.ipynb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after 4.17-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc7/</link>
      <pubDate>Mon, 28 May 2018 10:41:50 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc7/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17-rc7&#34;&gt;Linux 4.17-rc7&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwUqz9z1Rf4Wwr29W7DeKxQ67qKEW5xty+JPyCY3aNQ=A@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFwUqz9z1Rf4Wwr29W7DeKxQ67qKEW5xty+JPyCY3aNQ=A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;일곱번째 rc 입니다.  지난 몇주보다는 조금 변경사항이 있었지만 그렇다 해도
그렇게 심한 정도는 아니었기에 아마도 이게 마지막 rc 일 거라는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-00-13-introdue-io-latency-io-controller-for-cgroups&#34;&gt;[PATCH 00/13] Introdue io.latency io controller for cgroups&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180529211724.4531-1-josef@toxicpanda.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180529211724.4531-1-josef@toxicpanda.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cgroup 에 응답시간 (latency) 기반의 I/O 컨트롤러를 추가하는 패치셋입니다.
Cgroup 은 용량 기반의 컨트롤러는 많지만 응답시간 기반의 컨트롤러가 부족하다고
느껴왔는데, 역시 추가되어 가는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc6/</link>
      <pubDate>Mon, 21 May 2018 10:19:16 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc6/</guid>
      <description>

&lt;h2 id=&#34;linux-v4-17-rc6&#34;&gt;Linux v4.17-rc6&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CA+55aFxxYQFL3mwsQcC+__R23ZmO8c3F0SThi6r44TdK0ePNDQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;여섯번째 release candidate 버전입니다.  이번 릴리즈에도 특기할 만한 일은
없었습니다.  이제 충분히 안정화 되었을 거라고 하는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-mm-v3-00-21-mm-thp-swap-swapout-swapin-thp-in-one-piece&#34;&gt;[PATCH -mm -V3 00/21] mm, THP, swap: Swapout/swapin THP in one piece&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180523082625.6897-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180523082625.6897-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이전에도 이 시리즈로 소개했던, THP 의 swap out 과 swap in 최적화 마지막 단계
패치의 세번째 버전입니다.  마지막 단계 이야기 하니 문득 인피니티워의 오역
논란이 떠오르는군요 ;)  두번째 버전 이후 특정 컨피규레이션에서의 빌드 버그를
수정했고, mmotm/master 브랜치의 5월 18일자 버전으로 rebase 한게 차이점의
전부군요.&lt;/p&gt;

&lt;p&gt;RAM 으로 PMEM 을 시뮬레이션 하는 환경에서 vm-scalability 라는 벤치마크를 사용해
16개 프로세스가 anonymous page 를 상당량 할당받고 반복해서 접근하는 워크로드로
성능 차이를 비교했습니다.  이로 인해 패치 전 대비 워크로드 처리량 (throughput)
이 992.8% 향상되었습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v3-0-4-fixes-cleanups-for-rcu-dev&#34;&gt;[PATCH v3 0/4] fixes, cleanups for rcu/dev&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180521044220.123933-1-joel@joelfernandes.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180521044220.123933-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RCU 코드의 주석, 변수 사용, 변수 이름 등의 개선 패치셋입니다.&lt;/p&gt;

&lt;h2 id=&#34;resend-patch-v5-00-33-block-support-multipage-bvec&#34;&gt;[RESEND PATCH V5 00/33] block: support multipage bvec&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180525034621.31147-1-ming.lei@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180525034621.31147-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;하나의 &lt;code&gt;struct bio_bvec&lt;/code&gt; 이 물리적으로 연속적인 복수개의 페이지를 가질 수 있게
하는 패치입니다.  시스템의 메모리가 거대해지고 THP 등이 널리 쓰임에 따라 이런
변화가 필요했다는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-mm-0-4-mm-huge-page-copy-target-sub-page-last-when-copy-huge-page&#34;&gt;[PATCH -V2 -mm 0/4] mm, huge page: Copy target sub-page last when copy huge page&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180524005851.4079-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180524005851.4079-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Huge page 의 복사 시에는 source 와 destination page 각각에 접근을 해야 하므로,
2 MiB huge page 를 사용한다 가정하면 총 4 MiB 데이터 액세스가 필요합니다.
예컨대 Xeon E5 v3 2699 CPU 는 18개의 코어, 36개 쓰레드, 그리고 45 MiB Last
Level Cache 를 가지므로 코어별로는 2.5 MiB, 쓰레드별로는 1.25 MiB 의 Last Level
Cache 밖에 갖지 못하므로, 여기서 huge page 복사가 일어나면 자신의 Last Level
Cache 를 모조리 접근해서 데이터가 flooding 나고 이후 데이터 접근은 cache miss
가 날 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;이 패치셋은 target huge page 의 sub-page 를 마지막에 복사하도록 복사 시의
데이터 접근 순서를 약간 바꿔서 대부분의 경우에는 캐시 미스를 좀 더 줄일 수
있도록 했습니다.&lt;/p&gt;

&lt;p&gt;vm-scalability 의 anon-cow-seq 테스트 케이스를 2 socket Xeon E5 v3 2699
시스템에서 돌려본 결과, 약 16.6% 까지의 성능 향상이 있었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc5/</link>
      <pubDate>Mon, 14 May 2018 10:23:45 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc5/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17-rc5&#34;&gt;Linux 4.17-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxi-Q6hvdHn+JwYSQ9b3feNGoFM3eeAuKNhpkfxVNAGpA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFxi-Q6hvdHn+JwYSQ9b3feNGoFM3eeAuKNhpkfxVNAGpA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.17을 향한 다섯번째 rc 릴리즈입니다.  이번 릴리즈도 여느 때와 다름없이
평범하군요.  대부분 드라이버 변경들이고, amd gpu 쪽 변경이 있지만 나머지
부분들은 그렇게 많지 않고 대부분 한두줄 짜리 변경들입니다.  이대로라면 이번
4.17 릴리즈는 꽤 무난무난하게 끝나겠군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v11-00-26-speculative-page-faults&#34;&gt;[PATCH v11 00/26] Speculative page faults&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1526555193-7242-1-git-send-email-ldufour@linux.vnet.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1526555193-7242-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 블로그에서도 몇차례 소개한, speculative page fault 의 11번째 버전입니다.
지난 LSFMM 에서도 관련해 논의를 한 것 같던데, 아주 긍정적 반응은 아니었던 것
같습니다만, 어쨌든 오랫만에 올라온 새로운 버전의 패치셋이군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v6-00-17-rearrange-struct-page&#34;&gt;[PATCH v6 00/17] Rearrange struct page&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180518194519.3820-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180518194519.3820-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;struct page&lt;/code&gt; 의 구조를 좀 더 사용하기 쉽게 개선하는 패치의 여섯번째
버전입니다.  LSFMM 에서는 그 구조를 구글 문서[1]를 사용해 그림으로 그려가며
설명했고, 꽤 괜찮은 반응을 얻었던 것 같더군요.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QEMU 를 사용한 리눅스 커널 디버깅</title>
      <link>https://sjp38.github.io/post/qemu_kernel_debugging/</link>
      <pubDate>Mon, 07 May 2018 18:21:01 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/qemu_kernel_debugging/</guid>
      <description>

&lt;p&gt;토발즈는 좋아하지 않지만, 리눅스 커널 프로그래밍에도 디버거를 사용할 수
있습니다.  저도 디버거 사용을 좋아하지는 않는 편이지만, 경우에 따라선 디버거를
사용하는게 좋을 때도 있고 취향은 존중되어야죠. ;)&lt;/p&gt;

&lt;p&gt;커널 디버깅 방법은 여러가지가 있는데, 그 중 하나는 QEMU 등을 이용한 리눅스 가상
머신을 띄워 두고, 호스트 머신에서 해당 가상 머신의 리눅스 커널을 디버깅 하는
방법입니다.  이 글에선 이렇게 디버깅 하는 방법을 간단히 정리해 봅니다.&lt;/p&gt;

&lt;h1 id=&#34;테스트-환경&#34;&gt;테스트 환경&lt;/h1&gt;

&lt;p&gt;글 작성 과정에서 테스트에 사용한 주요 소프트웨어들과 버전은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ubuntu 16.04.3 Server&lt;/li&gt;
&lt;li&gt;gdb 7.11.1&lt;/li&gt;
&lt;li&gt;QEMU v2.11.0-dirty&lt;/li&gt;
&lt;li&gt;Linux v4.16&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;커널-빌드&#34;&gt;커널 빌드&lt;/h1&gt;

&lt;p&gt;디버깅할 커널을 빌드합니다.  이 때 &lt;code&gt;CONFIG_GDB_SCRIPTS&lt;/code&gt; 는 켜고
&lt;code&gt;CONFIG_DEBUG_INFO_REDUCED&lt;/code&gt; 는 끄고, 타겟 아키텍쳐가 &lt;code&gt;CONFIG_FRAME_POINTER&lt;/code&gt; 를
지원한다면 켜야 합니다.&lt;/p&gt;

&lt;h1 id=&#34;가상-머신-부팅&#34;&gt;가상 머신 부팅&lt;/h1&gt;

&lt;p&gt;빌드가 완료되면 해당 커널을 사용해 QEMU 가상 머신을 부팅시킵니다.  가상 머신
위에 커널을 설치하는 방법도 있겠고, QEMU 에 &lt;code&gt;-kernel&lt;/code&gt; 과 &lt;code&gt;-append&lt;/code&gt;, &lt;code&gt;-initrd&lt;/code&gt;
등을 사용해서 호스트에서 빌드한 리눅스 커널로 부팅시키는 방법도 있을 겁니다.
이 때, &lt;strong&gt;kaslr&lt;/strong&gt; 을 꺼야 합니다.  커널 패러미터에 &lt;code&gt;nokaslr&lt;/code&gt; 을 추가하는 걸로 끌
수 있습니다.  kaslr 이 켜진 채로 디버깅 해야 한다면 다른 방법이 있는데, 여기선
다루지 않겠습니다.&lt;/p&gt;

&lt;p&gt;QEMU 가상 머신을 시작할 때 QEMU 에 &lt;code&gt;-s&lt;/code&gt; 옵션을 주거나 QEMU monitor console 에서
&lt;code&gt;gdbserver&lt;/code&gt; 라고 명령을 입력해 줍니다.  이 명령은 가상머신에서 gdbserver 를
시작시켜서 gdbserver 가 &lt;code&gt;tcp::1234&lt;/code&gt; 에서 접속을 기다리게 함으로써 QEMU 의 gdb
기능을 활성화 시켜줍니다.  &lt;code&gt;-nographic&lt;/code&gt; 옵션을 주거나 해서 QEMU 를 수행시켰다면
화면에 QEMU monitor console 이 아니라 가상머신의 console 로 연결되었을 텐데,
&lt;code&gt;Ctrl+a c&lt;/code&gt; 키 조합으로 QEMU monitor console 로 이동할 수 있습니다.  여기서
가상머신 콘솔로 돌아가려면 &lt;code&gt;Ctrl+a c &amp;lt;enter&amp;gt;&lt;/code&gt; 를 입력해 줍니다.&lt;/p&gt;

&lt;h1 id=&#34;gdb-시작&#34;&gt;gdb 시작&lt;/h1&gt;

&lt;p&gt;호스트 머신에서 디버깅할 커널의 빌드 디렉토리로 이동해서 &lt;code&gt;gdb vmlinux&lt;/code&gt; 명령어를
입력해 빌드된 리눅스 심볼과 디버깅 정보를 사용해 gdb 가 켜지도록 합니다.
우분투나 일부 배포본에서는 이 때 &lt;code&gt;vmlinux-gdb.py&lt;/code&gt; 를 읽어들이는데 실패할 수
있을 겁니다.  gdb 에서도 에러메세지를 띄워 주겠지만, 홈디렉토리의 &lt;code&gt;.gdbinit&lt;/code&gt;
파일에 다음 한줄을 추가해 주고 앞서 설명한 커맨드로 gdb 를 다시 시작합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add-auto-load-state-path /path/to/linux-build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이후, gdb 세션에서 다음과 같은 명령어를 입력해 QEMU 가상머신에 연결합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote :1234
Remote debugging using :1234
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&amp;quot;sti; hlt&amp;quot;: : :&amp;quot;memory&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이와 함께 QEMU 가상 머신은 동작이 멈출 겁니다.  여기서부터 gdb 를 평소에
사용하듯이 사용해 리눅스 커널의 변수를 보거나 중단점 (breakpoint) 를 설정하거나
한단계씩 코드를 수행시키거나 할 수 있습니다.  예를 들어 다음과 같이 특정 함수에
breakpoint 를 설정할 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b cma_alloc
Breakpoint 1 at 0xffffffff81240f10: file /home/sjpark/linux/mm/cma.c, line 399.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어 수행이 멈춰 있는 가상머신의 수행을 다시 가능하게 하려면 다음과 같이 c
를 입력해 줍니다.  가상머신의 커널 수행이 재개되며, Breakpoint 가 설정되어 있고
해당 위치 코드가 수행되면 다시 수행이 멈출 겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) c
Continuing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 멈추려면 gdb 에서 Ctrl+C 를 누릅시다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^C
Thread 1 received signal SIGINT, Interrupt.
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&amp;quot;sti; hlt&amp;quot;: : :&amp;quot;memory&amp;quot;);
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;리눅스-gdb-helper-사용하기&#34;&gt;리눅스 gdb helper 사용하기&lt;/h1&gt;

&lt;p&gt;사실은 앞 단계에서 &lt;code&gt;.gdbinit&lt;/code&gt; 를 굳이 수정하지 않아서 gdb가 &lt;code&gt;vmlinux-gdb.py&lt;/code&gt; 를
읽어들이는데 실패하더라도 gdb 를 평범하게 사용할 수 있습니다.  &lt;code&gt;vmlinux-gdb.py&lt;/code&gt;
는 사실 gdb 위에서 리눅스 커널을 디버깅하는걸 편리하게 해줄 수 있는 일부
스크립트, 즉 gdb helper 를 담고 있습니다.  이걸 사용하면 보다 쉽게 커널
디버깅을 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;helper-스크립트-리스트업&#34;&gt;helper 스크립트 리스트업&lt;/h2&gt;

&lt;p&gt;사용 가능한 helper 스크립트는 lx로 시작하는 규칙을 갖고 있습니다.  다음
명령으로 사용 가능한 스크립트 목록과 간단한 설명을 볼 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) apropos lx
function lx_current -- Return current task
function lx_module -- Find module by name and return the module variable
function lx_per_cpu -- Return per-cpu variable
function lx_task_by_pid -- Find Linux task by PID and return the task_struct variable
function lx_thread_info -- Calculate Linux thread_info from task variable
function lx_thread_info_by_pid -- Calculate Linux thread_info from task variable found by pid
lx-cmdline --  Report the Linux Commandline used in the current kernel
lx-cpus -- List CPU status arrays
lx-dmesg -- Print Linux kernel log buffer
lx-fdtdump -- Output Flattened Device Tree header and dump FDT blob to the filename
lx-iomem -- Identify the IO memory resource locations defined by the kernel
lx-ioports -- Identify the IO port resource locations defined by the kernel
lx-list-check -- Verify a list consistency
lx-lsmod -- List currently loaded modules
lx-mounts -- Report the VFS mounts of the current process namespace
lx-ps -- Dump Linux tasks
lx-symbols -- (Re-)load symbols of Linux kernel and currently loaded modules
lx-version --  Report the Linux Version of the current kernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참 쉽죠? ;)&lt;/p&gt;

&lt;h1 id=&#34;참고-자료&#34;&gt;참고 자료&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/v4.11/dev-tools/gdb-kernel-debugging.html&#34; target=&#34;_blank&#34;&gt;커널 디버깅 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.alexlambert.com/2017/12/18/kernel-debugging-for-newbies.html&#34; target=&#34;_blank&#34;&gt;참고할만한 영문 블로그 글&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/Server.html&#34; target=&#34;_blank&#34;&gt;gdbserver 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc4/</link>
      <pubDate>Mon, 07 May 2018 12:12:32 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc4/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17-rc4&#34;&gt;Linux 4.17-rc4&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyry0qeZvYjU5pf8a6zvb_ALmP-2T9+HZH2DHK93P6rQg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFyry0qeZvYjU5pf8a6zvb_ALmP-2T9+HZH2DHK93P6rQg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;어느새 네번째 rc 버전입니다.  v4.17 을 향한 여정이 절반을 넘어가는군요.  이번 릴리즈도 특이사항 없이 평범합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc3</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc3/</link>
      <pubDate>Mon, 30 Apr 2018 12:59:19 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc3/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17-rc3&#34;&gt;Linux 4.17-rc3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyu=y0SBesB+vx3JZFGcOhP+tuVG7sjfrkfBhXHTe0Skg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFyu=y0SBesB+vx3JZFGcOhP+tuVG7sjfrkfBhXHTe0Skg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;세번째 rc 버전이 나왔습니다.  평소보다 좀 일찍 왔군요.  rc2 에 비해 커다란
릴리즈이긴 한데, 그렇다 해도 평범한 릴리즈라고 리누스는 이야기 합니다.
대부분의 변경 사항이 드라이버 쪽 수정이기 때문이라고 하는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v4-00-16-rearrange-struct-page&#34;&gt;[PATCH v4 00/16] Rearrange struct page&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180430202247.25220-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180430202247.25220-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 블로그에서도 소개했던, Matthew Wilcox 의 &amp;lsquo;struct page&amp;rsquo; 정리 패치의 네번째
버전입니다.  지난주 LSFMM 에서도 소개한 모양인데, 이 변화의 전/후를 google
spread sheet 로 정리한 문서도 여기서 공개했나보군요:
&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-0-4-interface-for-higher-order-contiguous-allocations&#34;&gt;[PATCH v2 0/4] Interface for higher order contiguous allocations&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180503232935.22539-1-mike.kravetz@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180503232935.22539-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mmap(MAP_CONTIG)&lt;/code&gt; 를 추가하자는 아이디어가 있었습니다.  현재 리눅스 커널에서
연속된 메모리 공간 할당에 사용되기 위해 만들어진 인터페이스는 CMA가 있는데, 그
목적이 좀 특수한 상황에 맞춰져 있다보니 좀 더 범용적 인터페이스가 있으면
어떻겠나 하는 이야기가 나와, 그런 인터페이스를 만들어 제시하는 패치입니다.
제안하는 인터페이스는 다음과 같습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct page *find_alloc_contig_pages(unsigned long nr_pages, gfp_t gfp,
                                        int nid, nodemask_t *nodemask)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rfc-distinguish-vmalloc-pages&#34;&gt;[RFC] Distinguish vmalloc pages&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180502152733.GB2737@bombadil.infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180502152733.GB2737@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;VMalloc 페이지는 유저스페이스에 매핑될 수도 있으므로 성능 분석과 memory leak
문제 분석의 편의를 위해  page-&amp;gt;mapping 값에 이를 가리키는 표식과 해당 페이지를
가리키는 &lt;code&gt;vm_struct&lt;/code&gt; 와 그 안에서의 &lt;code&gt;offset&lt;/code&gt; 을 저장하는 RFC 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;introduce-atomic-dec-and-lock-irqsave&#34;&gt;Introduce atomic_dec_and_lock_irqsave()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180504154533.8833-1-bigeasy@linutronix.de&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180504154533.8833-1-bigeasy@linutronix.de&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;local_irq_save()&lt;/code&gt; + &lt;code&gt;atomic_dec_and_lock()&lt;/code&gt; 조합을 써야 하던 코드를 위해 이를
감싸는 새로운 함수, &lt;code&gt;atomic_dec_and_lock_irqsave()&lt;/code&gt; 를 만들고 기존의 코드가
이를 사용하도록 고친 패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc2</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc2/</link>
      <pubDate>Mon, 23 Apr 2018 12:03:23 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc2/</guid>
      <description>

&lt;h2 id=&#34;linux-v4-17-rc2&#34;&gt;Linux v4.17-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwzkGuq5ASF-vhYj7mEX26V0K+uZCLWi1BLYq+9F1n-Rw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFwzkGuq5ASF-vhYj7mEX26V0K+uZCLWi1BLYq+9F1n-Rw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;두번째 rc 버전의 릴리즈입니다.  &lt;code&gt;perf&lt;/code&gt; 와 테스트 스크립트 쪽에 변경사항이 좀
많긴 하지만 평소와 크게 다르지 않은 추이라는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.17 Rc2</title>
      <link>https://sjp38.github.io/lkml_news_v4.17-rc2/</link>
      <pubDate>Mon, 23 Apr 2018 12:03:06 +0900</pubDate>
      
      <guid>https://sjp38.github.io/lkml_news_v4.17-rc2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc1/</link>
      <pubDate>Mon, 16 Apr 2018 10:59:58 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc1/</guid>
      <description>

&lt;h2 id=&#34;linux-v4-17-rc1&#34;&gt;Linux v4.17-rc1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFx62iBkj+hOmhLksUtvjwTcm_o1dwcyvaNnVpJ-AmvzVQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFx62iBkj+hOmhLksUtvjwTcm_o1dwcyvaNnVpJ-AmvzVQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2주간의 머지 윈도우가 지나고, v4.17-rc1 이 릴리즈 되었습니다.  크게 특별할 것
없이 평범한 머지 윈도우였다고 토발즈는 평하는군요.  그리고 이번에 git objects
mark 가 4백만을 넘겼습니다.  따라서 다음 커널이 v5.0 이어도 될 것 같은데, 꼭
다음 버전에서 그렇게 할지는 모르겠다는군요.  리눅스 커널에서 버전은 그저 시간이
흘렀음을 의미할 뿐, 큰 변화가 있어서 메이저 버전 넘버가 바뀌는게 아니기
때문이죠.  참고로 v3.0 과 v4.0 은 각각 git objects mark 2백만과 4백만에서
이루어졌군요.&lt;/p&gt;

&lt;p&gt;암튼 언젠가는 v5.0 을 릴리즈 하겠지만 너무 큰 의미를 부여하지 말아달라고 이야기 하고 있습니다.&lt;/p&gt;

&lt;p&gt;토발즈는 또한 이번 머지 윈도우에서의 변화로 몇가지를 꼽는데요.
오래된 아키텍쳐인 backfin, cris, frv, m32r, metag, mn10300, score, tile
아키텍쳐의 지원을 끊기로 했고 nds32 라는 새로운 아키텍쳐를 지원하게 되었군요.
해당 아키텍쳐에 지원이 더 필요하다면 언제든 되살려도 좋지만 본인이 잘 관리할 수
있음을 증명해야 함을 한번 더 언급하고 있습니다.&lt;/p&gt;

&lt;p&gt;또한, 이번 머지 윈도우에선 클린업이 꽤 있었습니다.  staging 드라이버들 몇개가
제거되었고, spdx 를 사용함으로써 카피라이트 문구도 많이 줄었습니다.
pre-shipped lexer / parser 파일들도 사라졌구요.&lt;/p&gt;

&lt;p&gt;결국, 이번 릴리즈는 추가된 코드 라인보다 삭제된 코드 라인이 많았던 릴리즈군요.
프로젝트 관리자로써 토발즈가 속시원할 것 같습니다.  이런 경우는 커널 릴리즈
역사상 처음이라는군요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 13538 files changed, 627723 insertions(+), 818855 deletions(-)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;patch-v10-00-25-speculative-page-faults&#34;&gt;[PATCH v10 00/25] Speculative page faults&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1523975611-15978-1-git-send-email-ldufour@linux.vnet.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1523975611-15978-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;어느새 열번째 버전의 speculative page faults 패치셋입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-00-12-improve-shrink-slab-scalability-old-complexity-was-o-n-2-new-is-o-n&#34;&gt;[PATCH v2 00/12] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/152397794111.3456.1281420602140818725.stgit@localhost.localdomain&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/152397794111.3456.1281420602140818725.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;많은 memort shrinker 들 또는 메모리 cgroups 를 가진 시스템에서는 그 수의 제곱에
비례해 &lt;code&gt;shrink_slab()&lt;/code&gt; 의 수행시간이 증가하는데, 이 문제를 해결하고자 하는
패치셋입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/code&gt; 의 수행시간을 사용해 성능 차이를
측정했군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-00-21-mm-thp-swap-swapout-swapin-thp-as-a-whole&#34;&gt;[PATCH 00/21] mm, THP, swap: Swapout/swapin THP as a whole&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180417020230.26412-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180417020230.26412-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;THP (Transparent Huge Page) 는 swap out 되기 전에 regular page 로 쪼개져야
했습니다.  이 작업에 많은 시간이 걸렸기에 한번에 THP 를 swap out 하기 위한
작업을 Huang Ying 이 해왔고 일단 쪼개는 작업은 최후로 미뤄뒀는데 마침내 완전히
THP 단위로 swap out 을 행하는 패치셋을 올렸습니다.&lt;/p&gt;

&lt;p&gt;RAM 으로 PMEM swap device 를 시뮬레이션 해서 vm-scalability 벤치마크의
swap-w-seq 테스트를 16개 프로세스로 실험한 결과, 약 10배의 성능 개선을
보았군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-tip-core-rcu-0-21-contention-reduction-for-v4-18&#34;&gt;[PATCH tip/core/rcu 0/21] Contention reduction for v4.18&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180423030258.GA23370@linux.vnet.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180423030258.GA23370@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RCU 의 루트 &amp;lsquo;rcu_node&amp;rsquo; 구조체로의 락 컨텐션을 줄이는 Paul McKenney 의
패치셋입니다.  별 문제 없으면 4.18 버전에 들어가겠군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.16/</link>
      <pubDate>Mon, 02 Apr 2018 07:13:40 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.16/</guid>
      <description>

&lt;h2 id=&#34;linux-4-16&#34;&gt;Linux 4.16&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyxn0bu5jOAJvO_63GHaGMkJ0uA=bVBm2T3HVX9SimZzw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFyxn0bu5jOAJvO_63GHaGMkJ0uA=bVBm2T3HVX9SimZzw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;릴리즈 마지막 주 치고는 네트워킹 쪽에 조금 변경사항이 있었습니다만, 큰 문제가
될 정도는 아니었습니다.  결과, 4.16이 드디어 릴리즈 되었습니다!  동시에 4.17
머지 윈도우가 시작되는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-2-move-kfree-rcu-out-of-rcu-code-and-use-kfree-bulk&#34;&gt;[PATCH 0/2] Move kfree_rcu out of rcu code and use kfree_bulk&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522647064-27167-1-git-send-email-rao.shoaib@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1522647064-27167-1-git-send-email-rao.shoaib@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;kfree_rcu() 대신 kfree_bulk() 라는 새로 만들어진, 더 효율적인 기능을 사용하도록
하는 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-0-1-mm-support-multiple-kswapd-threads-per-node&#34;&gt;[RFC PATCH 0/1] mm: Support multiple kswapd threads per node&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522661062-39745-1-git-send-email-buddy.lumpkin@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1522661062-39745-1-git-send-email-buddy.lumpkin@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;NUMA 아키텍쳐에서 리눅스 커널은 NUMA 노드당 하나의 kswapd 쓰레드를 띄웁니다.
노드당 kswapd 쓰레드 수를 늘려 성능을 높이려는 쓰레드입니다.  결국은 이런
움직임이 있어야 할거라고 봅니다만, 당장 이 패치에 대해서는 수정 요청 의견도 꽤
있군요.&lt;/p&gt;

&lt;h2 id=&#34;rfc-group-struct-page-elements&#34;&gt;[RFC] Group struct page elements&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180408142334.GA29357@bombadil.infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180408142334.GA29357@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;커널에서 페이지를 관리하는 구조체인 &lt;code&gt;struct page&lt;/code&gt; 는 매우 복잡한 구조로
되어있고, 페이지가 어떤 목적으로 쓰이느냐에 따라 같은 필드가 다른 목적으로
쓰이기도 합니다.
이 RFC 패치는 이 혼란스러운 구조를 좀 개선해 보려는 시도를 담고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-1-2-slab-gfp-zero-is-incompatible-with-a-constructor&#34;&gt;[PATCH &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;] slab: &lt;code&gt;__GFP_ZERO&lt;/code&gt; is incompatible with a constructor&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180410125351.15837-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180410125351.15837-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;시작은 김민찬 님의 null pointer dereference 문제에 대한 수정을 담은
패치셋이었습니다
(&lt;a href=&#34;https://lkml.kernel.org/r/20180409015815.235943-1-minchan@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180409015815.235943-1-minchan@kernel.org&lt;/a&gt;).
이걸 Matthew 는 근본적인 실수가 있었던 것 같다고 보고 이 패치셋을 내놓았습니다.
메모리 할당 요청에 &lt;code&gt;__GFP_ZERO&lt;/code&gt; 플래그를 넣으면 메모리 영역을 0으로 초기화 해서
할당을 해줍니다.  그런데 constructor 가 있다면 초기화 작업을 constructor 에서
해야 하기에 &lt;code&gt;__GFP_ZERO&lt;/code&gt; 플래그를 여기에 넣는건 뭔가 이상하죠.
이 패치셋은 그런 경우는 모두 실수에 의한 것이라 보고 경고를 표시해 주도록
합니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-tip-locking-lockdep-v6-20-20-lockdep-selftest-add-a-test-case-for-srcu&#34;&gt;[RFC tip/locking/lockdep v6 &lt;sup&gt;20&lt;/sup&gt;&amp;frasl;&lt;sub&gt;20&lt;/sub&gt;] lockdep/selftest: Add a test case for SRCU&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180411135721.22723-1-boqun.feng@gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180411135721.22723-1-boqun.feng@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 커널의 락킹 관련 문제 추적 기능인 &lt;code&gt;lockdep&lt;/code&gt; 이 SRCU 를 지원하게 하는
패치와 함께 올라온 패치입니다.
&lt;code&gt;lockdep&lt;/code&gt; 을 위한 selftest 에 SRCU 기능 역시 테스트하도록 테스트를
추가했습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.16-rc7/</link>
      <pubDate>Mon, 26 Mar 2018 08:45:19 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.16-rc7/</guid>
      <description>

&lt;h2 id=&#34;linux-4-16-rc7&#34;&gt;Linux 4.16-rc7&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxpxHnWBeTXN+DKqwCMW_=T2cR8UxSBVk_6c8LL7Et5JQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFxpxHnWBeTXN+DKqwCMW_=T2cR8UxSBVk_6c8LL7Et5JQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.16을 향한 일곱번째 rc 가 릴리즈 되었습니다.  평소대로라면 이게 마지막 rc 여야
할텐데, 평소와 다름없거나 변경사항이 적은 편이던 그동안의 rc와 달리 이번 rc 는
좀 변경사항이 많군요.  그렇다곤 해도 아마도 네트워킹 쪽 코드 머지가 늦었기
때문으로 보이며 rc8을 릴리즈할 생각은 아직은 없다고 토발즈는 이야기 하네요.&lt;/p&gt;

&lt;p&gt;더불어, 토발즈가 rc 릴리즈 때마다 변경 사항들을 정리하기 위해 주로 사용하는 git
사용 스크립트를 공개했습니다.&lt;/p&gt;

&lt;p&gt;다음주는 4.16이 릴리즈 될까요?  아니면, rc8이?&lt;/p&gt;

&lt;h2 id=&#34;patch-mm-list-lru-replace-spinlock-with-rcu-in-list-lru-count-one&#34;&gt;[PATCH] mm/list_lru: replace spinlock with RCU in &lt;code&gt;__list_lru_count_one&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522137544-27496-1-git-send-email-lirongqing@baidu.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1522137544-27496-1-git-send-email-lirongqing@baidu.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;list_lru_count_one()&lt;/code&gt; 이 스핀락을 잡기 때문에 &lt;code&gt;shrink_slab()&lt;/code&gt; 이 많은 시간을
소모하게 되는데, 이를 스핀락 대신 RCU 를 사용하게 해서 최적화 시킨 패치입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dd&lt;/code&gt; 를 사용해 커다란 메모리를 사용한 후 파일을 제거하고서
&lt;code&gt;/cgroup/memory/test/memory.limit_in_bytes&lt;/code&gt; 의 크기를 작게 잡아 인위적으로
reclaim 을 유발시키고 여기에 걸리는 시간을 측정했군요.  기존 0.415초에서 최적화
후 0.395초로 개선되었습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v10-00-62-convert-page-cache-to-xarray&#34;&gt;[PATCH v10 00/62] Convert page cache to XArray&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180330034245.10462-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180330034245.10462-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;XArray 패치 중 일부가 이미 Andrew Morton 의 -next 트리에 들어갔습니다.  Matthew
Wilcox 는 XArray 를 활용하는 패치를 이어서 계속 올리고 있군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-mm-limit-a-process-rss&#34;&gt;[PATCH] mm: limit a process RSS&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522386674-12047-1-git-send-email-lirongqing@baidu.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1522386674-12047-1-git-send-email-lirongqing@baidu.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -m&lt;/code&gt; 명령을 이용해 프로세스의 최대 RSS (Resident Set Size) 를 제어할 수
있는 인터페이스가 있지만 실제로 커널이 제한을 하고 있진 않습니다.  제한하도록
구현하는 패치입니다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
