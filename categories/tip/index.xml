<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Happy Hacking</title>
    <link>https://sjp38.github.io/categories/tip/index.xml</link>
    <description>Recent content on Happy Hacking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>sj38.park@gmail.com (SeongJae Park)</managingEditor>
    <webMaster>sj38.park@gmail.com (SeongJae Park)</webMaster>
    <atom:link href="https://sjp38.github.io/categories/tip/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Parsec 3.0 설치 / 사용법</title>
      <link>https://sjp38.github.io/post/parsec_3_howto/</link>
      <pubDate>Fri, 19 May 2017 06:23:15 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/parsec_3_howto/</guid>
      <description>

&lt;p&gt;PARSEC 은 멀티쓰레드 프로그램들로 구성된 benchmark suite 입니다.  멀티쓰레드로
구성되어 있기 때문에 멀티코어 시스템에서의 multi core scalability 를 테스트
하기에도 적합합니다.  이 글에선 현재 최신 버전인 3.0 버전의 PARSEC 을 Ubuntu
16.04 server 에 설치하면서 겪는 문제의 해결법과 간단한 사용법을 정리해 봅니다.&lt;/p&gt;

&lt;h1 id=&#34;parsec-3-0-download&#34;&gt;PARSEC 3.0 Download&lt;/h1&gt;

&lt;p&gt;공식 홈페이지[1] 에 들어가면 PARSEC 3.0 다운로드 링크가 첫페이지부터 있습니다.
해당 링크를 사용하면 &lt;code&gt;tar.gz&lt;/code&gt; 포맷의 tarball 로 정리된 PARSEC 3.0 을 다운받을
수 있습니다.  웹브라우저로 들어가서 다운로드를 받는 방법도 있겠고, &lt;code&gt;curl&lt;/code&gt; 이나
&lt;code&gt;wget&lt;/code&gt; 등의 command line tool 을 사용해 다운받을 수도 있겠습니다.  다음
커맨드는 PARSEC 3.0 을 다운받아 &lt;code&gt;parsec-3.0/&lt;/code&gt; 디렉토리 아래 압축을 풀고 압축을
푼 디렉토리로 이동합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://parsec.cs.princeton.edu/download/3.0/parsec-3.0.tar.gz
$ tar zxvf parsec-3.0.tar.gz
$ cd parsec-3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;build&#34;&gt;Build&lt;/h1&gt;

&lt;p&gt;이제 PARSEC 3.0 을 빌드해야 합니다.  PARSEC 은 여러 벤치마크를 포함하고
있으므로 개별적 벤치마크를 하나하나 직접적으로 다루기보다는 suite 내의 각
벤치마크를 통합적으로 관리할 수 있는 &lt;code&gt;parsecmgmt&lt;/code&gt; 라는 관리 프로그램을
사용하도록 되어 있습니다.  빌드 역시 마찬가지입니다.  참고로, &lt;code&gt;parsecmgmt&lt;/code&gt; 는
bash script 입니다.&lt;/p&gt;

&lt;p&gt;기본적인 PARSEC 3.0 빌드 방법은 다음과 같이 간단합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ source ./env.sh
$ parsecmgmt -a build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫번째 커맨드는 parsecmgmt 의 경로를 PATH 에 추가하는 등, 환경 변수 설정 등의
일을 처리해 주며, 두번째의 간단한 커맨드가 전체 PARSEC 3.0 빌드 프로세스를
수행하게 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;perl-version-problem&#34;&gt;Perl Version Problem&lt;/h2&gt;

&lt;p&gt;하지만 Ubuntu 16.04 server 에서는 다음과 같은 에러 메세지를 내뱉으며 빌드에
실패합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;smime.pod around line 272: Expected text after =item, not a number
smime.pod around line 276: Expected text after =item, not a number
smime.pod around line 280: Expected text after =item, not a number
smime.pod around line 285: Expected text after =item, not a number
smime.pod around line 289: Expected text after =item, not a number
POD document had syntax errors at /usr/bin/pod2man line 68.
make: *** [install_docs] Error 1
Makefile:680: recipe for target &#39;install_docs&#39; failed
[PARSEC] Error: &#39;env PATH=/usr/bin:/home/sjpark/benchmarks/parsec/parsec-3.0/bin:/home/sjpark/bin:/home/sjpark/.local/bin:/home/sjpark/bin:/home/sjpark/bin:/home/sjpark/.local/bin:/home/sjpark/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/bin:/snap/bin:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/bin:/home/sjpark/benchmarks/parsec/parsec-3.0/bin /usr/bin/make install&#39; failed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;에러 메세지에서 유추할 수 있듯 PARSEC 3.0 의 소스 코드 중 smime.pod 파일이
문법에 맞지 않아 생긴 문제입니다.  참고로 pod 는 perl 프로그램 문서화에
사용되는 간단한 markup language 입니다[2].  Ubuntu 16.04 는 perl 5.22.1 버전을
기본으로 사용하고 있는데, PARSEC 3.0 에 있는 코드는 perl 5.14.2 버전에 맞춰져
있으며 최신 버전으로 오는 사이 문법이 바뀐 것으로 인한 문제로 보입니다.
해결책은 두가지가 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;방법 1: perl 5.14.2 설치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Google groups 의 관련 쓰레드[3] 를 참고한 방법입니다.
5.14.2 버전의 perl 소스코드를 받아와 이를 설치하고 PARSEC 빌드에 이 버전의 perl
을 사용하는 방법입니다.  다음의 커맨드로 &lt;code&gt;~/localperl/&lt;/code&gt; 디렉토리 아래 5.14.2
버전 perl 을 설치하고 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.cpan.org/src/5.0/perl-5.14.2.tar.gz
$ tar zxvf perl-5.14.2.tar.gz
$ cd perl-5.14.2/
$ mkdir ~/localperl
$ ./Configure -des -Dprefix=$HOME/localperl
$ time make -j # hydra 에서 16초 걸린다.
$ make test
$ make install
$ ~/localperl/bin/perl -v
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;방법 2: pod 파일 문법 오류 수정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;좀 더 정공법에 가까운 방법으로, 다음 글을 참고한 해결책입니다:
&lt;a href=&#34;https://yulistic.gitlab.io/2016/05/parsec-3.0-installation-issues/&#34;&gt;https://yulistic.gitlab.io/2016/05/parsec-3.0-installation-issues/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;최신 버전의 문법에 맞게 pod 파일의 문제시 되는 부분들을 고쳐주는 것으로,
문제되는 모든 pod 파일의 &lt;code&gt;=item [0-9]&lt;/code&gt; 을 &lt;code&gt;=item C&amp;lt;[0-9]&amp;gt;&lt;/code&gt; 으로 바꿔줍니다.
&lt;code&gt;diff&lt;/code&gt; 로 표현하면 다음과 같은 수정을 가하게 되겠습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- a/pkgs/libs/ssl/src/doc/apps/smime.pod
+++ b/pkgs/libs/ssl/src/doc/apps/smime.pod
@@ -265,28 +265,28 @@ encrypted data is used for other purposes.

 =over 4

-=item 0
+=item C&amp;lt;0&amp;gt;

 the operation was completely successfully.

-=item 1
+=item C&amp;lt;1&amp;gt;

 an error occurred parsing the command options.

-=item 2
+=item C&amp;lt;2&amp;gt;

 one of the input files could not be read.

-=item 3
+=item C&amp;lt;3&amp;gt;

 an error occurred creating the PKCS#7 file or when reading the MIME
 message.

-=item 4
+=item C&amp;lt;4&amp;gt;

 an error occurred decrypting or verifying the message.

-=item 5
+=item C&amp;lt;5&amp;gt;

 the message was verified correctly but an error occurred writing out
 the signers certificates.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 파일 하나하나 수정하면 이 에러 메세지는 사라집니다.  참고한 링크에서는
하나하나 손으로 수정하기보다는 다음과 같이 간단한 bash shell script 를 짜서
일괄적으로 수정하는 걸 추천합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /bin/bash
for i in 0 1 2 3 4 5 6 7 8 9 
do
    echo &amp;quot;Replacing &#39;=item $i&#39; to &#39;=item C&amp;lt;$i&amp;gt;&#39;&amp;quot;
    grep -rl &amp;quot;=item $i&amp;quot; * | xargs sed -i &amp;quot;s/=item $i/=item C&amp;lt;$i&amp;gt;/g&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이어서 설명할 문제들과 해결책도 해당 링크를 참고한 것임을 밝혀둡니다.&lt;/p&gt;

&lt;h2 id=&#34;mbstate-t-conflict&#34;&gt;&lt;code&gt;__mbstate_t&lt;/code&gt; Conflict&lt;/h2&gt;

&lt;p&gt;앞의 에러 메세지는 사라지지만 이제 다음과 같은 에러 메세지가 나올 겁니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/include/wchar.h:94:3: error: conflicting types for ‘__mbstate_t’
 } __mbstate_t;
   ^
In file included from ../include/machine/bsd_endian.h:37:0,
                 from ../include/sys/bsd_types.h:44,
                 from ../include/sys/bsd_param.h:64,
                 from if_host.c:48:
../include/sys/bsd__types.h:105:3: note: previous declaration of ‘__mbstate_t’ was here
 } __mbstate_t;
   ^
In file included from ../include/net/bsd_if_var.h:82:0,
                 from ../include/net/bsd_if.h:459,
                 from if_host.c:57:
../include/sys/bsd_buf_ring.h: In function ‘buf_ring_dequeue_sc’:
../include/sys/bsd_buf_ring.h:200:33: warning: variable ‘cons_next_next’ set but not used [-Wunused-but-set-variable]
  uint32_t cons_head, cons_next, cons_next_next;
                                 ^
make[1]: *** [if_host.o] Error 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;basd__types.h&lt;/code&gt; 파일에 &lt;code&gt;__mbstate_t&lt;/code&gt; 타입을 중복 정의했기 때문에 발생한
문제입니다.  해당 파일에서 해당 정의 부분을 다음과 같이 주석 처리하면 이 문제는
사라집니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff --git a/pkgs/libs/uptcpip/src/include/sys/bsd__types.h b/pkgs/libs/uptcpip/src/include/sys/bsd__types.h
index fa1b0f0f26d9..bd7e6a97f4c8 100644
--- a/pkgs/libs/uptcpip/src/include/sys/bsd__types.h
+++ b/pkgs/libs/uptcpip/src/include/sys/bsd__types.h
@@ -93,6 +93,7 @@ typedef       __ct_rune_t     __wint_t;       /* wint_t (see above) */

 typedef        __uint32_t      __fixpt_t;      /* fixed point number */

+#if 0  /* Skip conflicting __mbstate_t definition */
 /*
  * mbstate_t is an opaque object to keep conversion state during multibyte
  * stream conversions.
@@ -104,5 +105,6 @@ typedef union {
        __int64_t       _mbstateL;      /* for alignment */
 } __mbstate_t;
 #endif
+#endif /* Skip conflicting __mbstate_t definition */

 #endif /* !_BSD_SYS__TYPES_H_ */
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pkg-config-package-not-found&#34;&gt;pkg-config Package Not Found&lt;/h2&gt;

&lt;p&gt;성공적인 빌드를 위해선 당연하지만 PARSEC 3.0 이 의존성을 가진 패키지가 모두
설치되어 있어야 합니다.  이를 주의 깊게 미리 설치해 두지 않았다면 다음과 같은
에러 메세지를 만날 수도 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;configure: error: *** pkg-config not found. See http://www.freedesktop.org/software/pkgconfig/
[PARSEC] Error: &#39;env CFLAGS=-I/home/sjpark/benchmarks/parsec/parsec-3.0/pkgs/libs/zlib/inst/amd64-linux.gcc/include  -O3 -g -funroll-loops -fprefetch-loop-arrays -static-libgcc -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20150206 LDFLAGS=-L/home/sjpark/benchmarks/parsec/parsec-3.0/pkgs/libs/zlib/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib /home/sjpark/benchmarks/parsec/parsec-3.0/pkgs/libs/glib/src/configure --disable-shared --enable-threads --with-threads=posix --prefix=/home/sjpark/benchmarks/parsec/parsec-3.0/pkgs/libs/glib/inst/amd64-linux.gcc&#39; failed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 메세지는 &lt;code&gt;pkg-config&lt;/code&gt; 프로그램이 설치되어 있지 않아서 발생한 문제임을 알 수
있습니다.  간단히 Ubuntu 의 package 시스템인 apt 를 사용해 다음과 같이 해당
프로그램을 설치해 주면 문제는 사라집니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt install pkg-config
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-success&#34;&gt;Build Success&lt;/h2&gt;

&lt;p&gt;이 정도까지가 나타날 수 있는 대부분의 문제입니다.  위 해결책들을 모두
적용했다면 아마 빌드에 성공할 겁니다.  빌드에 성공하면 다음과 같이 성공했다는
메세지를 볼 수 있을 겁니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[PARSEC]
[PARSEC] BIBLIOGRAPHY
[PARSEC]
[PARSEC] [1] Bienia. Benchmarking Modern Multiprocessors. Ph.D. Thesis, 2011.
[PARSEC] [2] Woo et al. The SPLASH-2 Programs: Characterization and Methodological Considerations. ISCA, 1995.
[PARSEC]
[PARSEC] Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 빌드에 꽤 긴 시간이 소모됩니다.  제가 사용한 72 코어 / 144 쓰레드
머신에서도 약 10분이 걸렸습니다.&lt;/p&gt;

&lt;h1 id=&#34;simple-usage&#34;&gt;Simple Usage&lt;/h1&gt;

&lt;p&gt;이제 빌드가 잘 되었는지 돌려봐야 할 차례입니다.  다음 커맨드는 각 벤치마크를
가장 작은 크기의 데이터셋을 가지고 실행해 보기 때문에 각 벤치마크가 돌아가긴
하는지만 보는데 적격입니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parsecmgmt -a run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;가장 작은 크기의 데이터셋을 사용하기 때문에 모든 벤치마크를 수행하지만 빠르게
종료됩니다.&lt;/p&gt;

&lt;h2 id=&#34;parsecmgmt-options&#34;&gt;&lt;code&gt;parsecmgmt&lt;/code&gt; Options&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 옵션은 action 을 의미합니다.  앞의 섹션에서는 빌드를 위해 여기에 &lt;code&gt;build&lt;/code&gt;
값을 주었고, 여기선 벤치마크 수행을 위해 &lt;code&gt;run&lt;/code&gt; 값을 준 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-i&lt;/code&gt; 옵션을 통해 벤치마크들은 워크로드에서 사용할 데이터 크기를 지정할 수
있습니다.  이 인자의 값으로 test, simdev, simsmall, simmedium, simlarge, native
를 줄 수 있습니다.  Test 는 정확성 테스트만을 위한, 빨리 끝나는 데이터로 이
인자를 주지 않으면 default 로 이 값이 취해집니다.  native 는 가장 realworld
workload 에 가까운 벤치마크를 위한 데이터라 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; 옵션을 통해 어떤 sub benchmark 를 돌릴지 정할 수 있습니다.  이 옵션을
별도로 주지 않으면 모든 benchmark 를 돌리게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; 옵션은 number of threads to use 입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code&gt;parsecmgmt -p canneal -a run -i native -n 1&lt;/code&gt; 은 &lt;code&gt;canneal&lt;/code&gt; sub
benchmark 하나만을 쓰레드 한개 써서 &lt;code&gt;native&lt;/code&gt; 데이터셋으로 실행합니다.&lt;/p&gt;

&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;[1] http://parsec.cs.princeton.edu
[2] https://en.wikipedia.org/wiki/Plain_Old_Documentation
[3] https://groups.google.com/forum/#!topic/snipersim/_1qpbmpPRtg
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 Server 위에 MariaDB 설치/사용하기</title>
      <link>https://sjp38.github.io/post/mariadb_setup/</link>
      <pubDate>Wed, 17 May 2017 22:44:07 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/mariadb_setup/</guid>
      <description>

&lt;p&gt;악의 조직 Oracle 에서 Sun 을 인수한 후 이어진 반 open source 적 행보에 MySQL
개발자는 MySQL 을 fork 해서 MariaDB 를 개발하고 있습니다.  저작권을 악용해
중요한 기능은 천천히 릴리즈 하거나 유료 라이센스로만 공개하기도 하는 Oracle 의
MySQL 과 달리 MariaDB 는 예전 MySQL 처럼 공개적으로 개발되고 있어 새롭고
진보적인 기능도 많이 있는 편인 것 같습니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 Ubuntu 16.04 서버에 MariaDB 를 소스코드부터 가져와서 설치하고
사용하는 간단한 사용법을 정리해 봅니다.&lt;/p&gt;

&lt;h1 id=&#34;build-and-install&#34;&gt;Build and Install&lt;/h1&gt;

&lt;p&gt;MariaDB 는 대부분의 리눅스 배포본을 위한 패키징이 잘 되어 있어서 각 배포본의
패키징 시스템을 사용하면 한두줄의 커맨드로 쉽게 설치할 수 있습니다.  하지만
여기선 문서[1] 를 참고해 가며 소스 코드부터 가져와서 바닥부터 가장 최신 버전을
설치해 보기로 합시다.&lt;/p&gt;

&lt;p&gt;소스코드는 github 에 git repository 의 형태로 공개되어 있습니다.  아래의
명령어로 코드를 &lt;code&gt;mariadb/&lt;/code&gt; 디렉토리 아래에 가져올 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/MariaDB/server.git mariadb
$ cd mariadb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;git repository 인만큼 버전은 git 을 통해 tag 로 관리되고 있습니다.  이 글을
작성 중인 시점에서 가장 최신 stable 릴리즈는 10.1.22[2] 로, 2017년 3월 11일
자로 릴리즈 되었습니다.  다음 커맨드로 해당 버전의 코드를 checkout 할 수
있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout mariadb-10.1.22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 소스코드는 준비되었고, 빌드할 차례입니다.  &lt;code&gt;cmake&lt;/code&gt; 를 사용해 어떻게
빌드할지 등을 설정할 수 있는데, 여기선 release 할때 사용하는 설정을 사용해
보겠습니다.  이어서 간단히 &lt;code&gt;make&lt;/code&gt; 를 사용해 빌드하고 설치를 할 수 있습니다.
설치는 super user 권한이 필요하기 때문에 &lt;code&gt;sudo&lt;/code&gt; 를 사용해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cmake . -DBUILD_CONFIG=mysql_release
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 사양의 머신에서 빌드하느냐에 따라 다르겠지만 빌드하는데 꽤 긴 시간이
걸립니다.  이 글을 작성하며 사용한 72 코어 / 144 쓰레드 머신에서는 &lt;code&gt;-j144&lt;/code&gt;
옵션을 줘서 빌드할 경우 1분 5초 걸렸습니다.&lt;/p&gt;

&lt;h1 id=&#34;start-mariadb-server&#34;&gt;Start MariaDB Server&lt;/h1&gt;

&lt;p&gt;이제 MariaDB 를 띄워 볼 차례입니다.  아무 프로세스나 super user 권한으로
실행하는 건 보안적으로 위험할 수 있으므로, MariaDB 는 기본적으로 별개의 사용자
계정을 사용할 것을 권장합니다.  다음 예에서는 mysql 이라는 이름의 user 를
생성해서 이 사용자 계정을 사용하도록 해서 초기화를 진행합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo adduser mysql
$ sudo chown -R mysql /usr/local/mysql/
$ cd /usr/local/mysql/
$ sudo -u mysql ./scripts/mysql_install_db --user=mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 준비가 끝났습니다.  다음 커맨드로 MariaDB 서버를 시작할 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo -u mysql /usr/local/mysql/bin/mysqld_safe --user=mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;connect-to-local-mariadb-server&#34;&gt;Connect to Local MariaDB Server&lt;/h1&gt;

&lt;p&gt;다음 커맨드로 mariadb local shell 을 열 수 있습니다.  이 커맨드는 같은 기계
위에 띄워져 있는 MariaDB 서버 프로세스에 접속해 해당 서버에 sql 쿼리를 날릴 수
있는 프롬프트를 띄워 줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/mysql/bin/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 커맨드에 &amp;ndash;version 인자를 주면 현재 mariadb 의 버전도 볼 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/mysql/bin/mysql --version
mysql  Ver 15.1 Distrib 10.1.22-MariaDB, for Linux (x86_64) using readline 5.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;kill-mariadb-server&#34;&gt;Kill MariaDB Server&lt;/h1&gt;

&lt;p&gt;서버를 끝낼 수도 있어야겠죠.  다음의 커맨드로 mysql 서버 프로세스에게 SIGTERM
시그널을 날려서 서버 프로세스를 종료시킬 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo -u mysql kill -SIGTERM `pidof mysqld`
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;basical-usage&#34;&gt;Basical Usage&lt;/h1&gt;

&lt;p&gt;프롬프트에서 다음과 같이 기본적인 sql 쿼리를 날릴 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/local/mysql/bin/mysql
&amp;gt; create database sj_db;
&amp;gt; create table sjtable ( id INT PRIMARY KEY, name VARCHAR(20) );
&amp;gt; insert into sjtable values ( 1, &#39;Will&#39; );
&amp;gt; select * from sjtable;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그 외의 MariaDB sql 문법을 위해서는 MariaDB basic sql statement 문서[3] 를
참고합시다.&lt;/p&gt;

&lt;h1 id=&#34;my-cnf-configuration&#34;&gt;my.cnf configuration&lt;/h1&gt;

&lt;p&gt;mysql 과 마찬가지로 MariaDB 역시 my.cnf 파일을 사용해[1] 대부분의 설정을
구성합니다.  기본적으로 /etc/my.cnf, /etc/mysql/my.cnf &amp;hellip; 순으로 설정 파일을
찾게 되며, mysqld_safe 실행파일 실행 시에 &amp;ndash;defaults-file 인자로 파일 경로를
줄수도 있습니다.  소스 코드 디렉토리의 support-files/ 디렉토리 아래에
my-huge.cnf, my-large.cnf, my-medium.cnf 등의 예제 설정도 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;data-directory-specification&#34;&gt;Data Directory Specification&lt;/h1&gt;

&lt;p&gt;실험용으로 MariaDB 를 사용하는 경우라면 MariaDB 데이터를 최초 상태로 백업해
두거나 서로 다른 설정의 데이터를 유지해야 할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;MariaDB 의 default data directory 는 /usr/local/mysql/data/ 로, 프롬프트에서&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; select @@datadir;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;명령으로 현재 띄워진 MariaDB 서버 프로세스가 사용중인 data directory 의 경로를
볼 수 있습니다.  이 경로는 my.cnf 상에서 수정할 수도 있고, mysqld_safe 실행 시
&amp;ndash;datadir 옵션으로 지정할 수도 있습니다.  주의할 점은, 이때 &amp;ndash;datadir 인자로
주는 데이터 디렉토리는 한번은 scripts/mysql_install_db 를 실행해준 디렉토리여야
한다는 것입니다.  mysql_install_db 명령에도 &amp;ndash;datadir 인자를 줄수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;MariaDB 최신 버전의 소스코드를 가져와 빌드하고 설치해서 사용하는 방법을
알아봤습니다.  하나의 예제로 정리해 보자면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/MariaDB/server.git mariadb
$ cd mariadb
$ git checkout mariadb-10.1.22
$ cmake . -DBUILD_CONFIG=mysql_release
$ make
$ sudo make install
$ sudo adduser mysql
$ sudo chown -R mysql /usr/local/mysql/
$ cd /usr/local/mysql/
$ sudo -u mysql ./scripts/mysql_install_db --user=mysql &amp;amp;
$ /usr/local/mysql/bin/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;[1] https://mariadb.com/kb/en/mariadb/generic-build-instructions/
[2] https://downloads.mariadb.org/mariadb/+releases/
[3] https://mariadb.com/kb/en/mariadb/basic-sql-statements/
[4] https://mariadb.com/kb/en/mariadb/configuring-mariadb-with-mycnf/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>원격 데스크탑의 clipboard 를 ssh 와 xclip 으로 복사해오기</title>
      <link>https://sjp38.github.io/post/xclip_copy_remote_clipboard/</link>
      <pubDate>Fri, 31 Mar 2017 13:53:54 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/xclip_copy_remote_clipboard/</guid>
      <description>&lt;p&gt;여러개의 리눅스 데스크탑 PC 를 한 책상 위에서 사용하는 경우가 있다.  이 때, 한
PC 에서 Ctrl-C 해서 clipboard 에 복사한 내용을 다른쪽 PC 에서 Ctrl-V 로
붙여넣고 싶은 경우가 있다.  여러가지 해결책이 있겠으나, 다음과 같이 ssh 와
xclip 을 사용해서 해결할 수도 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh &amp;lt;username&amp;gt;@&amp;lt;remote host&amp;gt; &#39;DISPLAY=:0 xclip -o -selection clipboard&#39; | \
	xclip -i -selection clipboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고: &lt;a href=&#34;http://askubuntu.com/questions/513442/can-two-pcs-with-ubuntu-share-the-clipboard-buffer&#34;&gt;http://askubuntu.com/questions/513442/can-two-pcs-with-ubuntu-share-the-clipboard-buffer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>spec cpu2006 벤치마크 설치하기</title>
      <link>https://sjp38.github.io/post/spec_cpu2006_install/</link>
      <pubDate>Wed, 29 Mar 2017 05:10:55 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/spec_cpu2006_install/</guid>
      <description>

&lt;p&gt;SPEC 은 벤치마크를 위한 협력기구 [0] 로, 다양한 벤치마크 suite 들을 만들고
공유합니다.  SPEC CPU 2006 은 여기서 만든 벤치마크 도구집합 중 하나 [1] 로 계산
작업 집중적인 워크로드에 대한 성능을 측정을 목표로 만들어졌으며, 많은 곳에서
사용되고 있습니다.  2006년 1.0 버전이, 2008년에 1.1 버전이, 그리고 2011년에 1.2
버전이 나왔습니다.  본 글은 Ubuntu 16.04 서버 위에서의 SPEC CPU 2006 v1.1 의
설치에 대해 간단히 설명합니다.&lt;/p&gt;

&lt;h1 id=&#34;설치-환경&#34;&gt;설치 환경&lt;/h1&gt;

&lt;p&gt;본 글에서 설명하는 내용은 다음과 같은 환경의 머신 위에서 수행되었습니다:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Intel Xeon E7-8870 v3&lt;/li&gt;
&lt;li&gt;Linux 4.10 kernel&lt;/li&gt;
&lt;li&gt;Ubuntu 16.04.1 Server version&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;소스-코드-구하기&#34;&gt;소스 코드 구하기&lt;/h1&gt;

&lt;p&gt;먼저 소스 코드가 있어야겠죠.  SPEC CPU 2006 은 DVD 또는 &lt;code&gt;.iso&lt;/code&gt; 파일의 형태로
구매 [2] 될 수 있습니다 (작성 시점에서 SPEC CPU 2006 v1.2 의 가격은 $800 군요).
이렇게 구매된 DVD 안에는 벤치마크 소스코드와 벤치마크의 컴파일과 수행, 검증을
위한 tool 프로그램들의 소스코드, 미리 컴파일된 tool 프로그램들, 벤치마크 실행을
위한 규칙 파일, 그리고 문서등이 들어있습니다.  이 글에선 SPEC CPU 2006 v1.1 을
바탕으로 설명합니다.  &lt;code&gt;.iso&lt;/code&gt; 파일을 구했다면 다음과 같은 명령으로 mount 해서 그
안의 파일들을 보고 사용할 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir tmnt
$ sudo mount -o loop SPEC_CPU2006v1.1.iso ./tmnt
$ ls tmnt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마운트한 위치에서 곧바로 설치 / 실행을 수행해도 좋지만 파일을 복사해두고
사용하겠습니다.  &lt;code&gt;mount&lt;/code&gt; 를 &lt;code&gt;sudo&lt;/code&gt; 로 해야하는 관계로 이 파일들의 owner 는
&lt;code&gt;root&lt;/code&gt; 이며 쓰기권한도 없습니다.  굳이 &lt;code&gt;root&lt;/code&gt; 가 되지 않고도 벤치마크를
설치하고 돌릴 수 있으므로 파일의 owner 와 권한을 바꿔줍니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir SPEC_CPU2006v1.1
$ cp -R ./tmnt/* SPEC_CPU2006v1.1/
$ sudo umount ./tmnt &amp;amp;&amp;amp; rm -fr ./tmnt
$ sudo chown -R &amp;lt;username&amp;gt; SPEC_CPU2006v1.1
$ sudo chmod -R 755 SPEC_CPU2006v1.1
$ cd SPEC_CPU2006v1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;툴-빌드&#34;&gt;툴 빌드&lt;/h1&gt;

&lt;p&gt;SPEC 에서 사용되는 도구들은 앞서 가져온 &lt;code&gt;.iso&lt;/code&gt; 파일 안에 redhat, suse 등 여러
플랫폼 용으로 미리 빌드되어 있습니다.  하지만 Ubuntu 를 위한 버전은 없습니다.
따라서 다음과 같이 소스코드로부터 직접 빌드를 해야 합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd tools/src
$ ./buildtools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;buildtools&lt;/code&gt; 는 셸 스크립트로, &lt;code&gt;tools/src&lt;/code&gt; 아래 있는 각 툴들을 빌드합니다.
곧바로 진행되면 좋겠지만, 다음과 같은 에러들이 발생합니다.&lt;/p&gt;

&lt;h2 id=&#34;conflicting-types-for-getline&#34;&gt;Conflicting types for &amp;lsquo;getline&amp;rsquo;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;md5sum&lt;/code&gt; 빌드 중 다음과 같은 에러 메세지가 나옵니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -DHAVE_CONFIG_H    -I/home/sjpark/benchmarks/spec/SPEC_CPU2006v1.1/tools/output/include   -I. -Ilib  -c -o md5sum.o md5sum.c
In file included from md5sum.c:38:0:
lib/getline.h:31:1: error: conflicting types for &#39;getline&#39;
 getline PARAMS ((char **_lineptr, size_t *_n, FILE *_stream));
 ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;md5sum&lt;/code&gt; 빌드 중 &lt;code&gt;getline()&lt;/code&gt;, &lt;code&gt;getdelim()&lt;/code&gt; 함수가 &lt;code&gt;stdio.h&lt;/code&gt; 에서 선언되어
있는데도 &lt;code&gt;getline.h&lt;/code&gt; 파일에 또 선언되어서 conflicting type 으로 나는
문제입니다.  역시 툴 중 하나인 &lt;code&gt;tar&lt;/code&gt; 의 경우엔 GLIBC 버전을 체크해 2 이상일
경우엔 해당 declaration 을 제거해 두었는데, &lt;code&gt;md5sum&lt;/code&gt; 아래의 &lt;code&gt;getline.h&lt;/code&gt; 엔 이
체크가 없기 때문에 문제가 됩니다.  다음과 같이 GLIBC 버전 체크를 추가해
중복선언이 없도록 수정해 줍니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- a/tools/src/specmd5sum/lib/getline.h
+++ b/tools/src/specmd5sum/lib/getline.h
@@ -27,10 +27,14 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 #  endif
 # endif

+# if __GLIBC__ &amp;lt; 2
+
 int
 getline PARAMS ((char **_lineptr, size_t *_n, FILE *_stream));

 int
 getdelim PARAMS ((char **_lineptr, size_t *_n, int _delimiter, FILE *_stream));

+#endif
+
 #endif /* not GETLINE_H_ */
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;undefined-reference-to-pow&#34;&gt;Undefined reference to &lt;code&gt;pow&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;이 문제와 아래의 두개의 문제는 인터넷 상의 SPEC CPU 2000 에 대한 비슷한 문제의
해결책[3] 을 참고했습니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;perl&lt;/code&gt; 빌드 중 다음과 같은 에러 메세지가 발생합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cc -L/home/sjpark/benchmarks/spec/SPEC_CPU2006v1.1/tools/output/lib -L/usr/local/lib -o miniperl \
            miniperlmain.o opmini.o libperl.a
libperl.a(pp.o): In function `Perl_pp_pow&#39;:
pp.c:(.text+0x2a76): undefined reference to `pow&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pow&lt;/code&gt; 함수를 찾지 못하는 문제로, &lt;code&gt;libm&lt;/code&gt; 라이브러리를 링크 시점에 링크하도록
알려줘야 합니다.  다음과 같이 &lt;code&gt;PERLFLAGS&lt;/code&gt; 환경변수를 설정하고 &lt;code&gt;buildtools&lt;/code&gt; 를
실행하는 것으로 해결할 수 있습니다:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ PERLFLAGS=&amp;quot;-A libs=-lm -A libs=-ldl&amp;quot; ./buildtools&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;asm-page-h-file-not-found&#34;&gt;&lt;code&gt;asm/page.h&lt;/code&gt; file not found&lt;/h2&gt;

&lt;p&gt;커널 헤더파일인 &lt;code&gt;asm/page.h&lt;/code&gt; 파일을 &lt;code&gt;tools/src/perl-5.8.8/ext/IPC/SysV/SysV.xs&lt;/code&gt;
파일에서 &lt;code&gt;include&lt;/code&gt; 하고 있어 발생하는 문제가 다음과 같이 발생합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cc -c   -I/home/sjpark/benchmarks/spec/SPEC_CPU2006v1.1/tools/output/include -fno-strict-aliasing -pipe -Wdeclaration-after-statement -I/usr/local/include -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -O2   -DVERSION=\&amp;quot;1.04\&amp;quot; -DXS_VERSION=\&amp;quot;1.04\&amp;quot; -fpic &amp;quot;-I../../..&amp;quot;   SysV.c
SysV.xs:7:25: fatal error: asm/page.h: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SysV.xs&lt;/code&gt; 파일의 해당 &lt;code&gt;include&lt;/code&gt; 문을 다음과 같이 막고 &lt;code&gt;PAGE_SIZE&lt;/code&gt; 를 정의해준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- a/tools/src/perl-5.8.8/ext/IPC/SysV/SysV.xs
+++ b/tools/src/perl-5.8.8/ext/IPC/SysV/SysV.xs
@@ -4,7 +4,7 @@

 #include &amp;lt;sys/types.h&amp;gt;
 #ifdef __linux__
-#   include &amp;lt;asm/page.h&amp;gt;
+#define PAGE_SIZE      4096
 #endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;you-haven-t-done-a-make-depend-yet&#34;&gt;You haven&amp;rsquo;t done a &amp;ldquo;make depend&amp;rdquo; yet!&lt;/h2&gt;

&lt;p&gt;이어서 다음 에러 메세지가 나옵니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;You haven&#39;t done a &amp;quot;make depend&amp;quot; yet!
make[1]: *** [hash.o] Error 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;perl&lt;/code&gt; 빌드 중 사용되는 &lt;code&gt;/bin/sh&lt;/code&gt; 은 &lt;code&gt;/bin/dash&lt;/code&gt; 를 가리키고 있는데, &lt;code&gt;dash&lt;/code&gt;
에서 생기는 문제입니다.  다음과 같이 심볼릭 링크를 수정해 &lt;code&gt;bin/sh&lt;/code&gt; 이 &lt;code&gt;bash&lt;/code&gt; 를
가리키도록 하면 문제는 해결됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rm /bin/sh
$ sudo ln -s /bin/bash /bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;시스템을 원래대로 돌리고 싶다면 빌드 끝나고 나중에 심볼릭 링크를 되돌리면
됩니다.&lt;/p&gt;

&lt;h2 id=&#34;perl-test-fail&#34;&gt;&lt;code&gt;perl&lt;/code&gt; test fail&lt;/h2&gt;

&lt;p&gt;위의 해결책을 모두 적용하고 &lt;code&gt;$ PERLFLAGS=&amp;quot;-A libs=-lm -A libs=-ldl&amp;quot;
./buildtools&lt;/code&gt; 를 수행하면 perl 쪽의 테스트 약 900개 가운데 9개 정도 fail 나는
문제가 있긴 하지만 이건 무시하겠다고 하면 무시가 되고 빌드 진행이 됩니다.
테스트 9개가 fail 났는데 무시하겠냐는 질문이 아래와 같이 뜨는데, 무시하겠다고
답해줍시다 (해당 프롬프트에서 설명하는대로, &lt;code&gt;y&lt;/code&gt; 를 입력하면 됩니다).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Failed 9 test scripts out of 907, 99.01% okay.
### Since not all tests were successful, you may want to run some of
### them individually and examine any diagnostic messages they produce.
### See the INSTALL document&#39;s section on &amp;quot;make test&amp;quot;.
### You have a good chance to get more information by running
###   ./perl harness
### in the &#39;t&#39; directory since most (&amp;gt;=80%) of the tests succeeded.
### You may have to set your dynamic library search path,
### LD_LIBRARY_PATH, to point to the build directory:
###   setenv LD_LIBRARY_PATH `pwd`:$LD_LIBRARY_PATH; cd t; ./perl harness
###   LD_LIBRARY_PATH=`pwd`:$LD_LIBRARY_PATH; export LD_LIBRARY_PATH; cd t; ./perl harness
###   export LD_LIBRARY_PATH=`pwd`:$LD_LIBRARY_PATH; cd t; ./perl harness
### for csh-style shells, like tcsh; or for traditional/modern
### Bourne-style shells, like bash, ksh, and zsh, respectively.
u=0.92  s=0.69  cu=89.23  cs=5.47  scripts=907  tests=112394
make[2]: *** [_test_tty] Error 1
make[2]: Leaving directory `/home/sjpark/benchmarks/spec/SPEC_CPU2006v1.1/tools/src/perl-5.8.8&#39;
make[1]: *** [_test] Error 2
make[1]: Leaving directory `/home/sjpark/benchmarks/spec/SPEC_CPU2006v1.1/tools/src/perl-5.8.8&#39;
make: *** [test] Error 2
+ &#39;[&#39; 2 -ne 0 &#39;]&#39;
+ set +x


Hey!  Some of the Perl tests failed!  If you think this is okay, enter y now:
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-success&#34;&gt;Build success&lt;/h2&gt;

&lt;p&gt;여기까지 오면 이제 빌드가 완료됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tools built successfully.  Go to the top of the tree and
source the shrc file.  Then you should be ready.
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;SPEC CPU 2006 을 Ubuntu 16.04 에 설치하는 과정을 알아봤습니다.  다음 글에서는
SPEC CPU 벤치마크를 실행해 보는 방법을 설명합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;[0] &lt;a href=&#34;http://spec.org/&#34;&gt;http://spec.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://spec.org/benchmarks.html#cpu&#34;&gt;http://spec.org/benchmarks.html#cpu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;http://spec.org/order.html&#34;&gt;http://spec.org/order.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] &lt;a href=&#34;https://wiki.linaro.org/MichaelHope/Sandbox/BuildingSPECTools&#34;&gt;https://wiki.linaro.org/MichaelHope/Sandbox/BuildingSPECTools&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Updating Google Chrome on Fedora 23</title>
      <link>https://sjp38.github.io/post/fedora-chrome-update/</link>
      <pubDate>Mon, 20 Mar 2017 22:24:26 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/fedora-chrome-update/</guid>
      <description>&lt;p&gt;I am using Fedora 23 laptop and installed stable version Google Chrome from its
official website [0].  In this case, just using &lt;code&gt;Updates&lt;/code&gt; of Fedora &lt;code&gt;Software&lt;/code&gt;
program doesn&amp;rsquo;t update Chrome automatically.  For the case, follow below
commands to update your Chrome:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo dnf update google-chrome-stable
...
$ sudo killall chrome
$ google-chrome-stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second &lt;code&gt;killall&lt;/code&gt; command is necessary because Chrome doesn&amp;rsquo;t kill its
process by just cliking &lt;code&gt;Close&lt;/code&gt; button.  Or, you may reboot your computer but
you wouldn&amp;rsquo;t like that.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;랩톱에 Fedora 23 을 깔고 크롬을 공식 홈페이지 [0] 에서 다운받아 메인 브라우저로
사용하고 있습니다.  그런데 이렇게 설치한 경우에는 단순히 Fedora &lt;code&gt;Software&lt;/code&gt;
프로그램의 &lt;code&gt;Updates&lt;/code&gt; 기능을 통해 업데이트가 되지 않더군요.  이런 경우에는
다음의 커맨드를 통해 직접 업데이트를 할 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo dnf update google-chrome-stable
...
$ sudo killall chrome
$ google-chrome-stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두번째의 &lt;code&gt;killall&lt;/code&gt; 커맨드는 Chrome 프로세스들이 &lt;code&gt;닫기&lt;/code&gt; 버튼을 누르는 것만으로는
모두 종료되지 않기 때문에 명시적으로 종료시키기 위해 필요합니다.  컴퓨터를 아예
리붓 하는 방법도 있겠지만 별로 그러고 싶지는 않을테지요.  이후에 크롬을 다시
시작하면 업데이트된 버전으로 시작됩니다.&lt;/p&gt;

&lt;p&gt;[0] &lt;a href=&#34;https://www.google.com/chrome/browser/desktop/index.html?brand=CHBD&amp;amp;gclid=CKiMjdqX5dICFYcGKgodqZIM2Q&#34;&gt;https://www.google.com/chrome/browser/desktop/index.html?brand=CHBD&amp;amp;gclid=CKiMjdqX5dICFYcGKgodqZIM2Q&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using arping to know ip-MAC mapping</title>
      <link>https://sjp38.github.io/post/arping-howto/</link>
      <pubDate>Tue, 07 Mar 2017 19:41:16 +0900</pubDate>
      <author>sj38.park@gmail.com (SeongJae Park)</author>
      <guid>https://sjp38.github.io/post/arping-howto/</guid>
      <description>&lt;p&gt;You can use &lt;code&gt;arping&lt;/code&gt; to know IP address to MAC address mapping of your local
network.  Usage is simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arping  [-AbDfhqUV]  [-c count] [-w deadline] [-s source] -I interface destination
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, you may use the command as below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arping -I eth0 10.0.0.1
ARPING 10.0.0.1 from 10.0.0.2 eth0
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.123ms
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.251ms
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Secret of the tool is ARP protocol [1].  To know the MAC address of the machine
that has a specific IP address, IP protocol layer uses the protocol.  MAC
address that found in this way can be used to communicate with Ethernet
protocol layer.  &lt;code&gt;arping&lt;/code&gt; just sends the ARP REQUEST to local network
neighbour.&lt;/p&gt;

&lt;p&gt;It could be useful in case of internet connection problem if IP duplication is
suspicious.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;로컬 네트워크에서 어떤 IP 주소가 어떤 MAC 어드레스에 매핑되는지 알기 위해
&lt;code&gt;arping&lt;/code&gt; 을 사용할 수 있습니다. 사용법은 간단합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arping  [-AbDfhqUV]  [-c count] [-w deadline] [-s source] -I interface destination
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들면, 다음과 같습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arping -I eth0 10.0.0.1
ARPING 10.0.0.1 from 10.0.0.2 eth0
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.123ms
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.251ms
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 툴의 동작 원리는 ARP 프로토콜 [1] 입니다.  IP 프로토콜 레이어는 이
프로토콜을 사용해 특정 IP 주소를 사용하는 기계의 MAC 어드레스를 파악하고 이
주소를 아랫단의 Ethernet 레이어에 보냅니다.  &lt;code&gt;arping&lt;/code&gt; 은 단지 ARP REQUEST 를
로컬 네트워크의 컴퓨터들에게 보내는 일을 합니다.&lt;/p&gt;

&lt;p&gt;인터넷 연결 문제가 발생했을 때, IP 중복이 의심된다면 유용하게 사용될 수
있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html&#34;&gt;http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>