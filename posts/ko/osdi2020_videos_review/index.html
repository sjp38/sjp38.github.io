<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OSDI 2020 발표 영상 감상 | hacklog</title>
<meta name=keywords content="osdi,osdi20,paper"><meta name=description content="차일 피일 미루고 있던 OSDI'20 발표 영상 비디오를 휴가 기간동안 하루 한편이라도 보기로 했습니다.
A large scale analysis of hundreds of in-memory cache clusters at Twitter https://www.youtube.com/watch?v=OQtMM5vdhlI&amp;feature=emb_title
트위터의 in-memory 캐시 시스템의 워크로드를 트레이스하고 그 특성을 분석한 논문입니다. 개인적으로 아래 내용이 흥미로웠습니다.
쓰기 리퀘스트가 많음. 각 오브젝트의 크기는 작아서 (중간값이 200 바이트), 오브젝트별 메타데이터 (64 바이트) 가 공간을 많이 차지함. 키의 크기가 밸류의 크기보다 그렇게 작지 않음. 트레이스 데이터는 github[1] 통해 받을 수 있습니다."><meta name=author content="Me"><link rel=canonical href=https://sjp38.github.io/posts/ko/osdi2020_videos_review/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sjp38.github.io/posts/ko/osdi2020_videos_review/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="OSDI 2020 발표 영상 감상"><meta property="og:description" content="차일 피일 미루고 있던 OSDI'20 발표 영상 비디오를 휴가 기간동안 하루 한편이라도 보기로 했습니다.
A large scale analysis of hundreds of in-memory cache clusters at Twitter https://www.youtube.com/watch?v=OQtMM5vdhlI&amp;feature=emb_title
트위터의 in-memory 캐시 시스템의 워크로드를 트레이스하고 그 특성을 분석한 논문입니다. 개인적으로 아래 내용이 흥미로웠습니다.
쓰기 리퀘스트가 많음. 각 오브젝트의 크기는 작아서 (중간값이 200 바이트), 오브젝트별 메타데이터 (64 바이트) 가 공간을 많이 차지함. 키의 크기가 밸류의 크기보다 그렇게 작지 않음. 트레이스 데이터는 github[1] 통해 받을 수 있습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://sjp38.github.io/posts/ko/osdi2020_videos_review/"><meta property="og:image" content="https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-19T22:35:27+01:00"><meta property="article:modified_time" content="2020-12-19T22:35:27+01:00"><meta property="og:site_name" content="hacklog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="OSDI 2020 발표 영상 감상"><meta name=twitter:description content="차일 피일 미루고 있던 OSDI'20 발표 영상 비디오를 휴가 기간동안 하루 한편이라도 보기로 했습니다.
A large scale analysis of hundreds of in-memory cache clusters at Twitter https://www.youtube.com/watch?v=OQtMM5vdhlI&amp;feature=emb_title
트위터의 in-memory 캐시 시스템의 워크로드를 트레이스하고 그 특성을 분석한 논문입니다. 개인적으로 아래 내용이 흥미로웠습니다.
쓰기 리퀘스트가 많음. 각 오브젝트의 크기는 작아서 (중간값이 200 바이트), 오브젝트별 메타데이터 (64 바이트) 가 공간을 많이 차지함. 키의 크기가 밸류의 크기보다 그렇게 작지 않음. 트레이스 데이터는 github[1] 통해 받을 수 있습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sjp38.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Posts","item":"https://sjp38.github.io/posts/ko/"},{"@type":"ListItem","position":3,"name":"OSDI 2020 발표 영상 감상","item":"https://sjp38.github.io/posts/ko/osdi2020_videos_review/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OSDI 2020 발표 영상 감상","name":"OSDI 2020 발표 영상 감상","description":"차일 피일 미루고 있던 OSDI'20 발표 영상 비디오를 휴가 기간동안 하루 한편이라도 보기로 했습니다.\nA large scale analysis of hundreds of in-memory cache clusters at Twitter https://www.youtube.com/watch?v=OQtMM5vdhlI\u0026amp;feature=emb_title\n트위터의 in-memory 캐시 시스템의 워크로드를 트레이스하고 그 특성을 분석한 논문입니다. 개인적으로 아래 내용이 흥미로웠습니다.\n쓰기 리퀘스트가 많음. 각 오브젝트의 크기는 작아서 (중간값이 200 바이트), 오브젝트별 메타데이터 (64 바이트) 가 공간을 많이 차지함. 키의 크기가 밸류의 크기보다 그렇게 작지 않음. 트레이스 데이터는 github[1] 통해 받을 수 있습니다.","keywords":["osdi","osdi20","paper"],"articleBody":"차일 피일 미루고 있던 OSDI'20 발표 영상 비디오를 휴가 기간동안 하루 한편이라도 보기로 했습니다.\nA large scale analysis of hundreds of in-memory cache clusters at Twitter https://www.youtube.com/watch?v=OQtMM5vdhlI\u0026feature=emb_title\n트위터의 in-memory 캐시 시스템의 워크로드를 트레이스하고 그 특성을 분석한 논문입니다. 개인적으로 아래 내용이 흥미로웠습니다.\n쓰기 리퀘스트가 많음. 각 오브젝트의 크기는 작아서 (중간값이 200 바이트), 오브젝트별 메타데이터 (64 바이트) 가 공간을 많이 차지함. 키의 크기가 밸류의 크기보다 그렇게 작지 않음. 트레이스 데이터는 github[1] 통해 받을 수 있습니다. 압축해도 2.8TB, 압출 풀면 14TB 군요.\n[1] https://github.com/twitter/cache-trace\nAIFM: High-Performance, Application-Integrated Far Memory https://www.youtube.com/watch?v=xHhaniGXTUg\u0026feature=emb_title\nOS 수준에서의 fast network 기반 far memory 접근법은 어플리케이션의 수정이 필요없다는 장점을 갖지만 고정된 크기의 페이지 abstraction 에 따른 semantic 차이와 어플리케이션에 대한 지식이 없는 커널에서의 주요 오퍼레이션 수행으로 인해 성능이 떨어집니다. AIFM 은 새로운 데이터 구조 abstraction 을 사용해 semantic 차이를 해결하고 user space 런타임 시스템을 사용해 kernel space 에서의 시간 낭비를 제거했습니다. 결과적으로 어플리케이션은 수정이 필요하지만 저자들은 약간의 수정일 뿐이라 주자합니다. 또다른 state-of-the-art (FastSwap, EuroSys'20) 대비 13배 성능 향상을 이뤘다는군요.\nLinnOS: Predictability on Unpredictable Flash Storage with a Light Neural Network https://www.youtube.com/watch?v=yzv9lcjxhAg\u0026feature=emb_title\n최신 고속 저장장치는 캐싱, 웨어레벨링, 가비지 콜렉션 등의 복잡한 내부 구조를 가지고 있어서, 각 I/O 에 대한 응답시간을 예측하기가 어렵습니다. 이에 대한 잘 알려진 해결책은 Hedging 입니다. 여러 SSD 를 준비해 두고, I/O 요청을 그 중 하나의 SSD 에 일단 던지고, 그 응답이 미리 지정된 한계치를 넘도록 돌아오지 않으면 해당 요청을 취소하고 다른 SSD 를 쓰는 것이죠. 한계치 만큼은 기다려야 한다는 게 약점입니다. LinnOS 는 Hedging 과 유사하지만 각 SSD 로의 각 I/O 가 빠르게 처리될지 예측하는 신경망을 이용합니다. 이를 위해, 해당 신경망은 현재 I/O queue depth, 최근의 몇개 I/O 시 queue depth 와 latency 를 입력으로 받고 그 결과 레이턴시가 빠를지 느릴지만 예측합니다. 잘못된 예측으로 인한 문제를 처리하기 위해선 biased learning 과 예측 정확도에 따른 adaptive hedging 을 사용합니다. 신경망의 학습은 오프라인으로 이루어집니다.\nDo OS abstractions make sense on FPGAs? https://www.youtube.com/watch?v=k-cp4U3JKug\u0026feature=emb_title\nHeterogeneous computing system 이라고도 불리는, FPGA 를 내장한 컴퓨터 시스템이 널리 사용되고 있습니다. 이런 시스템에는 운영 복잡성이 높게 마련이며, 특히 FPGA 용 어플리케이션의 개발과 배포가 복잡합니다. 때문에 FPGA 관리를 위해 운영체제의 추상화 개념이 일부 사용되고 있습니다. 저자는 Coyote 라고 하는, 운영체제의 일반적 추상화 개념을 모두 지원하는 FPGA 관리 도구를 만들어 운영체제 추상화 개념이 FPGA 에 잘 적용되는지 실험했고, 그에 대한 긍정적 결과를 얻었습니다.\nFast RDMA-based Ordered Key-Value Store using Remote Learned Cache https://www.youtube.com/watch?v=Qv-0YL_SII4\u0026feature=emb_title\n서버 중심적 key-value store (KVS) 는 서버의 CPU 에 성능이 제한되므로, RDMA 기반의 방법들이 제안되어왔습니다. 한번의 RDMA 에 한번의 RTT 가 소요되므로, 이 방법은 여러번 네트워크 순회를 해야 하는 문제가 있어 성능이 떨어지는 문제가 있습니다. 인덱스를 클라이언트 내에 캐시해 두는 해결책도 있습니다만, 클라이언트의 메모리 사용량을 급격하게 늘린다는 문제가 있습니다. 이 논문의 저자들은 신경망을 인덱스로 사용하자는 제안을 합니다. 키를 입력으로 받아 밸류의 주소를 내놓는 신경망을 서버 측에서 학습시키고, 전체 인덱스에 비해 훨씬 작은 이 신경망을 클라이언트로 전송, 각 클라이언트가 이 신경망을 캐시로 사용해 밸류의 서버내 주소를 알아내고, RDMA 로 한번에 밸류를 얻어오는 방법입니다.\nA Simpler and Faster NIC Driver Model for Network Functions https://www.youtube.com/watch?v=zKJIY4vbBDA\u0026feature=emb_title\nBridge, router, firewall 등의 기능을 소프트웨어로 구현하려는 software-defined network 방식이 널리 사용되고 있습니다. 이 과정에서 성능과 유연성을 위해 소프트웨어 복잡도를 높이는 경향이 있었습니다. 결과, software-defined network stack 의 안정성을 검증하기도 어려워졌습니다. 저자팀은 약간의 유연성을 희생함으로써 단순하면서 성능 높은 network stack 구현이 가능함을 주장하며, 자신들의 새로운 네트워크 드라이버 모델, tinynf 로 이를 증명합니다. 이 드라이버 모델을 바탕으로 구현된 Intel 82599 드라이버는 550줄밖에 안되는 코드로 기존 state-of-the-art 드라이버보다 7배 빨리 formal verification 을 마칠 수 있었고, 성능 역시 1.6배 높았습니다.\nTheseus: an experiment in operating system structure and state management https://www.youtube.com/watch?v=i1pLDZKtlBI\n이 논문에서 저자들은 Theseus 라는 이름의, state spill 문제를 해결할 수 있도록 설계된 운영체제를 선보입니다. 해당 문제의 해결을 위해 ‘cell’ 이라 불리는 다수의 작은 컴포넌트로 운영체제를 구성시켰으며, Rust 와 같은 언어 수준에서의 안전성 보장 메커니즘들을 운영체제 단계에 적용시켰습니다.\nSpecification and verification in the field: Applying formal methods to BPF just-in-time compilers in the Linux kernel https://www.youtube.com/watch?v=2V3ts5-W_9g\u0026feature=emb_title\nBPF 프로그램은 수행되기 전에 검증되지만, 그 검증 이후에 JIT 를 통해 컴파일 된 후에 수행됩니다. 따라서, JIT 에 버그가 있다면 문제가 생길 수 있습니다. 이 논문의 저자들은 JIT 의 정확성 명세 프레임웍, jitterbug 를 사용해 RISC-V 를 위한 새로운 BPF JIT 를 개발했습니다. 이 과정에서 만들어진 커널 변경사항은 메인라인 리눅스 커널에 머지되었습니다.\nStorage Systems are Distributed Systems (So Verify Them That Way!) https://www.youtube.com/watch?v=4s8EeXcu_8Y\u0026feature=emb_title\n스토리지 시스템도 높은 복잡도를 갖기에 기계적으로 검증을 하기 까다롭습니다. 이 논문의 저자들은 그런 스토리지 시스템의 구조가 분산 시스템과 비슷한 측면이 있음을 발견하고 분산 시스템의 기계적 검증을 위해 제안된 방법을 보다 범용화 해서 스토리지 시스템에 적용합니다. 이를 바탕으로 저자팀은 VeriSafeKV 라는 검증 가능한 key-value storage 를 만들었습니다. VeriSafeKV 는 검증이 되지 않는 DB 들과 비슷한 수준의 성능을 보였습니다.\nCaladan: Mitigating Interference at Microsecond Timescales https://www.youtube.com/watch?v=G-v3ndwixOI\u0026feature=emb_title\n시스템 상에는 서로 다른 요구사항을 가진 워크로드들이 함께 스케쥴링 됩니다. 예를 들어, 어떤 워크로드는 최선의 리소스만 주어지면 되지만 어떤 것들은 tail latency 에 민감하죠. 워크로드들이 LLC 나 memory bandwidth 같은 하드웨어 리소스를 공유하므로, 모든 요구사항을 지켜주기가 어렵습니다. 이에 대한 잘 알려진 해결책은 리소스 파티셔닝입니다. 하지만 정적 파티셔닝은 리소스 사용률을 낮출 수 있기 때문에 동적 파티셔닝이 제안되어왔습니다. 하지만 저자들의 주장에 따르면 tail latency 문제를 위해선 100 마이크로세컨드 내에 동적 파티셔닝이 이루어져야 하는데 기존 해결책들은 그정도로 빠르지 않습니다. 때문에 저자들은 간섭을 알아채기 위해 다른 시그널을 사용하면서 시스템 전체를 마이크로세컨드 레벨로 재설계 했습니다.\nSemeru: A Memory-Disaggregated Managed Runtime https://www.youtube.com/watch?v=MFA3MmNDKaM\u0026feature=emb_title\nCPU 작업과 메모리 작업들 같이 다른 일을 위한 분산된 기계들을 가지고 시스템을 구축하는 resource-disaggregated 아키텍쳐가 널리 사용되어가고 있습니다. 하지만, 이 구조는 보통 native 어플리케이션을 위해 만들어졌지, GC 기반 어플리케이션을 위해 만들어지진 않았습니다. 이 논문은 resource-disaggregation 구조를 위해 설계된 JVM, Semeru 를 소개합니다.\nPANIC: A High-Performance Programmable NIC for Multi-tenant Networks https://www.youtube.com/watch?v=EB6dK3L8Jzg\u0026feature=emb_title\nMulti-tenant 네트웍은 programmable NIC 에게 범용성, 유연한 chaining, isolation, 그리고 성능을 요구합니다. 하지만 현재의 programmable NIC 들은 그걸 제공하지 않고 있죠. 이 논문의 저자들은 이를 위한 새로운 programmable NIC 설계를 제안하고 PANIC 이라는 이름의 FPGA 기반 구현을 소개합니다.\nServing DNNs like Clockwork: Performance Predictability from the Bottom Up https://www.youtube.com/watch?v=wHOpY_MY57Y\u0026feature=emb_title\n오늘날 데이터 센터는 수많은 머신러닝 모델을 다른 사용자들을 위해 수행해 주고 있습니다. 각각의 인퍼런스는 조건적 실행 분기문 같은게 없으므로 그 응답시간을 쉽게 예측 가능합니다만 모델 서빙 시스템 자체의 복잡도로 인해 끝단 사이의 응답시간을 예측 불가능하게 만들고 있습니다. 이 논문은 이 문제를 해결하기 위해 응답시간을 고려해 재설계된 머신러닝 모델 서빙 스케쥴러 시스템을 소개합니다.\nTeting Configuration Changes in Context to Prevent Production Failures https://www.youtube.com/watch?v=QrGKmp3ALKQ\u0026feature=emb_title\n이 논문은 ‘ctest’ 라는, 제품 환경에서의 설정 변경이 옳은지 검증할 수 있는 테스트 프레임웍을 제안합니다. 형태는 Junit 등의 다른 테스트 프레임웍과 비슷합니다.\n","wordCount":"1031","inLanguage":"en","image":"https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2020-12-19T22:35:27+01:00","dateModified":"2020-12-19T22:35:27+01:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sjp38.github.io/posts/ko/osdi2020_videos_review/"},"publisher":{"@type":"Organization","name":"hacklog","logo":{"@type":"ImageObject","url":"https://sjp38.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sjp38.github.io/ accesskey=h title="hacklog (Alt + H)"><img src=https://sjp38.github.io/apple-touch-icon.png alt aria-label=logo height=35>hacklog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sjp38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://sjp38.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sjp38.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://sjp38.github.io/files/resume_sjpark.pdf title=cv><span>cv</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sjp38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sjp38.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://sjp38.github.io/posts/ko/>Posts</a></div><h1 class="post-title entry-hint-parent">OSDI 2020 발표 영상 감상</h1><div class=post-meta><span title='2020-12-19 22:35:27 +0100 +0100'>December 19, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1031 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/ko/osdi2020_videos_review.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#a-large-scale-analysis-of-hundreds-of-in-memory-cache-clusters-at-twitter>A large scale analysis of hundreds of in-memory cache clusters at Twitter</a></li><li><a href=#aifm-high-performance-application-integrated-far-memory>AIFM: High-Performance, Application-Integrated Far Memory</a></li><li><a href=#linnos-predictability-on-unpredictable-flash-storage-with-a-light-neural-network>LinnOS: Predictability on Unpredictable Flash Storage with a Light Neural Network</a></li><li><a href=#do-os-abstractions-make-sense-on-fpgas>Do OS abstractions make sense on FPGAs?</a></li><li><a href=#fast-rdma-based-ordered-key-value-store-using-remote-learned-cache>Fast RDMA-based Ordered Key-Value Store using Remote Learned Cache</a></li><li><a href=#a-simpler-and-faster-nic-driver-model-for-network-functions>A Simpler and Faster NIC Driver Model for Network Functions</a></li><li><a href=#theseus-an-experiment-in-operating-system-structure-and-state-management>Theseus: an experiment in operating system structure and state management</a></li><li><a href=#specification-and-verification-in-the-field-applying-formal-methods-to-bpf-just-in-time-compilers-in-the-linux-kernel>Specification and verification in the field: Applying formal methods to BPF just-in-time compilers in the Linux kernel</a></li><li><a href=#storage-systems-are-distributed-systems-so-verify-them-that-way>Storage Systems are Distributed Systems (So Verify Them That Way!)</a></li><li><a href=#caladan-mitigating-interference-at-microsecond-timescales>Caladan: Mitigating Interference at Microsecond Timescales</a></li><li><a href=#semeru-a-memory-disaggregated-managed-runtime>Semeru: A Memory-Disaggregated Managed Runtime</a></li><li><a href=#panic-a-high-performance-programmable-nic-for-multi-tenant-networks>PANIC: A High-Performance Programmable NIC for Multi-tenant Networks</a></li><li><a href=#serving-dnns-like-clockwork-performance-predictability-from-the-bottom-up>Serving DNNs like Clockwork: Performance Predictability from the Bottom Up</a></li><li><a href=#teting-configuration-changes-in-context-to-prevent-production-failures>Teting Configuration Changes in Context to Prevent Production Failures</a></li></ul></nav></div></details></div><div class=post-content><p>차일 피일 미루고 있던 OSDI'20 발표 영상 비디오를 휴가 기간동안 하루 한편이라도
보기로 했습니다.</p><hr><h2 id=a-large-scale-analysis-of-hundreds-of-in-memory-cache-clusters-at-twitter>A large scale analysis of hundreds of in-memory cache clusters at Twitter<a hidden class=anchor aria-hidden=true href=#a-large-scale-analysis-of-hundreds-of-in-memory-cache-clusters-at-twitter>#</a></h2><p><a href="https://www.youtube.com/watch?v=OQtMM5vdhlI&amp;feature=emb_title">https://www.youtube.com/watch?v=OQtMM5vdhlI&amp;feature=emb_title</a></p><p>트위터의 in-memory 캐시 시스템의 워크로드를 트레이스하고 그 특성을 분석한
논문입니다. 개인적으로 아래 내용이 흥미로웠습니다.</p><ul><li>쓰기 리퀘스트가 많음.</li><li>각 오브젝트의 크기는 작아서 (중간값이 200 바이트), 오브젝트별 메타데이터 (64
바이트) 가 공간을 많이 차지함.</li><li>키의 크기가 밸류의 크기보다 그렇게 작지 않음.</li></ul><p>트레이스 데이터는 github[1] 통해 받을 수 있습니다. 압축해도 2.8TB, 압출 풀면
14TB 군요.</p><p>[1] <a href=https://github.com/twitter/cache-trace>https://github.com/twitter/cache-trace</a></p><h2 id=aifm-high-performance-application-integrated-far-memory>AIFM: High-Performance, Application-Integrated Far Memory<a hidden class=anchor aria-hidden=true href=#aifm-high-performance-application-integrated-far-memory>#</a></h2><p><a href="https://www.youtube.com/watch?v=xHhaniGXTUg&amp;feature=emb_title">https://www.youtube.com/watch?v=xHhaniGXTUg&amp;feature=emb_title</a></p><p>OS 수준에서의 fast network 기반 far memory 접근법은 어플리케이션의 수정이
필요없다는 장점을 갖지만 고정된 크기의 페이지 abstraction 에 따른 semantic
차이와 어플리케이션에 대한 지식이 없는 커널에서의 주요 오퍼레이션 수행으로 인해
성능이 떨어집니다. AIFM 은 새로운 데이터 구조 abstraction 을 사용해 semantic
차이를 해결하고 user space 런타임 시스템을 사용해 kernel space 에서의 시간
낭비를 제거했습니다. 결과적으로 어플리케이션은 수정이 필요하지만 저자들은
약간의 수정일 뿐이라 주자합니다. 또다른 state-of-the-art (FastSwap,
EuroSys'20) 대비 13배 성능 향상을 이뤘다는군요.</p><h2 id=linnos-predictability-on-unpredictable-flash-storage-with-a-light-neural-network>LinnOS: Predictability on Unpredictable Flash Storage with a Light Neural Network<a hidden class=anchor aria-hidden=true href=#linnos-predictability-on-unpredictable-flash-storage-with-a-light-neural-network>#</a></h2><p><a href="https://www.youtube.com/watch?v=yzv9lcjxhAg&amp;feature=emb_title">https://www.youtube.com/watch?v=yzv9lcjxhAg&amp;feature=emb_title</a></p><p>최신 고속 저장장치는 캐싱, 웨어레벨링, 가비지 콜렉션 등의 복잡한 내부 구조를
가지고 있어서, 각 I/O 에 대한 응답시간을 예측하기가 어렵습니다. 이에 대한 잘
알려진 해결책은 Hedging 입니다. 여러 SSD 를 준비해 두고, I/O 요청을 그 중
하나의 SSD 에 일단 던지고, 그 응답이 미리 지정된 한계치를 넘도록 돌아오지
않으면 해당 요청을 취소하고 다른 SSD 를 쓰는 것이죠. 한계치 만큼은 기다려야
한다는 게 약점입니다. LinnOS 는 Hedging 과 유사하지만 각 SSD 로의 각 I/O 가
빠르게 처리될지 예측하는 신경망을 이용합니다. 이를 위해, 해당 신경망은 현재
I/O queue depth, 최근의 몇개 I/O 시 queue depth 와 latency 를 입력으로 받고 그
결과 레이턴시가 빠를지 느릴지만 예측합니다. 잘못된 예측으로 인한 문제를
처리하기 위해선 biased learning 과 예측 정확도에 따른 adaptive hedging 을
사용합니다. 신경망의 학습은 오프라인으로 이루어집니다.</p><h2 id=do-os-abstractions-make-sense-on-fpgas>Do OS abstractions make sense on FPGAs?<a hidden class=anchor aria-hidden=true href=#do-os-abstractions-make-sense-on-fpgas>#</a></h2><p><a href="https://www.youtube.com/watch?v=k-cp4U3JKug&amp;feature=emb_title">https://www.youtube.com/watch?v=k-cp4U3JKug&amp;feature=emb_title</a></p><p>Heterogeneous computing system 이라고도 불리는, FPGA 를 내장한 컴퓨터 시스템이
널리 사용되고 있습니다. 이런 시스템에는 운영 복잡성이 높게 마련이며, 특히 FPGA
용 어플리케이션의 개발과 배포가 복잡합니다. 때문에 FPGA 관리를 위해 운영체제의
추상화 개념이 일부 사용되고 있습니다. 저자는 Coyote 라고 하는, 운영체제의
일반적 추상화 개념을 모두 지원하는 FPGA 관리 도구를 만들어 운영체제 추상화
개념이 FPGA 에 잘 적용되는지 실험했고, 그에 대한 긍정적 결과를 얻었습니다.</p><h2 id=fast-rdma-based-ordered-key-value-store-using-remote-learned-cache>Fast RDMA-based Ordered Key-Value Store using Remote Learned Cache<a hidden class=anchor aria-hidden=true href=#fast-rdma-based-ordered-key-value-store-using-remote-learned-cache>#</a></h2><p><a href="https://www.youtube.com/watch?v=Qv-0YL_SII4&amp;feature=emb_title">https://www.youtube.com/watch?v=Qv-0YL_SII4&amp;feature=emb_title</a></p><p>서버 중심적 key-value store (KVS) 는 서버의 CPU 에 성능이 제한되므로, RDMA
기반의 방법들이 제안되어왔습니다. 한번의 RDMA 에 한번의 RTT 가 소요되므로, 이
방법은 여러번 네트워크 순회를 해야 하는 문제가 있어 성능이 떨어지는 문제가
있습니다. 인덱스를 클라이언트 내에 캐시해 두는 해결책도 있습니다만,
클라이언트의 메모리 사용량을 급격하게 늘린다는 문제가 있습니다. 이 논문의
저자들은 신경망을 인덱스로 사용하자는 제안을 합니다. 키를 입력으로 받아 밸류의
주소를 내놓는 신경망을 서버 측에서 학습시키고, 전체 인덱스에 비해 훨씬 작은 이
신경망을 클라이언트로 전송, 각 클라이언트가 이 신경망을 캐시로 사용해 밸류의
서버내 주소를 알아내고, RDMA 로 한번에 밸류를 얻어오는 방법입니다.</p><h2 id=a-simpler-and-faster-nic-driver-model-for-network-functions>A Simpler and Faster NIC Driver Model for Network Functions<a hidden class=anchor aria-hidden=true href=#a-simpler-and-faster-nic-driver-model-for-network-functions>#</a></h2><p><a href="https://www.youtube.com/watch?v=zKJIY4vbBDA&amp;feature=emb_title">https://www.youtube.com/watch?v=zKJIY4vbBDA&amp;feature=emb_title</a></p><p>Bridge, router, firewall 등의 기능을 소프트웨어로 구현하려는 software-defined
network 방식이 널리 사용되고 있습니다. 이 과정에서 성능과 유연성을 위해
소프트웨어 복잡도를 높이는 경향이 있었습니다. 결과, software-defined network
stack 의 안정성을 검증하기도 어려워졌습니다. 저자팀은 약간의 유연성을
희생함으로써 단순하면서 성능 높은 network stack 구현이 가능함을 주장하며,
자신들의 새로운 네트워크 드라이버 모델, tinynf 로 이를 증명합니다. 이 드라이버
모델을 바탕으로 구현된 Intel 82599 드라이버는 550줄밖에 안되는 코드로 기존
state-of-the-art 드라이버보다 7배 빨리 formal verification 을 마칠 수 있었고,
성능 역시 1.6배 높았습니다.</p><h2 id=theseus-an-experiment-in-operating-system-structure-and-state-management>Theseus: an experiment in operating system structure and state management<a hidden class=anchor aria-hidden=true href=#theseus-an-experiment-in-operating-system-structure-and-state-management>#</a></h2><p><a href="https://www.youtube.com/watch?v=i1pLDZKtlBI">https://www.youtube.com/watch?v=i1pLDZKtlBI</a></p><p>이 논문에서 저자들은 Theseus 라는 이름의, state spill 문제를 해결할 수 있도록
설계된 운영체제를 선보입니다. 해당 문제의 해결을 위해 &lsquo;cell&rsquo; 이라 불리는
다수의 작은 컴포넌트로 운영체제를 구성시켰으며, Rust 와 같은 언어 수준에서의
안전성 보장 메커니즘들을 운영체제 단계에 적용시켰습니다.</p><h2 id=specification-and-verification-in-the-field-applying-formal-methods-to-bpf-just-in-time-compilers-in-the-linux-kernel>Specification and verification in the field: Applying formal methods to BPF just-in-time compilers in the Linux kernel<a hidden class=anchor aria-hidden=true href=#specification-and-verification-in-the-field-applying-formal-methods-to-bpf-just-in-time-compilers-in-the-linux-kernel>#</a></h2><p><a href="https://www.youtube.com/watch?v=2V3ts5-W_9g&amp;feature=emb_title">https://www.youtube.com/watch?v=2V3ts5-W_9g&amp;feature=emb_title</a></p><p>BPF 프로그램은 수행되기 전에 검증되지만, 그 검증 이후에 JIT 를 통해 컴파일 된
후에 수행됩니다. 따라서, JIT 에 버그가 있다면 문제가 생길 수 있습니다. 이
논문의 저자들은 JIT 의 정확성 명세 프레임웍, jitterbug 를 사용해 RISC-V 를 위한
새로운 BPF JIT 를 개발했습니다. 이 과정에서 만들어진 커널 변경사항은 메인라인
리눅스 커널에 머지되었습니다.</p><h2 id=storage-systems-are-distributed-systems-so-verify-them-that-way>Storage Systems are Distributed Systems (So Verify Them That Way!)<a hidden class=anchor aria-hidden=true href=#storage-systems-are-distributed-systems-so-verify-them-that-way>#</a></h2><p><a href="https://www.youtube.com/watch?v=4s8EeXcu_8Y&amp;feature=emb_title">https://www.youtube.com/watch?v=4s8EeXcu_8Y&amp;feature=emb_title</a></p><p>스토리지 시스템도 높은 복잡도를 갖기에 기계적으로 검증을 하기 까다롭습니다. 이
논문의 저자들은 그런 스토리지 시스템의 구조가 분산 시스템과 비슷한 측면이
있음을 발견하고 분산 시스템의 기계적 검증을 위해 제안된 방법을 보다 범용화 해서
스토리지 시스템에 적용합니다. 이를 바탕으로 저자팀은 VeriSafeKV 라는 검증
가능한 key-value storage 를 만들었습니다. VeriSafeKV 는 검증이 되지 않는 DB
들과 비슷한 수준의 성능을 보였습니다.</p><h2 id=caladan-mitigating-interference-at-microsecond-timescales>Caladan: Mitigating Interference at Microsecond Timescales<a hidden class=anchor aria-hidden=true href=#caladan-mitigating-interference-at-microsecond-timescales>#</a></h2><p><a href="https://www.youtube.com/watch?v=G-v3ndwixOI&amp;feature=emb_title">https://www.youtube.com/watch?v=G-v3ndwixOI&amp;feature=emb_title</a></p><p>시스템 상에는 서로 다른 요구사항을 가진 워크로드들이 함께 스케쥴링 됩니다.
예를 들어, 어떤 워크로드는 최선의 리소스만 주어지면 되지만 어떤 것들은 tail
latency 에 민감하죠. 워크로드들이 LLC 나 memory bandwidth 같은 하드웨어
리소스를 공유하므로, 모든 요구사항을 지켜주기가 어렵습니다. 이에 대한 잘
알려진 해결책은 리소스 파티셔닝입니다. 하지만 정적 파티셔닝은 리소스 사용률을
낮출 수 있기 때문에 동적 파티셔닝이 제안되어왔습니다. 하지만 저자들의 주장에
따르면 tail latency 문제를 위해선 100 마이크로세컨드 내에 동적 파티셔닝이
이루어져야 하는데 기존 해결책들은 그정도로 빠르지 않습니다. 때문에 저자들은
간섭을 알아채기 위해 다른 시그널을 사용하면서 시스템 전체를 마이크로세컨드
레벨로 재설계 했습니다.</p><h2 id=semeru-a-memory-disaggregated-managed-runtime>Semeru: A Memory-Disaggregated Managed Runtime<a hidden class=anchor aria-hidden=true href=#semeru-a-memory-disaggregated-managed-runtime>#</a></h2><p><a href="https://www.youtube.com/watch?v=MFA3MmNDKaM&amp;feature=emb_title">https://www.youtube.com/watch?v=MFA3MmNDKaM&amp;feature=emb_title</a></p><p>CPU 작업과 메모리 작업들 같이 다른 일을 위한 분산된 기계들을 가지고 시스템을
구축하는 resource-disaggregated 아키텍쳐가 널리 사용되어가고 있습니다. 하지만,
이 구조는 보통 native 어플리케이션을 위해 만들어졌지, GC 기반 어플리케이션을
위해 만들어지진 않았습니다. 이 논문은 resource-disaggregation 구조를 위해
설계된 JVM, Semeru 를 소개합니다.</p><h2 id=panic-a-high-performance-programmable-nic-for-multi-tenant-networks>PANIC: A High-Performance Programmable NIC for Multi-tenant Networks<a hidden class=anchor aria-hidden=true href=#panic-a-high-performance-programmable-nic-for-multi-tenant-networks>#</a></h2><p><a href="https://www.youtube.com/watch?v=EB6dK3L8Jzg&amp;feature=emb_title">https://www.youtube.com/watch?v=EB6dK3L8Jzg&amp;feature=emb_title</a></p><p>Multi-tenant 네트웍은 programmable NIC 에게 범용성, 유연한 chaining, isolation,
그리고 성능을 요구합니다. 하지만 현재의 programmable NIC 들은 그걸 제공하지
않고 있죠. 이 논문의 저자들은 이를 위한 새로운 programmable NIC 설계를
제안하고 PANIC 이라는 이름의 FPGA 기반 구현을 소개합니다.</p><h2 id=serving-dnns-like-clockwork-performance-predictability-from-the-bottom-up>Serving DNNs like Clockwork: Performance Predictability from the Bottom Up<a hidden class=anchor aria-hidden=true href=#serving-dnns-like-clockwork-performance-predictability-from-the-bottom-up>#</a></h2><p><a href="https://www.youtube.com/watch?v=wHOpY_MY57Y&amp;feature=emb_title">https://www.youtube.com/watch?v=wHOpY_MY57Y&amp;feature=emb_title</a></p><p>오늘날 데이터 센터는 수많은 머신러닝 모델을 다른 사용자들을 위해 수행해 주고
있습니다. 각각의 인퍼런스는 조건적 실행 분기문 같은게 없으므로 그 응답시간을
쉽게 예측 가능합니다만 모델 서빙 시스템 자체의 복잡도로 인해 끝단 사이의
응답시간을 예측 불가능하게 만들고 있습니다. 이 논문은 이 문제를 해결하기 위해
응답시간을 고려해 재설계된 머신러닝 모델 서빙 스케쥴러 시스템을 소개합니다.</p><h2 id=teting-configuration-changes-in-context-to-prevent-production-failures>Teting Configuration Changes in Context to Prevent Production Failures<a hidden class=anchor aria-hidden=true href=#teting-configuration-changes-in-context-to-prevent-production-failures>#</a></h2><p><a href="https://www.youtube.com/watch?v=QrGKmp3ALKQ&amp;feature=emb_title">https://www.youtube.com/watch?v=QrGKmp3ALKQ&amp;feature=emb_title</a></p><p>이 논문은 &lsquo;ctest&rsquo; 라는, 제품 환경에서의 설정 변경이 옳은지 검증할 수 있는
테스트 프레임웍을 제안합니다. 형태는 Junit 등의 다른 테스트 프레임웍과
비슷합니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sjp38.github.io/tags/osdi/>Osdi</a></li><li><a href=https://sjp38.github.io/tags/osdi20/>Osdi20</a></li><li><a href=https://sjp38.github.io/tags/paper/>Paper</a></li></ul><nav class=paginav><a class=prev href=https://sjp38.github.io/posts/en/lkml_news_v5.11-rc2/><span class=title>« Prev</span><br><span>LKML News v5.11-rc2</span>
</a><a class=next href=https://sjp38.github.io/posts/en/osdi2020_videos_review/><span class=title>Next »</span><br><span>Watching OSDI 2020 presentation videos</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share OSDI 2020 발표 영상 감상 on x" href="https://x.com/intent/tweet/?text=OSDI%202020%20%eb%b0%9c%ed%91%9c%20%ec%98%81%ec%83%81%20%ea%b0%90%ec%83%81&amp;url=https%3a%2f%2fsjp38.github.io%2fposts%2fko%2fosdi2020_videos_review%2f&amp;hashtags=osdi%2cosdi20%2cpaper"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OSDI 2020 발표 영상 감상 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsjp38.github.io%2fposts%2fko%2fosdi2020_videos_review%2f&amp;title=OSDI%202020%20%eb%b0%9c%ed%91%9c%20%ec%98%81%ec%83%81%20%ea%b0%90%ec%83%81&amp;summary=OSDI%202020%20%eb%b0%9c%ed%91%9c%20%ec%98%81%ec%83%81%20%ea%b0%90%ec%83%81&amp;source=https%3a%2f%2fsjp38.github.io%2fposts%2fko%2fosdi2020_videos_review%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OSDI 2020 발표 영상 감상 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsjp38.github.io%2fposts%2fko%2fosdi2020_videos_review%2f&title=OSDI%202020%20%eb%b0%9c%ed%91%9c%20%ec%98%81%ec%83%81%20%ea%b0%90%ec%83%81"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OSDI 2020 발표 영상 감상 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsjp38.github.io%2fposts%2fko%2fosdi2020_videos_review%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OSDI 2020 발표 영상 감상 on whatsapp" href="https://api.whatsapp.com/send?text=OSDI%202020%20%eb%b0%9c%ed%91%9c%20%ec%98%81%ec%83%81%20%ea%b0%90%ec%83%81%20-%20https%3a%2f%2fsjp38.github.io%2fposts%2fko%2fosdi2020_videos_review%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OSDI 2020 발표 영상 감상 on telegram" href="https://telegram.me/share/url?text=OSDI%202020%20%eb%b0%9c%ed%91%9c%20%ec%98%81%ec%83%81%20%ea%b0%90%ec%83%81&amp;url=https%3a%2f%2fsjp38.github.io%2fposts%2fko%2fosdi2020_videos_review%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share OSDI 2020 발표 영상 감상 on ycombinator" href="https://news.ycombinator.com/submitlink?t=OSDI%202020%20%eb%b0%9c%ed%91%9c%20%ec%98%81%ec%83%81%20%ea%b0%90%ec%83%81&u=https%3a%2f%2fsjp38.github.io%2fposts%2fko%2fosdi2020_videos_review%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sjp38.github.io/>hacklog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>