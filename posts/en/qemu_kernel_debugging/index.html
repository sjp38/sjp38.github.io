<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux Kernel Debugging Using QEMU | hacklog</title>
<meta name=keywords content="linux,kernel,tip,linux-kernel-hack"><meta name=description content="You can use classical debugger for your Linux kernel programming, though Torvalds doesn&rsquo;t like it. I also do not prefer such use of debuggers, but admit that sometimes debuggers are quite useful. ;)
There are several ways to debug Linux kernel, but one of above is to set up a Linux virtual machine using QEMU and debugging the Linux kernel of the virtual machine from the host machine. This post summarises how to debug the Linux kernel in this way."><meta name=author content="Me"><link rel=canonical href=https://sjp38.github.io/posts/en/qemu_kernel_debugging/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sjp38.github.io/posts/en/qemu_kernel_debugging/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Linux Kernel Debugging Using QEMU"><meta property="og:description" content="You can use classical debugger for your Linux kernel programming, though Torvalds doesn&rsquo;t like it. I also do not prefer such use of debuggers, but admit that sometimes debuggers are quite useful. ;)
There are several ways to debug Linux kernel, but one of above is to set up a Linux virtual machine using QEMU and debugging the Linux kernel of the virtual machine from the host machine. This post summarises how to debug the Linux kernel in this way."><meta property="og:type" content="article"><meta property="og:url" content="https://sjp38.github.io/posts/en/qemu_kernel_debugging/"><meta property="og:image" content="https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-05-07T18:21:01+09:00"><meta property="article:modified_time" content="2018-05-07T18:21:01+09:00"><meta property="og:site_name" content="hacklog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Linux Kernel Debugging Using QEMU"><meta name=twitter:description content="You can use classical debugger for your Linux kernel programming, though Torvalds doesn&rsquo;t like it. I also do not prefer such use of debuggers, but admit that sometimes debuggers are quite useful. ;)
There are several ways to debug Linux kernel, but one of above is to set up a Linux virtual machine using QEMU and debugging the Linux kernel of the virtual machine from the host machine. This post summarises how to debug the Linux kernel in this way."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sjp38.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Posts","item":"https://sjp38.github.io/posts/en/"},{"@type":"ListItem","position":3,"name":"Linux Kernel Debugging Using QEMU","item":"https://sjp38.github.io/posts/en/qemu_kernel_debugging/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux Kernel Debugging Using QEMU","name":"Linux Kernel Debugging Using QEMU","description":"You can use classical debugger for your Linux kernel programming, though Torvalds doesn\u0026rsquo;t like it. I also do not prefer such use of debuggers, but admit that sometimes debuggers are quite useful. ;)\nThere are several ways to debug Linux kernel, but one of above is to set up a Linux virtual machine using QEMU and debugging the Linux kernel of the virtual machine from the host machine. This post summarises how to debug the Linux kernel in this way.","keywords":["linux","kernel","tip","linux-kernel-hack"],"articleBody":"You can use classical debugger for your Linux kernel programming, though Torvalds doesn’t like it. I also do not prefer such use of debuggers, but admit that sometimes debuggers are quite useful. ;)\nThere are several ways to debug Linux kernel, but one of above is to set up a Linux virtual machine using QEMU and debugging the Linux kernel of the virtual machine from the host machine. This post summarises how to debug the Linux kernel in this way.\nTest Environment The versions and names of the software I used for test of this post are as below.\nUbuntu 16.04.3 Server gdb 7.11.1 QEMU v2.11.0-dirty Linux v4.16 Kernel Build First, build the kernel you want to debug. You should turn CONFIG_GDB_SCRIPTS on, turn CONFIG_DEBUG_INFO_REDUCED off, and turn CONFIG_FRAME_POINTER on if your target architecture supports it.\nBoot The Virtual Machine If your kernel is ready, boot a QEMU vertual machine with it. You could do it in several ways. For example, you could install the kernel on the virtual machine disk. Or, you could use -kernel, -append and -initrd QEMU option to boot the virtual machine with your kernel image in host machine directly, or some other ways. One thing you should keep in your mind is that you should turn kaslr off. Just giving nokaslr in the kernel parameter doesn’t works well.\nPass -s option to QEMU when you start up the QEMU virtual machine, or enter gdbserver in the QEMU monitor console command line. This make the virtual machine to start gdbserver and wait on tcp::1234 for some accesses. If you have given -nographic QEMU option and set the kernel parameter so that the virtual machine’s console is connected to your terminal, you could not see the QEMU monitor console directly. In this case, you can go back to QEMU monitor console by entering Ctrl+a c. If you want to go back to the virtual machine’s console again, Ctrl+a c .\nStart gdb Move to the build directory of the kernel to debug, enter gdb vmlinux. This will start up gdb using the symbol and debuggin information of the kernel. Ubuntu or some distributions might fail to read vmlinux-gdb.py. The error message also show you how you can fix it, but in summary, you should append below one line at the end of the .gdbinit file and start the gdb again with the above command:\nadd-auto-load-state-path /path/to/linux-build Now, connect to the QEMU virtual machine by entering below command from the gdb session:\n(gdb) target remote :1234 Remote debugging using :1234 0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54 54 asm volatile(\"sti; hlt\": : :\"memory\"); Just after you entering this command, QEMU virtual machine will be frozen. From now, you can see the variables of the kernel, set the breakpoint, execute the code step by step, as you normally did with gdb and user space programs. For example, you can set breakpoint to specific function as below:\n(gdb) b cma_alloc Breakpoint 1 at 0xffffffff81240f10: file /home/hacklog/linux/mm/cma.c, line 399. If you want your virtual machine to run again, you can enter c. This will resume the execution of the kernel. If you set a breakpoint as described above and if the code is be executed, the execution will be started on the breakpoint.\n(gdb) c Continuing. If you want the kernel to stop again, enter Ctrl+C in the gdb.\n^C Thread 1 received signal SIGINT, Interrupt. 0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54 54 asm volatile(\"sti; hlt\": : :\"memory\"); (gdb) Use Linux gdb helper Actually, you can normally use gdb even though it failed to load vmlinux-gdb.py. The python script contains some helper scripts for more convenient kernel debugging on the gdb. You can do kernel debugging a little bit more conveniently if you use it.\nList of the helper scripts The helper scripts have lx prefix. You can list up their names and brief descriptions as below:\n(gdb) apropos lx function lx_current -- Return current task function lx_module -- Find module by name and return the module variable function lx_per_cpu -- Return per-cpu variable function lx_task_by_pid -- Find Linux task by PID and return the task_struct variable function lx_thread_info -- Calculate Linux thread_info from task variable function lx_thread_info_by_pid -- Calculate Linux thread_info from task variable found by pid lx-cmdline -- Report the Linux Commandline used in the current kernel lx-cpus -- List CPU status arrays lx-dmesg -- Print Linux kernel log buffer lx-fdtdump -- Output Flattened Device Tree header and dump FDT blob to the filename lx-iomem -- Identify the IO memory resource locations defined by the kernel lx-ioports -- Identify the IO port resource locations defined by the kernel lx-list-check -- Verify a list consistency lx-lsmod -- List currently loaded modules lx-mounts -- Report the VFS mounts of the current process namespace lx-ps -- Dump Linux tasks lx-symbols -- (Re-)load symbols of Linux kernel and currently loaded modules lx-version -- Report the Linux Version of the current kernel So easy, huh? ;)\nReferences The Kernel Official Document for the Kernel Debugging A blog article The gdbserver official document ","wordCount":"837","inLanguage":"en","image":"https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2018-05-07T18:21:01+09:00","dateModified":"2018-05-07T18:21:01+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sjp38.github.io/posts/en/qemu_kernel_debugging/"},"publisher":{"@type":"Organization","name":"hacklog","logo":{"@type":"ImageObject","url":"https://sjp38.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sjp38.github.io/ accesskey=h title="hacklog (Alt + H)"><img src=https://sjp38.github.io/apple-touch-icon.png alt aria-label=logo height=35>hacklog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sjp38.github.io/posts/en/ title=posts><span>posts</span></a></li><li><a href=https://sjp38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://sjp38.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sjp38.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://sjp38.github.io/files/resume_sjpark.pdf title=cv><span>cv</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sjp38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sjp38.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://sjp38.github.io/posts/en/>Posts</a></div><h1 class="post-title entry-hint-parent">Linux Kernel Debugging Using QEMU</h1><div class=post-meta><span title='2018-05-07 18:21:01 +0900 +0900'>May 7, 2018</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;837 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/sjp38/sjp38.github.io/tree/master/src/content/posts/en/qemu_kernel_debugging.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#list-of-the-helper-scripts>List of the helper scripts</a></li></ul></nav></div></details></div><div class=post-content><p>You can use classical debugger for your Linux kernel programming, though
Torvalds doesn&rsquo;t like it.
I also do not prefer such use of debuggers, but admit that sometimes debuggers
are quite useful. ;)</p><p>There are several ways to debug Linux kernel, but one of above is to set up a
Linux virtual machine using QEMU and debugging the Linux kernel of the virtual
machine from the host machine.
This post summarises how to debug the Linux kernel in this way.</p><h1 id=test-environment>Test Environment<a hidden class=anchor aria-hidden=true href=#test-environment>#</a></h1><p>The versions and names of the software I used for test of this post are as
below.</p><ul><li>Ubuntu 16.04.3 Server</li><li>gdb 7.11.1</li><li>QEMU v2.11.0-dirty</li><li>Linux v4.16</li></ul><h1 id=kernel-build>Kernel Build<a hidden class=anchor aria-hidden=true href=#kernel-build>#</a></h1><p>First, build the kernel you want to debug. You should turn
<code>CONFIG_GDB_SCRIPTS</code> on, turn <code>CONFIG_DEBUG_INFO_REDUCED</code> off, and turn
<code>CONFIG_FRAME_POINTER</code> on if your target architecture supports it.</p><h1 id=boot-the-virtual-machine>Boot The Virtual Machine<a hidden class=anchor aria-hidden=true href=#boot-the-virtual-machine>#</a></h1><p>If your kernel is ready, boot a QEMU vertual machine with it.
You could do it in several ways.
For example, you could install the kernel on the virtual machine disk. Or, you
could use <code>-kernel</code>, <code>-append</code> and <code>-initrd</code> QEMU option to boot the virtual
machine with your kernel image in host machine directly, or some other ways.
One thing you should keep in your mind is that you should turn <strong>kaslr</strong> off.
Just giving <code>nokaslr</code> in the kernel parameter doesn&rsquo;t works well.</p><p>Pass <code>-s</code> option to QEMU when you start up the QEMU virtual machine, or enter
<code>gdbserver</code> in the QEMU monitor console command line.
This make the virtual machine to start gdbserver and wait on <code>tcp::1234</code> for
some accesses.
If you have given <code>-nographic</code> QEMU option and set the kernel parameter so that
the virtual machine&rsquo;s console is connected to your terminal, you could not see
the QEMU monitor console directly. In this case, you can go back to QEMU
monitor console by entering <code>Ctrl+a c</code>.
If you want to go back to the virtual machine&rsquo;s console again, <code>Ctrl+a c &lt;enter></code>.</p><h1 id=start-gdb>Start gdb<a hidden class=anchor aria-hidden=true href=#start-gdb>#</a></h1><p>Move to the build directory of the kernel to debug, enter <code>gdb vmlinux</code>.
This will start up gdb using the symbol and debuggin information of the kernel.
Ubuntu or some distributions might fail to read <code>vmlinux-gdb.py</code>. The error
message also show you how you can fix it, but in summary, you should append
below one line at the end of the <code>.gdbinit</code> file and start the gdb again with
the above command:</p><pre tabindex=0><code>add-auto-load-state-path /path/to/linux-build
</code></pre><p>Now, connect to the QEMU virtual machine by entering below command from the gdb
session:</p><pre tabindex=0><code>(gdb) target remote :1234
Remote debugging using :1234
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&#34;sti; hlt&#34;: : :&#34;memory&#34;);
</code></pre><p>Just after you entering this command, QEMU virtual machine will be frozen.
From now, you can see the variables of the kernel, set the breakpoint, execute
the code step by step, as you normally did with gdb and user space programs.
For example, you can set breakpoint to specific function as below:</p><pre tabindex=0><code>(gdb) b cma_alloc
Breakpoint 1 at 0xffffffff81240f10: file /home/hacklog/linux/mm/cma.c, line 399.
</code></pre><p>If you want your virtual machine to run again, you can enter <code>c</code>.
This will resume the execution of the kernel.
If you set a breakpoint as described above and if the code is be executed, the
execution will be started on the breakpoint.</p><pre tabindex=0><code>(gdb) c
Continuing.
</code></pre><p>If you want the kernel to stop again, enter <code>Ctrl+C</code> in the gdb.</p><pre tabindex=0><code>^C
Thread 1 received signal SIGINT, Interrupt.
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&#34;sti; hlt&#34;: : :&#34;memory&#34;);
(gdb)
</code></pre><h1 id=use-linux-gdb-helper>Use Linux gdb helper<a hidden class=anchor aria-hidden=true href=#use-linux-gdb-helper>#</a></h1><p>Actually, you can normally use gdb even though it failed to load
<code>vmlinux-gdb.py</code>.
The python script contains some helper scripts for more convenient kernel
debugging on the gdb.
You can do kernel debugging a little bit more conveniently if you use it.</p><h2 id=list-of-the-helper-scripts>List of the helper scripts<a hidden class=anchor aria-hidden=true href=#list-of-the-helper-scripts>#</a></h2><p>The helper scripts have <code>lx</code> prefix. You can list up their names and brief
descriptions as below:</p><pre tabindex=0><code>(gdb) apropos lx
function lx_current -- Return current task
function lx_module -- Find module by name and return the module variable
function lx_per_cpu -- Return per-cpu variable
function lx_task_by_pid -- Find Linux task by PID and return the task_struct variable
function lx_thread_info -- Calculate Linux thread_info from task variable
function lx_thread_info_by_pid -- Calculate Linux thread_info from task variable found by pid
lx-cmdline --  Report the Linux Commandline used in the current kernel
lx-cpus -- List CPU status arrays
lx-dmesg -- Print Linux kernel log buffer
lx-fdtdump -- Output Flattened Device Tree header and dump FDT blob to the filename
lx-iomem -- Identify the IO memory resource locations defined by the kernel
lx-ioports -- Identify the IO port resource locations defined by the kernel
lx-list-check -- Verify a list consistency
lx-lsmod -- List currently loaded modules
lx-mounts -- Report the VFS mounts of the current process namespace
lx-ps -- Dump Linux tasks
lx-symbols -- (Re-)load symbols of Linux kernel and currently loaded modules
lx-version --  Report the Linux Version of the current kernel
</code></pre><p>So easy, huh? ;)</p><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><ol><li><a href=https://www.kernel.org/doc/html/v4.11/dev-tools/gdb-kernel-debugging.html>The Kernel Official Document for the Kernel Debugging</a></li><li><a href=http://www.alexlambert.com/2017/12/18/kernel-debugging-for-newbies.html>A blog article</a></li><li><a href=https://sourceware.org/gdb/onlinedocs/gdb/Server.html>The gdbserver official document</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://sjp38.github.io/tags/linux/>Linux</a></li><li><a href=https://sjp38.github.io/tags/kernel/>Kernel</a></li><li><a href=https://sjp38.github.io/tags/tip/>Tip</a></li><li><a href=https://sjp38.github.io/tags/linux-kernel-hack/>Linux-Kernel-Hack</a></li></ul><nav class=paginav><a class=prev href=https://sjp38.github.io/posts/ko/lkml_news_v4.17-rc5/><span class=title>« Prev</span><br><span>LKML News after v4.17-rc5</span>
</a><a class=next href=https://sjp38.github.io/posts/ko/qemu_kernel_debugging/><span class=title>Next »</span><br><span>QEMU 를 사용한 리눅스 커널 디버깅</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux Kernel Debugging Using QEMU on x" href="https://x.com/intent/tweet/?text=Linux%20Kernel%20Debugging%20Using%20QEMU&amp;url=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2fqemu_kernel_debugging%2f&amp;hashtags=linux%2ckernel%2ctip%2clinux-kernel-hack"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux Kernel Debugging Using QEMU on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2fqemu_kernel_debugging%2f&amp;title=Linux%20Kernel%20Debugging%20Using%20QEMU&amp;summary=Linux%20Kernel%20Debugging%20Using%20QEMU&amp;source=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2fqemu_kernel_debugging%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux Kernel Debugging Using QEMU on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2fqemu_kernel_debugging%2f&title=Linux%20Kernel%20Debugging%20Using%20QEMU"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux Kernel Debugging Using QEMU on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2fqemu_kernel_debugging%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux Kernel Debugging Using QEMU on whatsapp" href="https://api.whatsapp.com/send?text=Linux%20Kernel%20Debugging%20Using%20QEMU%20-%20https%3a%2f%2fsjp38.github.io%2fposts%2fen%2fqemu_kernel_debugging%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux Kernel Debugging Using QEMU on telegram" href="https://telegram.me/share/url?text=Linux%20Kernel%20Debugging%20Using%20QEMU&amp;url=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2fqemu_kernel_debugging%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linux Kernel Debugging Using QEMU on ycombinator" href="https://news.ycombinator.com/submitlink?t=Linux%20Kernel%20Debugging%20Using%20QEMU&u=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2fqemu_kernel_debugging%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sjp38.github.io/>hacklog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>