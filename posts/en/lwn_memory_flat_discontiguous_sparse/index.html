<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Memory: the flat, the discontiguous, and the sparse (Korean) | hacklog</title>
<meta name=keywords content="lwn,linux,kernel,memory models,translation,lwn translations"><meta name=description content="LWN 의 &ldquo;Memory: the flat, the discontiguous, and the sparse&rdquo; 라는 제목의 글의 한글 번역입니다. 원문은 LWN 에서 볼 수 있습니다: https://lwn.net/Articles/789304/
May 27, 2019
이 기사는 Mike Rapoport 에 의해 기여되었습니다.
컴퓨터 시스템에서 물리 메모리는 소중한 자원이어서, 이를 효율적으로 관리하기 위한 많은 노력이 기울여져왔습니다. 이 일은 현대의 시스템에서의 메모리 구조가 복잡해짐에 따라 더 어려워졌습니다. 물리 메모리가 실제로 어떻게 위치해 있는가를 다루기 위한 여러 계층의 추상화가 존재합니다; 그런 추상화 중 하나는 &ldquo;메모리 모델&rdquo; 이라고 불립니다."><meta name=author content="Me"><link rel=canonical href=https://sjp38.github.io/posts/en/lwn_memory_flat_discontiguous_sparse/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://sjp38.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sjp38.github.io/posts/en/lwn_memory_flat_discontiguous_sparse/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Memory: the flat, the discontiguous, and the sparse (Korean)"><meta property="og:description" content="LWN 의 &ldquo;Memory: the flat, the discontiguous, and the sparse&rdquo; 라는 제목의 글의 한글 번역입니다. 원문은 LWN 에서 볼 수 있습니다: https://lwn.net/Articles/789304/
May 27, 2019
이 기사는 Mike Rapoport 에 의해 기여되었습니다.
컴퓨터 시스템에서 물리 메모리는 소중한 자원이어서, 이를 효율적으로 관리하기 위한 많은 노력이 기울여져왔습니다. 이 일은 현대의 시스템에서의 메모리 구조가 복잡해짐에 따라 더 어려워졌습니다. 물리 메모리가 실제로 어떻게 위치해 있는가를 다루기 위한 여러 계층의 추상화가 존재합니다; 그런 추상화 중 하나는 &ldquo;메모리 모델&rdquo; 이라고 불립니다."><meta property="og:type" content="article"><meta property="og:url" content="https://sjp38.github.io/posts/en/lwn_memory_flat_discontiguous_sparse/"><meta property="og:image" content="https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-31T07:45:17+09:00"><meta property="article:modified_time" content="2019-07-31T07:45:17+09:00"><meta property="og:site_name" content="hacklog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Memory: the flat, the discontiguous, and the sparse (Korean)"><meta name=twitter:description content="LWN 의 &ldquo;Memory: the flat, the discontiguous, and the sparse&rdquo; 라는 제목의 글의 한글 번역입니다. 원문은 LWN 에서 볼 수 있습니다: https://lwn.net/Articles/789304/
May 27, 2019
이 기사는 Mike Rapoport 에 의해 기여되었습니다.
컴퓨터 시스템에서 물리 메모리는 소중한 자원이어서, 이를 효율적으로 관리하기 위한 많은 노력이 기울여져왔습니다. 이 일은 현대의 시스템에서의 메모리 구조가 복잡해짐에 따라 더 어려워졌습니다. 물리 메모리가 실제로 어떻게 위치해 있는가를 다루기 위한 여러 계층의 추상화가 존재합니다; 그런 추상화 중 하나는 &ldquo;메모리 모델&rdquo; 이라고 불립니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sjp38.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Posts","item":"https://sjp38.github.io/posts/en/"},{"@type":"ListItem","position":3,"name":"Memory: the flat, the discontiguous, and the sparse (Korean)","item":"https://sjp38.github.io/posts/en/lwn_memory_flat_discontiguous_sparse/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Memory: the flat, the discontiguous, and the sparse (Korean)","name":"Memory: the flat, the discontiguous, and the sparse (Korean)","description":"LWN 의 \u0026ldquo;Memory: the flat, the discontiguous, and the sparse\u0026rdquo; 라는 제목의 글의 한글 번역입니다. 원문은 LWN 에서 볼 수 있습니다: https://lwn.net/Articles/789304/\nMay 27, 2019\n이 기사는 Mike Rapoport 에 의해 기여되었습니다.\n컴퓨터 시스템에서 물리 메모리는 소중한 자원이어서, 이를 효율적으로 관리하기 위한 많은 노력이 기울여져왔습니다. 이 일은 현대의 시스템에서의 메모리 구조가 복잡해짐에 따라 더 어려워졌습니다. 물리 메모리가 실제로 어떻게 위치해 있는가를 다루기 위한 여러 계층의 추상화가 존재합니다; 그런 추상화 중 하나는 \u0026ldquo;메모리 모델\u0026rdquo; 이라고 불립니다.","keywords":["lwn","linux","kernel","memory models","translation","lwn translations"],"articleBody":"LWN 의 “Memory: the flat, the discontiguous, and the sparse” 라는 제목의 글의 한글 번역입니다. 원문은 LWN 에서 볼 수 있습니다: https://lwn.net/Articles/789304/\nMay 27, 2019\n이 기사는 Mike Rapoport 에 의해 기여되었습니다.\n컴퓨터 시스템에서 물리 메모리는 소중한 자원이어서, 이를 효율적으로 관리하기 위한 많은 노력이 기울여져왔습니다. 이 일은 현대의 시스템에서의 메모리 구조가 복잡해짐에 따라 더 어려워졌습니다. 물리 메모리가 실제로 어떻게 위치해 있는가를 다루기 위한 여러 계층의 추상화가 존재합니다; 그런 추상화 중 하나는 “메모리 모델” 이라고 불립니다. 커널은 세개의 모델을 지원하고 있는데, 그 중 하나는 지원이 멈춰져 가고 있습니다. 이 변경을 이해하기 위한 방법으로, 이 기사는 커널의 메모리 모델들의 진화, 현재 상태, 그리고 있을 법한 미래에 대해 자세히 들여다 봅니다.\nFLATMEM 리눅스가 처음 나왔을 때, 메모리는 평평했습니다: 메모리는 0 부터 수 메가바이트의 물리 주소를 갖는 단순한 선형적 배열일 뿐이었습니다. 각 물리 페이지 프레임은 커널의 mem_map 배열에 하나의 원소와 연관되었으며, 이 당시에 이 배열은 해당 페이지가 가진 레퍼런스의 갯수를 세는 하나의 unsigned short 원소로 이루어져 있었습니다. 하지만, 얼마 있지 않아서, 이 mem_map 의 원소들은 스왑 관리를 위한 age 와 dirty counter 를 포함하도록 커졌습니다. Linux 1.3.50 에서 mem_map 의 원소들은 마침내 struct page 로 이름지어졌습니다.\n이 평평한 메모리 매핑은 물리 페이지 프레임 번호 (page-frame number : PFN) 와 그에 대응되는 struct page 사이의 쉽고 빠른 변환을 제공했습니다; 이 변환 작업은 간단한 배열 인덱스 계산 문제였습니다. 이후 struct page 의 레이아웃 변경이 있었는데, 새로운 사용처 (예컨대, page cache) 들과 struct page 의 캐시 성능 최적화를 위한 것이었습니다. 메모리 매핑은 깔끔하고 효율적인 평평한 배열로 유지되었습니다만, 이는 중요한 단점을 가지고 있었습니다: 물리 주소 공간 상의 큰 공백을 처리할 수 없었습니다. 이 메모리 매핑 가운데 공백에 연관된 부분은 낭비되어지거나, ARM 에서처럼, 메모리 매핑 자체가 공백을 가질 수 있었습니다.\nDISCONTIGMEM 상당히 비연속적인 물리 메모리를 효율적으로 처리하기 위한 지원이 리눅스를 NUMA 기계들 위에서 잘 동작하도록 하기 위한 노력의 일환으로 1999년에 메모리 관리 서브시스템으로 들어왔습니다. 이 코드는 CONFIG_DISCONTIGMEM 설정 옵션에 종속적이어서, 이 메모리 모델은 DISCONTIGMEM 이라 이름지어진 첫번째 모델이었습니다.\n이 DISCONTIGMEM 모델은 메모리 노드 (memory node) 라는 개념을 소개했는데, 이 개념은 여전히 NUMA 메모리 관리의 기본으로 남아있습니다. 각 노드는 free-page lists, in-use page lists, least-recently-used (LRU) 정보, 사용 통계 등을 포함한, (대부분) 독립적인 메모리 관리 서브시스템을 갖습니다. 이런 것들 가운데, struct pglist_data (또는 짧게 pg_data_t) 로 표현되는 노드 데이터는 하나의 노드에 대한 메모리 매핑 정보를 가지고 있습니다. 각 노드가 연속적인 물리 메모리를 가지고 있다는 가정 하에, 노드당 하나의 struct page 배열을 갖는 것은 평평한 메모리 매핑 안의 거대한 공백 문제를 해결했습니다.\n하지만 이게 공짜로 된 건 아닙니다. DISCONTIGMEM 에서는, 예를 들면 어떤 PFN 을 그에 연관된 struct page 로 변환하기 위해 특정 페이지를 어떤 노드가 가지고 있는지를 알 수 있어야 합니다. 비슷하게, 페이지를 가지고 PFN 을 구하기 위해 어떤 노드의 메모리 맵이 해당 struct page 를 가지고 있는지도 알 수 있어야 합니다. 긴 진화의 끝에, KVADDR_TO_NID(), LOCAL_MAP_BASE(), ADDR_TO_MAPBASE(), 그리고 LOCAL_BASE_ADDR() 매크로를 처음 정의한 mips64 부터 시작해서 PFN 의 struct page 로의 변환과 그 반대 작업은 include/asm-generic/memory_model.h 안에 정의된, 비교적 간단한 pfn_to_page() 와 page_to_pfn() 매크로로 수행되게 되었습니다.\n하지만, DISCONTIGMEM 은 약점이 있었습니다: 메모리 핫플러그 (hotplug) 와 핫리무브 (hot remove) 입니다. 실제 NUMA 노드는 실제 핫플러그를 지원하기엔 너무 굵은 크기였고, 노드를 쪼개는 것은 불필요한게 많은 단편화와 오버헤드를 가져올 것이었습니다. 각 노드가 독립적인 메모리 관리 구조체들을 연관된 비용과 함께 가짐을 기억해 보세요; 노드를 쪼개는 것은 그런 비용을 상당히 증가시킬 겁니다.\nSPARSEMEM 이 한계는 SPARSEMEM 을 통해 해결되었습니다. 이 모델은 메모리 매핑을 아키텍쳐별로 정의된 임의의 크기의 섹션들의 집합으로 추상화 했습니다. 각 섹션은 struct mem_section 으로 표현되며, (코드에 설명된 바에 따르면): “논리적으로, struct page 의 배열로의 포인터입니다. 하지만, 다른 마술을 통해 저장됩니다”. 이 섹션들의 배열은 SECTION_SIZE 크기로 효율적으로 쪼개질 수 있는 메타 메모리 매핑입니다. PFN 과 struct page 사이의 효율적인 변환을 위해, PFN 의 상위 비트 몇개는 이 섹션 배열로의 인덱스로 사용됩니다. 반대 방향 변환을 위해선, 이 섹션 넘버가 page 의 flag 로 인코딩 됩니다.\n이 모델이 리눅스 커널에 소개되고 몇달 후, SPARSEMEM 은 SPARSEMEM_EXTREME 으로 확장되었는데, 이 모델은 산재하는 물리 주소 공간을 갖는 시스템에 적합합니다. SPARSEMEM_EXTREME 에서는, 첫번째 레벨은 mem_section 구조체들로의 포인터가 되고, 실제 mem_section 객체는 실제로 꽂힌 물리 메모리에 기반해서 동적으로 할당됩니다.\n2007년에 SPARSEMEM 의 또다른 개선이 이루어졌습니다; 이는 SPARSEMEM 의 일반적인 가상 메모리 매핑 지원 또는 SPARSEMEM_VMEMMAP 이라고 불렸습니다. SPARSEMEM_VMEMMAP 의 아이디어는 전체 메모리 매핑이 가상 연속 공간에 매핑되어 있지만, 활성화된 섹션들만이 물리 페이지로 연결되어 있도록 하자는 것입니다. 이 모델은 32-bit 시스템에서는 물리 메모리의 크기가 가상 주소 공간을 넘을 수 있기 때문에 잘 동작하지 못할 수 있습니다. 하지만, 64-bit 시스템에서 SPARSEMEM_VMEMMAP 은 확실히 우수합니다. 추가적인 페이지 테이블 엔트리 사용이라는 비용 아래, page_to_pfn() 과 pfn_to_page() 는 평평한 모델만큼이나 간단해 졌습니다.\nSPARSEMEM 메모리 모델의 마지막 확장은 꽤 최근 (2016) 이었습니다; 이는 persistent 메모리 디바이스의 사용 증가로 인해 이루어졌습니다. 메모리 매핑을 메인 메모리가 아니라 그런 디바이스들 내에 직접 저장하는 걸 지원하기 위해, 이 가상 메모리 매핑은 struct vmem_altmap 을 사용할 수 있게 되었는데, 이 구조체는 persistent 메모리 안의 페이지 구조체를 제공합니다.\n2005년으로 돌아가보면, SPARSEMEM 은 “새로운, 그리고 실험적인 discontiguous memory 의 대체재” 로 설명되었습니다. SPARSEMEM_VMEMMAP 을 추가한 커밋은 그것을 “우리가 SPARSEMEM 을 대부분의 시스템에 기본 (그리고 유일한) 옵션이 되게 할 가능성이 있다” 고 했습니다. 그리고 실제로, 일부 아키텍쳐는 DISCONTIGMEM 에서 SPARSEMEM 으로 옮겨탔습니다. 2008년, SPARSEMEM_VMEMMAP 은 x86-64 를 위한 유일한 메모리 모델이 되었는데, FLATMEM 보단 조금 비싸지만 DISCONTIGMEM 보다는 효율적이기 때문입니다.\n메모리 핫플러그, persistent 메모리 지원, 다양한 성능 최적화와 같은 최근의 메모리 관리 분야 개발은 모두 SPARSEMEM 모델을 타겟으로 하고 있습니다. 하지만 과거의 모델들은 여전히 존재해서, 아키텍쳐와 메모리 관리 코드 상의 많은 #ifdef 블록의 존재와, 관련된 구성 옵션의 특별한 미로의 존재라는 추가비용을 유발하고 있습니다. 남아있는 DISCONTIGMEM 사용자들을 SPARSEMEM 으로 완전히 바꿔타게 하려는 노력들이 있습니다만, ia64 나 mips64 와 같은 아키텍쳐들을 그렇게 변화시키기는 쉬운 작업이 아닐 겁니다. 그리고 ARC 아키텍쳐의 DISCONTIGMEM 사용은 “normal” 메모리 아래 “high memory” 영역의 존재를 갖는데, 이는 분명 변경하기 어려울 겁니다.\n","wordCount":"919","inLanguage":"en","image":"https://sjp38.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2019-07-31T07:45:17+09:00","dateModified":"2019-07-31T07:45:17+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sjp38.github.io/posts/en/lwn_memory_flat_discontiguous_sparse/"},"publisher":{"@type":"Organization","name":"hacklog","logo":{"@type":"ImageObject","url":"https://sjp38.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sjp38.github.io/ accesskey=h title="hacklog (Alt + H)"><img src=https://sjp38.github.io/apple-touch-icon.png alt aria-label=logo height=35>hacklog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sjp38.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://sjp38.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sjp38.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://sjp38.github.io/files/resume_sjpark.pdf title=cv><span>cv</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sjp38.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sjp38.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://sjp38.github.io/posts/en/>Posts</a></div><h1 class="post-title entry-hint-parent">Memory: the flat, the discontiguous, and the sparse (Korean)</h1><div class=post-meta><span title='2019-07-31 07:45:17 +0900 +0900'>July 31, 2019</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;919 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/en/lwn_memory_flat_discontiguous_sparse.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#flatmem>FLATMEM</a></li><li><a href=#discontigmem>DISCONTIGMEM</a></li><li><a href=#sparsemem>SPARSEMEM</a></li></ul></nav></div></details></div><div class=post-content><p>LWN 의 &ldquo;Memory: the flat, the discontiguous, and the sparse&rdquo; 라는 제목의 글의
한글 번역입니다. 원문은 LWN 에서 볼 수 있습니다:
<a href=https://lwn.net/Articles/789304/>https://lwn.net/Articles/789304/</a></p><hr><p>May 27, 2019</p><p>이 기사는 Mike Rapoport 에 의해 기여되었습니다.</p><p>컴퓨터 시스템에서 물리 메모리는 소중한 자원이어서, 이를 효율적으로 관리하기
위한 많은 노력이 기울여져왔습니다.
이 일은 현대의 시스템에서의 메모리 구조가 복잡해짐에 따라 더 어려워졌습니다.
물리 메모리가 실제로 어떻게 위치해 있는가를 다루기 위한 여러 계층의 추상화가
존재합니다; 그런 추상화 중 하나는 &ldquo;메모리 모델&rdquo; 이라고 불립니다.
커널은 세개의 모델을 지원하고 있는데, 그 중 하나는 지원이 멈춰져 가고 있습니다.
이 변경을 이해하기 위한 방법으로, 이 기사는 커널의 메모리 모델들의 진화, 현재
상태, 그리고 있을 법한 미래에 대해 자세히 들여다 봅니다.</p><h2 id=flatmem>FLATMEM<a hidden class=anchor aria-hidden=true href=#flatmem>#</a></h2><p>리눅스가 처음 나왔을 때, 메모리는 평평했습니다: 메모리는 0 부터 수 메가바이트의
물리 주소를 갖는 단순한 선형적 배열일 뿐이었습니다.
각 물리 페이지 프레임은 커널의 <code>mem_map</code> 배열에 하나의 원소와 연관되었으며, 이
당시에 이 배열은 해당 페이지가 가진 레퍼런스의 갯수를 세는 하나의 <code>unsigned short</code> 원소로 이루어져 있었습니다.
하지만, 얼마 있지 않아서, 이 <code>mem_map</code> 의 원소들은 스왑 관리를 위한 <code>age</code> 와
<code>dirty counter</code> 를 포함하도록 커졌습니다.
Linux 1.3.50 에서 <code>mem_map</code> 의 원소들은 마침내 <code>struct page</code> 로
이름지어졌습니다.</p><p>이 평평한 메모리 매핑은 물리 페이지 프레임 번호 (page-frame number : PFN) 와
그에 대응되는 <code>struct page</code> 사이의 쉽고 빠른 변환을 제공했습니다; 이 변환
작업은 간단한 배열 인덱스 계산 문제였습니다.
이후 <code>struct page</code> 의 레이아웃 변경이 있었는데, 새로운 사용처 (예컨대, page
cache) 들과 <code>struct page</code> 의 캐시 성능 최적화를 위한 것이었습니다.
메모리 매핑은 깔끔하고 효율적인 평평한 배열로 유지되었습니다만, 이는 중요한
단점을 가지고 있었습니다: 물리 주소 공간 상의 큰 공백을 처리할 수 없었습니다.
이 메모리 매핑 가운데 공백에 연관된 부분은 낭비되어지거나, ARM 에서처럼, 메모리
매핑 자체가 공백을 가질 수 있었습니다.</p><h2 id=discontigmem>DISCONTIGMEM<a hidden class=anchor aria-hidden=true href=#discontigmem>#</a></h2><p>상당히 비연속적인 물리 메모리를 효율적으로 처리하기 위한 지원이 리눅스를 NUMA
기계들 위에서 잘 동작하도록 하기 위한 노력의 일환으로 1999년에 메모리 관리
서브시스템으로 들어왔습니다.
이 코드는 <code>CONFIG_DISCONTIGMEM</code> 설정 옵션에 종속적이어서, 이 메모리 모델은
<code>DISCONTIGMEM</code> 이라 이름지어진 첫번째 모델이었습니다.</p><p>이 <code>DISCONTIGMEM</code> 모델은 메모리 노드 (memory node) 라는 개념을 소개했는데, 이
개념은 여전히 NUMA 메모리 관리의 기본으로 남아있습니다.
각 노드는 free-page lists, in-use page lists, least-recently-used (LRU) 정보,
사용 통계 등을 포함한, (대부분) 독립적인 메모리 관리 서브시스템을 갖습니다.
이런 것들 가운데, <code>struct pglist_data</code> (또는 짧게 <code>pg_data_t</code>) 로 표현되는 노드
데이터는 하나의 노드에 대한 메모리 매핑 정보를 가지고 있습니다.
각 노드가 연속적인 물리 메모리를 가지고 있다는 가정 하에, 노드당 하나의 <code>struct page</code> 배열을 갖는 것은 평평한 메모리 매핑 안의 거대한 공백 문제를 해결했습니다.</p><p>하지만 이게 공짜로 된 건 아닙니다.
<code>DISCONTIGMEM</code> 에서는, 예를 들면 어떤 PFN 을 그에 연관된 <code>struct page</code> 로
변환하기 위해 특정 페이지를 어떤 노드가 가지고 있는지를 알 수 있어야 합니다.
비슷하게, 페이지를 가지고 PFN 을 구하기 위해 어떤 노드의 메모리 맵이 해당
<code>struct page</code> 를 가지고 있는지도 알 수 있어야 합니다.
긴 진화의 끝에, <code>KVADDR_TO_NID()</code>, <code>LOCAL_MAP_BASE()</code>, <code>ADDR_TO_MAPBASE()</code>,
그리고 <code>LOCAL_BASE_ADDR()</code> 매크로를 처음 정의한 <code>mips64</code> 부터 시작해서 PFN 의
<code>struct page</code> 로의 변환과 그 반대 작업은 <code>include/asm-generic/memory_model.h</code>
안에 정의된, 비교적 간단한 <code>pfn_to_page()</code> 와 <code>page_to_pfn()</code> 매크로로 수행되게
되었습니다.</p><p>하지만, DISCONTIGMEM 은 약점이 있었습니다: 메모리 핫플러그 (hotplug) 와
핫리무브 (hot remove) 입니다.
실제 NUMA 노드는 실제 핫플러그를 지원하기엔 너무 굵은 크기였고, 노드를 쪼개는
것은 불필요한게 많은 단편화와 오버헤드를 가져올 것이었습니다.
각 노드가 독립적인 메모리 관리 구조체들을 연관된 비용과 함께 가짐을 기억해
보세요; 노드를 쪼개는 것은 그런 비용을 상당히 증가시킬 겁니다.</p><h2 id=sparsemem>SPARSEMEM<a hidden class=anchor aria-hidden=true href=#sparsemem>#</a></h2><p>이 한계는 SPARSEMEM 을 통해 해결되었습니다. 이 모델은 메모리 매핑을
아키텍쳐별로 정의된 임의의 크기의 섹션들의 집합으로 추상화 했습니다.
각 섹션은 <code>struct mem_section</code> 으로 표현되며, (코드에 설명된 바에 따르면):
&ldquo;논리적으로, <code>struct page</code> 의 배열로의 포인터입니다. 하지만, 다른 마술을 통해
저장됩니다&rdquo;.
이 섹션들의 배열은 <code>SECTION_SIZE</code> 크기로 효율적으로 쪼개질 수 있는 메타 메모리
매핑입니다.
PFN 과 <code>struct page</code> 사이의 효율적인 변환을 위해, PFN 의 상위 비트 몇개는 이
섹션 배열로의 인덱스로 사용됩니다.
반대 방향 변환을 위해선, 이 섹션 넘버가 page 의 flag 로 인코딩 됩니다.</p><p>이 모델이 리눅스 커널에 소개되고 몇달 후, SPARSEMEM 은 <code>SPARSEMEM_EXTREME</code> 으로
확장되었는데, 이 모델은 산재하는 물리 주소 공간을 갖는 시스템에 적합합니다.
<code>SPARSEMEM_EXTREME</code> 에서는, 첫번째 레벨은 <code>mem_section</code> 구조체들로의 포인터가
되고, 실제 <code>mem_section</code> 객체는 실제로 꽂힌 물리 메모리에 기반해서 동적으로
할당됩니다.</p><p>2007년에 SPARSEMEM 의 또다른 개선이 이루어졌습니다; 이는 SPARSEMEM 의 일반적인
가상 메모리 매핑 지원 또는 <code>SPARSEMEM_VMEMMAP</code> 이라고 불렸습니다.
<code>SPARSEMEM_VMEMMAP</code> 의 아이디어는 전체 메모리 매핑이 가상 연속 공간에 매핑되어
있지만, 활성화된 섹션들만이 물리 페이지로 연결되어 있도록 하자는 것입니다.
이 모델은 32-bit 시스템에서는 물리 메모리의 크기가 가상 주소 공간을 넘을 수
있기 때문에 잘 동작하지 못할 수 있습니다.
하지만, 64-bit 시스템에서 <code>SPARSEMEM_VMEMMAP</code> 은 확실히 우수합니다.
추가적인 페이지 테이블 엔트리 사용이라는 비용 아래, <code>page_to_pfn()</code> 과
<code>pfn_to_page()</code> 는 평평한 모델만큼이나 간단해 졌습니다.</p><p>SPARSEMEM 메모리 모델의 마지막 확장은 꽤 최근 (2016) 이었습니다; 이는
persistent 메모리 디바이스의 사용 증가로 인해 이루어졌습니다.
메모리 매핑을 메인 메모리가 아니라 그런 디바이스들 내에 직접 저장하는 걸
지원하기 위해, 이 가상 메모리 매핑은 <code>struct vmem_altmap</code> 을 사용할 수 있게
되었는데, 이 구조체는 persistent 메모리 안의 페이지 구조체를 제공합니다.</p><p>2005년으로 돌아가보면, SPARSEMEM 은 &ldquo;새로운, 그리고 실험적인 <code>discontiguous memory</code> 의 대체재&rdquo; 로 설명되었습니다.
<code>SPARSEMEM_VMEMMAP</code> 을 추가한 커밋은 그것을 &ldquo;우리가 SPARSEMEM 을 대부분의
시스템에 기본 (그리고 유일한) 옵션이 되게 할 가능성이 있다&rdquo; 고 했습니다.
그리고 실제로, 일부 아키텍쳐는 DISCONTIGMEM 에서 SPARSEMEM 으로 옮겨탔습니다.
2008년, <code>SPARSEMEM_VMEMMAP</code> 은 x86-64 를 위한 유일한 메모리 모델이 되었는데,
FLATMEM 보단 조금 비싸지만 DISCONTIGMEM 보다는 효율적이기 때문입니다.</p><p>메모리 핫플러그, persistent 메모리 지원, 다양한 성능 최적화와 같은 최근의
메모리 관리 분야 개발은 모두 SPARSEMEM 모델을 타겟으로 하고 있습니다.
하지만 과거의 모델들은 여전히 존재해서, 아키텍쳐와 메모리 관리 코드 상의 많은
<code>#ifdef</code> 블록의 존재와, 관련된 구성 옵션의 특별한 미로의 존재라는 추가비용을
유발하고 있습니다.
남아있는 <code>DISCONTIGMEM</code> 사용자들을 <code>SPARSEMEM</code> 으로 완전히 바꿔타게 하려는
노력들이 있습니다만, ia64 나 mips64 와 같은 아키텍쳐들을 그렇게 변화시키기는
쉬운 작업이 아닐 겁니다.
그리고 ARC 아키텍쳐의 DISCONTIGMEM 사용은 &ldquo;normal&rdquo; 메모리 아래 &ldquo;high memory&rdquo;
영역의 존재를 갖는데, 이는 분명 변경하기 어려울 겁니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sjp38.github.io/tags/lwn/>Lwn</a></li><li><a href=https://sjp38.github.io/tags/linux/>Linux</a></li><li><a href=https://sjp38.github.io/tags/kernel/>Kernel</a></li><li><a href=https://sjp38.github.io/tags/memory-models/>Memory Models</a></li><li><a href=https://sjp38.github.io/tags/translation/>Translation</a></li><li><a href=https://sjp38.github.io/tags/lwn-translations/>Lwn Translations</a></li></ul><nav class=paginav><a class=prev href=https://sjp38.github.io/posts/ko/lkml_news_v5.3-rc3/><span class=title>« Prev</span><br><span>LKML News v5.3-rc3</span>
</a><a class=next href=https://sjp38.github.io/posts/ko/lwn_memory_flat_discontiguous_sparse/><span class=title>Next »</span><br><span>Memory: the flat, the discontiguous, and the sparse (Korean)</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory: the flat, the discontiguous, and the sparse (Korean) on x" href="https://x.com/intent/tweet/?text=Memory%3a%20the%20flat%2c%20the%20discontiguous%2c%20and%20the%20sparse%20%28Korean%29&amp;url=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2flwn_memory_flat_discontiguous_sparse%2f&amp;hashtags=lwn%2clinux%2ckernel%2cmemorymodels%2ctranslation%2clwntranslations"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory: the flat, the discontiguous, and the sparse (Korean) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2flwn_memory_flat_discontiguous_sparse%2f&amp;title=Memory%3a%20the%20flat%2c%20the%20discontiguous%2c%20and%20the%20sparse%20%28Korean%29&amp;summary=Memory%3a%20the%20flat%2c%20the%20discontiguous%2c%20and%20the%20sparse%20%28Korean%29&amp;source=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2flwn_memory_flat_discontiguous_sparse%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory: the flat, the discontiguous, and the sparse (Korean) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2flwn_memory_flat_discontiguous_sparse%2f&title=Memory%3a%20the%20flat%2c%20the%20discontiguous%2c%20and%20the%20sparse%20%28Korean%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory: the flat, the discontiguous, and the sparse (Korean) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2flwn_memory_flat_discontiguous_sparse%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory: the flat, the discontiguous, and the sparse (Korean) on whatsapp" href="https://api.whatsapp.com/send?text=Memory%3a%20the%20flat%2c%20the%20discontiguous%2c%20and%20the%20sparse%20%28Korean%29%20-%20https%3a%2f%2fsjp38.github.io%2fposts%2fen%2flwn_memory_flat_discontiguous_sparse%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory: the flat, the discontiguous, and the sparse (Korean) on telegram" href="https://telegram.me/share/url?text=Memory%3a%20the%20flat%2c%20the%20discontiguous%2c%20and%20the%20sparse%20%28Korean%29&amp;url=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2flwn_memory_flat_discontiguous_sparse%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Memory: the flat, the discontiguous, and the sparse (Korean) on ycombinator" href="https://news.ycombinator.com/submitlink?t=Memory%3a%20the%20flat%2c%20the%20discontiguous%2c%20and%20the%20sparse%20%28Korean%29&u=https%3a%2f%2fsjp38.github.io%2fposts%2fen%2flwn_memory_flat_discontiguous_sparse%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sjp38.github.io/>hacklog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>