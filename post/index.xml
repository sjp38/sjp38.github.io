<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hacklog</title>
    <link>https://sjp38.github.io/post/</link>
    <description>Recent content in Posts on Hacklog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Your Name</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0900</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LKML News v5.0-rc8</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc8/</link>
      <pubDate>Tue, 19 Feb 2019 08:33:37 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc8/</guid>
      <description>

&lt;h2 id=&#34;lsf-mm-attend-mm-track-numa-thp-locality-reclaim&#34;&gt;[LSF/MM ATTEND] MM track: NUMA, THP locality, reclaim&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190218143203.GW9565@techsingularity.net&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190218143203.GW9565@techsingularity.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mel Gorman 의 LSF/MM 참여 메일입니다.  NUMA remote THP vs NUMA local non-THP,
NUMA, 메모리 계층 그리고 디바이스 메모리, NUMA rebalancing 과 메모리 reclaim 에
참여하고 싶다고 이야기 하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc7/</link>
      <pubDate>Mon, 18 Feb 2019 12:30:24 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc7/</guid>
      <description>

&lt;h2 id=&#34;patch-v15-00-18-block-support-multi-page-bvec&#34;&gt;[PATCH V15 00/18] block: support multi-page bvec&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190215111324.30129-1-ming.lei@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190215111324.30129-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;시스템의 RAM 이 커지고 huge page 가 널리 사용되면서 물리적으로 연속된
페이지들의 I/O 가 흔해지고 있습니다.  이를 위해 &lt;code&gt;struct bio_bvec&lt;/code&gt; 이 물리적으로
연속된 여러 페이지를 다룰 수 있게 해주는 패치의 15번째 버전입니다.&lt;/p&gt;

&lt;h2 id=&#34;memory-management-facing-a-400gpbs-network-link&#34;&gt;Memory management facing a 400Gpbs network link&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/01000168e2f54113-485312aa-7e08-4963-af92-803f8c7d21e6-000000@email.amazonses.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/01000168e2f54113-485312aa-7e08-4963-af92-803f8c7d21e6-000000@email.amazonses.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;올해 내로 400Gbps 인피니밴드가 가능해질 거라고 합니다!  이건 프로세서-메모리
사이의 밴드위쓰를 넘길 수 있는 스피드죠!  단일 하드웨어 쓰레드는 20GB/s 이기
때문입니다.  이 재미있는 트렌드를 커널은 어떻게 대처해야 할 것인가 하는
메일입니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-generating-physically-contiguous-memory&#34;&gt;[LSF/MM TOPIC] Generating physically contiguous memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CEDBC792-DE5A-42CB-AA31-40C039470BD0@nvidia.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CEDBC792-DE5A-42CB-AA31-40C039470BD0@nvidia.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GPU, FPGA, NIC, RDMA 같은 고성능 디바이스들에게 있어 물리적 연속 메모리는 매우
중요합니다.  이 디바이스들은 내부적으로 고밀도의 computation 을 하는데 tlb miss
와 이어지는 page table walk 로 인한 성능 문제가 CPU 에 비해서도 매우 크기
때문이라는군요.&lt;/p&gt;

&lt;p&gt;Boot time reservation 도, THP 도 유연성이 부족하기 때문에 새로운 패치도 만들고,
관련해서 LSF/MM 에서 논의해 보자는군요.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc7&#34;&gt;Linux 5.0-rc7&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgvF18PqBch4=56DFwCamYpy+owngTZXGnjVbFgKq467g@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgvF18PqBch4=56DFwCamYpy+owngTZXGnjVbFgKq467g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;휴일을 끼고 시작된 머지 윈도우로 이래저래 걱정도 있던 5.0 릴리즈들이었습니다만
이번 rc 릴리즈는 정말 별다른 게 없네요.  매우 고요한 릴리즈였다고 합니다.
아마도 다음주에 5.0 정식 릴리즈가 될 걸로 보이네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc6/</link>
      <pubDate>Mon, 11 Feb 2019 12:40:20 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc6/</guid>
      <description>

&lt;h2 id=&#34;patch-v4-1-1-psi-introduce-psi-monitor&#34;&gt;[PATCH v4 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;] psi: introduce psi monitor&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190206023446.177362-1-surenb@google.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190206023446.177362-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;시스템의 메모리 부족 등의 현상이 어떻게 일어나고 있는지 쉽게 파악할 수 있는
장치를 추가하는 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-address-space-isolation-inside-the-kernel&#34;&gt;[LSF/MM TOPIC] Address space isolation inside the kernel&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190207072421.GA9120@rapoport-lnx&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190207072421.GA9120@rapoport-lnx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스의 어드레스 스페이스 기능은 유저스페이스 프로그램들이 서로에게 영향을
끼치지 못하게 해줘서 컨테이너 등에 쓰이고 있죠.  하지만 커널은 공유하기 때문에
커널 버그는 여전히 영향을 끼칠 수 있습니다.  커널 코드도 어드레스 스페이스를
어느정도 인식하고 코드 분류를 시킴으로써 그 문제를 줄여보자는 LSF/MM 토론 주제
제안입니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-2019-call-for-proposals-updated&#34;&gt;LSF/MM 2019: Call for Proposals (UPDATED!)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/4f5a15c1-4f9e-acae-5094-2f38c8eebd96@kernel.dk&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/4f5a15c1-4f9e-acae-5094-2f38c8eebd96@kernel.dk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;올해 LSF/MM 에는 BPF 트랙이 있을 거라는군요.  이에 따른 공지 업데이트입니다.
BPF 의 상승세가 올해도 계속될 것 같군요!&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-bpf-for-block-devices&#34;&gt;[LSF/MM TOPIC] BPF for Block Devices&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/40D2EB06-6BF2-4233-9196-7A26AC43C64E@raithlin.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/40D2EB06-6BF2-4233-9196-7A26AC43C64E@raithlin.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LSF/MM 에 BPF 라면 당연히 block device 와 BPF 의 결합을 이야기 해야하지
않겠냐는 LSF/MM 토론 제안입니다.  Computational Storage 개념을 이야기 하는데요,
I/O 레이어에서 간단한 연산을 처리해 줌으로써 성능을 높이자는 거죠.  그러기 위한
연산 요청에 BPF 를 쓰자는 것 같습니다.  말 되네요!&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc6&#34;&gt;Linux 5.0-rc6&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whuSY_-hAU8ugVR7a=xz3uZeRrAPdhsoMZHmZ_7Qc49YQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whuSY_-hAU8ugVR7a=xz3uZeRrAPdhsoMZHmZ_7Qc49YQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이제 리눅스 5.0 정식 릴리즈가 얼마 남지 않았네요, 여섯번째 rc 가 나왔습니다.
그런데 이번 rc 는 토발즈가 바랬던 것보다는 조금 변경사항이 많았군요.  대부분
네트워킹 쪽 변경이었다고 합니다만, 그래도 나머지는 큰 문제 없어 보인다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc5/</link>
      <pubDate>Mon, 04 Feb 2019 09:18:08 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc5/</guid>
      <description>

&lt;h2 id=&#34;lsf-mm-topic-page-flags-can-we-free-up-space&#34;&gt;[LSF/MM TOPIC] Page flags, can we free up space ?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190122201744.GA3939@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190122201744.GA3939@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 커널의 page 정보는 &lt;code&gt;PG_&lt;/code&gt; 로 시작하는 플래그를 사용해 현재 상태를
알리는데요, 이걸 저장하는데 사용되는 공간을 더 줄일 수 있을지에 대한 논의를
해보고 싶다는 LSF/MM 제안입니다.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-use-nvdimm-as-numa-node-and-numa-api&#34;&gt;[LSF/MM TOPIC] Use NVDIMM as NUMA node and NUMA API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/f0d66b0c-c9b6-a040-c485-1606041a70a2@linux.alibaba.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/f0d66b0c-c9b6-a040-c485-1606041a70a2@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;알리바바에서는 NVDIMM 을 클라우드 고객들에게 싼 비용의 메모리로 제공하려
한다는군요.  이를 위해 여러 필요성이 있고, 현재 NUMA API 로는 모든 경우를
커퍼하기가 어렵다고 합니다.  때문에, LSFMM 에서 어떤 use-case 와 needs 가
있는지 공유하고 더 나은 NUMA API 에 대해 논의하고자 하는군요.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-memory-reclaim-with-numa-rebalancing&#34;&gt;[LSF/MM TOPIC] memory reclaim with NUMA rebalancing&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190130174847.GD18811@dhcp22.suse.cz&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190130174847.GD18811@dhcp22.suse.cz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;NVDIMM 을 싸고 무척 느린 NUMA 노드로 인식되고 사용되게끔 하고자 하는 노력들이
있습니다.  이게 완벽하게 동작하려면 hot page 는 가깝고 빠른 NUMA node 에, cold
page 는 멀고 느린 NUMA node 에 위치되도록 커널이 조정해줄 필요가 있겠죠.  NUMA
balancing 기능이 있긴 하지만 cold page 를 멀고 느린 NUMA node 로 보내는 기능은
현재까지는 없습니다.  이에 대한 논의를 LSF/MM 에서 시작해 보자고 하네요.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc5&#34;&gt;Linux 5.0-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjoGOgYFCbpazT2Fyv=zHaiagU5PhmiAfrZ5DOmE-y0rg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjoGOgYFCbpazT2Fyv=zHaiagU5PhmiAfrZ5DOmE-y0rg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아무래도 이번 릴리즈들은 머지 윈도우가 길고 연휴와 함께 있었던 탓인지
전체적으로 뭔가 변경사항이 줄지 않는듯 보였는데, 드디어 변경사항이 줄어들고
있다고 합니다.  좋은 신호죠.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the FAST&#39;19</title>
      <link>https://sjp38.github.io/post/fast2019_talk/</link>
      <pubDate>Sat, 02 Feb 2019 11:13:29 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/fast2019_talk/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.usenix.org/conference/fast19/wips&#34; target=&#34;_blank&#34;&gt;FAST&amp;rsquo;19 Work-in-progress 세션&lt;/a&gt;
에서 현재 진행중인 연구에 대해 발표하게 되었습니다.  발표 제목은 &amp;ldquo;Automated
Data Access Pattern Hint Instrumentation for System Performance and Durability
of Swap Storage&amp;rdquo; 입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc4/</link>
      <pubDate>Mon, 28 Jan 2019 09:21:25 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc4/</guid>
      <description>

&lt;h2 id=&#34;patch-0-5-v4-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;&lt;code&gt;[PATCH 0/5] [v4] Allow persistent memory to be used like normal RAM&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190124231441.37A4A305@viggo.jf.intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190124231441.37A4A305@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PMEM 을 평범한 RAM 처럼 접근할 수 있게 해주는 드라이버를 소개하는 패치셋의
네번째 버전입니다.  인터페이스적 측면에서 개선이 많이 됐고, 패치에 대한 소개도
많이 좋아졌네요.&lt;/p&gt;

&lt;p&gt;이 패치셋이 의도하는 PMEM 은 Intel Optane DC persistent memory 와 같은 NVDIMM
입니다.  휘발성이 없고, flash 보다 빠르고, RAM 에 비해 가격 경쟁력이 좋죠.&lt;/p&gt;

&lt;p&gt;RAM-based NVDIMM 은 의도한 대상이 아닙니다.  그것들은 RAM 대비 가격 경쟁력이
없기 때문이라는군요.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-numa-remote-thp-vs-numa-local-non-thp-under-madv-hugepage&#34;&gt;[LSF/MM TOPIC] NUMA remote THP vs NUMA local non-THP under MADV_HUGEPAGE&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190129234058.GH31695@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190129234058.GH31695@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;제목 그대로입니다.  NUMA remote THP 를 쓰는게 나을까요?  THP 를 포기하고 NUMA
local regular page 를 쓰는게 나을까요?  이에 대해서 LSF/MM 에서 이야기 하고
싶다는군요.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc4&#34;&gt;Linux 5.0-rc4&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgNph26eD1zhP91LQLrwB91QPy4=d82SPfvYmSexV7UpQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgNph26eD1zhP91LQLrwB91QPy4=d82SPfvYmSexV7UpQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;어느새 네번째 rc.  이제 5.0 이 그리 멀지 않았네요.  주말 쯤에 갑자기 많은
패치가 밀려왔다고 하지만 큰 문제는 없었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc3</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc3/</link>
      <pubDate>Mon, 21 Jan 2019 09:21:14 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc3/</guid>
      <description>

&lt;h2 id=&#34;lsf-mm-2019-call-for-proposals&#34;&gt;LSF/MM 2019: Call for Proposals&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/51b4b263-a0f2-113d-7bdc-f7960b540929@kernel.dk&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/51b4b263-a0f2-113d-7bdc-f7960b540929@kernel.dk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;올해의 LSF/MM 을 위한 발표 모집입니다.  올해는 푸에르토리코에서 4월 30일부터
5월 2일까지 열리는군요.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-numa-memory-hierarchy-and-device-memory&#34;&gt;[LSF/MM TOPIC] NUMA, memory hierarchy and device memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190118174512.GA3060@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190118174512.GA3060@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LSF/MM 을 위한 발표 지원입니다.
NUMA API 가 다계층 메모리에 적용될 때의 단점에 대해서 이야기 해보겠다는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-00-22-increase-success-rates-and-reduce-latency-of-compaction-v3&#34;&gt;[PATCH 00/22] Increase success rates and reduce latency of compaction v3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190118175136.31341-1-mgorman@techsingularity.net&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190118175136.31341-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mel Gorman 의 compaction 개선 패치셋 세번째 버전입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc3&#34;&gt;Linux 5.0-rc3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whS=6Z_UxzoMjLANupOk3u-8ycERLPnaZxShMTviW0jkQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whS=6Z_UxzoMjLANupOk3u-8ycERLPnaZxShMTviW0jkQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.0 세번째 릴리즈입니다.  지난 릴리즈에서 여행 중이지만 항상 그렇듯 일요일
릴리즈를 하려 한다고 했는데, 이번에도 성공적이군요.  더불어 어디 여행 중인지도
나왔습니다, LCA 2019 여행 중이었군요.  여담이지만 올해 LCA 도 재밌는 발표가
많은 것 같습니다.&lt;/p&gt;

&lt;p&gt;지난 rc2 에서 머지하는 걸 빼먹은 네트워킹 쪽 풀리퀘스트를 이번에 머지했기
때문에 이번 rc3 는 조금 크다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc2</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc2/</link>
      <pubDate>Tue, 15 Jan 2019 09:06:44 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc2/</guid>
      <description>

&lt;h2 id=&#34;patch-v11-00-26-speculative-page-faults&#34;&gt;[PATCH v11 00/26] Speculative page faults&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/8b0b2c05-89f8-8002-2dce-fa7004907e78@codeaurora.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/8b0b2c05-89f8-8002-2dce-fa7004907e78@codeaurora.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SPF 패치에서 발견된 버그 레포트입니다.  ARM 위에서 데드락 문제가 발견되었군요.
버그 발견자가 패치도 같이 내놓았는데, 이에 대한 토론은 아직도 계속되고 있네요.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-v7-00-16-add-support-for-exclusive-page-frame-ownership&#34;&gt;[RFC PATCH v7 00/16] Add support for eXclusive Page Frame Ownership&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/cover.1547153058.git.khalid.aziz@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/cover.1547153058.git.khalid.aziz@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;lsquo;ret2dir&amp;rsquo; 보안 공격[1]에 대비하기 위한 패치입니다.  하지만 이로 인해 tlb 를 좀
많이 flush 해야 하는 문제가 있었고, 이 패치셋은 그에 대한 해결책도 의논하고
있습니다.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf&#34; target=&#34;_blank&#34;&gt;http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;patch-0-4-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;[PATCH 0/4] Allow persistent memory to be used like normal RAM&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190116181859.D1504459@viggo.jf.intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190116181859.D1504459@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PMEM 을 사용하기 위해선 현재로썬 어플리케이션 코드를 수정해야 합니다.  그냥
평범한, 조금 느린 RAM 처럼 어플리케이션이 기존에 RAM 접근하듯 접근할 수 있게
하면 안될까요?  이 패치셋은 그런 경우를 위한 드라이버를 소개합니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-0-5-psi-pressure-stall-monitors-v2&#34;&gt;[PATCH v2 0/5] psi: pressure stall monitors v2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190110220718.261134-1-surenb@google.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190110220718.261134-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LWN 에서도 소개된 pressure stall monitor 의 두번째 버전입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc2&#34;&gt;Linux 5.0-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wicCXd7nALwEz+022iNesJV3DUmejS+dzVRE0D3UGzs_g@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wicCXd7nALwEz+022iNesJV3DUmejS+dzVRE0D3UGzs_g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.x 로 나아가는 두번째 릴리즈 후보가 나왔습니다.  이번 머지 윈도우가 휴일이
섞여 있었기 때문에 두번째 rc 를 위한 과정에 문제가 있지 않을까 싶었지만 별 문제
없었다는군요.  그리고 지금 토발즈는 여행중이라 현지시간으로는 항상 하는 일요일
릴리즈가 아니라 월요일 릴리즈라 합니다만, 뭐&amp;hellip; 큰 이슈는 아니죠 ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.0-rc1/</link>
      <pubDate>Mon, 07 Jan 2019 11:18:50 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.0-rc1/</guid>
      <description>

&lt;h2 id=&#34;rfc-v3-0-3-test-driver-to-analyse-vmalloc-allocator&#34;&gt;[RFC v3 0/3] test driver to analyse vmalloc allocator&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190102085924.14145-1-urezki@gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190102085924.14145-1-urezki@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;vmalloc 의 성능과 스트레스 테스트를 위한 모듈을 구현한 패치입니다.  Selftests
에도 테스트 스크립트를 추가했군요.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-0-1-mm-add-a-warning-about-high-order-allocations&#34;&gt;[RFC PATCH 0/1] mm: add a warning about high order allocations&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181225153927.2873-1-khorenko@virtuozzo.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181225153927.2873-1-khorenko@virtuozzo.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;특정 노드의 메모리에 접근이 많이 되고 있는 상황에서 해당 메모리가 fragment 되어
있고 이 시점에서 high order allocation 이 요청되면 이걸 위해 compaction 등이
작동하니까 다른 태스크의 latency 가 떨어질 수 있습니다.  이런 상황을 모니터링
할 수 있게끔, 이 패치는 &lt;code&gt;vm.war_high_order&lt;/code&gt; 라는 값을 sysctl 통해 설정하면 이
값을 넘는 order 의 allocation 이 요청되었을 때 워닝을 뱉어 줍니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-mm-introduce-page-size&#34;&gt;[PATCH] mm: Introduce page_size()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181231134223.20765-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181231134223.20765-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Huge page 의 존재로 인해 페이지의 실제 크기는 모두 똑같지가 않기 때문에 이를
판별할 방법이 필요하죠.  이 패치는 단순히 기존에 좀 복잡하게 직접 페이지 크기를
구하던 것을 별도의 wrapper function 으로 대체하기 위한 준비 작업입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-0-rc1&#34;&gt;Linux 5.0-rc1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wgKYnrL3LjhVkH2Fp+ecmWhLqezT9zmR6CzfcpwcJX0qA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/wgKYnrL3LjhVkH2Fp+ecmWhLqezT9zmR6CzfcpwcJX0qA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 커널 버전의 숫자가 큰 의미 없게 된지도 오래이긴 합니다만 그래도 메이저
버전 변경은 항상 뭔가 들뜨게 마련이죠.
드디어 5.x 커널의 시대가 시작되었습니다.&lt;/p&gt;

&lt;p&gt;연말/연처 휴일이 섞여 있는 덕에 꽤 오랫만의 릴리즈가 되었고, 그덕에 좀 늦게
풀리퀘스트가 온 것들도 있었지만 큰 문제는 없었다고 하네요.&lt;/p&gt;

&lt;p&gt;메이저 버전이 4.x 에서 5.x 로 바뀌긴 했지만 손가락 발가락 다 써도 4.21 의
버전은 셀수가 없기 때문에 5.x 로 바뀌었을 뿐 특별한 변경이나 새로운 기능은
없다는 점도 한번 더 공지합니다.
하지만 많은 기능들이 추가된 것도 사실이니 원하면 하나 꼽아들고 이거 때문에 5.x
로 업데이트 되었다고 생각해도 좋다고 하는군요.&lt;/p&gt;

&lt;p&gt;이번 릴리즈는 총 11000여개의 커밋을 받아들인 긴 머지 윈도우를 거쳤지만,
그렇다고 유별날 건 없다는군요.  절반 가량이 드라이버, 20%는 아키텍쳐, 10% 툴링,
나머진 여기저기.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perf symbol problem on Linux 4.19</title>
      <link>https://sjp38.github.io/post/perf_symbol_problem_4.19/</link>
      <pubDate>Fri, 21 Dec 2018 17:00:22 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/perf_symbol_problem_4.19/</guid>
      <description>&lt;p&gt;4.19 커널에서 오랫만에 perf 를 다시 빌드하고 써보려고 하니, &lt;code&gt;perf report&lt;/code&gt; 가
아래와 같이 제대로 된 symbol name 을 찾질 못합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo perf record -g ls
arch                     builtin-ftrace.c    builtin-report.c     Documentation       perf.data.old
bench                    builtin.h           builtin-sched.c      examples            perf.h
Build                    builtin-help.c      builtin-script.c     include             perf-read-vdso.c
builtin-annotate.c       builtin-inject.c    builtin-stat.c       jvmti               perf-sys.h
builtin-bench.c          builtin-kallsyms.c  builtin-timechart.c  Makefile            perf-with-kcore.sh
builtin-buildid-cache.c  builtin-kmem.c      builtin-top.c        Makefile.config     pmu-events
builtin-buildid-list.c   builtin-kvm.c       builtin-trace.c      Makefile.perf       python
builtin-c2c.c            builtin-list.c      builtin-version.c    MANIFEST            scripts
builtin-config.c         builtin-lock.c      check-headers.sh     perf-archive.sh     tests
builtin-data.c           builtin-mem.c       command-list.txt     perf.c              trace
builtin-diff.c           builtin-probe.c     CREDITS              perf-completion.sh  ui
builtin-evlist.c         builtin-record.c    design.txt           perf.data           util
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.025 MB perf.data (21 samples) ]
sjpark@hydra:~/linux/tools/perf$ sudo perf report --stdio
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 21  of event &#39;cycles:ppp&#39;
# Event count (approx.): 2712237
#
# Children      Self  Command  Shared Object      Symbol
# ........  ........  .......  .................  .................................
#
    59.39%     0.00%  ls       [unknown]          [k] 0xffffffffa8a00088
            |
            ---0xffffffffa8a00088
               |
               |--51.91%--0xffffffffa8004185
               |          |
               |          |--17.13%--0xffffffffa8212c8b
               |          |          0xffffffffa8212afe
               |          |          0xffffffffa821274a
               |          |          0xffffffffa81bb3c5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;왜이러지 하고 삽질하다가 알고보니 perf 쪽 최신 커밋인 edeb0c90df35 (&amp;ldquo;perf
tools: Stop fallbacking to kallsyms for vdso symbols lookup&amp;rdquo;) 이 만든 버그군요.
해당 커밋만 revert 하고 perf 를 다시 빌드하면 다시 잘 됩니다.&lt;/p&gt;

&lt;p&gt;저만 겪는 문제는 아닌지 버그질라에도 이에 대한 이슈가 올라와 있네요:
&lt;a href=&#34;https://bugzilla.kernel.org/show_bug.cgi?id=201551&#34; target=&#34;_blank&#34;&gt;https://bugzilla.kernel.org/show_bug.cgi?id=201551&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News for v4.20</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20/</link>
      <pubDate>Fri, 21 Dec 2018 08:35:03 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20/</guid>
      <description>

&lt;h2 id=&#34;patch-v5-0-3-mm-kvm-vfio-ppc64-migrate-compound-pages-out-of-cma&#34;&gt;[PATCH V5 0/3] mm/kvm/vfio/ppc64: Migrate compound pages out of CMA&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181219034047.16305-1-aneesh.kumar@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181219034047.16305-1-aneesh.kumar@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ppc64 에서는 guest os page table 을 CMA area 내에 할당하는데, VFIO 를 쓰는 경우
이게 pinning 되어 있다 보니 CMA area 밖으로 migrate 하는데 실패해, guest os
page table 할당에 실패하고, 이로 인해 guest 시작조차 불가능하게 되는 문제가
있었습니다.&lt;/p&gt;

&lt;p&gt;이 패치는 compound page 에 대해서도 CMA area 밖으로의 migration 이 가능하게
합니다.&lt;/p&gt;

&lt;h2 id=&#34;resend-patch-v3-0-5-arm64-mm-enable-hugetlb-migration&#34;&gt;[RESEND PATCH V3 0/5] arm64/mm: Enable HugeTLB migration&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1545121450-1663-1-git-send-email-anshuman.khandual@arm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1545121450-1663-1-git-send-email-anshuman.khandual@arm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;HugeTLB 를 통째로 migrate 할 수 있게 하는 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-0-2-hugetlbfs-use-i-mmap-rwsem-for-better-synchronization&#34;&gt;[PATCH v2 0/2] hugetlbfs: use i_mmap_rwsem for better synchronization&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181218223557.5202-1-mike.kravetz@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181218223557.5202-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hugetlbfs 와 truncation 사이에 race conditional bug 가 존재해 왔는데, 이 패치는
&lt;code&gt;i_mmap_rwsem&lt;/code&gt; 을 사용해 동기화를 적용함으로써 이 race bug 를 제거합니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-1-2-mm-swap-check-if-swap-backing-device-is-congested&#34;&gt;[RFC PATCH &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;] mm: swap: check if swap backing device is congested&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1545115948-25467-1-git-send-email-yang.shi@linux.alibaba.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1545115948-25467-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Swap readahead 기능이 이미 다른 요청으로 바쁜 storage device 에 행해진다면 swap
자체 성능도 떨어지고 storage 를 더욱 바빠지게 해서 남들에게도 민폐가 됩니다.
&lt;code&gt;vma_cluster_radahead()&lt;/code&gt; 에서 먼저 storage 의 congestion 을 체크해 보게 하는
패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-4-20-released&#34;&gt;Linux 4.20 released..&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wg0zF4wa87Q5rAhFe2es0t0eExX2UjvKD7-Pghvcbt5Vw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wg0zF4wa87Q5rAhFe2es0t0eExX2UjvKD7-Pghvcbt5Vw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;예정대로 4.20 이 정식 릴리즈 되었습니다.  원했던 것보단 조금 시끄러운
주간이었지만 어쨌건 연말 휴일을 방해하고 싶진 않고 정말 큰 문제가 있는 것 같아
보이진 않기에 릴리즈 했다고 합니다.&lt;/p&gt;

&lt;p&gt;이번 정식 릴리즈에서 개인적으로 눈길 가는건 XArray 입니다.  앞으로도 많은
영역에 쓰이고자 하는 것 같던데, 향후 행보도 궁금합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20-rc7/</link>
      <pubDate>Mon, 17 Dec 2018 09:16:11 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20-rc7/</guid>
      <description>

&lt;h2 id=&#34;patch-v9-00-21-swap-swapout-swapin-thp-in-one-piece&#34;&gt;[PATCH -V9 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181214062754.13723-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181214062754.13723-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아직 머지되지 못한 THP swap in 패치셋의 아홉번째 버전입니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-0-3-reduce-thp-fault-thrashing&#34;&gt;[RFC 0/3] reduce THP fault thrashing&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181211142941.20500-1-vbabka@suse.cz&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181211142941.20500-1-vbabka@suse.cz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;THP fault 로 인한 로컬 노드 thrashing 을 해결하기 위한 패치의 RFC 입니다.  THP
fault 성공률을 낮추는 부작용도 있긴 하군요.  아직 테스트도 안된 첫번째 RFC
이니, 이대로 머지되진 않겠지 싶긴 합니다만 재밌네요.&lt;/p&gt;

&lt;h2 id=&#34;linux-4-20-rc76&#34;&gt;Linux 4.20-rc76&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whv9u9aTEPoCz8h83JJbVK4fmHELJF=GG01ht9=1_MaCQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whv9u9aTEPoCz8h83JJbVK4fmHELJF=GG01ht9=1_MaCQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;일곱번째 rc 버전의 릴리즈입니다&amp;hellip; 만, 이번엔 릴리즈 메일 제목에 오타가
있었군요.  전체적으로 일곱번째인만큼 변경사항이 적습니다.  릴리즈 하는 토발즈
입장에선 반가운 일이군요.  특히나 연휴가 다가오니까요.&lt;/p&gt;

&lt;p&gt;릴리즈 계획은 기존과 같이, 크리스마스 전에 4.20 버전을 릴리즈하고, 이후에 머지
윈도우를 가질텐데, 가급적이면 연휴 전에 미리미리 풀리퀘스트를 보내달라고
하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20-rc6/</link>
      <pubDate>Wed, 05 Dec 2018 08:20:36 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20-rc6/</guid>
      <description>

&lt;h2 id=&#34;patch-memory-model-0-3-updates-to-the-formal-memory-model&#34;&gt;[PATCH memory-model 0/3] Updates to the formal memory model&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181203230411.GA27476@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181203230411.GA27476@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 커널 메모리 모델의 업데이트 입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;smp_mb__after_unlock_lock()&lt;/code&gt; 을 추가로 모델링했고, github 리트머스 테스트를
체크하기 위한 스크립트가 추가되었으며, &lt;code&gt;-j&lt;/code&gt; 옵션을 서포트 하게 되었습니다.&lt;/p&gt;

&lt;h2 id=&#34;tip-core-rcu-tracing-replace-synchronize-sched-and-call-rcu-sched&#34;&gt;[tip:core/rcu] tracing: Replace synchronize_sched() and call_rcu_sched()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/tip-7440172974e85b1828bdd84ac6b23b5bcad9c5eb@git.kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/tip-7440172974e85b1828bdd84ac6b23b5bcad9c5eb@git.kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;synchronize_rcu()&lt;/code&gt; 가 이제는 RCU read-side 크리티컬 섹션 만이 아니라
preempt-disable 코드 영역도 기다리므로, &lt;code&gt;synchronize_sched()&lt;/code&gt; 를 대체할 수
있고, &lt;code&gt;call_rcu_sched()&lt;/code&gt; 도 &lt;code&gt;call_rcu()&lt;/code&gt; 로 대체될 수 있습니다.  이 패치는 이
대체를 진행하고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v8-00-21-swap-swapout-swapin-thp-in-one-piece&#34;&gt;[PATCH -V8 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181207054122.27822-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181207054122.27822-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 블로그를 통해 여러번 공유한 THP 를 통째로 스왑아웃 / 스왑인 하는 패치입니다.
Daniel 에 의해 레포트된 버그 하나를 고쳐서 여덟번째 버전이 올라왔습니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-4-20-rc6&#34;&gt;Linux 4.20-rc6&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wgHSX8x6mOB0xZibbg-xc3veqsQEnHZ1+3H2DbO5MU5Rw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/wgHSX8x6mOB0xZibbg-xc3veqsQEnHZ1+3H2DbO5MU5Rw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;지난 rc5 릴리즈는 평소와 달리 굉장히 규모가 컸기에 걱정이 있었죠.  이번
릴리즈에는 확연히 변경의 양이 줄어들었다고 합니다.  뭔가 다시 정상적으로 간다는
거죠.  토발즈는 어쨌건 4.20 릴리즈 전에 최소한 하나의 rc 릴리즈는 더 있을
거라고 하는군요.  하지만 여전히 크리스마스 휴일 시즌을 위해 크리스마스 전에
릴리즈를 마치고, 이후 일주일은 푹 쉴테니 그전에 풀리퀘스트도 준비해 두라고
하네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by 4.20-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20-rc5/</link>
      <pubDate>Thu, 29 Nov 2018 08:14:01 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20-rc5/</guid>
      <description>

&lt;h2 id=&#34;patch-v12-00-20-block-support-multi-page-bvec&#34;&gt;[PATCH V12 00/20] block: support multi-page bvec&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181126021720.19471-1-ming.lei@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181126021720.19471-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;struct bio_bvec&lt;/code&gt; 하나가 물리적으로 연속적인 여러개의 페이지를 담을 수 있게
해서 block layer 의 효율성을 높이기 위한 시도입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-aio-convert-ioctx-table-to-xarray&#34;&gt;[PATCH] aio: Convert ioctx_table to XArray&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181128183531.5139-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181128183531.5139-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;aio 쪽의 &lt;code&gt;ioctx_table&lt;/code&gt; 이라는 자료구조가 스펙터에 취약한 자료구조인데, 인덱스
오버플로 문제가 없는 XArray 로 교체하는 패치입니다.  정말 코드가
깔끔해지는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-4-v4-drop-the-mmap-sem-when-doing-io-in-the-fault-path&#34;&gt;&lt;code&gt;[PATCH 0/4][V4] drop the mmap_sem when doing IO in the fault path&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181130195812.19536-1-josef@toxicpanda.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181130195812.19536-1-josef@toxicpanda.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ps&lt;/code&gt; 등의 도구를 사용해 시스템 상황을 모니터링하는 커다란 어플리케이션을 사용
중인데, 이 과정에서 다른 &lt;code&gt;task&lt;/code&gt; 의 &lt;code&gt;mmap_sem&lt;/code&gt; 을 &lt;code&gt;down_read()&lt;/code&gt; 해야 하는 경우가
종종 생긴다는군요.  문제는 이 &lt;code&gt;mmap_sem&lt;/code&gt; 의 쓰기 권한을 얻어오는 과정이 사실상
mutex 와 동일하니 레이턴시가 크게 늘어날 때가 종종 생긴다고 합니다.  이 문제를
해결하기 위해 &lt;code&gt;retry&lt;/code&gt; 메커니즘을 적용하는 패치셋입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-0-9-use-vm-insert-range&#34;&gt;[PATCH v2 0/9] Use vm_insert_range&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181202061707.GA3070@jordon-HP-15-Notebook-PC&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181202061707.GA3070@jordon-HP-15-Notebook-PC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;드라이버가 자신의 커널 메모리를 사용자 vma 로 매핑하는 방법은
&lt;code&gt;vm_insert_page()&lt;/code&gt; 를 사용하는 방식이었고, 여러 페이지를 매핑하려면 이 함수를
루프를 돌면서 수행해야 했는데요, 이게 좀 귀찮으므로 아예 &lt;code&gt;vm_insert_range()&lt;/code&gt;
라는 함수를 추가한 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-4-20-rc5&#34;&gt;Linux 4.20-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wizcNrsoyCM1EXQqoswMCYsJaby2iAkZb9wBAzDEhvxNg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wizcNrsoyCM1EXQqoswMCYsJaby2iAkZb9wBAzDEhvxNg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;벌써 다섯번째 rc 릴리즈이므로 변경내용이 줄어들어야 할 타이밍이지만, 이상하게도
이번 릴리즈는 -rc1 을 제외하고는 가장 변경이 큰 릴리즈라는군요.  게다가 arch 쪽
변경사항이 꽤 많은데, 아마도 STIPB 쪽 성능 리그레션 때문인 것으로 보인다고
합니다.  아무튼 일반적인 모습은 아니다보니 릴리즈 일정이 변경될 가능성이
생겼는데요, 너무 미루면 연말연초 휴일에 머지 윈도우가 겹치게 되는데 토발즈는
휴일 동안 머지 윈도우 관리하기 싫고, 그렇다고 더 미루면 토발즈도 1월 후반에
여행 갈거고, 남들도 휴일에 머지 윈도우를 준비하기가 싫을 거라 고민이라
하는군요.&lt;/p&gt;

&lt;p&gt;결국 일단은 크리스마스 직전 쯤 4.20 을 릴리즈 하고, 남들도 머지 윈도우 준비를
그 전까지 마치는 걸 제안하고 있습니다.  물론, rc6 에서도 변경사항이 충분히
줄어들지 않는다면 릴리즈 일정은 더 늦춰질 수 있겠죠.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20-rc4/</link>
      <pubDate>Mon, 26 Nov 2018 08:06:40 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20-rc4/</guid>
      <description>

&lt;h2 id=&#34;patch-v7-00-21-swap-swapout-swapin-thp-in-one-piece&#34;&gt;[PATCH -V7 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181120085449.5542-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181120085449.5542-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Transparent Huge Page 를 쪼개지 않고 swap out / swap in 함으로써 스왑 성능을
최적화 하는 패치의 일곱번째 버전입니다.  이 블로그에서도 소개한 바 있죠.  크게
바뀐 부분은 없지만 최신 버전에 맞춰 리베이스 되었고, Daniel 에 의해 발견된 주소
정렬 관련 문제를 해결했군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-5-fragmentation-avoidance-improvements-v5&#34;&gt;[PATCH 0/5] Fragmentation avoidance improvements v5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181123114528.28802-1-mgorman@techsingularity.net&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181123114528.28802-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;시스템이 충분히 오래 운영되거나 특정한 패턴의 워크로드가 동작하게 되면 시스템의
메모리는 fragment 되게 마련이어서, 장기적으로 물리적 연속 페이지 할당이
실패하게 됩니다.  이 패치셋은 메모리 분절화를 야기하는 워크로드 (이벤트)를
정의하고 그런 이벤트의 발생을 줄이는 내용을 담고 있습니다.&lt;/p&gt;

&lt;p&gt;최적화 방법은 다음과 같습니다.  먼저, lower id free list 가 사용 가능하면 high
order free list 를 쪼개기보다 그걸 먼저 사용합니다.  메모리 분절화 이벤트가
발생하면 임시적으로 워터마크를 높입니다.  kswapd 가 일어나서 적은양의 오래된
메모리를 리클레임하고, 이어서 kcompactd 가 일어나서 시스템 메모리 연속성을
복구시킵니다.  물론 이는 오버헤드를 추가합니다.  마지막으로, kswapd 가 진전을
일으킬 수 있도록 일부 movable 페이지 할당을 기다리게 합니다.  이 기다리는 시간
역시 오버헤드와 연관되므로 적절히 맞춰질 필요가 있겠죠.&lt;/p&gt;

&lt;p&gt;이 패치셋을 적용한 결과 94% 이상 메모리 분절화를 줄일 수 있었다고 합니다.&lt;/p&gt;

&lt;h2 id=&#34;git-pull-xarray-updates&#34;&gt;[GIT PULL] XArray updates&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181124173209.GZ3065@bombadil.infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181124173209.GZ3065@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;XArray 는 작년 OSSummit 에서 처음 발표를 들은 후 주의 깊게 보고 있었는데 이번에
머지되었고 커널 서밋에서도 발표를 들었는데 매우 인상적이었습니다.  DAX 가
XArray 를 사용하도록 수정한 후 DAX 의 버그가 발견되었고, 그에 대한 수정을
포함한 수정사항들을 담은 풀 리퀘스트입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-4-20-rc4&#34;&gt;Linux 4.20-rc4&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgdsXyCaLsFEpyUpAeRqVS69u=xo4rzEN+cS=xwz2gajg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgdsXyCaLsFEpyUpAeRqVS69u=xo4rzEN+cS=xwz2gajg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.x 의 마지막이 될 예정인 4.20을 향한 네번째 rc 버전 릴리즈입니다.  변경의 60
퍼센트가 드라이버고, 나머진 네트워킹, 파일시스템쪽 수정과 arch, 문서화
업데이트고 xarray 쪽 수정도 있었군요.  평소와 다를바 없어서 평이한 릴리즈라 할
수 있지만, STIBP 수정이라던지 mm 쪽 수정에 대한 논의가 안끝났다던지 하는 부분은
남아있다는군요.&lt;/p&gt;

&lt;p&gt;한가지 지난 릴리즈 때 이야기 할 것을 빼먹은 것도 이야기 하는데, 풀 리퀘스트에
대한 응답 메일을 Konstantin 이 자동화 했기 때문에 더이상 토발즈 자신이 하나하나
답장을 보내지 않는다는 겁니다.  그리고 이 자동화의 구성상 LKML 의 &lt;code&gt;linux-*&lt;/code&gt;
그룹을 cc 하지 않으면 ack 을 주지 않는데, 그걸로 인해 혼동이 있을 수 있었겠다고
하는군요.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
