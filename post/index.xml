<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hacklog</title>
    <link>https://sjp38.github.io/post/</link>
    <description>Recent content in Posts on Hacklog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Your Name</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0900</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Lkml_news_v4.18 Rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc6/</link>
      <pubDate>Tue, 24 Jul 2018 06:19:53 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc6/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc6&#34;&gt;Linux 4.18-rc6&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번 rc는 평소보다 조금 크게 되었는데, 네트워킹 쪽 메인테이너인 David 가 많은
수정사항을 아직 보내지 않았다가 이번에 모아서 보냈기 때문이라는군요.  그렇다
해도 그렇게 큰 양까진 아니라는 토발즈의 설명입니다.&lt;/p&gt;

&lt;p&gt;지난 rc5 작업 주간을 귀찮게 했던 VM 버그에 대한 두줄의 수정이 rc5 에
들어갔었지만 32비트 환경에 대한 고려가 없었기에 이번에 그 수정이
들어갔다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Alpine for LKML</title>
      <link>https://sjp38.github.io/post/alpine-for-lkml/</link>
      <pubDate>Wed, 18 Jul 2018 21:09:54 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/alpine-for-lkml/</guid>
      <description>

&lt;p&gt;리눅스 커널 커뮤니티는 버그 레포팅, 패치 업로드, 리뷰, 릴리즈, 토론 등등 모든
활동은 이메일을 통해 이루어집니다.  이 포스트에서는 리누스 토발즈도 쓰는 이메일
클라이언트인 Alpine 을 gmail 과 연동하는 방법을 알아봅니다.&lt;/p&gt;

&lt;p&gt;먼저 alpine 설치는 대부분 리눅스 배포판의 패키지 시스템에 등록되어 있으므로
해당 패키지 시스템을 사용해 쉽게 설치할 수 있습니다.  데비안 계열이면 &lt;code&gt;apt
install alpine&lt;/code&gt;, 페도라 계열이면 &lt;code&gt;dnf install alpine&lt;/code&gt; 이죠.&lt;/p&gt;

&lt;h1 id=&#34;gmail-imap-정보-입력&#34;&gt;gmail imap 정보 입력&lt;/h1&gt;

&lt;p&gt;S (Settings) -&amp;gt; L (collectionLists) -&amp;gt; A (Add Cltn)&lt;/p&gt;

&lt;p&gt;Nickname: gmail or anything
Server: imap.gmail.com/ssl/user=sj@gmail.com&lt;/p&gt;

&lt;p&gt;^X (Commit change)
E (Exit Setup)&lt;/p&gt;

&lt;h1 id=&#34;smtp-서버-설정&#34;&gt;SMTP 서버 설정&lt;/h1&gt;

&lt;p&gt;S (Setup) -&amp;gt; C (config)&lt;/p&gt;

&lt;p&gt;SMTP server: smtp.gmail.com/tls/user=sj@gmail.com&lt;/p&gt;

&lt;h2 id=&#34;쓰레드-기반-소팅&#34;&gt;쓰레드 기반 소팅&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[Sort key]&lt;/code&gt;: tHread (enter)&lt;/p&gt;

&lt;h2 id=&#34;리눅스-커널-커뮤니티에서-요구하는-설정&#34;&gt;리눅스 커널 커뮤니티에서 요구하는 설정&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[Sending Preferences]&lt;/code&gt;: Do Not Send Flowed Text, Strip Whitespace Before Sending&lt;/p&gt;

&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://harbhag.wordpress.com/2010/07/14/configure-alpine-to-sendreceive-emails-from-gmail/&#34; target=&#34;_blank&#34;&gt;https://harbhag.wordpress.com/2010/07/14/configure-alpine-to-sendreceive-emails-from-gmail/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc5/</link>
      <pubDate>Mon, 16 Jul 2018 06:07:33 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc5/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc5&#34;&gt;Linux 4.18-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/A+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/A+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다섯번째 rc 릴리즈입니다.  토발즈 개인적으로는 조금 바쁘단 느낌이 있었지만
숫자로 보면 평범한 rc 릴리즈 주간이었다는 평입니다.&lt;/p&gt;

&lt;p&gt;토발즈를 귀찮게 만들었던 건 VM 쪽 버그로, 단 두줄의 수정으로 고쳐졌다는데,
아무래도 아래 패치인 것 같군요:
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bce73e4842390f7b7309c8e253e139db71288ac3&#34; target=&#34;_blank&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bce73e4842390f7b7309c8e253e139db71288ac3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그리고 repeatable sequence 에 대한 cleanup 도 있었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc4/</link>
      <pubDate>Mon, 09 Jul 2018 10:01:05 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc4/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc4&#34;&gt;Linux 4.18-rc4&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwXGyZ1Yx+Z8a93gpvb596ZRJ5ppiQL_+-k7gjeQLtcsQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFwXGyZ1Yx+Z8a93gpvb596ZRJ5ppiQL_+-k7gjeQLtcsQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;어느덧 네번째 RC 버전 릴리즈입니다.  지루할 정도로 평범한 릴리즈라는군요.
대부분 드라이버쪽 업데이트이고, bpf, cifs, ext4, 스케쥴러, 그리고 일부 arch
업데이트가 대부분입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc3</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc3/</link>
      <pubDate>Mon, 02 Jul 2018 11:18:24 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc3/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc3&#34;&gt;Linux 4.18-rc3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwGk-pWKKCtp+kQUN_hov9tW+vUo6Wgob91bewwBL17fA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFwGk-pWKKCtp+kQUN_hov9tW+vUo6Wgob91bewwBL17fA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.18 을 향하는 세번째 릴리즈입니다.  그간 일본에 중국을 방문하고 있던 토발즈가
집에 돌아와서 이번엔 평소처럼 한국시간으로는 월요일 아침 릴리즈가 되었군요.&lt;/p&gt;

&lt;p&gt;큰 이상은 없고 드라이버, arch, 파일시스템 등에 변경이 있군요.&lt;/p&gt;

&lt;p&gt;그리고, 오늘이 리누스 토발즈가 리눅스 파운데이션 소속으로 일하게 된지
15주년이라는군요.  리눅스 파운데이션도 리눅스도 오래오래 건강했으면 좋겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-0-2-x86-numa-emulation-introduce-uniform-split-capability&#34;&gt;[PATCH v2 0/2] x86/numa_emulation: Introduce uniform split capability&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/153089327581.27680.11402583130804677094.stgit@dwillia2-desk3.amr.corp.intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/153089327581.27680.11402583130804677094.stgit@dwillia2-desk3.amr.corp.intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;X86 에서는 커널 패러미터를 줘서 NUMA emulation 이 가능한데, 각 NUMA node 의
메모리 사이즈를 모두 똑같게 하기보다는 요청된 NUMA node 수를 맞추는걸 우선시
하고 있습니다.  이 패치는 해당 커널 패러미터에 &amp;lsquo;U&amp;rsquo; suffix 를 주면 사이즈를
동일하게 맞추는 걸 우선시하게 만들어주도록 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc2</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc2/</link>
      <pubDate>Mon, 25 Jun 2018 08:45:22 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc2/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc2&#34;&gt;Linux 4.18-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/alpine.LFD.2.21.999.1806242116240.20621@xps13.linux-foundation.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/alpine.LFD.2.21.999.1806242116240.20621@xps13.linux-foundation.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번주도 지난주처럼 평소보단 빠른 릴리즈입니다.  토발즈가 여전히
여행중이라는군요.  지난주엔 일본이었고, 이번주는 중국이라는군요.  그런고로 중국
시간으로 일요일 저녁의 rc 릴리즈입니다.&lt;/p&gt;

&lt;p&gt;이번 rc 에서도 큰 변경은 없고 평범한 rc 입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-tip-core-rcu-0-40-rcu-gp-seq-conversion-for-v4-19&#34;&gt;[PATCH tip/core/rcu 0/40] RCU -&amp;gt;gp_seq conversion for v4.19&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180626000841.GA15696@linux.vnet.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180626000841.GA15696@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RCU 의 &lt;code&gt;-&amp;gt;gpnum&lt;/code&gt; 과 &lt;code&gt;-&amp;gt;completed&lt;/code&gt; 필드를 하나의 &lt;code&gt;-&amp;gt;gp_seq&lt;/code&gt; 로 대체하는
패치입니다.  그동안 &lt;code&gt;-&amp;gt;gpnum&lt;/code&gt; 과 &lt;code&gt;-&amp;gt;completed&lt;/code&gt; 로 grace period 를 관리해오고
있지만 사실상 &lt;code&gt;-&amp;gt;gpnum&lt;/code&gt; 과 &lt;code&gt;-&amp;gt;completed&lt;/code&gt; 는 수가 똑같거나 하나 차이이니 하나의
bit 으로도 같은 정보를 처리할 수 있을 뿐더러 로드 횟수를 두번에서 한번으로 줄일
수 있다는 거죠.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.18-rc1/</link>
      <pubDate>Sun, 17 Jun 2018 11:59:59 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.18-rc1/</guid>
      <description>

&lt;h2 id=&#34;linux-4-18-rc1&#34;&gt;Linux 4.18-rc1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw34Dh6p0qAZ_Ja=fjuJ89ojZZTWtmrRPKmB1QuP3C7hw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFw34Dh6p0qAZ_Ja=fjuJ89ojZZTWtmrRPKmB1QuP3C7hw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;평소보다 많이 빠르게 4.18 머지윈도우가 닫혔습니다.  토발즈가 지금 일본에 있기 때문에 자기는 이미 일요일이고, 오후엔 뱃놀이 하러 갈거라서 일찍 릴리즈 한다네요.&lt;/p&gt;

&lt;p&gt;전체적으로 크기에서도 한 일에 있어서도 평범한 릴리즈입니다.  4.17 에서 더이상 사용되지 않는 과거 코드 삭제를 많이 했던 것처럼 이번에도 미사용 코드 제거가 좀 있군요, 하지만 4.17 때만큼 큰 변화는 아닙니다.&lt;/p&gt;

&lt;p&gt;제거된 컴포넌트들 가운데 특이할만한 점은 Lustre 의 제거군요.  Staging 트리에서 머물던 Lustre 는 계속 out of tree 로 개발이 진행되어왔고, Staging 딱지를 떼지 못한채 커널 소스트리에서 제거되게 되었습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v7-rebased-00-17-improve-shrink-slab-scalability-old-complexity-was-o-n-2-new-is-o-n&#34;&gt;[PATCH v7 REBASED 00/17] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/152931465724.27697.12828290733260370115.stgit@localhost.localdomain&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/152931465724.27697.12828290733260370115.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;지난번에도 소개한 패치의 v7 입니다.  시스템에 여러 shrinker 들과 memcg cgroup
이 등록되어 있는 경우 이 shrinker 의 갯수를 n 이라 할 때 O(n^2) 의 time
complexity 로 &lt;code&gt;shrink_slab()&lt;/code&gt; 수행시간이 늘어나게 되어있는데 이 문제를 해결한
패치입니다.  이 문제를 보기 위해 다음과 같은 테스트를 사용했습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$echo 1 &amp;gt; /sys/fs/cgroup/memory/memory.use_hierarchy
$mkdir /sys/fs/cgroup/memory/ct
$echo 4000M &amp;gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes
$for i in `seq 0 4000`;
        do mkdir /sys/fs/cgroup/memory/ct/$i;
        echo $$ &amp;gt; /sys/fs/cgroup/memory/ct/$i/cgroup.procs;
        mkdir -p s/$i; mount -t tmpfs $i s/$i; touch s/$i/file;
done
$time echo 3 &amp;gt; /proc/sys/vm/drop_caches
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ct/0 부터 ct/4000 까지 4001개의 메모리 cgroup 들을 만들어 놓고 tmpfs 를 만든 후
거기 파일을 만들어 메모리를 소모하게 한 후 &lt;code&gt;drop_caches&lt;/code&gt; 를 통해
&lt;code&gt;shrink_slab()&lt;/code&gt; 이 발동되게 했군요.  패치 저자의 환경에서의 테스트 결과는
다음과 같습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0.00user 13.78system 0:13.78elapsed 99%CPU
0.00user 5.59system 0:05.60elapsed 99%CPU
0.00user 5.48system 0:05.48elapsed 99%CPU
0.00user 8.35system 0:08.35elapsed 99%CPU
0.00user 8.34system 0:08.35elapsed 99%CPU
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 패치셋은 time complexity 가 O(n) 이 되도록 합니다.  패치셋이 적용된 후의
테스트 결과는 다음과 같이 548배 이상 개선되었습니다!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0.00user 1.10system 0:01.10elapsed 99%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;patch-00-11-docs-mm-add-boot-time-memory-management-docs&#34;&gt;[PATCH 00/11] docs/mm: add boot time memory management docs&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1529341199-17682-1-git-send-email-rppt@linux.vnet.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1529341199-17682-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;초기 부팅 시점에서의 메모리 관리에 대한 문서화를 개선하고 이에 대한 문서를
추가하는 패치입니다.  추가된 문서는 Documentation/core-api/boot-time-mm.rst 에
있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17/</link>
      <pubDate>Mon, 04 Jun 2018 11:29:16 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17&#34;&gt;Linux 4.17&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxhx_tKGm02UySguvbyfB_7oTF31QfgOHCK0YkBvmfV0g@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFxhx_tKGm02UySguvbyfB_7oTF31QfgOHCK0YkBvmfV0g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.17 버전 리눅스 릴리즈입니다.  지난주에 토발즈가 이야기한 것처럼 별다른 지연
없이 릴리즈 되었군요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git object&lt;/code&gt; 의 갯수라던지 릴리즈를 위한 스크립트 등이 리눅스 5.x 버전으로의
메이저 버전 업데이트가 될 준비가 되었다고 하지만 토발즈는 딱히 5.x 로 아직은
넘어갈 생각이 없군요.  너무 멀지 않은 미래에 넘어가겠지만, 적어도 지금은
아니라고 합니다.&lt;/p&gt;

&lt;p&gt;항상 그렇듯 이 릴리즈는 4.18을 위한 머지 윈도우의 시작이기도 한데, 토발즈는
두번째 주에 여행을 갈거라 가능하면 첫째주에 중요한 머지를 마무리 했으면 한다고
하네요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v13-00-72-convert-page-cache-to-xarray&#34;&gt;[PATCH v13 00/72] Convert page cache to XArray&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180611140639.17215-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180611140639.17215-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Radix tree 를 대체하기위한 목적으로 Matthew Wilcox 가 개발중인 XArray 의 구현과
Page cache 가 이 자료구조를 사용하도록 변경하는 패치의 13번째 버전입니다.  작년
OSSummit Europe 에서 처음 XArray 에 대한 발표를 들었는데 계속 발전중인 것
같군요.&lt;/p&gt;

&lt;h2 id=&#34;re-4-17-regression-performance-drop-on-kernel-4-17-visible-on&#34;&gt;Re: [4.17 regression] Performance drop on kernel-4.17 visible on&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180607110713.GJ32433@dhcp22.suse.cz&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180607110713.GJ32433@dhcp22.suse.cz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.16 대비 4.17 의 NUMA 시스템에서 Stream, Linpack, NAS 벤치마크 성능이 크게
떨어졌다는 레포트입니다.  최대 50% 까지의 성능 하락이 있었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>머신러닝 학습/실습 환경 (Jupyter Notebook &amp; Google Colab)</title>
      <link>https://sjp38.github.io/post/ml-study-env/</link>
      <pubDate>Mon, 28 May 2018 19:51:49 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/ml-study-env/</guid>
      <description>

&lt;p&gt;이 글은 머신러닝 학습 환경으로도 널리 사용되는 Jupyter Notebook 과 Google Colab
에 대해 간단히 설명합니다.&lt;/p&gt;

&lt;h1 id=&#34;jupyter-notebook&#34;&gt;Jupyter Notebook&lt;/h1&gt;

&lt;p&gt;Jupyter Notebook [1] 은 대화형으로 프로그래밍 언어를 공부하고 실습해 볼 수
있도록 만들어진 개발 / 학습 환경입니다.  이 환경은 크게 노트북 문서, Jupyter
Notebook App, Notebook kernel, 그리고 Notebook Dashboard 로 구성됩니다.&lt;/p&gt;

&lt;h2 id=&#34;노트북-문서&#34;&gt;노트북 문서&lt;/h2&gt;

&lt;p&gt;노트북 문서는 프로그램 코드 조각들과 Rich text (이걸 한글로 뭐라 해야 할지&amp;hellip;),
그리고 각 코드 조각의 수행 결과 로 구성됩니다.  백문이 불여일견, 이
&lt;a href=&#34;https://colab.research.google.com/github/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&#34; target=&#34;_blank&#34;&gt;링크&lt;/a&gt;
를 따라가 보시기 바랍니다.  링크는 간단한 파이썬 교육을 위해 만들어진 노트북
문서로,  코드를 수정하고 수행해 볼 수 있습니다.  텍스트도 수정할 수 있습니다.
문서에 코드 또는 텍스트 셀을 추가해 코드 셀에는 코드를, 텍스트 셀에는 텍스트를
작성할 수 있으며, 텍스트 셀에 작성할 수 있는 텍스트는 단순한 평문이 아니라
강조, 이탤릭 등의 효과를 포함할 수 있습니다.  Jupyter Notebook 환경은 노트북
문서들을 읽어들여 Rich Text 를 저자가 의도한 모습대로 렌더링 해주고, 코드 셀을
사용자가 원하면 셀별로 수행시켜줍니다.  코드 셀의 좌측에 수행 버튼이 떠서, 이를
클릭하면 해당 셀을 수행하는 형태입니다.  문서 상의 모든 코드 셀의 일괄 수행
역시 가능합니다.  이 때, 앞서 수행된 코드 셀의 수행 결과는 다음에 수행되는 코드
셀에 영향을 끼칩니다.  예를 들어 특정 셀에서 전역 변수의 값을 변경했다면 다음에
수행하는 셀에 변경된 전역 변수의 값이 보입니다.&lt;/p&gt;

&lt;p&gt;이를 통해 Jupyter Notebook 사용자는 노트북 문서를 사용해 타인에게 학습시킬
문서를 작성하고 학습자가 곧바로 하나씩 수행해 볼 수 있게 해줄 수 있으며, 스스로
공부하는 사람도 자신이 공부한 내용을 쉽게 정리할 수 있게 해줍니다.&lt;/p&gt;

&lt;h2 id=&#34;jupyter-notebook-app&#34;&gt;Jupyter Notebook App&lt;/h2&gt;

&lt;p&gt;Jupyter Notebook App 은 Jupyter 노트북 문서를 읽어들여 작성자가 원한 모습으로
보여주고 코드의 수행 등을 대신해 주고, 또한 노트북 문서를 새로 작성할 수 있는
에디터 역할을 합니다.  서버-클라이언트 구조로 되어 있어 로컬 컴퓨터에 서버를
띄우고 웹브라우저로 접속해서 작업할 수도, 다른 컴퓨터에 띄워진 서버에
웹브라우저로 접속해 작업할 수도 있습니다.  일부 공개 Jupyter Notebook 서버도
서비스 되고 있습니다.  Google Colab 역시 그런 형태입니다.&lt;/p&gt;

&lt;p&gt;Github 은 웹인터페이스 상에서 Notebook 문서를 렌더링 해 보여주는 기능을
제공하고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;notebook-kernel-과-notebook-dashboard&#34;&gt;Notebook kernel 과 Notebook Dashboard&lt;/h2&gt;

&lt;p&gt;실제 코드의 수행을 담당하는게 Notebook kernel, 각 노트북 문서의 관리를 담당해
주는 인터페이스가 Dashboard 입니다.  커널은 프로그램이 언어별로 존재하며,
Jupyter Notebook 에서는 다양한 언어의 커널을 지원하고 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;google-colab&#34;&gt;Google Colab&lt;/h1&gt;

&lt;p&gt;Jupyter Notebook 은 앞서 설명했듯 자신의 컴퓨터에 설치하고 서버를 띄울수도,
다른 컴퓨터에 설치하고 서버를 띄울 수도 있습니다.  &lt;code&gt;...  as a Service&lt;/code&gt; 의
시대인 만큼, Jupyter Notebook Server 를 서비스하는 회사들이 많습니다.  Google
Colab[2] 은 그런 서비스 중 하나입니다.  이 프로젝트는 머신러닝 교육과 연구를
돕기 위해 만들어진 Google 의 연구 프로젝트로, 결국은 하나의 Jupyter notebook
환경일 뿐인데, 어떠한 셋업도 필요 없고 구글 클라우드 위에서 동작합니다.&lt;/p&gt;

&lt;p&gt;노트북 문서는 구글 드라이브에 저장하고 불러올 수 있으며, Github 에 있는 노트북
문서도 읽어올 수 있습니다.  참고로 노트북 문서는 &lt;code&gt;.ipynb&lt;/code&gt; 라는 확장자를
사용하는 텍스트 파일입니다.  Colab 에서 작성한 노트북 문서를 &lt;code&gt;.ipynb&lt;/code&gt; 확장자
파일로 곧바로 다운받을 수 있으므로 구글 드라이브로 공유하기 부담스러운 경우는
github 을 통해 공유해도 좋겠습니다.  뿐만 아니라 읽기만 하므로 다른 사람의
Jupyter Notebook 문서도 공개되어 있다면 얼마든지 불러올 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;github-의-노트북-문서-불러오기&#34;&gt;Github 의 노트북 문서 불러오기&lt;/h2&gt;

&lt;p&gt;Github 의 노트북 파일을 불러오는 방법은 간단합니다.  먼저 Github 웹
인터페이스에 들어가 Google Colab 에서 읽고자 하는 문서의 github 상에서의 주소를
파악합니다.  대략
&lt;a href=&#34;https://github.com/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&#34; target=&#34;_blank&#34;&gt;https://github.com/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&lt;/a&gt; 와
같은 형태가 될겁니다.  여기서 &lt;code&gt;https://&lt;/code&gt; 를 제거하고 &lt;code&gt;github.com&lt;/code&gt; 에서 &lt;code&gt;./com&lt;/code&gt;
을 제거한 후, &lt;a href=&#34;https://colab.research.google.com/&#34; target=&#34;_blank&#34;&gt;https://colab.research.google.com/&lt;/a&gt; 뒤에 붙여줍니다.  그러면 대략
&lt;a href=&#34;https://colab.research.google.com/github/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&#34; target=&#34;_blank&#34;&gt;https://colab.research.google.com/github/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&lt;/a&gt;
같은 모습이 되겠죠.  이 주소를 웹브라우저에 입력하면, Colab 에 해당 노트북이
열리고 수행도 해볼 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;머신러닝 학습에 많이 사용되는 Jupyter Notebook 과 머신러닝을 위한 Jupyter
Notebook 서비스 중 하나인 Google Colab 에 대해 알아봤습니다.  저도 최근에야
알게 된 프로젝트인데, 코드와 그에 대한 설명을 정말 쉽고 효과적으로 공유할 수
있는 획기적 방법 같습니다.  다른 분야에도 널리 퍼지면 좋겠군요.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html&#34; target=&#34;_blank&#34;&gt;http://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&#34;https://colab.research.google.com/notebooks/welcome.ipynb&#34; target=&#34;_blank&#34;&gt;https://colab.research.google.com/notebooks/welcome.ipynb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after 4.17-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc7/</link>
      <pubDate>Mon, 28 May 2018 10:41:50 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc7/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17-rc7&#34;&gt;Linux 4.17-rc7&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwUqz9z1Rf4Wwr29W7DeKxQ67qKEW5xty+JPyCY3aNQ=A@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFwUqz9z1Rf4Wwr29W7DeKxQ67qKEW5xty+JPyCY3aNQ=A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;일곱번째 rc 입니다.  지난 몇주보다는 조금 변경사항이 있었지만 그렇다 해도
그렇게 심한 정도는 아니었기에 아마도 이게 마지막 rc 일 거라는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-00-13-introdue-io-latency-io-controller-for-cgroups&#34;&gt;[PATCH 00/13] Introdue io.latency io controller for cgroups&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180529211724.4531-1-josef@toxicpanda.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180529211724.4531-1-josef@toxicpanda.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cgroup 에 응답시간 (latency) 기반의 I/O 컨트롤러를 추가하는 패치셋입니다.
Cgroup 은 용량 기반의 컨트롤러는 많지만 응답시간 기반의 컨트롤러가 부족하다고
느껴왔는데, 역시 추가되어 가는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc6/</link>
      <pubDate>Mon, 21 May 2018 10:19:16 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc6/</guid>
      <description>

&lt;h2 id=&#34;linux-v4-17-rc6&#34;&gt;Linux v4.17-rc6&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CA+55aFxxYQFL3mwsQcC+__R23ZmO8c3F0SThi6r44TdK0ePNDQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;여섯번째 release candidate 버전입니다.  이번 릴리즈에도 특기할 만한 일은
없었습니다.  이제 충분히 안정화 되었을 거라고 하는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-mm-v3-00-21-mm-thp-swap-swapout-swapin-thp-in-one-piece&#34;&gt;[PATCH -mm -V3 00/21] mm, THP, swap: Swapout/swapin THP in one piece&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180523082625.6897-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180523082625.6897-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이전에도 이 시리즈로 소개했던, THP 의 swap out 과 swap in 최적화 마지막 단계
패치의 세번째 버전입니다.  마지막 단계 이야기 하니 문득 인피니티워의 오역
논란이 떠오르는군요 ;)  두번째 버전 이후 특정 컨피규레이션에서의 빌드 버그를
수정했고, mmotm/master 브랜치의 5월 18일자 버전으로 rebase 한게 차이점의
전부군요.&lt;/p&gt;

&lt;p&gt;RAM 으로 PMEM 을 시뮬레이션 하는 환경에서 vm-scalability 라는 벤치마크를 사용해
16개 프로세스가 anonymous page 를 상당량 할당받고 반복해서 접근하는 워크로드로
성능 차이를 비교했습니다.  이로 인해 패치 전 대비 워크로드 처리량 (throughput)
이 992.8% 향상되었습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v3-0-4-fixes-cleanups-for-rcu-dev&#34;&gt;[PATCH v3 0/4] fixes, cleanups for rcu/dev&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180521044220.123933-1-joel@joelfernandes.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180521044220.123933-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RCU 코드의 주석, 변수 사용, 변수 이름 등의 개선 패치셋입니다.&lt;/p&gt;

&lt;h2 id=&#34;resend-patch-v5-00-33-block-support-multipage-bvec&#34;&gt;[RESEND PATCH V5 00/33] block: support multipage bvec&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180525034621.31147-1-ming.lei@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180525034621.31147-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;하나의 &lt;code&gt;struct bio_bvec&lt;/code&gt; 이 물리적으로 연속적인 복수개의 페이지를 가질 수 있게
하는 패치입니다.  시스템의 메모리가 거대해지고 THP 등이 널리 쓰임에 따라 이런
변화가 필요했다는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-mm-0-4-mm-huge-page-copy-target-sub-page-last-when-copy-huge-page&#34;&gt;[PATCH -V2 -mm 0/4] mm, huge page: Copy target sub-page last when copy huge page&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180524005851.4079-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180524005851.4079-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Huge page 의 복사 시에는 source 와 destination page 각각에 접근을 해야 하므로,
2 MiB huge page 를 사용한다 가정하면 총 4 MiB 데이터 액세스가 필요합니다.
예컨대 Xeon E5 v3 2699 CPU 는 18개의 코어, 36개 쓰레드, 그리고 45 MiB Last
Level Cache 를 가지므로 코어별로는 2.5 MiB, 쓰레드별로는 1.25 MiB 의 Last Level
Cache 밖에 갖지 못하므로, 여기서 huge page 복사가 일어나면 자신의 Last Level
Cache 를 모조리 접근해서 데이터가 flooding 나고 이후 데이터 접근은 cache miss
가 날 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;이 패치셋은 target huge page 의 sub-page 를 마지막에 복사하도록 복사 시의
데이터 접근 순서를 약간 바꿔서 대부분의 경우에는 캐시 미스를 좀 더 줄일 수
있도록 했습니다.&lt;/p&gt;

&lt;p&gt;vm-scalability 의 anon-cow-seq 테스트 케이스를 2 socket Xeon E5 v3 2699
시스템에서 돌려본 결과, 약 16.6% 까지의 성능 향상이 있었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc5/</link>
      <pubDate>Mon, 14 May 2018 10:23:45 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc5/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17-rc5&#34;&gt;Linux 4.17-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxi-Q6hvdHn+JwYSQ9b3feNGoFM3eeAuKNhpkfxVNAGpA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFxi-Q6hvdHn+JwYSQ9b3feNGoFM3eeAuKNhpkfxVNAGpA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.17을 향한 다섯번째 rc 릴리즈입니다.  이번 릴리즈도 여느 때와 다름없이
평범하군요.  대부분 드라이버 변경들이고, amd gpu 쪽 변경이 있지만 나머지
부분들은 그렇게 많지 않고 대부분 한두줄 짜리 변경들입니다.  이대로라면 이번
4.17 릴리즈는 꽤 무난무난하게 끝나겠군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v11-00-26-speculative-page-faults&#34;&gt;[PATCH v11 00/26] Speculative page faults&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1526555193-7242-1-git-send-email-ldufour@linux.vnet.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1526555193-7242-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 블로그에서도 몇차례 소개한, speculative page fault 의 11번째 버전입니다.
지난 LSFMM 에서도 관련해 논의를 한 것 같던데, 아주 긍정적 반응은 아니었던 것
같습니다만, 어쨌든 오랫만에 올라온 새로운 버전의 패치셋이군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v6-00-17-rearrange-struct-page&#34;&gt;[PATCH v6 00/17] Rearrange struct page&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180518194519.3820-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180518194519.3820-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;struct page&lt;/code&gt; 의 구조를 좀 더 사용하기 쉽게 개선하는 패치의 여섯번째
버전입니다.  LSFMM 에서는 그 구조를 구글 문서[1]를 사용해 그림으로 그려가며
설명했고, 꽤 괜찮은 반응을 얻었던 것 같더군요.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QEMU 를 사용한 리눅스 커널 디버깅</title>
      <link>https://sjp38.github.io/post/qemu_kernel_debugging/</link>
      <pubDate>Mon, 07 May 2018 18:21:01 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/qemu_kernel_debugging/</guid>
      <description>

&lt;p&gt;토발즈는 좋아하지 않지만, 리눅스 커널 프로그래밍에도 디버거를 사용할 수
있습니다.  저도 디버거 사용을 좋아하지는 않는 편이지만, 경우에 따라선 디버거를
사용하는게 좋을 때도 있고 취향은 존중되어야죠. ;)&lt;/p&gt;

&lt;p&gt;커널 디버깅 방법은 여러가지가 있는데, 그 중 하나는 QEMU 등을 이용한 리눅스 가상
머신을 띄워 두고, 호스트 머신에서 해당 가상 머신의 리눅스 커널을 디버깅 하는
방법입니다.  이 글에선 이렇게 디버깅 하는 방법을 간단히 정리해 봅니다.&lt;/p&gt;

&lt;h1 id=&#34;테스트-환경&#34;&gt;테스트 환경&lt;/h1&gt;

&lt;p&gt;글 작성 과정에서 테스트에 사용한 주요 소프트웨어들과 버전은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ubuntu 16.04.3 Server&lt;/li&gt;
&lt;li&gt;gdb 7.11.1&lt;/li&gt;
&lt;li&gt;QEMU v2.11.0-dirty&lt;/li&gt;
&lt;li&gt;Linux v4.16&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;커널-빌드&#34;&gt;커널 빌드&lt;/h1&gt;

&lt;p&gt;디버깅할 커널을 빌드합니다.  이 때 &lt;code&gt;CONFIG_GDB_SCRIPTS&lt;/code&gt; 는 켜고
&lt;code&gt;CONFIG_DEBUG_INFO_REDUCED&lt;/code&gt; 는 끄고, 타겟 아키텍쳐가 &lt;code&gt;CONFIG_FRAME_POINTER&lt;/code&gt; 를
지원한다면 켜야 합니다.&lt;/p&gt;

&lt;h1 id=&#34;가상-머신-부팅&#34;&gt;가상 머신 부팅&lt;/h1&gt;

&lt;p&gt;빌드가 완료되면 해당 커널을 사용해 QEMU 가상 머신을 부팅시킵니다.  가상 머신
위에 커널을 설치하는 방법도 있겠고, QEMU 에 &lt;code&gt;-kernel&lt;/code&gt; 과 &lt;code&gt;-append&lt;/code&gt;, &lt;code&gt;-initrd&lt;/code&gt;
등을 사용해서 호스트에서 빌드한 리눅스 커널로 부팅시키는 방법도 있을 겁니다.
이 때, &lt;strong&gt;kaslr&lt;/strong&gt; 을 꺼야 합니다.  커널 패러미터에 &lt;code&gt;nokaslr&lt;/code&gt; 을 추가하는 걸로 끌
수 있습니다.  kaslr 이 켜진 채로 디버깅 해야 한다면 다른 방법이 있는데, 여기선
다루지 않겠습니다.&lt;/p&gt;

&lt;p&gt;QEMU 가상 머신을 시작할 때 QEMU 에 &lt;code&gt;-s&lt;/code&gt; 옵션을 주거나 QEMU monitor console 에서
&lt;code&gt;gdbserver&lt;/code&gt; 라고 명령을 입력해 줍니다.  이 명령은 가상머신에서 gdbserver 를
시작시켜서 gdbserver 가 &lt;code&gt;tcp::1234&lt;/code&gt; 에서 접속을 기다리게 함으로써 QEMU 의 gdb
기능을 활성화 시켜줍니다.  &lt;code&gt;-nographic&lt;/code&gt; 옵션을 주거나 해서 QEMU 를 수행시켰다면
화면에 QEMU monitor console 이 아니라 가상머신의 console 로 연결되었을 텐데,
&lt;code&gt;Ctrl+a c&lt;/code&gt; 키 조합으로 QEMU monitor console 로 이동할 수 있습니다.  여기서
가상머신 콘솔로 돌아가려면 &lt;code&gt;Ctrl+a c &amp;lt;enter&amp;gt;&lt;/code&gt; 를 입력해 줍니다.&lt;/p&gt;

&lt;h1 id=&#34;gdb-시작&#34;&gt;gdb 시작&lt;/h1&gt;

&lt;p&gt;호스트 머신에서 디버깅할 커널의 빌드 디렉토리로 이동해서 &lt;code&gt;gdb vmlinux&lt;/code&gt; 명령어를
입력해 빌드된 리눅스 심볼과 디버깅 정보를 사용해 gdb 가 켜지도록 합니다.
우분투나 일부 배포본에서는 이 때 &lt;code&gt;vmlinux-gdb.py&lt;/code&gt; 를 읽어들이는데 실패할 수
있을 겁니다.  gdb 에서도 에러메세지를 띄워 주겠지만, 홈디렉토리의 &lt;code&gt;.gdbinit&lt;/code&gt;
파일에 다음 한줄을 추가해 주고 앞서 설명한 커맨드로 gdb 를 다시 시작합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add-auto-load-state-path /path/to/linux-build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이후, gdb 세션에서 다음과 같은 명령어를 입력해 QEMU 가상머신에 연결합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) target remote :1234
Remote debugging using :1234
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&amp;quot;sti; hlt&amp;quot;: : :&amp;quot;memory&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이와 함께 QEMU 가상 머신은 동작이 멈출 겁니다.  여기서부터 gdb 를 평소에
사용하듯이 사용해 리눅스 커널의 변수를 보거나 중단점 (breakpoint) 를 설정하거나
한단계씩 코드를 수행시키거나 할 수 있습니다.  예를 들어 다음과 같이 특정 함수에
breakpoint 를 설정할 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b cma_alloc
Breakpoint 1 at 0xffffffff81240f10: file /home/sjpark/linux/mm/cma.c, line 399.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어 수행이 멈춰 있는 가상머신의 수행을 다시 가능하게 하려면 다음과 같이 c
를 입력해 줍니다.  가상머신의 커널 수행이 재개되며, Breakpoint 가 설정되어 있고
해당 위치 코드가 수행되면 다시 수행이 멈출 겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) c
Continuing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 멈추려면 gdb 에서 Ctrl+C 를 누릅시다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^C
Thread 1 received signal SIGINT, Interrupt.
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&amp;quot;sti; hlt&amp;quot;: : :&amp;quot;memory&amp;quot;);
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;리눅스-gdb-helper-사용하기&#34;&gt;리눅스 gdb helper 사용하기&lt;/h1&gt;

&lt;p&gt;사실은 앞 단계에서 &lt;code&gt;.gdbinit&lt;/code&gt; 를 굳이 수정하지 않아서 gdb가 &lt;code&gt;vmlinux-gdb.py&lt;/code&gt; 를
읽어들이는데 실패하더라도 gdb 를 평범하게 사용할 수 있습니다.  &lt;code&gt;vmlinux-gdb.py&lt;/code&gt;
는 사실 gdb 위에서 리눅스 커널을 디버깅하는걸 편리하게 해줄 수 있는 일부
스크립트, 즉 gdb helper 를 담고 있습니다.  이걸 사용하면 보다 쉽게 커널
디버깅을 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;helper-스크립트-리스트업&#34;&gt;helper 스크립트 리스트업&lt;/h2&gt;

&lt;p&gt;사용 가능한 helper 스크립트는 lx로 시작하는 규칙을 갖고 있습니다.  다음
명령으로 사용 가능한 스크립트 목록과 간단한 설명을 볼 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) apropos lx
function lx_current -- Return current task
function lx_module -- Find module by name and return the module variable
function lx_per_cpu -- Return per-cpu variable
function lx_task_by_pid -- Find Linux task by PID and return the task_struct variable
function lx_thread_info -- Calculate Linux thread_info from task variable
function lx_thread_info_by_pid -- Calculate Linux thread_info from task variable found by pid
lx-cmdline --  Report the Linux Commandline used in the current kernel
lx-cpus -- List CPU status arrays
lx-dmesg -- Print Linux kernel log buffer
lx-fdtdump -- Output Flattened Device Tree header and dump FDT blob to the filename
lx-iomem -- Identify the IO memory resource locations defined by the kernel
lx-ioports -- Identify the IO port resource locations defined by the kernel
lx-list-check -- Verify a list consistency
lx-lsmod -- List currently loaded modules
lx-mounts -- Report the VFS mounts of the current process namespace
lx-ps -- Dump Linux tasks
lx-symbols -- (Re-)load symbols of Linux kernel and currently loaded modules
lx-version --  Report the Linux Version of the current kernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참 쉽죠? ;)&lt;/p&gt;

&lt;h1 id=&#34;참고-자료&#34;&gt;참고 자료&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/v4.11/dev-tools/gdb-kernel-debugging.html&#34; target=&#34;_blank&#34;&gt;커널 디버깅 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.alexlambert.com/2017/12/18/kernel-debugging-for-newbies.html&#34; target=&#34;_blank&#34;&gt;참고할만한 영문 블로그 글&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/Server.html&#34; target=&#34;_blank&#34;&gt;gdbserver 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc4/</link>
      <pubDate>Mon, 07 May 2018 12:12:32 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc4/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17-rc4&#34;&gt;Linux 4.17-rc4&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyry0qeZvYjU5pf8a6zvb_ALmP-2T9+HZH2DHK93P6rQg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFyry0qeZvYjU5pf8a6zvb_ALmP-2T9+HZH2DHK93P6rQg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;어느새 네번째 rc 버전입니다.  v4.17 을 향한 여정이 절반을 넘어가는군요.  이번 릴리즈도 특이사항 없이 평범합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc3</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.17-rc3/</link>
      <pubDate>Mon, 30 Apr 2018 12:59:19 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.17-rc3/</guid>
      <description>

&lt;h2 id=&#34;linux-4-17-rc3&#34;&gt;Linux 4.17-rc3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyu=y0SBesB+vx3JZFGcOhP+tuVG7sjfrkfBhXHTe0Skg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFyu=y0SBesB+vx3JZFGcOhP+tuVG7sjfrkfBhXHTe0Skg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;세번째 rc 버전이 나왔습니다.  평소보다 좀 일찍 왔군요.  rc2 에 비해 커다란
릴리즈이긴 한데, 그렇다 해도 평범한 릴리즈라고 리누스는 이야기 합니다.
대부분의 변경 사항이 드라이버 쪽 수정이기 때문이라고 하는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v4-00-16-rearrange-struct-page&#34;&gt;[PATCH v4 00/16] Rearrange struct page&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180430202247.25220-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180430202247.25220-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 블로그에서도 소개했던, Matthew Wilcox 의 &amp;lsquo;struct page&amp;rsquo; 정리 패치의 네번째
버전입니다.  지난주 LSFMM 에서도 소개한 모양인데, 이 변화의 전/후를 google
spread sheet 로 정리한 문서도 여기서 공개했나보군요:
&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-0-4-interface-for-higher-order-contiguous-allocations&#34;&gt;[PATCH v2 0/4] Interface for higher order contiguous allocations&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180503232935.22539-1-mike.kravetz@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180503232935.22539-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mmap(MAP_CONTIG)&lt;/code&gt; 를 추가하자는 아이디어가 있었습니다.  현재 리눅스 커널에서
연속된 메모리 공간 할당에 사용되기 위해 만들어진 인터페이스는 CMA가 있는데, 그
목적이 좀 특수한 상황에 맞춰져 있다보니 좀 더 범용적 인터페이스가 있으면
어떻겠나 하는 이야기가 나와, 그런 인터페이스를 만들어 제시하는 패치입니다.
제안하는 인터페이스는 다음과 같습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct page *find_alloc_contig_pages(unsigned long nr_pages, gfp_t gfp,
                                        int nid, nodemask_t *nodemask)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rfc-distinguish-vmalloc-pages&#34;&gt;[RFC] Distinguish vmalloc pages&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180502152733.GB2737@bombadil.infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180502152733.GB2737@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;VMalloc 페이지는 유저스페이스에 매핑될 수도 있으므로 성능 분석과 memory leak
문제 분석의 편의를 위해  page-&amp;gt;mapping 값에 이를 가리키는 표식과 해당 페이지를
가리키는 &lt;code&gt;vm_struct&lt;/code&gt; 와 그 안에서의 &lt;code&gt;offset&lt;/code&gt; 을 저장하는 RFC 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;introduce-atomic-dec-and-lock-irqsave&#34;&gt;Introduce atomic_dec_and_lock_irqsave()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180504154533.8833-1-bigeasy@linutronix.de&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180504154533.8833-1-bigeasy@linutronix.de&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;local_irq_save()&lt;/code&gt; + &lt;code&gt;atomic_dec_and_lock()&lt;/code&gt; 조합을 써야 하던 코드를 위해 이를
감싸는 새로운 함수, &lt;code&gt;atomic_dec_and_lock_irqsave()&lt;/code&gt; 를 만들고 기존의 코드가
이를 사용하도록 고친 패치입니다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
