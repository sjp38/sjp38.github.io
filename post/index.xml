<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | hacklog</title>
    <link>/post/</link>
      <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0100</lastBuildDate>
    <image>
      <url>/img/tux.png</url>
      <title>Posts</title>
      <link>/post/</link>
    </image>
    
    <item>
      <title>LKML News v5.4</title>
      <link>/post/lkml_news_v5.4/</link>
      <pubDate>Tue, 19 Nov 2019 23:13:19 +0100</pubDate>
      <guid>/post/lkml_news_v5.4/</guid>
      <description>&lt;h2 id=&#34;patch-rfc-v3-0036-add-kernelmemorysanitizer-infrastructure&#34;&gt;[PATCH RFC v3 00/36] Add KernelMemorySanitizer infrastructure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191122112621.204798-1-glider@google.com&#34;&gt;https://lkml.kernel.org/r/20191122112621.204798-1-glider@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;초기화 되지 않은 메모리 영역에 접근함으로써 생기는 에러를 검출해내는 구글의
KMSAN 세번째 RFC 패치셋입니다.  다른 SAN 시리즈와 마찬가지로 구글 syzkaller 에
사용되어 지난 2년간 200개가 넘는 버그를 찾아냈다고 하네요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmmbpf-2020-call-for-proposals&#34;&gt;LSF/MM/BPF: 2020: Call for Proposals&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191122172502.vffyfxlqejthjib6@macbook-pro-91.dhcp.thefacebook.com&#34;&gt;https://lkml.kernel.org/r/20191122172502.vffyfxlqejthjib6@macbook-pro-91.dhcp.thefacebook.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;내년 LSF/MM 의 CFP 가 나왔습니다.  근데, 내년부턴 LSF/MM 에 BPF 세션이
추가되네요, 명칭도 LSF/MM/BPF 로 바뀌었습니다.  BPF 의 위상이 새삼 느껴지네요!&lt;/p&gt;
&lt;h2 id=&#34;linux-54&#34;&gt;Linux 5.4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjmzaD=BZ1hjUYu+RTnSGDLfCRwCdg99GeQpCjEwo9uzw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjmzaD=BZ1hjUYu+RTnSGDLfCRwCdg99GeQpCjEwo9uzw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여덟번의 rc 릴리즈를 끝으로 드디어 5.4 정식 버전이 릴리즈 되었습니다.  다행히
지난 일주일 간은 정말 별일 없었다는군요.  Thanksgiving 을 대비해 일찍 들어온
5.5 를 위한 풀리퀘스트가 대부분이었고, 네트워킹과 GPU 쪽의 일부 업데이트가
대부분이었다고 합니다.&lt;/p&gt;
&lt;p&gt;이렇게 5.5 머지 윈도우가 열렸는데, 머지윈도우 중에 Thanksgiving 이 있다는게
조금 걱정되긴 합니다만, 토발즈는 큰일은 없을 걸로 믿으며, 아이들 돌보느라 조금
처리가 늦어질 순 있겠다고 하네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc8</title>
      <link>/post/lkml_news_v5.4-rc8/</link>
      <pubDate>Tue, 12 Nov 2019 20:08:10 +0100</pubDate>
      <guid>/post/lkml_news_v5.4-rc8/</guid>
      <description>&lt;h2 id=&#34;patch-0013-finish-off-smpreadbarrierdepends&#34;&gt;&lt;code&gt;[PATCH 00/13] Finish off [smp_]read_barrier_depends()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191108170120.22331-1-will@kernel.org&#34;&gt;https://lkml.kernel.org/r/20191108170120.22331-1-will@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Alpha 에만 의존적인 메모리 모델 요소인 &lt;code&gt;smp_read_barrier_depends()&lt;/code&gt; 는
&lt;code&gt;READ_ONCE()&lt;/code&gt; 에 내장됨으로써 Alpha-specific 하지 않은 커널 코드에서는 Alpha 를
신경쓰지 않아도 되게 되었죠.  그럼에도 불구하고 이걸 신경쓰는 코드가 올라오는게
신경쓰였나 봅니다.
이 패치셋은 커널 코드의 모든 문서와 주석에서 해당 기능에 대한 설명을 삭제해
버립니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0010-add-kernel-concurrency-sanitizer-kcsan&#34;&gt;[PATCH v4 00/10] Add Kernel Concurrency Sanitizer (KCSAN)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191114180303.66955-1-elver@google.com&#34;&gt;https://lkml.kernel.org/r/20191114180303.66955-1-elver@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;구글의 동시성 버그를 잡아주는 KCSAN 패치입니다.  이번 버전은 x86 만을 위한
버전이지만 조만간 ARM64 와 POWER 지원을 추가할 예정이라는군요.  이번 네번째
버전은 이전 버전에 비해 성능이 33% 향상되었다고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-54rc8&#34;&gt;Linux 5.4-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiyR4Np_n5O6=rbf1GVNdr_zUd1WAC_GJDnc_hUhHqwWg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiyR4Np_n5O6=rbf1GVNdr_zUd1WAC_GJDnc_hUhHqwWg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;정식버전이 나올지 rc8 이 나올지 나름 두근두근한 일주일이었는데, 결국 rc8 이
나왔습니다.  하지만 딱히 문제가 있었던 건 아니라는군요.  떠들썩했던 인텔 취약점
패치가 들어온 한주였음에도 매우 조용했다고 합니다.&lt;/p&gt;
&lt;p&gt;다다음주는 Thanksgiving 이군요.  이 점을 생각하면 다음주는 5.4 에 대한
수정사항보다는 5.5 머지윈도우를 위한 early pull request 가 오길 바란다고
합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc7</title>
      <link>/post/lkml_news_v5.4-rc7/</link>
      <pubDate>Mon, 11 Nov 2019 07:17:00 +0100</pubDate>
      <guid>/post/lkml_news_v5.4-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-54rc7&#34;&gt;Linux 5.4-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wivmGEOTha5XkRHgH6VwfiroiN+PFVMNK3B0r-d0eFLPQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wivmGEOTha5XkRHgH6VwfiroiN+PFVMNK3B0r-d0eFLPQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 버전이 릴리즈 되었습니다.  지난 rc6 때도 변경량이 생각보다 많아
토발즈가 고민했는데, 이번주도 토발즈가 원했던 것보단 변경량이 많았다고
하는군요.  다음주에 rc8 을 낼지 5.4 정식 버전을 낼지는 좀 더 고민해 봐야겠다고
합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc6</title>
      <link>/post/lkml_news_v5.4-rc6/</link>
      <pubDate>Sat, 02 Nov 2019 09:24:21 +0100</pubDate>
      <guid>/post/lkml_news_v5.4-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-v8-mmdebug-add-tests-validating-architecture-page-table-helpers&#34;&gt;[PATCH V8] mm/debug: Add tests validating architecture page table helpers&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1572240562-23630-1-git-send-email-anshuman.khandual@arm.com&#34;&gt;https://lkml.kernel.org/r/1572240562-23630-1-git-send-email-anshuman.khandual@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아키텍쳐별 페이지 테이블 헬퍼 등을 테스트 하는 코드를 추가하는 패치입니다.
&lt;code&gt;CONFIG_DEBUG_VM_PGTABLE&lt;/code&gt; 컨피규레이션이 켜져 있으면 동작합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-v2-0025-add-kernelmemorysanitizer-infrastructure&#34;&gt;[PATCH RFC v2 00/25] Add KernelMemorySanitizer infrastructure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191030142237.249532-1-glider@google.com&#34;&gt;https://lkml.kernel.org/r/20191030142237.249532-1-glider@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;초기화 되지 않은 메모리 영역에 액세스 하는 에러를 찾아주는 KMSAN 을 커널에
추가하는 패치입니다.
KCSAN 과 비슷하게 syzkaller 를 통해 돌아가게끔 되어 있군요.&lt;/p&gt;
&lt;p&gt;False positive 문제가 존재할 수는 있는 모양입니다만, 구글 내부에서 syzbot 을
통해 테스트 한 환경에서는 중요한 false positive 는 나오지 않은 모양입니다.
구글 외부에서는 또 모른다는 거죠.&lt;/p&gt;
&lt;p&gt;요즘 커널 개발 프로세스를 개선하자는 이야기가 있고, 그 중에는 패치의 히스토리를
알고 싶다는 이야기가 많죠.
그래서인지 이 메일은 구글 내부 리뷰 시스템인 Gerrit 으로의 링크를 포함시켰네요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-v2-mm-proactive-compaction&#34;&gt;[RFC v2] mm: Proactive compaction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191031005127.8037-1-nigupta@nvidia.com&#34;&gt;https://lkml.kernel.org/r/20191031005127.8037-1-nigupta@nvidia.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 할당을 위해선 연속된 메모리 할당이 필요합니다.
Fragmentation 이 심한 시스템에선 이 할당이 어렵죠.
리눅스는 그래서 compaction 기법을 사용하는데요, 이걸 좀 더 적극적으로 하자는
패치입니다.
이를 통해 latency 가 개선될 수 있죠.&lt;/p&gt;
&lt;p&gt;단순히 hugepage 를 최대한, compaction 을 요청해가며 할당받는 드라이버를 통해 성능을 테스트 했군요.
80th percentile latency 까지는 몇십배 넘게 할당 응답시간을 줄였는데, 90th
percentile 부턴 별 차이 없군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-0010-autonuma-optimize-memory-placement-in-memory-tiering-system&#34;&gt;[RFC 00/10] autonuma: Optimize memory placement in memory tiering system&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191101075727.26683-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20191101075727.26683-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DRAM 과 PMEM 등으로 구성되어 PMEM 을 NUMA node 로 간주하는 multi-tiering memory
system 을 염두에 두고 hot page / cold page 를 구분할 수 있게 해주는
패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-54rc6&#34;&gt;Linux 5.4-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wg+8=w=sEx9WBF0OJj0SumQ4p-LuP8waRH=TSdAYDeqGg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wg+8=w=sEx9WBF0OJj0SumQ4p-LuP8waRH=TSdAYDeqGg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OSSEU 가 종료되고 토발즈는 집에 잘 도착했고, 시차 적응도 큰 문제는 없었기에
평소대로의 타이밍에 릴리즈가 가능했다고 합니다.
지난 rc5 도 큰 크기였고, rc6 는 이제 슬슬 변경사항이 줄어들어야 할, 토발즈
말로는 그러길 바라는 시점인데, 그렇지 못했습니다.
네트워킹 쪽에서 시점을 맞추지 못한 뒤늦은 풀리퀘스트들이 있었기 때문인데, 딱히
급작스런 문제가 있는 건 아니라는군요.
그렇다곤 해도 토발즈는 조금 찜찜한 모양입니다.
다음주까지 동향을 지켜봐야겠지만 다음주까지도 충분히 변경사항이 줄어들지
않는다면 rc8 까지 가야할 수도 있겠다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc5</title>
      <link>/post/lkml_news_v5.4-rc5/</link>
      <pubDate>Sun, 27 Oct 2019 12:48:30 +0100</pubDate>
      <guid>/post/lkml_news_v5.4-rc5/</guid>
      <description>&lt;h2 id=&#34;patch-0012-mm-remove-archhas4levelhack&#34;&gt;&lt;code&gt;[PATCH 00/12] mm: remove __ARCH_HAS_4LEVEL_HACK&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1571822941-29776-1-git-send-email-rppt@kernel.org&#34;&gt;https://lkml.kernel.org/r/1571822941-29776-1-git-send-email-rppt@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;서로 다른 아키텍쳐 간의 페이지 테이블 구조로 인해 사용해야 했던
&lt;code&gt;__ARCH_HAS_4LEVEL_HACK&lt;/code&gt; 을 제거하는 패치입니다.  Alpha, arm, c6x 등의
아키텍쳐가 변경되는군요.
UML, qemu 등에서 부팅 테스트를 거쳤군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-54rc5&#34;&gt;Linux 5.4-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgpewLxHxnO71tFHh=M4C4iUofJykMqq3r=eRyxUyVsiw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgpewLxHxnO71tFHh=M4C4iUofJykMqq3r=eRyxUyVsiw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다섯번째 rc 버전 릴리즈입니다.
하지만 안타깝게도 이번 릴리즈는 마냥 조용하진 않았다는군요.
최근의 다른 rc5 들에 비하면 조금 큰 크기의 릴리즈가 되었습니다.
그렇다곤 해도 아주 특이할 만한 정도는 아니라 토발즈도 큰 걱정은 없다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc4</title>
      <link>/post/lkml_news_v5.4-rc4/</link>
      <pubDate>Wed, 16 Oct 2019 20:29:00 +0200</pubDate>
      <guid>/post/lkml_news_v5.4-rc4/</guid>
      <description>&lt;h2 id=&#34;patch-08-add-kernel-concurrency-sanitizer-kcsan&#34;&gt;[PATCH 0/8] Add Kernel Concurrency Sanitizer (KCSAN)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191016083959.186860-1-elver@google.com&#34;&gt;https://lkml.kernel.org/r/20191016083959.186860-1-elver@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;구글에서 만든 동시성 버그 탐색기능, KCSAN 을 추가하는 패치셋입니다.
처음 세상에 모습을 드러낸건 9월이었고, 최근 컨퍼런스들에서도 발표가 있었죠.
메커니즘은 간단하다면 간단한, 샘플링 기반입니다.
구글 내부 fuzzing tester 인 syzkaller 는 이미 이 기능을 켠채 돌아간다는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-22-mm-zswap-support-thp&#34;&gt;[PATCH 2/2] mm, zswap: Support THP&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1571111349-5041-2-git-send-email-teawater@gmail.com&#34;&gt;https://lkml.kernel.org/r/1571111349-5041-2-git-send-email-teawater@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Zswap 이THP 를 지원하도록 수정하는 패치입니다.  그냥 &lt;code&gt;zswap_frontswap_store()&lt;/code&gt;
함수가 THP 페이지를 연속적인 4 KiB 페이지로 인식하고 처리하게끔 했군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-v1-0026-add-kernelmemorysanitizer-infrastructure&#34;&gt;[PATCH RFC v1 00/26] Add KernelMemorySanitizer infrastructure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191018094304.37056-1-glider@google.com&#34;&gt;https://lkml.kernel.org/r/20191018094304.37056-1-glider@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;구글에서 만든 또다른 sanitizer, KMSAN 입니다.  자매품으로 address sanitizer
등이 있고, 앞서 소개한 concurrency sanitizer 도 있죠.  KMSAN 은 초기화 안된
메모리에의 접근 문제를 찾아내는 Sanitizer 입니다.
Syzkaller 에 적용되어 지난 2년간 무려 200개가 넘는 문제를 발견했다고 합니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 KMSAN 을 적용한 커널을 QEMU 에서 부팅시킬 수 있게 해줍니다.
알려진 false positive 는 없지만 실제로 적용해보면 있을수도 있다고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-54rc4&#34;&gt;Linux 5.4-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wh3jhffc0u7s5n=-zUFpztuh+0Hfth4vwuyfc5SpBmvSA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wh3jhffc0u7s5n=-zUFpztuh+0Hfth4vwuyfc5SpBmvSA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;네번째 rc 버전 릴리즈입니다.  딱히 특별한 일 없이 평범한 릴리즈라고
자평하는군요.  토발즈는 이번주에 OSSummit Europe 참가를 위해 프랑스로 가는
모양입니다.  하지만 지금처럼 조용하면 큰일은 없을 것 같다고 하네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc3</title>
      <link>/post/lkml_news_v5.4-rc3/</link>
      <pubDate>Sun, 13 Oct 2019 12:22:50 +0200</pubDate>
      <guid>/post/lkml_news_v5.4-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-54rc3&#34;&gt;Linux 5.4-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjOhveT=qrq8HHyL7gpA5fmBtDa2ue7sO5ZSEBrrcY6Vg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjOhveT=qrq8HHyL7gpA5fmBtDa2ue7sO5ZSEBrrcY6Vg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;세번째 rc 릴리즈입니다.  실제 문제가 발견되고 그에 대한 수정이 본격적으로
시작되는 시즌이라 rc2보단 당연히 크지만 역대 rc3 들과 비교하면 작은 편의
릴리즈라는군요.
staging driver 일부가 사라진 게 조금 릴리즈 크기를 크게 보이게 만들 수 있다는게
그나마 유의할 점일까요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc2</title>
      <link>/post/lkml_news_v5.4-rc2/</link>
      <pubDate>Sat, 05 Oct 2019 11:46:07 +0200</pubDate>
      <guid>/post/lkml_news_v5.4-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-v18-0019-kunit-introduce-kunit-the-linux-kernel-unit-testing-framework&#34;&gt;[PATCH v18 00/19] kunit: introduce KUnit, the Linux kernel unit testing framework&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190923090249.127984-1-brendanhiggins@google.com&#34;&gt;https://lkml.kernel.org/r/20190923090249.127984-1-brendanhiggins@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어떻게 보면 별거 아닌 이유로 5.4 머지윈도우에서 튕겨나가고 만 kunit.
요청받은대로 파일 위치를 하위 디렉토리로 변경한 kunit 새 버전의 패치셋이
올라왔습니다.
&amp;lsquo;kunit/&amp;rsquo; 디렉토리와 kunit 을 위한 &amp;lsquo;Kconfig&amp;rsquo; 파일을 &amp;lsquo;lib/&amp;rsquo; 아래로 옮겼군요.&lt;/p&gt;
&lt;p&gt;이후 벌어진 대화가 재미있는데요, 토발즈는 이걸 5.5에 넣을 예정인데, 가능하면
그동안 실제 테스트 코드도 추가되면 좋겠다고 했습니다.
근데 테스트 프레임웍이 머지안되었는데 테스트 코드를?  메인테이너 간에 일이
복잡해지고 컨플릭 날 확률이 높아지니 이걸로 꽤 많은 이야기가 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-perf-script-python-integrate-page-reclaim-analyze-script&#34;&gt;[PATCH v2] perf script python: integrate page reclaim analyze script&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1569899984-16272-1-git-send-email-laoar.shao@gmail.com&#34;&gt;https://lkml.kernel.org/r/1569899984-16272-1-git-send-email-laoar.shao@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Page reclaim 을 좀더 잘 분석하기 위한 perf script 를 추가하는 패치셋의 두번째
버전입니다.
첫번째 버전은 이 블로그에서도 소개한 바 있죠.
첫번째 버전 이후로의 변화 중 눈에 띄는 건 파이썬 2.7 과 3.6 에서 모두
돌아가게끔 한 것이군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v5-0011-introduces-new-countbased-method-for-tracking-lockless-pagetable-walks&#34;&gt;[PATCH v5 00/11] Introduces new count-based method for tracking lockless pagetable walks&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191003013325.2614-1-leonardo@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20191003013325.2614-1-leonardo@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP promotion/demotion 과 동시에 page table 조작이 일어나는 걸 막기 위해
존재하는 &lt;code&gt;serialize_against_pte_lookup()&lt;/code&gt; 함수로 인해 발생하는 &lt;code&gt;munmap()&lt;/code&gt;
레이턴시 문제를 동시의 page table walk 존재 여부를 카운트 기반으로 추적해,
필요없을 땐 락을 잡지 않게 함으로써 레이턴시를 놀랍게 개선한 패치셋의 다섯번째
버전입니다.
이 블로그에서도 소개했죠.
지난 버전 이후로 인터럽트 처리 부분을 포함한 일부 부분이 조금 수정되었군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-export-cma-alloc-and-release&#34;&gt;[PATCH] mm: export cma alloc and release&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20191002212257.196849-1-salyzyn@android.com&#34;&gt;https://lkml.kernel.org/r/20191002212257.196849-1-salyzyn@android.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cma_alloc()&lt;/code&gt; 과 &lt;code&gt;cma_release()&lt;/code&gt; 함수를 드라이버에서도 쓸 수 있게 export 해주는
패치셋입니다.
안드로이드 ION 이라던지 RDMA, Camera 모듈들이 이에 의존적이어서 드라이버 레벨로
빌드가 안되기 때문에 이런 변경을 제안했다네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-54rc2&#34;&gt;Linux 5.4-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiNT4Yk+36OXMyPuesrU88cFyDG_XnjRiKwaac09PJpQw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiNT4Yk+36OXMyPuesrU88cFyDG_XnjRiKwaac09PJpQw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다시 일요일 오후 릴리즈로 돌아왔습니다.
큰 변화는 없고 그저 소소한 수정 사항들 뿐이었다는군요.
일반적으로 진짜 regression 에 대한 파악이 이루어지고 그에 대한 수정이
시작되는건 rc2 후라는 걸 감안하면 매우 평범한 릴리즈라고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.4-rc1</title>
      <link>/post/lkml_news_v5.4-rc1/</link>
      <pubDate>Sat, 21 Sep 2019 10:00:48 +0200</pubDate>
      <guid>/post/lkml_news_v5.4-rc1/</guid>
      <description>&lt;h2 id=&#34;patch-02-introduce-new-perfscript-pagereclaim&#34;&gt;[PATCH 0/2] introduce new perf-script page-reclaim&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1568817522-8754-1-git-send-email-laoar.shao@gmail.com&#34;&gt;https://lkml.kernel.org/r/1568817522-8754-1-git-send-email-laoar.shao@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Page reclaim 관련 성능 메트릭을 분석하기 위한 perf script 커맨드를 추가하는
패치입니다.  Direct reclaim 으로 인한 응답시간 폭증, page reclaim 이 왜
일어났는지, page reclaim 의 효과는 어땠는지 등을 알 수 있다는군요.&lt;/p&gt;
&lt;p&gt;구체적으로는 direct reclaim 이 몇번 일어났는지, 그 latency 분포는 어땠는지,
file / anon page 별로 reclaim, scan, sync write, async write 이 몇번
일어났는지, kswapd 는 몇번 일어났는지, kswapd latency 는 어땠는지 등등을
보입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ perf script report page-reclaim
    Direct reclaims: 4924
    Direct latency (ms)        total         max         avg         min
                          177823.211    6378.977      36.114       0.051
    Direct file reclaimed 22920
    Direct file scanned 28306
    Direct file sync write I/O 0
    Direct file async write I/O 0
    Direct anon reclaimed 212567
    Direct anon scanned 1446854
    Direct anon sync write I/O 0
    Direct anon async write I/O 278325
    Direct order      0     1     3
                   4870    23    31
    Wake kswapd requests 716
    Wake order      0     1
                  715     1

    Kswapd reclaims: 9
    Kswapd latency (ms)        total         max         avg         min
                           86353.046   42128.816    9594.783     120.736
    Kswapd file reclaimed 366461
    Kswapd file scanned 369554
    Kswapd file sync write I/O 0
    Kswapd file async write I/O 0
    Kswapd anon reclaimed 362594
    Kswapd anon scanned 693938
    Kswapd anon sync write I/O 0
    Kswapd anon async write I/O 330663
    Kswapd order      0     1     3
                      3     1     5
    Kswapd re-wakes 705

    Per process latency (ms):
         pid[comm]             total         max         avg         min
               timestamp  latency(ns)
           1[systemd]        276.764     248.933       21.29       0.293
           3406860552338: 16819800
           3406877381650: 5532855
           3407458799399: 929517
           3407459796042: 916682
           3407460763220: 418989
           3407461250236: 332355
           3407461637534: 401731
           3407462092234: 449219
           3407462605855: 292857
           3407462952343: 372700
           3407463364947: 414880
           3407463829547: 949162
           3407464813883: 248933444
         163[kswapd0]      86353.046   42128.816    9594.783     120.736
           3357637025977: 1026962745
           3358915619888: 41268642175
           3400239664127: 42128816204
           3443784780373: 679641989
           3444847948969: 120735792
           3445001978784: 342713657
           ...
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;git-pull-kselftest-update-for-linux-54rc1&#34;&gt;[GIT PULL] Kselftest update for Linux 5.4-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/be8059f4-8e8f-cd18-0978-a9c861f6396b@linuxfoundation.org&#34;&gt;https://lkml.kernel.org/r/be8059f4-8e8f-cd18-0978-a9c861f6396b@linuxfoundation.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이블로그에서도 여러차례 소개했던 kunit 은 제가 오랫동안 메인라인에 머지되기를
기다려 왔던 기능입니다.
이번 kernel summit 에서 발표한 제 damon 이란 프로젝트도 kunit 을 이용해 test
driven development 기법을 적용했고, 그 효과를 톡톡히 봤죠.
이 패치셋이 4.9에 들어갈 예정이었고, Shuah Kahn 이 이번 머지 윈도우에
풀리퀘스트에 이 패치셋을 포함해 보냈는데요.
토발즈가 바로 퉤에엣 을 시전했습니다.&lt;/p&gt;
&lt;p&gt;이유가 재미있습니다, kunit 패치는 리눅스 소스코드 루트 디렉토리에 &lt;code&gt;kunit/&lt;/code&gt;
디렉토리를 추가하는데, 이게 토발즈 마음에 들지 않았습니다.
토발즈의 tab 키를 활용한 자동완성 기능을 부셨기 때문이죠.
&lt;code&gt;kernel/&lt;/code&gt; 디렉토리로 이용하기 위해 &lt;code&gt;k&lt;/code&gt; 만 타이핑 하고 탭키를 누르면 되었는데,
이제 &lt;code&gt;kunit/&lt;/code&gt; 디렉토리 때문에 이게 안되는 거죠.&lt;/p&gt;
&lt;p&gt;생각하기에 따라선 좀 억지 아니냐고 생각할 수 있고 저도 kunit 의 오랜 팬으로써
좀 아쉬운 마음이 있었는데요.
또 이제와서 생각해 보면 저도 &lt;code&gt;kernel/&lt;/code&gt; 넘어가기 위해 한번 더 키보드에 손대야
하는게 좀 불쾌했던 거 같기도 하네요. ;)&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0011-introduces-new-countbased-method-for-monitoring-lockless-pagetable-walks&#34;&gt;[PATCH v4 00/11] Introduces new count-based method for monitoring lockless pagetable walks&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190927234008.11513-1-leonardo@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190927234008.11513-1-leonardo@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;128개 vcpu 의 qemu 가 THP 로 매핑된 496 GiB 메모리 영역을 &lt;code&gt;munmap()&lt;/code&gt; 완료하는데
무려 275초가 걸린다고 합니다.
그 원인은 &lt;code&gt;serialize_against_pte_lookup()&lt;/code&gt; 함수였다고 하는군요.
이 함수는 &lt;code&gt;find_current_mm_pte()&lt;/code&gt; 내에서의 &lt;code&gt;pmd_t&lt;/code&gt; 에서 &lt;code&gt;pte_t&lt;/code&gt; 로의 캐스팅
또는 lockless page table walk 이 THP promotion/demotion 과 동시에 이루어지지
않게끔 보호하는 용도로 사용됩니다.
그렇다면, 실제 lockless page table walk 이 없다면
&lt;code&gt;serialize_against_pte_lookup()&lt;/code&gt; 은 호출될 필요가 없겠죠.&lt;/p&gt;
&lt;p&gt;이를 위해 이 패치셋은 현재 수행되고 있는 &lt;code&gt;find_current_mm_pte()&lt;/code&gt; 함수 갯수를
세고 그 갯수가 0이면 이 오버헤드가 되는 동시성 보호 코드를 생략하게 합니다.&lt;/p&gt;
&lt;p&gt;이 패치를 적용한 후 앞의 문제시 되던 작업에 걸리는 시간이 275초에서 무려 418 ms
으로 줄었다는군요!&lt;/p&gt;
&lt;h2 id=&#34;linux-54rc1&#34;&gt;Linux 5.4-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgbGJ-SGeevEcgrThhPp+RwYOUUgWoZ3W27cbUpuB3VgA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgbGJ-SGeevEcgrThhPp+RwYOUUgWoZ3W27cbUpuB3VgA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;평소보다 하루 늦은 월요일에 5.4 머지윈도우가 닫히고 rc1 릴리즈가
이루어졌습니다.
좀 미뤄진 머지를 처리하느라 늦어져서 하루 늦은 릴리즈가 되긴 했지만 대수로운
일은 아니라는군요.&lt;/p&gt;
&lt;p&gt;전체적인 릴리즈 내용도 평시와 크게 다른 내용은 없습니다.
AMD DRM 관련 변경이 많이 있지만 이는 하드웨어 구성에 따른 변화니까 무시하면
되고, 그걸 제외하고 보면 평소와 변경사항들의 분포도 비슷하다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Richard Stallman Resigns</title>
      <link>/post/rms_resigns/</link>
      <pubDate>Thu, 19 Sep 2019 21:57:01 +0200</pubDate>
      <guid>/post/rms_resigns/</guid>
      <description>&lt;p&gt;몇일 전, 리차드 스톨만이 FSF 회장은 물론이고 의장직에서도 사임한다는 소식이
전해졌습니다.  무슨 일이 있었는지 아래의 reddit 코멘트가 가장 잘 설명하고
있다는 LWN 코멘트[1] 를 참고해, 해당 reddit 코멘트를 번역해 봅니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://lwn.net/Articles/799391/&#34;&gt;https://lwn.net/Articles/799391/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;최근 공개된 한 여성의 증언에 따르면 그녀가 17세 때, Epstein 이 그녀에게 Marvin
Minsky 와 성관계를 가지라고 했습니다.
Minsky 는 MIT Media Lab 창시자이자 A.I 선도자였으며, 2016년에 사망했습니다.
스톨만은 한 메일링 리스트에서 (Minsky 를 성폭행으로 비난하는 어느 시위 주도자의
주장에 대한 답변으로) 이렇게 주장했습니다, 자신도 Epstein 은 비난하지만, Minsky
는 그녀가 강요당한 걸 몰랐을 가능성이 있다구요:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;많은 시나리오를 상상해 볼 수 있겠습니다만, 가장 그럴싸한 시나리오는 그에게는
그녀가 스스로 원해서 그러는듯 보였을 거라는 겁니다.
Epstein 이 그녀를 강요했다면, 그는 그가 연관된 것을 그녀가 감추도록 해야 했을
겁니다.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;일부 SJW 는 &amp;ldquo;Remove Richard Stallman&amp;rdquo; 이라는 Medium 포스트를 작성했습니다.
Vice 와 The Daily Beast 와 같은 미디어 직판장은 Stallman 이 그 여성이 &amp;ldquo;완전히
원했다&amp;rdquo; 그리고 &amp;ldquo;Epstein 을 방어하고 있다&amp;rdquo; 라고 했다고 거짓말하고 그의 발언을
잘못된 의미로 인용했습니다.
Stallman 은 이제 MIT 에서 사퇴하라는 압력을 받고 있습니다.&lt;/p&gt;
&lt;p&gt;더 나아가서 이 증언에 그녀가 Minsky 와 성관계를 가졌다는 이야기는 없고, Epstein
이 그녀에게 그러라 했을 뿐이라는 이야기만 있습니다, 그리고 물리학자 Greg
Benford 에 따르면 그녀가 Minsky 를 유혹했고 그는 그녀를 거절했다고 합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;내가 알죠, 내가 거기 있었습니다.
Minsky 는 그녀를 거절했고, 제게 그 이야기를 했습니다.
그녀는 우리가 이야기 하는걸 보았고 제게 다가오지 않았습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이는 Stallman 의 생각에 대한 완전한 검증 같습니다.
Minsky 가 무엇을 알았는지가 중요치 않다면, &amp;ldquo;Minsky 가 한 여성을 성폭행 했다&amp;rdquo; 와
&amp;ldquo;Epstein 이 17살 여성에게 그의 강요를 Minsky 에게 알리지 않은 채 성행위를
가지라 했다&amp;rdquo; 사이에 차이가 없다면, 왜 그는 그녀를 거절했을까요?&lt;/p&gt;
&lt;p&gt;추가 수정: 그는 그가 설립한 Free Software Foundation 에서도 사임했습니다.
자유 소프트웨어에의 우울한 소식입니다, 저는 Stallman 같은 순수한 믿음을 가진
사람이 다양한 종류의 피해야할 선택을 막는데 필수적이라 생각하거든요.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Context: In a recently unsealed deposition a woman testified that, at the age
of 17, Epstein told her to have sex with Marvin Minsky. Minsky was a founder of
the MIT Media Lab and pioneer in A.I. who died in 2016. Stallman argued on a
mailing list (in response to a statement from a protest organizer accusing
Minsky of sexual assault) that, while he condemned Epstein, Minsky likely did
not know she was being coerced:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;We can imagine many scenarios, but the most plausible scenario is that she
presented herself to him as entirely willing. Assuming she was being coerced by
Epstein, he would have had every reason to tell her to conceal that from most
of his associates.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Some SJW responded by writing a Medium post called &amp;ldquo;Remove Richard Stallman&amp;rdquo;.
Media outlets like Vice and The Daily Beast then lied and misquoted Stallman as
saying that the woman was likely &amp;ldquo;entirely willing&amp;rdquo; and as &amp;ldquo;defending Epstein&amp;rdquo;.
He has now been pressured to resign from MIT&lt;/p&gt;
&lt;p&gt;Furthermore the deposition doesn&#39;t say she had sex with Minsky, only that
Epstein told her to do so, and according to physicist Greg Benford she
propositioned Minsky and he turned her down:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I know; I was there. Minsky turned her down. Told me about it. She saw us
talking and didn’t approach me.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This seems like a complete validation of the distinction Stallman was making.
If what Minsky knew doesn&#39;t matter, if there&#39;s no difference between &amp;ldquo;Minsky
sexually assaulted a woman&amp;rdquo; and &amp;ldquo;Epstein told a 17-year-old to have sex with
Minsky without his knowledge or consent&amp;rdquo;, then why did he turn her down?&lt;/p&gt;
&lt;p&gt;Edit: He has also resigned from the Free Software Foundation, which he founded.
Grim news for free software, since I think true-believing purists like Stallman
are vital to prevent various kinds of co-option.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3</title>
      <link>/post/lkml_news_v5.3/</link>
      <pubDate>Thu, 12 Sep 2019 17:59:25 +0200</pubDate>
      <guid>/post/lkml_news_v5.3/</guid>
      <description>&lt;h2 id=&#34;patch-x86mm-enable-5level-paging-support-by-default&#34;&gt;[PATCH] x86/mm: Enable 5-level paging support by default&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190913095452.40592-1-kirill.shutemov@linux.intel.com&#34;&gt;https://lkml.kernel.org/r/20190913095452.40592-1-kirill.shutemov@linux.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5 레벨 페이지 테이블 기능이 들어간지도 어느덧 시간이 지났죠.
인텔 내부적 테스트 상으론 이 기능을 켰을 때 4 레벨 페이지 테이블 기계에서도
딱히 리그레션 등은 나타나지 않았고, 주요 배포판들은 5 레벨 페이지 테이블
서포트를 기본으로 켤것으로 보인다고 합니다.
따라서 이 기능을 아예 디폴트로 켜져있게 하는 패치입니다.&lt;/p&gt;
&lt;p&gt;v5.4 에 들어가기엔 좀 늦은 관계로, v5.5 에 들어갈 것 같다는군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-53&#34;&gt;Linux 5.3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiP4K8DRJWsCo=20hn_6054xBamGKF2kPgUzpB5aMaofA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiP4K8DRJWsCo=20hn_6054xBamGKF2kPgUzpB5aMaofA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LPC 와 커널 서밋 등으로 인해 한주 늦춰진 5.3 릴리즈가 이뤄졌습니다.
지난 일주일은 고요했을 뿐더러, 이 늦춰진 일정 덕에 몇가지 수정도 더 이뤄질 수
있었다고 토발즈는 평하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc8</title>
      <link>/post/lkml_news_v5.3-rc8/</link>
      <pubDate>Wed, 04 Sep 2019 23:56:59 +0200</pubDate>
      <guid>/post/lkml_news_v5.3-rc8/</guid>
      <description>&lt;h2 id=&#34;patch-rfc-0014-the-new-slab-memory-controller&#34;&gt;[PATCH RFC 00/14] The new slab memory controller&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190905214553.1643060-1-guro@fb.com&#34;&gt;https://lkml.kernel.org/r/20190905214553.1643060-1-guro@fb.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;슬랩 할당자의 실제 메모리 활용률이 대부분 45-65 퍼센트에 불과했다고 합니다.
이는 슬랩 페이지가 각 메모리 cgroup 마다 배타적으로 사용되기 때문입니다.  적은
메모리만 사용하는 cgroup 여러개가 존재하면 슬랩에서 크게 받아놓은 메모리에서
조금씩만 실제 사용되니까 전체 활용률은 낮게 되는거죠.  이 RFC 패치셋은 서로
다른 cgroup 들이 슬랩 페이지를 공유할 수 있게 함으로써 이 문제를 해결합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-53rc8&#34;&gt;Linux 5.3-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whBQ+6c-h+htiv6pp8ndtv97+45AH9WvdZougDRM6M4VQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whBQ+6c-h+htiv6pp8ndtv97+45AH9WvdZougDRM6M4VQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;평소대로라면 5.3 정식 릴리즈가 되었을테고 별다른 문제는 없었지만, rc7
릴리즈에서 이야기된대로 LPC 와 커널 서밋도 있고 한 이유로, -rc8 이 릴리즈
되었습니다.
그렇다보니 특기할 만한 사항은 없습니다만, 정식 릴리즈를 늦춘 덕에 stable 트리로
넘어갈 뻔한 수정사항 몇가지를 이번 릴리즈 내에 넣을 수 있게 되었다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc7</title>
      <link>/post/lkml_news_v5.3-rc7/</link>
      <pubDate>Mon, 02 Sep 2019 10:57:44 +0200</pubDate>
      <guid>/post/lkml_news_v5.3-rc7/</guid>
      <description>&lt;p&gt;평소보다 늦은 월요일 아침 릴리즈가 이뤄졌습니다.  일요일에 토발즈가
컴퓨터로부터 떨어져 있었다는군요.&lt;/p&gt;
&lt;p&gt;늦어진 릴리즈 덕분에 뒤늦게 들어온 풀리퀘스트를 더 받을 수 있었고, 이로 인해
이번 rc 릴리즈는 평소보다 좀 사이즈가 큽니다.
따라서 이번 릴리즈의 크기가 불안정성을 의미하는 게 아니라 5.3 정식 릴리즈를 늦출 필요는 없습니다만, 공교롭게도 또한 다음주는 LPC 와 커널 서밋이 있죠.
토발즈도 그렇고 많은 다른 개발자들도 이때 LPC 와 커널 서밋에 참가할 거라, rc7
을 마지막으로 5.3 릴리즈를 하면 5.4 머지 윈도우의 많은 시간을 여행에 보내게
되므로, 그냥 rc8 을 릴리즈 하겠다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc6</title>
      <link>/post/lkml_news_v5.3-rc6/</link>
      <pubDate>Thu, 22 Aug 2019 15:30:54 +0200</pubDate>
      <guid>/post/lkml_news_v5.3-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-53rc6&#34;&gt;Linux 5.3-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgAKCTq+t5YnG6HzrF62=rr9H=q3LqokEP0_bQRHLwYNw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgAKCTq+t5YnG6HzrF62=rr9H=q3LqokEP0_bQRHLwYNw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;오늘은 리눅스의 28번째 생일입니다.  따라서 오늘 rc6 릴리즈는 28년만의
릴리즈이기도 하군요.  토발즈도 감회가 깊었는지 오늘의 릴리즈 메일엔 최초 릴리즈
메일에 적었던 내용과 비슷하게 시작 부분을 꾸몄네요.
감회 깊은 날, 감회 깊은 릴리즈입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;리눅스를 사용하는 여러분들 안녕하세요,

저는 486 AT 클론과 그외의 많은 다른 하드웨어를 위한 (자유) 운영체제를 (취미보단
더 진지하게) 만들고 있습니다.  이 일은 28년째 지속되고 있고, 아직도 끝나지
않았습니다.  이 릴리즈에 의해 만들어진 (또는 그보다 오래된) 모든 버그에 대한
피드백을 부탁드립니다.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;어쨌건, 아주 특별할 건 없는 릴리즈였습니다만, 토발즈가 원하던 것에 비하면
변경사항이 좀 많았다는군요.  다음주에 확실히 변경사항이 줄지 않는다면 rc8 을
만들어야 할 것 같다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc5</title>
      <link>/post/lkml_news_v5.3-rc5/</link>
      <pubDate>Mon, 19 Aug 2019 14:19:58 +0900</pubDate>
      <guid>/post/lkml_news_v5.3-rc5/</guid>
      <description>&lt;h2 id=&#34;rfc-patch-02-add-predictive-memory-reclamation-and-compaction&#34;&gt;[RFC PATCH 0/2] Add predictive memory reclamation and compaction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190813014012.30232-1-khalid.aziz@oracle.com&#34;&gt;https://lkml.kernel.org/r/20190813014012.30232-1-khalid.aziz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널의 page reclamation 과 compaction 등은 기본적으로 시스템 메모리 잔여량이
부족할 때 시작됩니다.  하지만 이땐 이미 때가 늦었습니다.  reclamation 과
compaction 을 열심히 하긴 하지만 어플리케이션은 이미 메모리 부족으로 인한
응답시간 폭증 등을 겪게 됩니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 시스템의 메모리 부족을 미리 예측하고 reclamation 과 compaction 을
시작하기 위한 패치셋입니다.  시간축에 따라 메모리 사용량 변화 추세를 보면 이걸
예측할 수 있지 않겠냐는 것이죠.&lt;/p&gt;
&lt;p&gt;이 패치셋은 이런 아이디어에 기반해 시스템의 메모리 부족을 예측하고 kswapd 를
깨울지 재울지를 결정합니다.  간단한 dd 기반의 테스트를 통해 그 성능을 측정한
결과도 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-kbuild-change-fallthrough-comments-to-attributes&#34;&gt;[PATCH] kbuild: Change fallthrough comments to attributes&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190812214711.83710-1-nhuck@google.com&#34;&gt;https://lkml.kernel.org/r/20190812214711.83710-1-nhuck@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C 언의 &lt;code&gt;switch&lt;/code&gt; 구문의 fall-through 기능은 복잡한 기능을 구현하기 좋긴 한데
암묵적으로 이루어지는 fall-through 를 방지하기 위해 &lt;code&gt;break;&lt;/code&gt; 를 추가하는 걸
깜박하곤 하는 경우가 많습니다.  GCC 는 주석으로 이 부분은 fall-through 가 맞다,
라는걸 지정할 수 있게 하고 이 주석이 없는 경우는 모두 fall-through 를
막아버림으로써 &lt;code&gt;switch&lt;/code&gt; 의 명시적 fall-through 기능이 가능하게 합니다.&lt;/p&gt;
&lt;p&gt;리눅스 커널 역시 이런 방식으로 암묵적 fall-through 에 의한 버그를 극복하려
노력하는데요, clang 은 이걸 주석 형태가 아니라 attribute 형태로 지원합니다.  이
패치는 이런 차이를 어드레스 하기 위한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-mm-proactive-compaction&#34;&gt;[RFC] mm: Proactive compaction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190816214413.15006-1-nigupta@nvidia.com&#34;&gt;https://lkml.kernel.org/r/20190816214413.15006-1-nigupta@nvidia.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 등의 할당 시간은 fragmentation 이 심한 메모리에선 길어지거나 아예
실패할 수 있죠.  Huge page 에 성능이 의존적인 어플리케이션에겐 큰 문제입니다.&lt;/p&gt;
&lt;p&gt;이 패치는 page order 별 fragmentation threshold 를 두고 이에 맞춰 page order
별로 다른 compaction 을 수행하자는 겁니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-53rc5&#34;&gt;Linux 5.3-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiO5-puMa30fCwtgze57MH2JOzedVcEVotEviYmmQNihQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiO5-puMa30fCwtgze57MH2JOzedVcEVotEviYmmQNihQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다섯번째 rc 릴리즈입니다.  노드 로컬 할당 대 huge page 할당 관련 커밋 일부가
리버트 시키지 않는 등의 몇가지 문제를 제외하면 조용한 릴리즈 주간이었다는군요.
잘 안정화 되어가고 있다는 증거겠지요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc4</title>
      <link>/post/lkml_news_v5.3-rc4/</link>
      <pubDate>Mon, 12 Aug 2019 01:40:13 +0900</pubDate>
      <guid>/post/lkml_news_v5.3-rc4/</guid>
      <description>&lt;h2 id=&#34;rfc-patch-v6-0092-vm-introspection&#34;&gt;[RFC PATCH v6 00/92] VM introspection&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190809160047.8319-1-alazar@bitdefender.com&#34;&gt;https://lkml.kernel.org/r/20190809160047.8319-1-alazar@bitdefender.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;호스트 또는 별도 VM 에서 돌아가는 어플리케이션이 다른 VM들을 제어하거나 상태를
알아보거나 shadow 페이지 테이블을 조정하거나 특정 이벤트 발생시 알림을 받거나
할 수 있게 해주는 KVM introspection 서브시스템을 제안하는 패치입니다.  무려
92개짜리의 거대한 패치군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-15-mmpageidle-add-perpid-idle-page-tracking-using-virtual-indexing&#34;&gt;[PATCH v4 1/5] &lt;code&gt;mm/page_idle&lt;/code&gt;: Add per-pid idle page tracking using virtual indexing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190805170451.26009-1-joel@joelfernandes.org&#34;&gt;https://lkml.kernel.org/r/20190805170451.26009-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;페이지 액세스 여부를 알아볼 수 있는 &lt;code&gt;page_idle&lt;/code&gt; 기능을 프로세스별로 트래킹 하기
편하게 만들어 주는 패치의 네번째 버전입니다.  저자는 구글 직원으로,
안드로이드의 heap profiler 가 이 기능을 쓰나봅니다.  이전 버전과의 차이는&amp;hellip;
Swap pte 처리가 추가되었군요.&lt;/p&gt;
&lt;p&gt;다섯번째 버전도 바로 올라왔습니다만, 큰 차이는 없어 보이는군요:
&lt;a href=&#34;https://lkml.kernel.org/r/20190807171559.182301-1-joel@joelfernandes.org&#34;&gt;https://lkml.kernel.org/r/20190807171559.182301-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;linux-53rc4&#34;&gt;Linux 5.3-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whWJ7Dv9yZBZpxWd1zcAMwokjt7c8YOp-FOf1PXDKGrmQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whWJ7Dv9yZBZpxWd1zcAMwokjt7c8YOp-FOf1PXDKGrmQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;세번째 rc 는 어째선지 작은 크기였다 말했었죠, 그냥 pull request 들이 천천히
왔기 때문이 맞는 것 같다고 합니다.  이번 rc 릴리즈는 평소 크기에 rc3 에
안들어간 내용이 들어간 만큼 크다고 합니다.
덕분에 최근 2년 사이의 rc4 중 가장 크다고 하네요.
rc3 에 안들어갔다가 rc4 에 뒤늦게 들어온 변경사항은 대부분 network 쪽
코드라는군요.&lt;/p&gt;
&lt;p&gt;이번 변경 중 개인적으로 눈에 띄는건 &lt;code&gt;switch-case&lt;/code&gt; 구문의 fall-through 코멘트
업데이트입니다.
LWN 에도 관련 글이 올라왔으니 한번 읽어보는 것도 좋을 겁니다:
&lt;a href=&#34;https://lwn.net/Articles/794944/&#34;&gt;https://lwn.net/Articles/794944/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 rc 릴리즈 개발 과정 시각화 동영상을 아래 링크에서 보실 수 있습니다:
&lt;a href=&#34;https://youtu.be/EB3i8iBuuHM&#34;&gt;https://youtu.be/EB3i8iBuuHM&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc3</title>
      <link>/post/lkml_news_v5.3-rc3/</link>
      <pubDate>Wed, 31 Jul 2019 08:40:48 +0900</pubDate>
      <guid>/post/lkml_news_v5.3-rc3/</guid>
      <description>&lt;h2 id=&#34;patch-v5-0014-provide-generic-topdown-mmap-layout-functions&#34;&gt;[PATCH v5 00/14] Provide generic top-down mmap layout functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190730055113.23635-1-alex@ghiti.fr&#34;&gt;https://lkml.kernel.org/r/20190730055113.23635-1-alex@ghiti.fr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아키텍쳐별로 다르게 구현되어 있던 mmap 레이아웃 함수들을 범용화 시키는 패치셋,
다섯번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v10-0022-generic-page-walk-and-ptdump&#34;&gt;[PATCH v10 00/22] Generic page walk and ptdump&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190731154603.41797-1-steven.price@arm.com&#34;&gt;https://lkml.kernel.org/r/20190731154603.41797-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;역시 아키텍쳐별로 다르게 구현되어 있던 page table walk 과 page table dump
기능을 범용화 시키는 패치입니다.  벌써 10번째 버전이군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-03-address-hugetlb-page-allocation-stalls&#34;&gt;[PATCH 0/3] address hugetlb page allocation stalls&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190802223930.30971-1-mike.kravetz@oracle.com&#34;&gt;https://lkml.kernel.org/r/20190802223930.30971-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sysctl&lt;/code&gt; 이나 &lt;code&gt;procfs&lt;/code&gt; 를 통한 hugetlb 페이지 할당은 수분이나 수시간까지도 오래
걸릴 수 있습니다.  이 패치셋은 이렇게 느린 할당시간 문제를 유발하는 reclaim 과
compaction 쪽 문제를 해결할 수 있는 수정사항들을 담고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-53rc3&#34;&gt;Linux 5.3-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiW+q32YcUL62XWjAme8giZDo-=kmB9=f_JEgyEgV7eaA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiW+q32YcUL62XWjAme8giZDo-=kmB9=f_JEgyEgV7eaA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;보통 머지 윈도우가 지난 후에는 사람들이 숨을 고르고 넘어가기 때문에 보통 rc2 가
작고 rc3 부터 변경이 많아집니다.  하지만 이번 릴리즈는 이상하게도 rc2 보다
작았다는군요.&lt;/p&gt;
&lt;p&gt;커밋 기반으로 그린 rc3 개발 시각화 동영상을 다음 링크에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/V1qUa2QXZes&#34;&gt;https://youtu.be/V1qUa2QXZes&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Memory: the flat, the discontiguous, and the sparse (Korean)</title>
      <link>/post/lwn_memory_flat_discontiguous_sparse/</link>
      <pubDate>Wed, 31 Jul 2019 07:45:17 +0900</pubDate>
      <guid>/post/lwn_memory_flat_discontiguous_sparse/</guid>
      <description>&lt;p&gt;LWN 의 &amp;ldquo;Memory: the flat, the discontiguous, and the sparse&amp;rdquo; 라는 제목의 글의
한글 번역입니다.  원문은 LWN 에서 볼 수 있습니다:
&lt;a href=&#34;https://lwn.net/Articles/789304/&#34;&gt;https://lwn.net/Articles/789304/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;May 27, 2019&lt;/p&gt;
&lt;p&gt;이 기사는 Mike Rapoport 에 의해 기여되었습니다.&lt;/p&gt;
&lt;p&gt;컴퓨터 시스템에서 물리 메모리는 소중한 자원이어서, 이를 효율적으로 관리하기
위한 많은 노력이 기울여져왔습니다.
이 일은 현대의 시스템에서의 메모리 구조가 복잡해짐에 따라 더 어려워졌습니다.
물리 메모리가 실제로 어떻게 위치해 있는가를 다루기 위한 여러 계층의 추상화가
존재합니다; 그런 추상화 중 하나는 &amp;ldquo;메모리 모델&amp;rdquo; 이라고 불립니다.
커널은 세개의 모델을 지원하고 있는데, 그 중 하나는 지원이 멈춰져 가고 있습니다.
이 변경을 이해하기 위한 방법으로, 이 기사는 커널의 메모리 모델들의 진화, 현재
상태, 그리고 있을 법한 미래에 대해 자세히 들여다 봅니다.&lt;/p&gt;
&lt;h2 id=&#34;flatmem&#34;&gt;FLATMEM&lt;/h2&gt;
&lt;p&gt;리눅스가 처음 나왔을 때, 메모리는 평평했습니다: 메모리는 0 부터 수 메가바이트의
물리 주소를 갖는 단순한 선형적 배열일 뿐이었습니다.
각 물리 페이지 프레임은 커널의 &lt;code&gt;mem_map&lt;/code&gt; 배열에 하나의 원소와 연관되었으며, 이
당시에 이 배열은 해당 페이지가 가진 레퍼런스의 갯수를 세는 하나의 &lt;code&gt;unsigned short&lt;/code&gt; 원소로 이루어져 있었습니다.
하지만, 얼마 있지 않아서, 이 &lt;code&gt;mem_map&lt;/code&gt; 의 원소들은 스왑 관리를 위한 &lt;code&gt;age&lt;/code&gt; 와
&lt;code&gt;dirty counter&lt;/code&gt; 를 포함하도록 커졌습니다.
Linux 1.3.50 에서 &lt;code&gt;mem_map&lt;/code&gt; 의 원소들은 마침내 &lt;code&gt;struct page&lt;/code&gt; 로
이름지어졌습니다.&lt;/p&gt;
&lt;p&gt;이 평평한 메모리 매핑은 물리 페이지 프레임 번호 (page-frame number : PFN) 와
그에 대응되는 &lt;code&gt;struct page&lt;/code&gt; 사이의 쉽고 빠른 변환을 제공했습니다; 이 변환
작업은 간단한 배열 인덱스 계산 문제였습니다.
이후 &lt;code&gt;struct page&lt;/code&gt; 의 레이아웃 변경이 있었는데, 새로운 사용처 (예컨대, page
cache) 들과 &lt;code&gt;struct page&lt;/code&gt; 의 캐시 성능 최적화를 위한 것이었습니다.
메모리 매핑은 깔끔하고 효율적인 평평한 배열로 유지되었습니다만, 이는 중요한
단점을 가지고 있었습니다: 물리 주소 공간 상의 큰 공백을 처리할 수 없었습니다.
이 메모리 매핑 가운데 공백에 연관된 부분은 낭비되어지거나, ARM 에서처럼, 메모리
매핑 자체가 공백을 가질 수 있었습니다.&lt;/p&gt;
&lt;h2 id=&#34;discontigmem&#34;&gt;DISCONTIGMEM&lt;/h2&gt;
&lt;p&gt;상당히 비연속적인 물리 메모리를 효율적으로 처리하기 위한 지원이 리눅스를 NUMA
기계들 위에서 잘 동작하도록 하기 위한 노력의 일환으로 1999년에 메모리 관리
서브시스템으로 들어왔습니다.
이 코드는 &lt;code&gt;CONFIG_DISCONTIGMEM&lt;/code&gt; 설정 옵션에 종속적이어서, 이 메모리 모델은
&lt;code&gt;DISCONTIGMEM&lt;/code&gt; 이라 이름지어진 첫번째 모델이었습니다.&lt;/p&gt;
&lt;p&gt;이 &lt;code&gt;DISCONTIGMEM&lt;/code&gt; 모델은 메모리 노드 (memory node) 라는 개념을 소개했는데, 이
개념은 여전히 NUMA 메모리 관리의 기본으로 남아있습니다.
각 노드는 free-page lists, in-use page lists, least-recently-used (LRU) 정보,
사용 통계 등을 포함한, (대부분) 독립적인 메모리 관리 서브시스템을 갖습니다.
이런 것들 가운데, &lt;code&gt;struct pglist_data&lt;/code&gt; (또는 짧게 &lt;code&gt;pg_data_t&lt;/code&gt;) 로 표현되는 노드
데이터는 하나의 노드에 대한 메모리 매핑 정보를 가지고 있습니다.
각 노드가 연속적인 물리 메모리를 가지고 있다는 가정 하에, 노드당 하나의 &lt;code&gt;struct page&lt;/code&gt; 배열을 갖는 것은 평평한 메모리 매핑 안의 거대한 공백 문제를 해결했습니다.&lt;/p&gt;
&lt;p&gt;하지만 이게 공짜로 된 건 아닙니다.
&lt;code&gt;DISCONTIGMEM&lt;/code&gt; 에서는, 예를 들면 어떤 PFN 을 그에 연관된 &lt;code&gt;struct page&lt;/code&gt; 로
변환하기 위해 특정 페이지를 어떤 노드가 가지고 있는지를 알 수 있어야 합니다.
비슷하게, 페이지를 가지고 PFN 을 구하기 위해 어떤 노드의 메모리 맵이 해당
&lt;code&gt;struct page&lt;/code&gt; 를 가지고 있는지도 알 수 있어야 합니다.
긴 진화의 끝에, &lt;code&gt;KVADDR_TO_NID()&lt;/code&gt;, &lt;code&gt;LOCAL_MAP_BASE()&lt;/code&gt;, &lt;code&gt;ADDR_TO_MAPBASE()&lt;/code&gt;,
그리고 &lt;code&gt;LOCAL_BASE_ADDR()&lt;/code&gt; 매크로를 처음 정의한 &lt;code&gt;mips64&lt;/code&gt; 부터 시작해서 PFN 의
&lt;code&gt;struct page&lt;/code&gt; 로의 변환과 그 반대 작업은 &lt;code&gt;include/asm-generic/memory_model.h&lt;/code&gt;
안에 정의된, 비교적 간단한 &lt;code&gt;pfn_to_page()&lt;/code&gt; 와 &lt;code&gt;page_to_pfn()&lt;/code&gt; 매크로로 수행되게
되었습니다.&lt;/p&gt;
&lt;p&gt;하지만, DISCONTIGMEM 은 약점이 있었습니다: 메모리 핫플러그 (hotplug) 와
핫리무브 (hot remove) 입니다.
실제 NUMA 노드는 실제 핫플러그를 지원하기엔 너무 굵은 크기였고, 노드를 쪼개는
것은 불필요한게 많은 단편화와 오버헤드를 가져올 것이었습니다.
각 노드가 독립적인 메모리 관리 구조체들을 연관된 비용과 함께 가짐을 기억해
보세요; 노드를 쪼개는 것은 그런 비용을 상당히 증가시킬 겁니다.&lt;/p&gt;
&lt;h2 id=&#34;sparsemem&#34;&gt;SPARSEMEM&lt;/h2&gt;
&lt;p&gt;이 한계는 SPARSEMEM 을 통해 해결되었습니다.  이 모델은 메모리 매핑을
아키텍쳐별로 정의된 임의의 크기의 섹션들의 집합으로 추상화 했습니다.
각 섹션은 &lt;code&gt;struct mem_section&lt;/code&gt; 으로 표현되며, (코드에 설명된 바에 따르면):
&amp;ldquo;논리적으로, &lt;code&gt;struct page&lt;/code&gt; 의 배열로의 포인터입니다.  하지만, 다른 마술을 통해
저장됩니다&amp;rdquo;.
이 섹션들의 배열은 &lt;code&gt;SECTION_SIZE&lt;/code&gt; 크기로 효율적으로 쪼개질 수 있는 메타 메모리
매핑입니다.
PFN 과 &lt;code&gt;struct page&lt;/code&gt; 사이의 효율적인 변환을 위해, PFN 의 상위 비트 몇개는 이
섹션 배열로의 인덱스로 사용됩니다.
반대 방향 변환을 위해선, 이 섹션 넘버가 page 의 flag 로 인코딩 됩니다.&lt;/p&gt;
&lt;p&gt;이 모델이 리눅스 커널에 소개되고 몇달 후, SPARSEMEM 은 &lt;code&gt;SPARSEMEM_EXTREME&lt;/code&gt; 으로
확장되었는데, 이 모델은 산재하는 물리 주소 공간을 갖는 시스템에 적합합니다.
&lt;code&gt;SPARSEMEM_EXTREME&lt;/code&gt; 에서는, 첫번째 레벨은 &lt;code&gt;mem_section&lt;/code&gt; 구조체들로의 포인터가
되고, 실제 &lt;code&gt;mem_section&lt;/code&gt; 객체는 실제로 꽂힌 물리 메모리에 기반해서 동적으로
할당됩니다.&lt;/p&gt;
&lt;p&gt;2007년에 SPARSEMEM 의 또다른 개선이 이루어졌습니다; 이는 SPARSEMEM 의 일반적인
가상 메모리 매핑 지원 또는 &lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 이라고 불렸습니다.
&lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 의 아이디어는 전체 메모리 매핑이 가상 연속 공간에 매핑되어
있지만, 활성화된 섹션들만이 물리 페이지로 연결되어 있도록 하자는 것입니다.
이 모델은 32-bit 시스템에서는 물리 메모리의 크기가 가상 주소 공간을 넘을 수
있기 때문에 잘 동작하지 못할 수 있습니다.
하지만, 64-bit 시스템에서 &lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 은 확실히 우수합니다.
추가적인 페이지 테이블 엔트리 사용이라는 비용 아래, &lt;code&gt;page_to_pfn()&lt;/code&gt; 과
&lt;code&gt;pfn_to_page()&lt;/code&gt; 는 평평한 모델만큼이나 간단해 졌습니다.&lt;/p&gt;
&lt;p&gt;SPARSEMEM 메모리 모델의 마지막 확장은 꽤 최근 (2016) 이었습니다; 이는
persistent 메모리 디바이스의 사용 증가로 인해 이루어졌습니다.
메모리 매핑을 메인 메모리가 아니라 그런 디바이스들 내에 직접 저장하는 걸
지원하기 위해, 이 가상 메모리 매핑은 &lt;code&gt;struct vmem_altmap&lt;/code&gt; 을 사용할 수 있게
되었는데, 이 구조체는 persistent 메모리 안의 페이지 구조체를 제공합니다.&lt;/p&gt;
&lt;p&gt;2005년으로 돌아가보면, SPARSEMEM 은 &amp;ldquo;새로운, 그리고 실험적인 &lt;code&gt;discontiguous memory&lt;/code&gt; 의 대체재&amp;rdquo; 로 설명되었습니다.
&lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 을 추가한 커밋은 그것을 &amp;ldquo;우리가 SPARSEMEM 을 대부분의
시스템에 기본 (그리고 유일한) 옵션이 되게 할 가능성이 있다&amp;rdquo; 고 했습니다.
그리고 실제로, 일부 아키텍쳐는 DISCONTIGMEM 에서 SPARSEMEM 으로 옮겨탔습니다.
2008년, &lt;code&gt;SPARSEMEM_VMEMMAP&lt;/code&gt; 은 x86-64 를 위한 유일한 메모리 모델이 되었는데,
FLATMEM 보단 조금 비싸지만 DISCONTIGMEM 보다는 효율적이기 때문입니다.&lt;/p&gt;
&lt;p&gt;메모리 핫플러그, persistent 메모리 지원, 다양한 성능 최적화와 같은 최근의
메모리 관리 분야 개발은 모두 SPARSEMEM 모델을 타겟으로 하고 있습니다.
하지만 과거의 모델들은 여전히 존재해서, 아키텍쳐와 메모리 관리 코드 상의 많은
&lt;code&gt;#ifdef&lt;/code&gt; 블록의 존재와, 관련된 구성 옵션의 특별한 미로의 존재라는 추가비용을
유발하고 있습니다.
남아있는 &lt;code&gt;DISCONTIGMEM&lt;/code&gt; 사용자들을 &lt;code&gt;SPARSEMEM&lt;/code&gt; 으로 완전히 바꿔타게 하려는
노력들이 있습니다만, ia64 나 mips64 와 같은 아키텍쳐들을 그렇게 변화시키기는
쉬운 작업이 아닐 겁니다.
그리고 ARC 아키텍쳐의 DISCONTIGMEM 사용은 &amp;ldquo;normal&amp;rdquo; 메모리 아래 &amp;ldquo;high memory&amp;rdquo;
영역의 존재를 갖는데, 이는 분명 변경하기 어려울 겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc2</title>
      <link>/post/lkml_news_v5.3-rc2/</link>
      <pubDate>Fri, 26 Jul 2019 08:41:19 +0900</pubDate>
      <guid>/post/lkml_news_v5.3-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-v6-05-introduce-madvcold-and-madvpageout&#34;&gt;[PATCH v6 0/5] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190723062539.198697-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190723062539.198697-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어플리케이션의 메모리를 좀 더 적극적으로 reclaim 시킴으로써 반응성을 높이기
위한 패치셋의 일부를 따로 떼어낸, &lt;code&gt;MADV_COLD&lt;/code&gt; 와 &lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 힌트를
&lt;code&gt;madvise()&lt;/code&gt; 에 추가하는 패치의 여섯번째 버전입니다.&lt;/p&gt;
&lt;p&gt;일곱번째 버전도 빠르게 올라왔군요:
&lt;a href=&#34;https://lkml.kernel.org/r/20190726023435.214162-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190726023435.214162-1-minchan@kernel.org&lt;/a&gt;
단순히 mmotm 최신 버전 위로 리베이스 한 것 같네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v9-0021-generic-page-walk-and-ptdump&#34;&gt;[PATCH v9 00/21] Generic page walk and ptdump&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190722154210.42799-1-steven.price@arm.com&#34;&gt;https://lkml.kernel.org/r/20190722154210.42799-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;x86 과 arm64 가 범용적 페이지 테이블 워킹을 하도록 했던 해치셋을 조금 더 확장한
버전입니다.  기존 대비 페이지 테이블 덤프 기능도 일반화 시킨게 차이군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v1-12-mmpageidle-add-support-for-perpid-pageidle-using-virtual-indexing&#34;&gt;[PATCH v1 1/2] mm/page_idle: Add support for per-pid page_idle using virtual indexing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190722213205.140845-1-joel@joelfernandes.org&#34;&gt;https://lkml.kernel.org/r/20190722213205.140845-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널은 &lt;code&gt;page_idle&lt;/code&gt; 이라는 인터페이스를 통해 특정 페이지의 액세스 여부를
파악할 수 있게 합니다.  저도 이걸 통해서 wss 를 재거나 하는데 쓸 수 있는
&lt;a href=&#34;https://github.com/sjp38/idle_page_tracking&#34;&gt;도구&lt;/a&gt;를 만들었었죠.&lt;/p&gt;
&lt;p&gt;문제는 이 인터페이스는 쓰기가 조금 복잡합니다.  PFN 을 가지고 페이지를 지목할
수 있게 되어 있기 때문에 특정 프로세스의 데이터 액세스를 추적하려면 해당
프로세스가 사용하고 있는 가상 메모리가 어떤 PFN 으로 매핑되어 있는지 알아야
하기 때문이죠.  달리 말하면 &lt;code&gt;page_idle&lt;/code&gt; 인터페이스가 글로벌하기 때문에 생기는
문제입니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 &lt;code&gt;/proc/&amp;lt;pid&amp;gt;/page_idle&lt;/code&gt; 파일을 생성하고 이를 통해 프로세스 단위로
virtual page frame number (VFN) 을 통해 페이지 트랙킹을 할 수 있게 합니다.
이로써 이 인터페이스를 사용하는 유저스페이스 도구의 코드가 간단해질 뿐더러 보안
이슈도 좀 더 편리해지죠.  구글에선 내부적으로 이를 통해 heap profiler
(heapprofd) 를 좀 더 쉽게 만들었나보군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-mmpageidle-simple-idle-page-tracking-for-virtual-memory&#34;&gt;[PATCH RFC] mm/page_idle: simple idle page tracking for virtual memory&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/156388286599.2859.5353604441686895041.stgit@buzz&#34;&gt;https://lkml.kernel.org/r/156388286599.2859.5353604441686895041.stgit@buzz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞에서 소개한 패치와 비슷하게 &lt;code&gt;page_idle&lt;/code&gt; 을 간편화 시키는 패치셋입니다.  특정
pid 의 모든 mapped page frame 의 access bit 을 한번에 clear 할 수 있게 합니다.
인터페이스는 &lt;code&gt;echo 6 &amp;gt; /proc/&amp;lt;pid&amp;gt;/clear_refs&lt;/code&gt; 같은 형태군요.  이후,
&lt;code&gt;/proc/&amp;lt;pid&amp;gt;/smaps&lt;/code&gt; 파일을 이용해 현재 idle 한 페이지들의 갯수를 알 수
있습니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-53rc2&#34;&gt;Linux 5.3-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiiKRJprQDJqJzdcjdaGs73UtVPTM2+jOHWdMgu5Sp2HQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiiKRJprQDJqJzdcjdaGs73UtVPTM2+jOHWdMgu5Sp2HQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;두번째 rc 버전이 예정대로 나왔습니다.  변경사항이 많은 머지윈도우였던 만큼 rc2
도 꽤 수정사항이 많은 것 같습니다.  전체적으로 문서, arch 코드, 그리고 드라이버
쪽 수정사항이 대부분인 듯 하군요.&lt;/p&gt;
&lt;p&gt;앞선 rc1 릴리즈부터 이번 릴리즈 사이의 변경 사항의 시각화 비디오를 아래
링크에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/yxtq3-lhebQ&#34;&gt;https://youtu.be/yxtq3-lhebQ&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NASA&#39;s Power of 10 Coding Rules (Korean)</title>
      <link>/post/nasa_coding_rules/</link>
      <pubDate>Sun, 21 Jul 2019 10:22:56 +0900</pubDate>
      <guid>/post/nasa_coding_rules/</guid>
      <description>&lt;p&gt;우연히 발견한
&lt;a href=&#34;https://dev.to/xowap/10-rules-to-code-like-nasa-applied-to-interpreted-languages-40dd?fbclid=IwAR1OA1FluREjWhd_1s93WBLtix8wrJZU6tOa5YLC-G9YxVu3iPeOOu09dzQ&#34;&gt;글&lt;/a&gt;
을 통해 &lt;a href=&#34;http://spinroot.com/gerard/pdf/P10.pdf&#34;&gt;NASA 의 코딩 규칙 10가지&lt;/a&gt; 를
알게 되었습니다.
너무 깐깐한 규칙 아닌가 싶기도 하지만 &lt;code&gt;ping&lt;/code&gt; 하나 날리는데 40분이 걸리고
물리적으로는 접근할 수 없는 화성에 로봇을 보내야 한다면 이런 규칙은 합리적이라
볼 수 있겠죠.
제가 참고한 저 글은 이걸 파이썬이나 자바스크립트와 같은 곳에서도 어떻게 적용해
볼 수 있을지를 고찰해 보고 있습니다.
이 포스트에선 단순히 이 10개의 규칙을 번역해 봅니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;goto&lt;/code&gt; 또는 재귀호출과 같은 복잡한 수행 흐름을 피하라.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;원문: 모든 코드를 매우 간단한 수행 흐름으로 제한하라 - &lt;code&gt;goto&lt;/code&gt; 문, &lt;code&gt;setjmp` 또는 &lt;/code&gt;longjmp`` 명령, 그리고 직/간접적 재귀 호출을 사용하지 말라.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Avoid complex flow constructs, such as goto and recursion.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Restrict all code to very simple control flow constructs – do not use goto
statements, setjmp or longjmp constructs, and direct or indirect recursion.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;모든 루프 (반복문) 은 고정된 최대 반복 횟수를 가져야 한다.  이는 무한반복
코드를 방지한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;모든 루프는 고정된 최대 반복 횟수를 가져야 한다.  코드 체크 도구가 정적으로
어떤 루프의 반복 횟수가 미리 설정된 최대 횟수를 넘는지를 쉽게 검사할 수 있어야
한다.  이 반복 한계가 정적으로 검증될 수 없다면, 이 규칙이 깨어진 것으로
간주한다.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;All loops must have fixed bounds. This prevents runaway code.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All loops must have a fixed upper-bound. It must be trivially possible for a
checking tool to prove statically that a preset upper-bound on the number of
iterations of a loop cannot be exceeded. If the loop-bound cannot be proven
statically, the rule is considered violated.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;힙 메모리 할당을 피하라.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;초기화 단계 후에는 동적 메모리 할당을 사용하지 말라.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Avoid heap memory allocation.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Do not use dynamic memory allocation after initialization.&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;함수의 크기를 한장의 종이에 적힐 수 있게 제한하라.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;어떤 함수도 명령문당 한줄, 선언당 한줄을 갖는 표준 레퍼런스 포맷을 지킨 채로
한장의 종이에 프린트 될 수 있는 길이 이상을 가져선 안된다.  보통, 이는 함수당
60줄 이상의 코드를 가져선 안된다는 것을 의미한다.&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Restrict functions to a single printed page.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;No function should be longer than what can be printed on a single sheet of
paper in a standard reference format with one line per statement and one line
per declaration. Typically, this means no more than about 60 lines of code per
function.&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;최소 함수당 두개의 런타임 단정문을 사용하라.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;평균적으로 함수당 최소 두개의 단정문이 있어야 한다.  단정문은 실제 수행 중에
일어나선 안되는 문제가 있는 조건을 검사하는데 사용되어야 한다.  단정문은 항상
사이드 이펙트로부터 자유로워야 하고 Boolean 테스트로 정의되어야 한다.  단정문이
실패한다면 명시적인 복구 동작이 행해져야 하는데, 예를 들면 이 실패한 단정문을
수행한 함수를 호출한 측에 에러 정보를 리턴하는 것이다.  정적 검사 도구가 절대
실패할 수 없거나 항상 성공한다고 증명해내는 단정문은 모두 이 규칙을 어기는
것이다. (예를 들어, 전혀 도움 되지 않을 &lt;code&gt;assert(true)&lt;/code&gt; 문을 추가함으로써 이
규칙을 만족시킬 순 없다.)&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Use a minimum of two runtime assertions per function.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The assertion density of the code should average to a minimum of two assertions
per function. Assertions are used to check for anomalous conditions that should
never happen in real-life executions. Assertions must always be side-effect
free and should be defined as Boolean tests. When an assertion fails, an
explicit recovery action must be taken, e.g., by returning an error condition
to the caller of the function that executes the failing assertion. Any
assertion for which a static checking tool can prove that it can never fail or
never hold violates this rule. (I.e., it is not possible to satisfy the rule by
adding unhelpful &amp;ldquo;assert(true)&amp;rdquo; statements.)&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;데이터의 사용 영역을 가능한 작게 잡아라.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;데이터 객체는 가능한 가장 작은 단계의 영역에서 선언되어야만 한다.&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Restrict the scope of data to the smallest possible.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Data objects must be declared at the smallest possible level of scope.&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;리턴 타입이 &lt;code&gt;void&lt;/code&gt; 가 아닌 (non-void) 모든 함수의 리턴값은 검사되거나
리턴값이 무의미하다는 걸 알리기 위해 &lt;code&gt;void&lt;/code&gt; 로 캐스팅 되어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;non-void&lt;/code&gt; 함수의 리턴값은 각 호출 함수에 의해 체크되어야 하며, 패러미터의
유효성은 각 함수 안에서 검사되어야 한다.&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;Check the return value of all non-void functions, or cast to void to
indicate the return value is useless.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The return value of non-void functions must be checked by each calling
function, and the validity of parameters must be checked inside each function.&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;전처리기를 아껴 사용하라.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;전처리기의 사용은 헤더 파일을 포함하는 용도와 간단한 매그로 정의로 국한되어야만
한다.  토큰 붙이기, 유동적 갯수의 인자 리스트, 그리고 재귀적 매크로 호출은
허용되지 않는다.  모든 매크로는 완전한 구문적 단위로 확장되어야만 한다.  조건적
컴파일 지시어의 사용은 많은 경우 모호하지만, 항상 금지될 수는 없다.  이는
거대한 소프트웨어 개발 노력이 든다 하더라도 동일한 헤더 파일의 중복 포함을
방지하는 상용문 외의 한두개의 조건적 컴파일 지시어를 위한 정당화가 필요하다는
것을 의미한다.  그런 모든 경우에는 도구 기반의 검사를 통한 플래그가 붙어있거나
코드 안에 사용의 정당성에 대한 설명이 있어야 한다.&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;Use the preprocessor sparingly.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The use of the preprocessor must be limited to the inclusion of header files
and simple macro definitions. Token pasting, variable argument lists
(ellipses), and recursive macro calls are not allowed. All macros must expand
into complete syntactic units. The use of conditional compilation directives is
often also dubious, but cannot always be avoided. This means that there should
rarely be justification for more than one or two conditional compilation
directives even in large software development efforts, beyond the standard
boilerplate that avoids multiple inclusion of the same header file. Each such
use should be flagged by a tool-based checker and
justified in the code.&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;포인터의 사용을 한단계 디레퍼런스로 제한하고, 함수 포인터는 사용하지 말라.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;포인터의 사용은 제한되어야 한다.  구체적으로, 두단계 이상의 디레퍼런스는
허용되지 않는다.  포인터 디레퍼런스 오퍼레이션이 매크로 정의나 &lt;code&gt;typedef&lt;/code&gt; 선언
안에 숨겨져선 안된다.  함수 포인터는 허용되지 않는다.&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;Limit pointer use to a single dereference, and do not use function pointers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The use of pointers should be restricted. Specifically, no more than one level
of dereferencing is allowed. Pointer dereference operations may not be hidden
in macro definitions or inside typedef declarations. Function pointers are not
permitted.&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;모든 가능한 경고를 활성화 한 채 컴파일 하라; 그리고 모든 경고는 해당
소프트웨어의 배포 전에 해결되어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;모든 코드는 개발을 시작한 첫날부터 모든 컴파일러 경고가 가장 엄중한 설정으로
활성화 된 채 컴파일 되어야만 한다.  모든 코드는 이 설정 아래 아무런 경고 없이
컴파일 되어야 한다.  모든 코드는 최소 하루에 한번, 그러나 가급적 한번 넘게,
최신의 정적 소스 코드 분석도구를 통해 검사되어야 하며 이 검사를 어떤 경고도
없이 통과해야만 한다.&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;Compile with all possible warnings active; all warnings should then be
addressed before release of the software.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All code must be compiled, from the first day of development, with allcompiler
warnings enabled at the compiler’s most pedantic setting. All code must compile
with these setting without any warnings. All code must be checked daily with at
least one, but preferably more than one, state-of-the-art static source code
analyzer and should pass the analyses with zero warnings.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the Linux Kernel Summit 2019</title>
      <link>/post/kernelsummit2019_talk/</link>
      <pubDate>Sat, 20 Jul 2019 02:41:46 +0900</pubDate>
      <guid>/post/kernelsummit2019_talk/</guid>
      <description>&lt;p&gt;[Linux Plumbers Conference 2019]
(&lt;a href=&#34;https://www.linuxplumbersconf.org/blog/2019/&#34;&gt;https://www.linuxplumbersconf.org/blog/2019/&lt;/a&gt;) 와 함께 열리는 올해의
[Linux Kernel Summit] (&lt;a href=&#34;https://lwn.net/Articles/788378/&#34;&gt;https://lwn.net/Articles/788378/&lt;/a&gt;) 에 제안한 발표
주제가 accept 되어 9월에 리스본에서 이에 대한 내용을 발표하게
되었습니다.  발표 제목은 &amp;ldquo;Tracing Data Access Pattern with Bounded
Overhead and Best-effort Accuracy&amp;rdquo; 입니다.&lt;/p&gt;
&lt;p&gt;티켓이 너무 일찍 팔려버리는 바람에 올해는 들으러도 못가나 걱정했는데 갈 수 있게
됐네요, 다행입니다! :D&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;My talk proposal to the Linux Kernel Summit of this year which is co-located
with the Linux Plumbers has accepted!  Hope to see you in Lisbon.  The title of
the talk is, &amp;ldquo;Tracing Data Access Pattern with Bounded Overhead and Best-effort
Accuracy&amp;rdquo;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.3-rc1</title>
      <link>/post/lkml_news_v5.3-rc1/</link>
      <pubDate>Thu, 11 Jul 2019 02:42:22 +0900</pubDate>
      <guid>/post/lkml_news_v5.3-rc1/</guid>
      <description>&lt;h2 id=&#34;patch-v5-05-introduce-madvcold-and-madvpageout&#34;&gt;[PATCH v5 0/5] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190714233401.36909-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190714233401.36909-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MADV_COLD&lt;/code&gt; 와 &lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 을 구현하는 패치, 어느새 다섯번째 버전입니다.  큰
변경은 없는 것 같군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-03-make-working-with-compound-pages-easier&#34;&gt;[PATCH v2 0/3] Make working with compound pages easier&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190721104612.19120-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20190721104612.19120-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 를 다루기 쉽게끔 &lt;code&gt;page_size()&lt;/code&gt;, &lt;code&gt;page_shift()&lt;/code&gt;, 그리고
&lt;code&gt;compound_nr()&lt;/code&gt; 이라는 세개의 helper 함수를 추가하고 이 함수들을 사용하게끔
기존 코드를 다듬는 패치셋입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PAGE_SIZE &amp;lt;&amp;lt; compound_order(page)&lt;/code&gt; 는 &lt;code&gt;page_size(page)&lt;/code&gt; 가,
&lt;code&gt;PAGE_SHIFT + compound_order(page)&lt;/code&gt; 는 &lt;code&gt;page_shift(page)&lt;/code&gt; 가, 그리고
&lt;code&gt;1 &amp;lt;&amp;lt; compound_order(page)&lt;/code&gt; 는 &lt;code&gt;compound_nr(page)&lt;/code&gt; 가 되는 것이죠.&lt;/p&gt;
&lt;h2 id=&#34;linux-53rc1&#34;&gt;Linux 5.3-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wiVjkTqzP6OppBuLQZ+t1mpRQC4T+Ho4Wg2sBAapKd--Q@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/wiVjkTqzP6OppBuLQZ+t1mpRQC4T+Ho4Wg2sBAapKd--Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 릴리즈 사이의 변경 사항을 시각화 한 비디오를 아래 링크에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/vx_BUvs00u8&#34;&gt;https://youtu.be/vx_BUvs00u8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2주일이 지나고 5.3 을 향한 첫번째 rc 릴리즈가 이루어졌습니다.&lt;/p&gt;
&lt;p&gt;이번 rc 릴리즈는 커밋 갯수로 볼 때 꽤 큰 릴리즈입니다.  4.12, 4.15, 4.19 때의
머지 윈도우와 비슷한 정도라는군요.  참고로 가장 큰 머지윈도우는 아직 4.9 의
것이었습니다.&lt;/p&gt;
&lt;p&gt;이번 머지 윈도우는 초기에 두개의 버그가 나와서 토발즈를 괴롭게 했다고 하는데요.
하나는 토발즈의 커널 컨피규레이션이 너무 간단하게 되어 있어 어떤 코드가 테스트
되지 않아 토발즈가 만들어낸 버그였고, 다른 하나는 패치 자체에 존재하는
버그였다고 합니다.  토발즈가 유발한 버그는 토발즈가 고쳤고, 두번째 버그를
일으킨 패치는 그냥 리버트 시켰다고 하는군요.&lt;/p&gt;
&lt;p&gt;그렇다고는 해도 이번 머지 윈도우의 후반부는 충분히 스무스하게 이뤄졌다고
합니다.&lt;/p&gt;
&lt;p&gt;그리고 이번 머지 윈도우에 이름을 올린 개발자는 총 1600명이었다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2</title>
      <link>/post/lkml_news_v5.2/</link>
      <pubDate>Mon, 01 Jul 2019 15:48:04 +0900</pubDate>
      <guid>/post/lkml_news_v5.2/</guid>
      <description>&lt;h2 id=&#34;patch-v5-0012-sara-a-new-stacked-lsm&#34;&gt;[PATCH v5 00/12] S.A.R.A. a new stacked LSM&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1562410493-8661-1-git-send-email-s.mesoraca16@gmail.com&#34;&gt;https://lkml.kernel.org/r/1562410493-8661-1-git-send-email-s.mesoraca16@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다양한 보안 측정을 위한 공용 인터페이스를 제공하는 스택 기반의 리눅스 보안
모듈입니다.  이름이 재밌네요. S.A.R.A 는 S.A.R.A is Another Recursive Acronym
의 약자라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-52&#34;&gt;Linux 5.2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whtW3FdruS-q2zehJPSan1SKtHoFHKX28A3J_1gfTFUMw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whtW3FdruS-q2zehJPSan1SKtHoFHKX28A3J_1gfTFUMw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 릴리즈 중간엔 토발즈의 여행이 있었죠.  초반엔 예상 외로 큰 rc 릴리즈도
있었구요.  해서 이번주는 rc8 이 릴리즈 될지 5.2가 릴리즈 될지 저도 좀
궁금했는데, 최종적으로 5.2 릴리즈가 되었습니다.  토발즈도 rc8 을 릴리즈 할까
망설였다고 하네요.  하지만 그래야 할만한 문제가 전혀 없었기에 5.2를 릴리즈
했다고 합니다.&lt;/p&gt;
&lt;p&gt;더불어, 토발즈는 이번 여행 중에도 스쿠버다이빙을 즐겼나보네요.  더크 혼델이
찍은 사진도 공유했습니다:
&lt;a href=&#34;https://hohndel.name/palau-2019&#34;&gt;https://hohndel.name/palau-2019&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Integrate external git repository with its history</title>
      <link>/post/integrate_external_git_repository_with_history/</link>
      <pubDate>Thu, 27 Jun 2019 17:02:49 +0900</pubDate>
      <guid>/post/integrate_external_git_repository_with_history/</guid>
      <description>&lt;p&gt;프로젝트 a 와 프로젝트 b 를 병렬로 진행하고 있었는데, 두개의 리포지토리를
합치고 싶어지는 경우가 있습니다.  예컨대 프로젝트 a 의 성격이 보다 범용이
되었고 프로젝트 b 는 프로젝트 a 를 위한 도구적 성격이 되는 경우가 있겠죠.
a 프로젝트에 &amp;lsquo;b&amp;rsquo; 디렉토리를 만들고 그 아래 기존 프로젝트 b 의 파일들을 위치하고
싶습니다.
하지만 기존 b 프로젝트의 git 히스토리들도 유지하고 싶습니다.
비슷한 사례로 리눅스 커널 메모리 모델 프로젝트는 별도의 리포지토리[1] 로
개발되었지만 리눅스 업스트림 리포지토리의 tools/ 디렉토리 아래로 머지[2]
되었는데, 이 때 기존 개발 히스토리를 유지했죠.&lt;/p&gt;
&lt;p&gt;이 포스트는 이렇게 특정 git 리포지토리를 그 히스토리를 유지한 채 다른 git
리포지토리의 하위 디렉토리로 옮기는 법을 설명합니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://github.com/aparri/memory-model&#34;&gt;https://github.com/aparri/memory-model&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/memory-model&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/memory-model&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;--&#34;&gt;초기 상황과 목표&lt;/h2&gt;
&lt;p&gt;먼저 현재 디렉토리 아래에 a 리포지토리와 b 리포지토리가 있다고 가정합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls
a   b
$
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;우리는 a 리포지토리 아래 b/ 디렉토리를 만들고 그 아래 b 리포지토리를 넣고
싶습니다.&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;전략&lt;/h2&gt;
&lt;p&gt;b 리포지토리가 b/ 디렉토리 아래 모든 파일을 위치하도록 변경한 후, 이
리포지토리를 a 리포지토리에서 &lt;code&gt;--allow-unrelated-histories&lt;/code&gt; 옵션을 사용해
머지하도록 하겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;----&#34;&gt;합쳐질 리포지토리 파일 구조 변경&lt;/h2&gt;
&lt;p&gt;먼저 b 리포지토리의 파일들이 b/ 디렉토리 아래 위치하도록 만듭니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd b
$ mkdir b
$ git mv !(b) b
$ git commit -a -m &amp;quot;Relocate files for inclusion&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;-&#34;&gt;리포지토리 병합&lt;/h2&gt;
&lt;p&gt;이제 b 리포지토리를 임시 remote 리포지토리로 등록하고 머지합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ../a
$ git remote add temp ../b
$ git fetch temp
$ git merge --allow-unrelated-histories temp/master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;--allow-unrelated-histories&lt;/code&gt; 는 경로가 다른 파일에 대한 커밋들도 머지가 될 수
있게 해줍니다.&lt;/p&gt;
&lt;p&gt;임시로 등록한 remote 리포지토리는 지워줍시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git remote rm temp
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading1&#34;&gt;정리&lt;/h2&gt;
&lt;p&gt;이상과 같이 기존의 개발 히스토리를 유지하면서 특정 git 리포지토리를 다른 git
리포지토리의 하위 디렉토리로 병합하는 방법을 알아보았습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc7</title>
      <link>/post/lkml_news_v5.2-rc7/</link>
      <pubDate>Thu, 27 Jun 2019 15:35:12 +0900</pubDate>
      <guid>/post/lkml_news_v5.2-rc7/</guid>
      <description>&lt;h2 id=&#34;patch-v7-04-thp-aware-uprobe&#34;&gt;[PATCH v7 0/4] THP aware uprobe&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190625235325.2096441-1-songliubraving@fb.com&#34;&gt;https://lkml.kernel.org/r/20190625235325.2096441-1-songliubraving@fb.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uprobe&lt;/code&gt; 가 THP 로 받쳐지고 있는 코드에 적용되면 이 THP 는 regular page 로
쪼개집니다.  이 패치셋은 이 문제를 해결합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v9-06-enable-thp-for-text-section-of-nonshmem-files&#34;&gt;[PATCH v9 0/6] Enable THP for text section of non-shmem files&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190625001246.685563-1-songliubraving@fb.com&#34;&gt;https://lkml.kernel.org/r/20190625001246.685563-1-songliubraving@fb.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어플리케이션의 텍스트 섹션을 THP 로 지원해 줌으로써 iTLB 미스를 줄이고 성능을
높이고자 하는 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-52rc7&#34;&gt;Linux 5.2-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgL5GyQ93o=VyiymFPfw=Z0TGHEPBJrCtGSqFSW2Mhx8g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgL5GyQ93o=VyiymFPfw=Z0TGHEPBJrCtGSqFSW2Mhx8g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여전히 토발즈의 여행 탓에 릴리즈가 평소와 조금 다른 시간대에 이뤄졌습니다,
토발즈 자신의 시점으로는 평소와 같은 일요일 오후지만요.  아마도 아시아 쪽에
있는 것 같군요.  이번 릴리즈는 심지어 바다 위에서의 릴리즈라네요.  인터넷 안될
줄 알았는데 Dirk Hohndel 이 핸폰 핫스팟을 빌려줬다고 ;)&lt;/p&gt;
&lt;p&gt;이번 릴리즈는 고요했고, 별 문제 없었다고 합니다.  다음주엔 정식 릴리즈일까요?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc6</title>
      <link>/post/lkml_news_v5.2-rc6/</link>
      <pubDate>Mon, 17 Jun 2019 19:22:48 +0900</pubDate>
      <guid>/post/lkml_news_v5.2-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-notformerge-05-extend-remote-madvise-api-to-ksm-hints&#34;&gt;[PATCH NOTFORMERGE 0/5] Extend remote madvise API to KSM hints&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190616085835.953-1-oleksandr@redhat.com&#34;&gt;https://lkml.kernel.org/r/20190616085835.953-1-oleksandr@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 여러번 소개한 remote &lt;code&gt;madvise()&lt;/code&gt; 에 대한 관심이 많이 있는 것
같네요.
이 패치셋은 &lt;code&gt;MADV_MERGEABLE&lt;/code&gt;, &lt;code&gt;MADV_UNMERGEABLE&lt;/code&gt; 을 추가해서 KSM 힌트도
&lt;code&gt;madvise()&lt;/code&gt; 를 통해 줄 수 있게 합니다.&lt;/p&gt;
&lt;p&gt;논의를 위한 패치라 이대로 머지되진 않겠지만, 사용처가 많이 늘어날 것 같네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-52rc6&#34;&gt;Linux 5.2-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wg+nPKhdn=vKSgJQkfOSGhauTO4jyt=0FH9cnM_QChDLw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wg+nPKhdn=vKSgJQkfOSGhauTO4jyt=0FH9cnM_QChDLw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;안타깝게도 기대와 달리 이번 릴리즈는 조용하지 않았습니다.  이번 5.2 개발을
위한 릴리즈 중 머지 윈도우와 rc1 을 제외하면 rc6 가 오히려 가장 많은 변화를
담고 있다는군요.  TCP SACK/fragmentation/mss 수정이 영향을 끼친 것들 중
하나라고 합니다.&lt;/p&gt;
&lt;p&gt;또, 이번에도 릴리즈가 빨라진 건 내일 토발즈가 비행기 타기 때문이랍니다.
컨퍼런스도 참여해야하고 휴양도 취하는 모양입니다.  이 때문에 rc7 은 조금 늦어질
수 있다는군요.  보통은 rc6 가 가장 안정화 되었을 무렵이라 이렇게 일정을
잡았다고 합니다만, 일이 복잡해졌네요.  자신에게 무슨 일이 있으면 Greg 이 대신할
거라고 합니다.&lt;/p&gt;
&lt;p&gt;뭐, 그렇다곤 해도 5.2 릴리즈 진행은 예정대로 진행될 것 같다고도 합니다.  이번
릴리즈의 주요 변경은 SPDX 제외하면 네트워킹, 셀프테스트 그리고 문서화였군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My Job Interview Record (2019 summer)</title>
      <link>/post/my_job_interview/</link>
      <pubDate>Mon, 17 Jun 2019 18:16:05 +0900</pubDate>
      <guid>/post/my_job_interview/</guid>
      <description>&lt;p&gt;이번 여름 졸업을 앞두고 구직 활동을 한 결과, 얼마전 운좋게도 미국에 본사를 두고
있는 한 글로벌 IT 기업의 커널/하이퍼바이저 팀으로부터 잡 오퍼를 받았습니다.
취업을 향한 한걸음 한걸음이 어둠 속을 더듬더듬, 때로는 막무가내로 헤쳐나가는
느낌이었는데, 이런 저의 경험을 공유하는게 어떤 분들께는 도움이 되지 않을까 싶어
공유해 봅니다.&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;목표설정&lt;/h2&gt;
&lt;p&gt;취업을 할까 포닥을 할까 모호한 고민만 하다가 어느새 4월 중순이 되어서야 해외 IT
회사로 직장을 구하겠다는 목표가 설정되었습니다.
그제서야 든 생각은 너무 늦었다, 준비가 부족하다, 하는 것이었습니다.
취업을 위해 뭐 하나 준비한게 없더라구요.&lt;/p&gt;
&lt;p&gt;일단은 졸업 후 국내에서 취업 준비를 탄탄히 해서 내년 봄 시즌에 해외 글로벌 IT
기업에 취업하는걸 목표로 하되, 당장 취업 준비를 시작하고 붙을 가능성은 없겠지만
볼 수 있는 면접은 연습삼아서라도 보기로 마음을 먹었습니다.&lt;/p&gt;
&lt;h2 id=&#34;--&#34;&gt;취업을 위한 준비&lt;/h2&gt;
&lt;p&gt;가장 시급한 건 영어 듣기 능력이었습니다.
토발즈의 인터뷰와 키노트, 리눅스 파운데이션 주최 컨퍼런스 발표들과 리눅스를
주제로 한 팟캐스트 등을 mp3 로 추출해 매일 출퇴근 길에 들었습니다.&lt;/p&gt;
&lt;p&gt;코딩 테스트를 연습하기 위해서는 유명한 &lt;a href=&#34;http://www.crackingthecodinginterview.com/&#34;&gt;cracking the coding
interview&lt;/a&gt; 책도 읽어보고, 이 즈음에
우연히 지인에게 소개받은 &lt;a href=&#34;https://leetcode.com/&#34;&gt;leetcode&lt;/a&gt; 라는 사이트를 통해
코딩 문제도 풀어보기 시작했습니다.
작년 무렵 지인을 통해 &lt;code&gt;cracking the coding interview&lt;/code&gt; 책을 이용한 오프라인
스터디도 진행했는데, 그 경험이 큰 도움이 되었습니다.
&lt;code&gt;Leetcode&lt;/code&gt; 는 왜 이제 알게 됐나 싶은 생각이 들 정도로 도움이 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;--1&#34;&gt;링크드인 및 이력서&lt;/h2&gt;
&lt;p&gt;지인들과의 대화 도중, 링크드인은 내가 지금 직업을 구하고 있는지 아닌지를 알리는
기능이 있다는 걸 우연히 알게 되었습니다.
이걸 켜니 몇몇 회사의 리크루터들이 연락을 줬습니다.
이 회사도 마찬가지였습니다.
채용하는 포지션에 대한 아주 짧막한 설명과 함께, 관심 있으면 이력서를 보내달라는
연락이 왔고, 이력서를 보내니 회사의 해당 포지션 채용 링크를 보내주며 시스템을
통해 지원해 달라고 했습니다.&lt;/p&gt;
&lt;h2 id=&#34;-&#34;&gt;온라인 코딩&lt;/h2&gt;
&lt;p&gt;사흘만에 이 회사에서 구축한 코딩 테스트 시스템으로의 초대장이 왔습니다.
Leetcode 와 같은 여타 코딩 테스트 사이트랑 비슷하게 되어 있는데, 네개 정도의
문제가 있습니다.
편한 시간을 골라서 문제를 풀 수 있으며, 테스트를 시작하면 중단은 못하고 두시간
내에 테스트를 반드시 끝내야 합니다.
실제 인터뷰어와 전화를 통해 진행하는게 아니다보니 내가 편한 시간을 고를 수
있고, 영어 듣기가 부족한 저로썬 문제가 글로 써져 있어 좋더군요.
제출하고 나면 곧바로 풀이에 대한 전체 테스트 결과도 볼 수 있었습니다.&lt;/p&gt;
&lt;p&gt;아주 어려운 문제는 없었고 간단한 자료구조와 알고리즘 위주였기에 무난하게 문제를
풀 수 있었습니다.
하지만 마지막 한문제는 일부 corner case 를 제대로 풀지 못해 점수가 만족스럽지는
않았습니다.&lt;/p&gt;
&lt;h2 id=&#34;-1&#34;&gt;전화 인터뷰&lt;/h2&gt;
&lt;p&gt;몇일 후, 전화 인터뷰 하고 싶으니 일정을 잡자는 메일이 왔습니다.
적당히 일정을 잡고 인터뷰를 진행했습니다.&lt;/p&gt;
&lt;p&gt;애초에 외국 회사는 온사이트 인터뷰까지 진행되면 후보에게 비행기표 등을 지불해야
되니 이 단계에서 가급적 많은 후보자를 탈락시킨다고 합니다.
전화 통화는 바디랭귀지가 일체 허용되지 않거니와 통화품질, 인터뷰어의 독특한
억양 등의 문제가 있을 수 있기에 저처럼 영어가 약한 사람에게는 정말 죽을
맛입니다.
다행히도 이번 인터뷰는 통화품질도 좋았고 인터뷰어의 발음도 제 귀에 또렷하게
들리는 억양이라 큰 문제는 없었습니다.
그래도 역시 기본 실력이 어디가진 않아서, 몇번은 못알아듣고 버벅이긴 했습니다.&lt;/p&gt;
&lt;p&gt;인터뷰는 약 한시간 정도 분량으로, 제가 채용되면 함께 일하게 될 팀과 업무,
그리고 인터뷰어 자신에 대한 간단한 소개를 시작으로, 제 소개와 그에 대한 문답,
업무적 경험에 대한 질문, 기술적 질문으로 이어졌고, 막판에 약 5분 정도 제가
회사에 대해 질문할 수 있는 시간으로 구성되었습니다.&lt;/p&gt;
&lt;p&gt;소개 후의 문답은 제가 소개한 제 연구들에 대해 깊은 질문이 왔는데, 평소 하는
일이라 쉽게 대답할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;업무적 경험에 대한 문답에서는 어떤 특정 상황에 처했던 경험을 이야기 해달라고
하는데, 이게 꽤 어려웠습니다.
질문받은 경우에 처한 경험이야 많지만 그 중 어떤 걸 골라서 이야기해야 좋은
인상을 얻을까 고민하게 되거든요.
팀원의 반대 의견에 부딪혔을 때에 대한 경험도 요청받았는데, 재밌게도 그날 아침에
함께 연구를 진행하고 있는 친구와 격렬하게 토론했던 즐거운 경험이 있어 그걸
이야기 했습니다.
다른 질문들에는 오픈소스 활동과 개인 프로젝트에 대한 경험도 이야기 했습니다.&lt;/p&gt;
&lt;p&gt;기술적 질문은 커널의 동작 구조 및 원리에 대한 몇가지 질문이 있었습니다.
역시 밥먹고 하는 일이다 보니 어렵지 않게 답할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;마지막 질답 시간엔 무슨 질문했는지 기억이 잘 안나는데, 내가 이 면접 통과하고
함께 일하게 되면 어떤 일을 하게 될지, 내가 소개한 연구들 중 어떤 내용이 회사에
도움 될 수 있을거라 생각하는지 뭐 그런 질문을 한 것 같습니다.&lt;/p&gt;
&lt;p&gt;전화 중에도 코딩 테스트가 있을 줄 알았는데, 없었습니다.
다행이었죠.&lt;/p&gt;
&lt;h2 id=&#34;--2&#34;&gt;온사이트 인터뷰 제의&lt;/h2&gt;
&lt;p&gt;다시 몇일 후, 2차 전화 인터뷰가 있겠거니 하고 있었는데, 온사이트 인터뷰를
보자는 메일이 왔습니다!
예전에 모 회사와는 대략 네다섯번까지 이어지는 전화 인터뷰를 하면서 파김치가
되었던 기억이 있는데, 이번엔 한번의 전화 인터뷰만에 스크리닝이 끝나서 정말
기뻤습니다.
메일은 온사이트 인터뷰 가능한 일정 (3주의 기한을 줬습니다), 일하게 된다면
언제부터 일할 수 있는지, 원하는 연봉은 얼마인지, 인터뷰 보러 오는데 비자
필요한지 등을 물어왔습니다.&lt;/p&gt;
&lt;p&gt;적당적당히 일정이 잡혔고, 회사에서 비행기표와 호텔을 예약해 줬습니다.
호텔은 이틀을 예약해 줬습니다.
앞에서 이야기했듯 사실 이때까지만 해도 전 이 회사에 붙을 거라는 생각은
없었습니다.
회사가 면접 통과하기 어렵기로 유명한 회사이기도 하고 준비가 부족하다고
생각했으니까요.
이 시점까지만 해도 그저 공짜로 외국여행 하는구나 싶었죠.&lt;/p&gt;
&lt;h2 id=&#34;-2&#34;&gt;온사이트 인터뷰&lt;/h2&gt;
&lt;p&gt;온사이트 인터뷰는 채용되면 실제 제가 일하게 될 오피스에서 아침 10시부터 오후
4시까지 6시간동안 이루어졌습니다.
한시간마다 한명씩 다른 인터뷰어가 들어왔는데, 중간에 한번은 두 인터뷰어가 함께
들어왔습니다.
따라서 총 여섯번의 인터뷰를 본 셈이며, 매 인터뷰마다 형식은 전화 인터뷰와
비슷했습니다.
인터뷰어의 회사와 자기 자신에 대한 소개, 제 소개와 그에 대한 문답, 업무적 경험
질문, 기술적 질문, 마지막으로 제가 질문하는 시간.&lt;/p&gt;
&lt;p&gt;붙을리가 있냐, 여행이나 하자 하는 생각으로 왔지만 막상 당일이 되자 굉장히
긴장되더군요.
그런데 이날 만난 직원들은 너무나도 친절하고 유쾌했습니다.
막상 면접이 시작되니 면접을 본다기보다는 기술 커뮤니티 밋업에서 만난 사람들이랑
즐거운 기술 이야기 하는 느낌이라 너무 즐거웠습니다.&lt;/p&gt;
&lt;p&gt;오후 12시부터 한시간은 점심시간이라 인터뷰어 한명과 함께 식사했습니다.
식사가 인터뷰의 연장인 셈이죠.
앞서 이야기한대로 어찌나 긴장이 풀렸는지 이 때 인터뷰어 앞에서 맥주까지 한잔
했습니다.&lt;/p&gt;
&lt;p&gt;그 중 두번의 인터뷰는 화이트보드를 사용한 코딩 인터뷰가 포함되었습니다.
그 와중에 가장 긴장한 시간이었긴 한데, 역시 즐겁게 진행되었습니다.
다행히 평범한 자료구조 문제였기에 조금 버벅이긴 했지만 일단 코딩을 하는건
어렵지 않았으며, 이후 관련한 질문에 답하고 개선을 어떻게 할 수 있을지
논의하고 추가 코딩을 했는데 이 과정 역시 즐거웠습니다.&lt;/p&gt;
&lt;p&gt;인터뷰가 끝나고 나선 붙든 떨어지든 상관 없지만 평생 잊지 못할 만큼 즐거운
시간이었고 이런 시간을 앞으로도 갖고 싶다, 떨어져도 여한이 없다는 생각이
들었습니다.
면접을 본게 아니라 커뮤니티 모임 같은데 가서 놀다 온 느낌이었죠.&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;오퍼&lt;/h2&gt;
&lt;p&gt;온사이트 인터뷰가 금요일이었습니다.
현지 시간으로 화요일, 인터뷰에 통과했으니 정식 오퍼를 보내겠다는 연락을
받았습니다.&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;정리&lt;/h2&gt;
&lt;p&gt;준비부터 오퍼를 받기까지의 제 경험을 정리해 봤습니다.
준비도 능력도 부족한데 어디까지나 운이 좋아서 면접을 통과한지라 다른 분들께 이
기록이 얼마나 도움이 될지 모르겠습니다.
그래도 공유하지 않는 것보다는 낫겠죠.
누군가에겐 이 기록이 도움이 되길 빌어봅니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc5</title>
      <link>/post/lkml_news_v5.2-rc5/</link>
      <pubDate>Mon, 10 Jun 2019 10:17:29 +0900</pubDate>
      <guid>/post/lkml_news_v5.2-rc5/</guid>
      <description>&lt;h2 id=&#34;patch-v3-05-thp-aware-uprobe&#34;&gt;[PATCH v3 0/5] THP aware uprobe&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190612220320.2223898-1-songliubraving@fb.com&#34;&gt;https://lkml.kernel.org/r/20190612220320.2223898-1-songliubraving@fb.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;uprobe 는 THP 로 되어있는 페이지를 쪼갭니다.  이로 인해 성능 향상 효과가
사라지죠.  이 패치셋은 uprobe 가 THP 를 인식하게 해서 이런 문제를 제거합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-05-introduce-madvcold-and-madvpageout&#34;&gt;[PATCH v2 0/5] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190610111252.239156-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190610111252.239156-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;기존에도 소개한 MADV_COLD 와 MADV_PAGEOUT 을 madvise() 에 추가하는 패치셋의
두번째 버전입니다.  이 패치셋을 ChromeOS 팀의 Brian Geffon 은 가져다가 탭이
백그라운드로 들어가고 45초 이상 그 상태를 유지하면 이 기능을 사용해서 페이지를
proactively swap out 시켰는데, 그 결과 tab 전환 속도가 25% 나 빨라졌다고
합니다.&lt;/p&gt;
&lt;h2 id=&#34;v3-rfc-patch-09-migrate-mode-for-node-reclaim-with-heterogeneous-memory-hierarchy&#34;&gt;[v3 RFC PATCH 0/9] Migrate mode for node reclaim with heterogeneous memory hierarchy&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1560468577-101178-1-git-send-email-yang.shi@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/1560468577-101178-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NUMA node 로 pmem 을 취급할 수 있게 된 이후, 노드간 migration 을 보다
효율적으로 하기 위한 패치셋의 세번째 버전입니다.  LSFMM 에서 이에 대해 토의가
있었는데, 이번 버전은 그에 기반해 수정되었다고 하네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-v52rc5&#34;&gt;Linux v5.2-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whEQPvLpDbx+WR4Q4jf2FxXjf_zTX3uLy_6ZzHtgTV4LA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whEQPvLpDbx+WR4Q4jf2FxXjf_zTX3uLy_6ZzHtgTV4LA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난주는 토발즈의 여행 때문에 릴리즈가 평소보다 조금 빨리 이루어졌는데요,
이번에도 마찬가지입니다.  앞으로도 2주동안 여행ㅇ을 더 한다네요.&lt;/p&gt;
&lt;p&gt;어쨌든 5.2 가 가까워졌습니다.  어느덧 rc5군요.  rc4 대비 사이즈도 많이
줄어들었습니다.  SPDX 업데이트도 없는 덕에 diff 도 깔끔하게 되었구요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc4</title>
      <link>/post/lkml_news_v5.2-rc4/</link>
      <pubDate>Tue, 04 Jun 2019 10:49:00 +0900</pubDate>
      <guid>/post/lkml_news_v5.2-rc4/</guid>
      <description>&lt;h2 id=&#34;patch-0015-slab-movable-objects-smo&#34;&gt;[PATCH 00/15] Slab Movable Objects (SMO)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190603042637.2018-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190603042637.2018-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;전에도 RFC 패치셋은 여기서도 소개했었죠.  Slab 할당자에 할당받은 객체들의
이동이 가능하게끔 하는 패치셋의 정식 패치 버전이 나왔습니다.  변경된
인터페이스는 XArray 와 dcache 에 적용되는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v1-04-introduce-madvcold-and-madvpageout&#34;&gt;[PATCH v1 0/4] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190603053655.127730-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190603053655.127730-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;바로 지난주에도 소개한 external madvise 패치셋이 쪼개졌네요.  &lt;code&gt;MADV_COLD&lt;/code&gt; 와
&lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 두개의 새로운 advice 기능 추가 버전만 담은 패치셋입니다.  이게
더 일찍 머지될 가능성이 생겼군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-52rc4&#34;&gt;Linux 5.2-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjm7FQxdF=RKa8Xe23CLNNpbGDOACewgo8e-hwDJ8TyQg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjm7FQxdF=RKa8Xe23CLNNpbGDOACewgo8e-hwDJ8TyQg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;메일을 받고 깜짝 놀랐습니다, 평소보다 빨랐기 때문이죠.  아시아를 여행중인가?
싶기도 했는데요, 그건 아니고 비행기 여행이 예정되어 있기 때문에 평소보다 일찍
했다는군요.&lt;/p&gt;
&lt;p&gt;지난 rc3 가 좀 작았던 탓인지 이번 rc4 는 덩치가 좀 큽니다.  하지만 그걸
감안하면 별 문제 없어 보인다고 하네요.&lt;/p&gt;
&lt;p&gt;이번 릴리즈에도 SPDX 변경이 많습니다.  변경 자체야 문제가 없긴 한데 diff 를
보기 귀찮게 하는게 조금은 짜증도 나는 것 같네요.&lt;/p&gt;
&lt;p&gt;어쨌든 이렇게 네번째 rc 가 릴리즈 되었습니다.  정식 버전도 많이 남지 않았네요!&lt;/p&gt;
&lt;p&gt;이번 릴리즈의 개발 과정을 시각화 한 비디오를 아래 URL 에서 볼 수 있습니다:
&lt;a href=&#34;https://youtu.be/OooOmr4Z8dw&#34;&gt;https://youtu.be/OooOmr4Z8dw&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Development History Visualization Youtube Channel</title>
      <link>/post/linux_develop_visualization_youtube/</link>
      <pubDate>Tue, 04 Jun 2019 10:44:33 +0900</pubDate>
      <guid>/post/linux_develop_visualization_youtube/</guid>
      <description>&lt;p&gt;재미 삼아 리눅스 커널 릴리즈 때마다 git history 를 visualize 해서 올리는 유투브
채널[1]을 개설해 봤습니다. 지금은 visualization 에는 gource[2] 를 사용하고
있습니다. 이 비디오를 만드는데 사용되는 스크립트도 GPL v3 로 공개[3]했으니
필요한 분은 사용해 보셔도 좋을 것 같습니다.&lt;/p&gt;
&lt;p&gt;I created a Youtube channel[1]. I will upload videos for the git history
between each release of the Linux kernel, just for jun. I use gource[2] for the
visualization for now. The scripts I use for these videos are available[3]
under GPL v3. If you want, you may use the scripts for your own video
generation.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://www.youtube.com/channel/UCI7qoGt1hOfCsI8hFqriYCg&#34;&gt;https://www.youtube.com/channel/UCI7qoGt1hOfCsI8hFqriYCg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&#34;https://gource.io/&#34;&gt;https://gource.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&#34;https://github.com/sjp38/linux_development_visualization&#34;&gt;https://github.com/sjp38/linux_development_visualization&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DAPHICX: Data Access Pattern Hint Injecting Compiler Extension</title>
      <link>/post/daphicx/</link>
      <pubDate>Thu, 30 May 2019 18:59:53 +0900</pubDate>
      <guid>/post/daphicx/</guid>
      <description>&lt;p&gt;Memory pressure is inevitable as the size of working sets is rapidly growing
while the capacity of dynamic random access memory (DRAM) is not. Meanwhile,
storage devices have evolved so that their speed is comparable to the speed of
DRAM while their capacity scales are comparable to that of hard disk drives
(HDD). Thus, hierarchial memory systems configuring DRAM as the main memory and
high-end storages as swap devices will be common.&lt;/p&gt;
&lt;p&gt;Due to the unique characteristics of these modern storage devices, the swap
target decision should be optimal. It is essential to know the exact data
access patterns of workloads for such an optimal decision, although underlying
systems cannot accurately estimate such complex and dynamic patterns. For this
reason, memory systems allow programs to voluntarily hint their data access
pattern. Nevertheless, it is exhausting for a human to manually figure out the
patterns and embed optimal hints if the workloads are huge and complex.&lt;/p&gt;
&lt;p&gt;This project introduces a compiler extension that automatically optimizes a
program to voluntarily hint its dynamic data access patterns to the underlying
swap system using a static/dynamic analysis based profiling result. To our best
knowledge, this is the first profile-guided optimization (PGO) for modern swap
devices. Our empirical evaluation of the scheme using realistic workloads shows
consistent improvement in performance and swap device lifetime up to 2.65 times
and 2.98 times, respectively.&lt;/p&gt;
&lt;p&gt;DAPHICX has introduced by the [FAST&#39;19 WiP]
(&lt;a href=&#34;https://www.usenix.org/conference/fast19/wips&#34;&gt;https://www.usenix.org/conference/fast19/wips&lt;/a&gt;) and the [HotStorage&#39;19]
(&lt;a href=&#34;https://www.usenix.org/conference/hotstorage19/presentation/park)&#34;&gt;https://www.usenix.org/conference/hotstorage19/presentation/park)&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc3</title>
      <link>/post/lkml_news_v5.2-rc3/</link>
      <pubDate>Tue, 28 May 2019 23:28:37 +0900</pubDate>
      <guid>/post/lkml_news_v5.2-rc3/</guid>
      <description>&lt;h2 id=&#34;patch-tipcorercu-012&#34;&gt;[PATCH tip/core/rcu 0/12]&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190530145204.GA28526@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190530145204.GA28526@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Paul E. McKenney 로부터의 RCU flavor consolidation 관련 추가 작업과 코드 정리를
위한 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-02-documentation-updates-for-v53&#34;&gt;[PATCH tip/core/rcu 0/2] Documentation updates for v5.3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190530145504.GA29820@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190530145504.GA29820@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 문서 업데이트를 담고 있는 패치셋입니다.  &lt;code&gt;rcuref&lt;/code&gt; 의 실제 예제와
&lt;code&gt;rcu_task_stall_timeout&lt;/code&gt; 의 정의에 대한 내용이 추가되었군요!&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-021-torturetest-updates-for-v53&#34;&gt;[PATCH tip/core/rcu 0/21] Torture-test updates for v5.3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190530151650.GA422@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190530151650.GA422@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 와 spinlock 등을 위해 사용되는 torture 테스트 업데이트를 담은 패치셋입니다.
무려 21개 패치네요!&lt;/p&gt;
&lt;h2 id=&#34;rfcv2-06-introduce-memory-hinting-api-for-external-process&#34;&gt;[RFCv2 0/6] introduce memory hinting API for external process&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190531064313.193437-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190531064313.193437-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다른 어플리케이션의 virtual memory 에 대해 madvise() 를 할 수 있게 하고
&lt;code&gt;MADV_COLD&lt;/code&gt; 등의 힌트를 추가한 패치셋의 두번째 RFC 버전입니다.  LWN 에서도
소개되었고 관련 반응이 매우 뜨겁네요.  저도 매우 흥미롭게 보고 있습니다.
두번째 버전에서는 &lt;code&gt;MADV_COOL&lt;/code&gt; 은 빠졌습니다.  &lt;code&gt;MADV_COLD&lt;/code&gt; 와 &lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 만
남았군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-52rc3&#34;&gt;Linux 5.2-rc3&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CAHk-=wg1evGTxx-aSNHO+m5xSa1sc6fQe7Y8fH=_ruGcwMyfyA@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;상당히 고요한 한 주였고, 그로 인해 rc3 는 rc2 와 사이즈가 비슷했습니다.  이는
조금 이상한 일인데, 보통 rc2 이후로는 사람들이 드디어 문제를 파악하기 시작하고
rc3 주간에 수정을 하느라 조금은 떠들썩해 왔기 때문이랍니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Biscuit (OS Written in Go) Install</title>
      <link>/post/biscuit_os_install/</link>
      <pubDate>Sun, 26 May 2019 23:27:44 +0900</pubDate>
      <guid>/post/biscuit_os_install/</guid>
      <description>&lt;pre&gt;&lt;code&gt;$ git clone https://go.googlesource.com/go go1.4; cd go1.4
$ git checkout release-branch.go1.4; cd src
$ ./make.bash
$ cd ../../
$ git clone https://github.com/mit-pdos/biscuit.git; cd biscuit/src
$ ./make.bash
$ cd ../biscuit/
$ make qemu CPUS=2
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc2</title>
      <link>/post/lkml_news_v5.2-rc2/</link>
      <pubDate>Tue, 21 May 2019 01:27:47 +0900</pubDate>
      <guid>/post/lkml_news_v5.2-rc2/</guid>
      <description>&lt;h2 id=&#34;rfc-patch-v5-0016-slab-movable-objects-smo&#34;&gt;[RFC PATCH v5 00/16] Slab Movable Objects (SMO)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190520054017.32299-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190520054017.32299-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 소개한 Slab movable objects 패치셋의 다섯번째 버전입니다.  RFC
로는 아마도 마지막 버전이 될거라는군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-0014-mmapsem-range-locking&#34;&gt;[RFC PATCH 00/14] mmap_sem range locking&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190521045242.24378-1-dave@stgolabs.net&#34;&gt;https://lkml.kernel.org/r/20190521045242.24378-1-dave@stgolabs.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 LSFMM 에서 개인적으로 가장 기대했던 세션이 &lt;code&gt;mmap_sem&lt;/code&gt; 해결에 대한
세션이었습니다.  해당 세션에서는 예전부터 이야기가 나온 range locking 에
대해서도 이야기가 있었는데요, 이 패치셋은 이 range locking 을 사용한 &lt;code&gt;mmap_sem&lt;/code&gt;
문제 해결 시도를 다시 정리해 RFC 의 형태로 올린 것입니다.&lt;/p&gt;
&lt;p&gt;RFC 라는 데서 알 수 있겠지만 이 패치 자체에도 문제가 많지만, 코드 자체보다는 이
range locking 이라는 아이디어가 갖는 한계와 그에 대한 대책 등을 논의해 보고자
올린 것이라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-07-introduce-memory-hinting-api-for-external-process&#34;&gt;[RFC 0/7] introduce memory hinting API for external process&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190520035254.57579-1-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190520035254.57579-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 여기서도 다룬 구글의 proactive swap 의 안드로이드 버전과 비슷한 일을 위한
패치셋입니다.  안쓰는 데이터 잔뜩 쥐고서는 스왑도 안당하고 있는 앱이 문제죠.
이런 데이터를 &lt;code&gt;madvise()&lt;/code&gt; 에 &lt;code&gt;MADVISE_COLD&lt;/code&gt; 와 &lt;code&gt;MADVISE_COOL&lt;/code&gt; 이라는 추가
힌트를 줘서 어플리케이션 레벨에서 이런 스왑하는게 좋을 데이터를 알려주는
형태입니다.  기존의 &lt;code&gt;MADVISE_WONTNEED&lt;/code&gt; 는 스왑을 하는게 아니라 걍 데이터를
버려버리기 때문에 이런 두개의 힌트를 추가한거죠.&lt;/p&gt;
&lt;p&gt;인공적 벤치마크가 아니라 수백명의 진짜 사용자를 통해 성능 실험을 했다고
하는데요, 구글에서 고용한 테스트 집단일까요?&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0014-provide-generic-topdown-mmap-layout-functions&#34;&gt;[PATCH v4 00/14] Provide generic top-down mmap layout functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190526134746.9315-1-alex@ghiti.fr&#34;&gt;https://lkml.kernel.org/r/20190526134746.9315-1-alex@ghiti.fr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;각 아키텍쳐별로 존재하는 중복 코드를 제거하기 위해 만들어진 범용 top-down mmap
을 위한 패치의 네번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-03-remove-tmem-and-code-depending-on-it&#34;&gt;[PATCH 0/3] remove tmem and code depending on it&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190527103207.13287-1-jgross@suse.com&#34;&gt;https://lkml.kernel.org/r/20190527103207.13287-1-jgross@suse.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xen 의 tmem 기능이 제거되었군요.  관련 코드를 리눅스 커널에서도 제거하는
패치셋입니다.  덕분에 cleancache 가 아예 사라질 모양입니다.  Cleancache 에
의존하는 GCMA 를 만들고 있는 제 입장에선 쇼킹한 일입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-52rc2&#34;&gt;Linux 5.2-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgob1t2g9iQZCuZ8My39CY26xGb6nqjVhCtb1nTirsR2Q@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgob1t2g9iQZCuZ8My39CY26xGb6nqjVhCtb1nTirsR2Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일정대로 두번째 rc2 가 릴리즈 되었습니다.  이번엔 그야말로 특기할 만한 점이
없다는군요.  그나마 큰 변화는 SPDX 관련 변경들 뿐이었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc1</title>
      <link>/post/lkml_news_v5.2-rc1/</link>
      <pubDate>Wed, 08 May 2019 10:22:05 +0900</pubDate>
      <guid>/post/lkml_news_v5.2-rc1/</guid>
      <description>&lt;h2 id=&#34;patch-mm-introduce-pagesize&#34;&gt;[PATCH] mm: Introduce page_size()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190510181242.24580-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20190510181242.24580-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 등의 경우를 위해 페이지의 실제 크기를 구하려면 &lt;code&gt;PAGE_SIZE &amp;lt;&amp;lt; compound_order(page)&lt;/code&gt; 를 해야 하는게 짜증난 Matthew Wilcox 가 별도의 함수를
만들고 기존 코드들을 이 함수를 사용하도록 변경한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-0015-remove-order-argument-from-many-mm-functions&#34;&gt;[PATCH v2 00/15] Remove &amp;lsquo;order&amp;rsquo; argument from many mm functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190510135038.17129-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20190510135038.17129-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mm 쪽 함수들은 order 를 인자로 많이 받죠.  어차피 gfp_t 는 무조건 받으니까 이
타입의 상위 bit 을 order 목적으로 사용하자는 패치입니다.  이 패치의 장점은?
커널 텍스트 사이즈를 줄인다는 것입니다 :)&lt;/p&gt;
&lt;h2 id=&#34;maintainers--kernel-summit-2019-planning-kickoff&#34;&gt;Maintainer&#39;s / Kernel Summit 2019 planning kick-off&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190513230643.GA4347@mit.edu&#34;&gt;https://lkml.kernel.org/r/20190513230643.GA4347@mit.edu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해의 커널 서밋 / 메인테이너 서밋을 위한 안내 메일입니다.  작년엔 커널 서밋은
LPC 와, 메인테이너 서밋은 OSSEU 와 함께 열렸었죠.  올해는 둘 다 LPC 와 함께
합니다.&lt;/p&gt;
&lt;p&gt;메인테이너 서밋은 올해는 아예 30명으로 더욱 작게 모이는군요.&lt;/p&gt;
&lt;p&gt;커널 서밋 발표 주제는 5월 31일까지 받습니다.  발표주제 선정되면 LPC 티켓도
준다는군요!&lt;/p&gt;
&lt;h2 id=&#34;linux-52rc1&#34;&gt;Linux 5.2-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgxi6fnxZ+p5Zdqr-i4s=xhOCBJL6s_RauYkjxM2CpXeA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgxi6fnxZ+p5Zdqr-i4s=xhOCBJL6s_RauYkjxM2CpXeA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.2 릴리즈를 위한 머지윈도우가 끝나고 rc1 버전이 릴리즈 되었습니다.  이번 머지
윈도우 중간에 토발즈의 개인적 여행이 있다고 했지만 다행히 잘 정리되었나보군요.
별다른 건은 없었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1</title>
      <link>/post/lkml_news_v5.1/</link>
      <pubDate>Tue, 30 Apr 2019 14:16:49 +0900</pubDate>
      <guid>/post/lkml_news_v5.1/</guid>
      <description>&lt;h2 id=&#34;rfc-patch-v4-0015-slab-movable-objects-smo&#34;&gt;[RFC PATCH v4 00/15] Slab Movable Objects (SMO)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190430030746.26102-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190430030746.26102-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 이 블로그에서도 공유한 SMO 패치의 새 버전입니다.  이번 버전은 dcache 쪽
코드를 많이 수정했군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-51&#34;&gt;Linux 5.1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whsbDxdapMJGvy9OkVSrKMsKRJBTrH-Qj-qTbkMUGnWUw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whsbDxdapMJGvy9OkVSrKMsKRJBTrH-Qj-qTbkMUGnWUw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.1 릴리즈입니다.  일요일 오후 릴리즈란 점은 평소와 같지만 평소보다 조금 늦은
시간이긴 했는데요, 오늘 갑자기 받은 풀 리퀘스트도 있었고, 이번 머지윈도우
기간에 졸업식에 참석해야 해서 조금 망설였다는군요.&lt;/p&gt;
&lt;p&gt;하지만 풀리퀘스트도 그렇게 크진 않고, 몇일 머지윈도우에 자리 비우는 정도는
어떻게든 할 수 있을거라 생각해서 5.1 릴리즈가 이뤄졌습니다!&lt;/p&gt;
&lt;p&gt;이제 5.2 머지윈도우의 시작이군요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fedora28 ibus-hangul input problem</title>
      <link>/post/fedora28_hangul_problem/</link>
      <pubDate>Fri, 26 Apr 2019 11:05:59 +0900</pubDate>
      <guid>/post/fedora28_hangul_problem/</guid>
      <description>&lt;p&gt;어느날부터 Fedora 터미널에서 한글 입력이 매우 불편해졌습니다.  한글 모드에서는
backspace, enter, esc 등의 특수키가 하나도 안먹힙니다.  Vim 을 쓰는 입장에선
매우 불편하죠.  알고보니 ibus-hangul 버그인 것 같습니다[1].  아래 커맨드로
ibus-hangul 을 문제 없던 버전으로 다운그레이드 시키고 세션을 재시작 하면 문제가
사라집니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo dnf downgrade ibus-hangul-1.5.0-12.fc28.x86_64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1] &lt;a href=&#34;http://www.fedoralinux.or.kr/board-read.do?boardId=bbs3&amp;amp;boardNo=153170459823549&amp;amp;command=READ&amp;amp;page=1&amp;amp;categoryId=-1&#34;&gt;http://www.fedoralinux.or.kr/board-read.do?boardId=bbs3&amp;amp;boardNo=153170459823549&amp;amp;command=READ&amp;amp;page=1&amp;amp;categoryId=-1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc7</title>
      <link>/post/lkml_news_v5.1-rc7/</link>
      <pubDate>Fri, 26 Apr 2019 11:02:24 +0900</pubDate>
      <guid>/post/lkml_news_v5.1-rc7/</guid>
      <description>&lt;h2 id=&#34;re-lsfmm-preliminary-agenda--anyone--anyone--bueller-&#34;&gt;Re: [LSF/MM] Preliminary agenda ? Anyone &amp;hellip; anyone ? Bueller ?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/83fda245-849a-70cc-dde0-5c451938ee97@kernel.dk&#34;&gt;https://lkml.kernel.org/r/83fda245-849a-70cc-dde0-5c451938ee97@kernel.dk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해의 LSFMM 스케쥴이 구글 문서로 공유되고 있었군요:
&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1Z1pDL-XeUT1ZwMWrBL8T8q3vtSqZpLPgF3Bzu_jejfk/edit#gid=0&#34;&gt;https://docs.google.com/spreadsheets/d/1Z1pDL-XeUT1ZwMWrBL8T8q3vtSqZpLPgF3Bzu_jejfk/edit#gid=0&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-proactive-memory-reclaim&#34;&gt;[LSF/MM TOPIC] Proactive Memory Reclaim&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CALvZod4V+56pZbPkFDYO3+60Xr0_ZjiSgrfJKs_=Bd4AjdvFzA@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이제 LSFMM 이 얼마 안남았습니다만, 또하나의 주제 제안이 올라왔습니다.&lt;/p&gt;
&lt;p&gt;메모리 오버커밋으로 인해 direct reclaim 이 발생하고, 이는 latency sensitive
어플리케이션의 latency 를 크게 저하시키니, 시스템이 좀 더 적극적으로 memory
reclaim 을 해서 direct reclaim 을 최소화 시켜보자는 건데요.  잘 접근되지 않는
cold memory 를 추적해서 미리미리 reclaim 시키자는 겁니다.  챌린지는 물론 cold
memory 를 어떻게 잘 추적하냐는 거지요.  이와 함께 커널의 &lt;code&gt;idle_page_tracking&lt;/code&gt;
의 비효율성도 이야기 했습니다.&lt;/p&gt;
&lt;p&gt;이 주제로 올해 ASPLOS 에 논문도 냈군요: &lt;a href=&#34;https://youtu.be/aKddds6jn1s&#34;&gt;https://youtu.be/aKddds6jn1s&lt;/a&gt;
개인적으로 최근 연구하고 있는 주제와도 관계 있을 수 있어서 흥미롭습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-docsvm-add-documentation-of-memory-models&#34;&gt;[PATCH] docs/vm: add documentation of memory models&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1556101715-31966-1-git-send-email-rppt@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/1556101715-31966-1-git-send-email-rppt@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FLAT, DISCONTIG, SPARSE 등의 다양한 메모리 모델에 대한 문서화 추가 패치입니다.
처음 코드 들여다 볼 때 조금 헷갈리던 부분인데 잘 설명되었군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-lightning-round&#34;&gt;[LSF/MM TOPIC] Lightning round?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190425211906.GH4739@mit.edu&#34;&gt;https://lkml.kernel.org/r/20190425211906.GH4739@mit.edu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 LSFMM 에는 라이트닝 토크 세션이 있는데요, 거기서 block layer 에 암호화
레이어를 추가하는 방안에 대해 이야기 해보자는 Ted 의 의견입니다.  안드로이드
쪽에서 이걸 열심히 해보고 있나보군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-04-toolsvmslabinfo-add-fragmentation-output&#34;&gt;[PATCH 0/4] tools/vm/slabinfo: Add fragmentation output&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190426022622.4089-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190426022622.4089-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SLAB vs SLUB 토론 중 현재 slab allocator 의 fragmentation 정도를 알려주는
도구가 있으면 좋겠다는 이야기가 있었는데, 이를 위한 기능을 추가한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51rc7&#34;&gt;Linux 5.1-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whvWQbP20g77U4QRXQDS5w+kf=V-P2QjMkgA-OwJJjHtg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whvWQbP20g77U4QRXQDS5w+kf=V-P2QjMkgA-OwJJjHtg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난번 rc6 가 거대했던 건 역시 풀 리퀘스트 타이밍 때문이었는지, 이번 rc7 은
다행히도 크기가 작은 편이라고 합니다.  네트워킹 쪽 변경이 좀 있고, 나머진
평소같이 아키텍쳐, 파일 시스템, 그외 드라이버 등의 변경이 내용을 차지했네요.
따라서 다음주엔 5.1이 예정대로 나올 것 같다고 합니다!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the Hotstorage&#39;19</title>
      <link>/post/hotstorage2019_talk/</link>
      <pubDate>Thu, 18 Apr 2019 09:37:04 +0900</pubDate>
      <guid>/post/hotstorage2019_talk/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.usenix.org/conference//hotstorage19&#34;&gt;HotStorage&#39;19&lt;/a&gt; 에 제출한 제
최근 연구에 대한 논문이 accept 되어 7월에 해당 워크샵에서 이에 대한 내용을
발표하게 되었습니다.  논문 제목은 &amp;ldquo;Automating Context Based Access Pattern Hint
Injection for System Performance and Swap Storage Durability&amp;rdquo; 입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc6</title>
      <link>/post/lkml_news_v5.1-rc6/</link>
      <pubDate>Tue, 16 Apr 2019 23:02:17 +0900</pubDate>
      <guid>/post/lkml_news_v5.1-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-v12-0031-speculative-page-faults&#34;&gt;[PATCH v12 00/31] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernl.org/r/20190416134522.17540-1-ldufour@linux.ibm.com&#34;&gt;https://lkml.kernl.org/r/20190416134522.17540-1-ldufour@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;오랫만에 업데이트 된 SPF 패치셋으로, 이번 패치셋은 v5.1 위로 리베이스
되었습니다.  RCU 에서 Fine-grained reader-writer locking 으로 옮겼던 vma 보호를
다시 RCU 로 되돌린 게 눈에 띄는군요.  기존엔 패치셋만 공개했는데, 이젠 패치셋이
적용된 코드 트리를 github 으로도 제공합니다:
&lt;a href=&#34;https://github.com/ldu4/linux/tree/spf-v12&#34;&gt;https://github.com/ldu4/linux/tree/spf-v12&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;patch-v3-0011-provide-generic-topdown-mmap-layout-functions&#34;&gt;[PATCH v3 00/11] Provide generic top-down mmap layout functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190417052247.17809-1-alex@ghiti.fr&#34;&gt;https://lkml.kernel.org/r/20190417052247.17809-1-alex@ghiti.fr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아키텍쳐별로 별도 구현을 하지 않고도 전체 mmap 레이아웃을 접근할 수 있게 해주는
범용 함수들을 구현하는 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-v51rc6&#34;&gt;Linux v5.1-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wii=Ym24FWf7J2s1CEwCXU3hjVXeHSkV3A8X5iAj6eT8Q@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wii=Ym24FWf7J2s1CEwCXU3hjVXeHSkV3A8X5iAj6eT8Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;부활절이었군요.  어쨌건 토발즈는 그런 사소한 휴일에 릴리즈 일정을 바꾸진
않았습니다.&lt;/p&gt;
&lt;p&gt;이번 rc6 는 평소보다 조금 커다란 릴리즈였고, 때문에 토발즈도 다시 한번 꼼꼼히
살펴봤지만 그렇게까지 이상한 일은 아니라는군요.  4.18 때와 5.0 때도
이정도였답니다.&lt;/p&gt;
&lt;p&gt;네트워킹 쪽 변경이 좀 컸고, 드라이버, arch, selftests 와 perf 쪽에 변경이
있었으며, core mm, filesystem, scheduler, tracing 쪽에도 변경이 조금씩 있었다고
하는군요.&lt;/p&gt;
&lt;p&gt;어쨌건 그다지 이상한 건 없다고 합니다.  적어도 아직까진 5.1 을 향한 여정엔
문제가 없어 보이네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hooking Library Function Calls</title>
      <link>/post/hooking_library_calls/</link>
      <pubDate>Wed, 10 Apr 2019 11:39:06 +0900</pubDate>
      <guid>/post/hooking_library_calls/</guid>
      <description>&lt;p&gt;&lt;code&gt;LD_PRELOAD&lt;/code&gt; 환경변수를 사용하면 로더가 프로그램을 로드할 때 동적 로드해야 할
바이너리 코드를 해당 변수의 값의 디렉토리에서부터 뒤지도록 합니다.
따라서 이를 이용해 &lt;code&gt;malloc()&lt;/code&gt;, &lt;code&gt;free()&lt;/code&gt; 등의 일반적으로 사용하는 라이브러리
함수를 우리의 구현으로 대체하거나 후킹할 수 있습니다.
이 글은 이런 방법으로 &lt;code&gt;malloc()&lt;/code&gt; 을 후킹하는 방법을 예제를 통해 간단히
설명합니다.&lt;/p&gt;
&lt;h2 id=&#34;original-program&#34;&gt;Original Program&lt;/h2&gt;
&lt;p&gt;먼저 다음과 같은 프로그램이 있을 수 있을 겁니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main(void)
{
	char *abc;

	abc = (char *)malloc(8);
	printf(&amp;quot;malloced address: %p\n&amp;quot;, abc);
	sprintf(abc, &amp;quot;hello\n&amp;quot;);
	printf(&amp;quot;%s\n&amp;quot;, abc);
	free(abc);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;단순히 &lt;code&gt;malloc()&lt;/code&gt; 을 통해 8바이트 메모리를 할당받아 그 영역을 표시하고 종료하는
프로그램입니다.  위 코드를 &lt;code&gt;program.c&lt;/code&gt; 라는 파일로 저장하고, 아래와 같이
컴파일하고 수행해 보면 우리가 익히 아는, 예상대로의 결과가 나옵니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -o program program.c
$ ./program
malloced address: 0x1cc5010
hello
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;malloc-hooking-code&#34;&gt;malloc Hooking Code&lt;/h2&gt;
&lt;p&gt;이제 &lt;code&gt;malloc()&lt;/code&gt; 함수를 후킹하는 코드를 만들어 봅시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define _GNU_SOURCE

#include &amp;lt;dlfcn.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

typedef void *(*malloc_t)(size_t size);

void *malloc(size_t size)
{
	malloc_t malloc_fn;

	fprintf(stderr, &amp;quot;malloc(%zu) hooked\n&amp;quot;, size);
	malloc_fn = (malloc_t)dlsym(RTLD_NEXT, &amp;quot;malloc&amp;quot;);
	return malloc_fn(size);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 코드는 우리가 아는 &lt;code&gt;malloc()&lt;/code&gt; 함수와 동일한 함수명, signature 의 함수를
구현하고 있습니다.
단순히 우리가 후킹했음을 알리고, 동적 라이브러리 구조를 통해 이 다음으로
검색되는 &lt;code&gt;malloc&lt;/code&gt; 이름의 라이브러리 함수 (이게 우리가 익히 아는 그 &lt;code&gt;malloc()&lt;/code&gt;
구현이겠죠) 를 찾아, 같은 인자로 수행하고 그 결과를 리턴합니다.
즉, 우리가 아는 &lt;code&gt;malloc()&lt;/code&gt; 과 같은 일을 하긴 하지만 &lt;code&gt;malloc()&lt;/code&gt; 이 호출되었음을
알리는 것이죠.&lt;/p&gt;
&lt;p&gt;이 코드를 &lt;code&gt;mallochook.c&lt;/code&gt; 라는 이름으로 저장 후, 다음과 같이 라이브러리로
빌드합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -shared -fPIC mallochook.c -o mallochook.so -ldl
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;install-the-hook&#34;&gt;Install The Hook&lt;/h2&gt;
&lt;p&gt;프로그램이 기존 &lt;code&gt;malloc()&lt;/code&gt; 대신 우리가 구현한 &lt;code&gt;malloc()&lt;/code&gt; 을 수행하게 하는 건
&lt;code&gt;LD_PRELOAD&lt;/code&gt; 를 활용하면 간단합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ LD_PRELOAD=./mallochook.so ./program
malloc(8) hooked
malloc(1024) hooked
malloced address: 0x20a5010
hello
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;두번째, 세번째 줄을 보면 &lt;code&gt;malloc()&lt;/code&gt; 이 후킹되어 우리의 메세지가 나오는 걸 볼 수
있습니다.  앞의 &lt;code&gt;program.c&lt;/code&gt; 에서는 8 바이트 &lt;code&gt;malloc()&lt;/code&gt; 호출만 있었는데 세번째
줄의 1024 바이트 malloc()&lt;code&gt;은 어디서 나온 걸까요?  아마도 뒤의&lt;/code&gt;sprintf()` 등의
라이브러리 함수가 호출한 거 아닐까 싶은데 그걸 분석하는 건 여러분의 몫으로
두겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;자세한 원리는 생략했습니다만, 간단히 주요 라이브러리 함수를 후킹하는 방법을
알아봤습니다.
여기서 사용된 예제 코드와 명령어는 제 [Github repo]
(&lt;a href=&#34;https://github.com/sjp38/mallochook&#34;&gt;https://github.com/sjp38/mallochook&lt;/a&gt;) 에 올려뒀으니 필요하면 참고 바랍니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Backtrace on C language program</title>
      <link>/post/backtrace_c_language/</link>
      <pubDate>Tue, 09 Apr 2019 17:33:50 +0900</pubDate>
      <guid>/post/backtrace_c_language/</guid>
      <description>&lt;p&gt;디버깅 과정에선 현재 어떤 코드가 어떤 함수를 거쳐 수행됐는지를 통한 컨텍스트
파악이 중요합니다.  Java, Python, Go 등 대부분의 언어가 이를 위해 콜스택을 뽑을
수 있는 기능을 제공하죠.  C 언어의 경우 gdb 등을 사용하면 쉽게 이를 볼 수
있지만 경우에 따라선 gdb 를 포기하고 &lt;code&gt;printf()&lt;/code&gt; 등에만 의존해야 하기도 합니다.
이를 위한 기능이 c 라이브러리에도 있습니다, &lt;code&gt;backtrace()&lt;/code&gt; 함수입니다.
&lt;a href=&#34;http://man7.org/linux/man-pages/man3/backtrace.3.html&#34;&gt;&lt;code&gt;man&lt;/code&gt;&lt;/a&gt; 에도 이에 대한
설명이 있습니다만, 여기서도 간단히 소개해 봅니다.&lt;/p&gt;
&lt;h2 id=&#34;example-source-code&#34;&gt;Example Source Code&lt;/h2&gt;
&lt;p&gt;예제로 설명하는게 가장 쉽죠.  간단한 사용법은 아래와 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;execinfo.h&amp;gt;

void baz(void)
{
	void *callstack[128];
	int i, frames;
	char **strs;

	frames = backtrace(callstack, 128);
	strs = backtrace_symbols(callstack, frames);
	for (i = 0; i &amp;lt; frames; i++)
		printf(&amp;quot;%s\n&amp;quot;, strs[i]);
	free(strs);
}

void bar(void)
{
	baz();
}

void foo(void)
{
	bar();
}

int main(void)
{
	foo();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;compile&#34;&gt;Compile&lt;/h2&gt;
&lt;p&gt;아래와 같이 컴파일 합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -rdynamic -g -o hello ./hello.c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;-rdynamic&lt;/code&gt; 과 &lt;code&gt;-g&lt;/code&gt; 옵션을 잊지 맙시다.&lt;/p&gt;
&lt;p&gt;이제 프로그램을 실행해 보면:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./hello

./hello(baz+0x2e) [0x400964]
./hello(bar+0x9) [0x4009fd]
./hello(foo+0x9) [0x400a09]
./hello(main+0x9) [0x400a15]
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0) [0x7f87c51e6830]
./hello(_start+0x29) [0x400869]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;main()&lt;/code&gt;, &lt;code&gt;foo()&lt;/code&gt;, &lt;code&gt;bar()&lt;/code&gt;, 를 거쳐 &lt;code&gt;baz()&lt;/code&gt; 가 수행되었음을 보입니다.  더
나아가서 어떤 소스파일의 몇번 라인인지를 보고 싶다면 &lt;code&gt;addr2line&lt;/code&gt; 커맨드를
사용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ addr2line -e hello 0x400964
./hello.c:10
$ addr2line -e hello 0x4009fd
./hello.c:20
$ addr2line -e hello 0x400a09
./hello.c:25
$ addr2line -e hello 0x400a15
./hello.c:30
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;쉽죠? ;)&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;C 프로그램에서 backtrace 를 떠보는 방법을 알아보았습니다.
위의 내용을 여러분의 환경에서도 쉽게 테스트 해 볼 수 있게끔 제 [Github repo]
(&lt;a href=&#34;https://github.com/sjp38/backtrace_example&#34;&gt;https://github.com/sjp38/backtrace_example&lt;/a&gt;) 에도 정리해 두었습니다.
클론하고, &lt;code&gt;$ make run&lt;/code&gt; 해주시면 예제가 자동으로 빌드되고 돌아갈 겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc5</title>
      <link>/post/lkml_news_v5.1-rc5/</link>
      <pubDate>Tue, 09 Apr 2019 17:33:01 +0900</pubDate>
      <guid>/post/lkml_news_v5.1-rc5/</guid>
      <description>&lt;h2 id=&#34;v2-rfc-patch-09-another-approach-to-use-pmem-as-numa-node&#34;&gt;[v2 RFC PATCH 0/9] Another Approach to Use PMEM as NUMA Node&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1554955019-29472-1-git-send-email-yang.shi@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/1554955019-29472-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;본 블로그를 통해 지속적으로 소개하고 있는, PMEM as NUMA node 를 위한, 보다 나은
hotness 기반 page location 을 위한 패치셋입니다.
기존 코멘트에 기반해서 두번째 버전을 내놓았군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v3-0015-slab-movable-objects-smo&#34;&gt;[RFC PATCH v3 00/15] Slab Movable Objects (SMO)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190411013441.5415-1-tobin@kernel.org&#34;&gt;https://lkml.kernel.org/r/20190411013441.5415-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;최근 LWN 에서도 소개된 (&lt;a href=&#34;https://lwn.net/Articles/784964/&#34;&gt;https://lwn.net/Articles/784964/&lt;/a&gt;) 패치입니다.
Slab allocator 에서 할당된 object 가 free page 가운데에 박혀 있어 page 를
회수할 수 없는 fragmentation 이 발생합니다.
이 패치셋은 slab allocator 로 할당된 object 의 사용자에게 가능하면 해당 object
들을 움직여 달라고 callback 할 수 있게 함으로써 이 fragmentation 을 해결하려
합니다.&lt;/p&gt;
&lt;p&gt;앞의 버전에 비해서 변경된 건 LWN 기사에 달린 코멘트를 기반으로 한 개선들이군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-guarantee-natural-alignment-for-kmalloc&#34;&gt;[LSF/MM TOPIC] guarantee natural alignment for kmalloc()?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/790b68b7-3689-0ff6-08ae-936728bc6458@suse.cz&#34;&gt;https://lkml.kernel.org/r/790b68b7-3689-0ff6-08ae-936728bc6458@suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LSFMM 을 위한 늦은 주제네요.
kmalloc() 이 2의 승수 크기 얼라인먼트를 지키도록 하는 패치에 대해서 논의하고
싶어합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51rc5&#34;&gt;Linux 5.1-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjvcuyCQGnfOhooaL1H4H63qXO=xgo+9yncSOG=eK+kbA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjvcuyCQGnfOhooaL1H4H63qXO=xgo+9yncSOG=eK+kbA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다섯번째 rc 커널입니다.  v5.1이 얼마 남지 않았군요.
이번 릴리즈에선 대부분 드라이버 쪽 변경이 있었으며, 딱히 이상하거나 수상한
움직임은 없다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc4</title>
      <link>/post/lkml_news_v5.1-rc4/</link>
      <pubDate>Sun, 07 Apr 2019 23:17:55 +0900</pubDate>
      <guid>/post/lkml_news_v5.1-rc4/</guid>
      <description>&lt;p&gt;Linux v5.1-rc3 릴리즈 후 Linux v.5.1-rc4 릴리즈 사이 기간에 LKML 에 올라온
흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v8-0020-convert-x86--arm64-to-use-generic-page-walk&#34;&gt;[PATCH v8 00/20] Convert x86 &amp;amp; arm64 to use generic page walk&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190403141627.11664-1-steven.price@arm.com&#34;&gt;https://lkml.kernel.org/r/20190403141627.11664-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;전에 이 블로그에도 공유했던, &lt;code&gt;walk_page_range()&lt;/code&gt; 함수가 커널에서 사용하는
페이지 테이블은 지원하지 않아서 아키텍쳐별로 page table walk 기능을 구현한 걸
&lt;code&gt;walk_page_range()&lt;/code&gt; 의 개선을 통해 가능하게 하고자 하는 패치의 여덟번째
버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-add-vm-event-for-page-cache-miss&#34;&gt;[PATCH] mm: add vm event for page cache miss&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1554185720-26404-1-git-send-email-laoar.shao@gmail.com&#34;&gt;https://lkml.kernel.org/r/1554185720-26404-1-git-send-email-laoar.shao@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Page cache miss 로 인해 사용중인 데이터베이스에 레이턴시가 증가하는 문제가
있는데, 기존 커널에는 페이지 캐시 미스 카운트를 세는 기능이 없기 때문에 만들어
봤다고 합니다.  반응은&amp;hellip; 별로 좋지 않군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-0025-accelerate-page-migration-and-use-memcg-for-pmem-management&#34;&gt;[RFC PATCH 00/25] Accelerate page migration and use memcg for PMEM management&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190404020046.32741-1-zi.yan@sent.com&#34;&gt;https://lkml.kernel.org/r/20190404020046.32741-1-zi.yan@sent.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 이 블로그에서도 소개한대로 PMEM 을 좀 많이 느린 NUMA node 로 다룰 수 있게
되었습니다.  따라서 적절한 페이지 마이그레이션이 중요해지죠.  리눅스 자체 page
replacement policy 를 이용해 page migration 을 하는 방법이 제기되었지만 그
방법은 충분한 쓰루풋을 제공하지 않고 너무 가끔 replacement 가 일어나 hot / cold
를 제대로 구분하기 어려운 문제가 있다고 이 메일은 주장하고, 자신이 생각하는
해결책을 RFC 의 형태로 제시하고 있습니다.&lt;/p&gt;
&lt;p&gt;실제 기존 방식의 마이그레이션 쓰루풋과 자신이 제안한 방식의 쓰루풋을 비교하면서
설명하는데, 재밌네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-tipcorercu-04-forbid-static-srcu-use-in-modules&#34;&gt;[PATCH RFC tip/core/rcu 0/4] Forbid static SRCU use in modules&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190402142816.GA13084@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190402142816.GA13084@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;로드될 수 있는 모듈 내에서의 &lt;code&gt;DEFINE_SRCU()&lt;/code&gt; 와 &lt;code&gt;DEFINE_STATIC_SRCU()&lt;/code&gt; 사용을
급지하는 패치셋입니다.  로드 되는 모듈에서 이걸 사용하면 메모리 회수가 안될
것이기 때문이죠.  대신 동적으로 메모리 할당받고 초기화 해서 쓰고, 모듈 exit 될
때 제대로 메모리 해제 시키라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51rc4&#34;&gt;Linux 5.1-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=widsb0vN7kqt8ATfNuNW6a54JpKjc6W0XPjt5=LW7UeGQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=widsb0vN7kqt8ATfNuNW6a54JpKjc6W0XPjt5=LW7UeGQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 릴리즈는 초반 rc 들이 좀 커서 걱정을 끼쳤었는데, rc4 는 다행히도
작아졌다고 합니다.  딱히 별다른 게 없다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc3</title>
      <link>/post/lkml_news_v5.1-rc3/</link>
      <pubDate>Tue, 26 Mar 2019 08:53:41 +0900</pubDate>
      <guid>/post/lkml_news_v5.1-rc3/</guid>
      <description>&lt;h2 id=&#34;patch-tipcorercu-04-documentation-updates-for-v52&#34;&gt;[PATCH tip/core/rcu 0/4] Documentation updates for v5.2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190326230408.GA17069@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190326230408.GA17069@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v5.2 에 머지될 목적의 RCU 문서화 업데이트 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-018-miscellaneous-fixes-for-v52&#34;&gt;[PATCH tip/core/rcu 0/18] Miscellaneous fixes for v5.2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190326231253.GA18343@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190326231253.GA18343@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v5.2 를 위한 RCU 의 다양한 업데이트 패치셋입니다.  rcu 를 위한 메일링 리스트도
추가되었군요.  &lt;a href=&#34;mailto:rcu@vger.kernel.org&#34;&gt;rcu@vger.kernel.org&lt;/a&gt; 입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-09-torturetest-updates-for-v52&#34;&gt;[PATCH tip/core/rcu 0/9] Torture-test updates for v5.2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190326233054.GA21523@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20190326233054.GA21523@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v5.2 를 위한 torture test 의 업데이트 패치셋입니다.  LKMM 이라던지 formal
verification 도 많은 발전이 있었지만, torture test 도 없어질 순 없겠죠.&lt;/p&gt;
&lt;h2 id=&#34;linux-51rc3&#34;&gt;Linux 5.1-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiHmEqxBvp3dfTqOut+NHzbNaip=BrnBO48SCTfnApLRg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiHmEqxBvp3dfTqOut+NHzbNaip=BrnBO48SCTfnApLRg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;한국시간으로 만우절 아침, 5.1 을 위한 세번째 rc 버전이 릴리즈 되었습니다.  이번
릴리즈는 다른 rc3 들에 비해 조금 많은 변화가 있었기에 좋은 현상은 아니지만
그렇다 해도 아직 rc3 정도니까 큰 문제는 아닐 거라 하는군요.  전체적으로 코드가
추가된 것보다 제거된 게 많은 것 같습니다.
어쨌건 앞으로는 점점 변경양이 줄었으면 좋겠다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unit test for the Linux kernel using Kunit</title>
      <link>/post/kunit_intro/</link>
      <pubDate>Wed, 20 Mar 2019 15:32:29 +0900</pubDate>
      <guid>/post/kunit_intro/</guid>
      <description>&lt;p&gt;지난 2월 말에 FAST&#39;19 학회를 다녀왔는데요, [Ted Tso] (&lt;a href=&#34;https://thunk.org/tytso/&#34;&gt;https://thunk.org/tytso/&lt;/a&gt;)
도 왔더군요.  심지어 구글 부스를 지키고 계시더라구요.  어쩌다보니
식사자리에서 합석하고 잡담 나눈 레드햇 개발자 분들이랑 이야기를 하고 있길래
껴서 좀 이야기를 했는데, 이야기 중 테스트에 대한 이야기가 나왔고, 이에 Ted 가
KUnit 이라는 도구를 소개해 줬습니다.  잠깐 사용해 보니 매우 매력적인 것 같아서
이 블로그에서도 소개해 볼까 합니다.&lt;/p&gt;
&lt;p&gt;KUnit 은 이름에서 짐작했겠지만 리눅스 커널을 위한 유닛 테스트 프레임웍입니다.
구글의 Brendan Higgins 라는 분이 개발하고 있고, 커널 내에 머지되는 걸 목표로
해서 LKML 에도 &lt;a href=&#34;https://lkml.org/lkml/2019/2/14/1144&#34;&gt;RFC 패치&lt;/a&gt;를 보내고
있습니다.
구글러다 보니 구글에서 호스팅 되는
&lt;a href=&#34;https://kunit.googlesource.com/linux/&#34;&gt;소스트리&lt;/a&gt; 위에서 개발을 하고 있고,
&lt;a href=&#34;https://google.github.io/kunit-docs/third_party/kernel/docs/&#34;&gt;문서화&lt;/a&gt; 도 잘
해뒀군요.&lt;/p&gt;
&lt;p&gt;이 글은 이런 KUnit 을 사용하는 법을 간단히 정리해 봅니다.  글 내의 테스트에
사용된 환경은 Ubuntu 16.04 서버 버전입니다.&lt;/p&gt;
&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;
&lt;p&gt;Kunit 개발 커널은 &lt;a href=&#34;https://kunit.googlesource.com&#34;&gt;https://kunit.googlesource.com&lt;/a&gt; 에서 받을 수 있습니다.  간단히
아래 명령으로 커널 코드를 땡겨옵시다.  여기선 가장 최근에 RFC 패치를 보냈던
5.0-rc5 위의 버전으로 가져오겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone -b kunit/rfc/5.0-rc5/v4 https://kunit.googlesource.com/linux
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;물론, [Patchwork]
(&lt;a href=&#34;https://lore.kernel.org/patchwork/project/lkml/list/?series=383391&#34;&gt;https://lore.kernel.org/patchwork/project/lkml/list/?series=383391&lt;/a&gt;) 을 통해
KUnit 패치만 직접 받아와 사용중인 커널에 적용하실 수도 있습니다.  전 v5.0 버전
위에도 적용해 봤는데 문제 없이 잘 적용되더군요.&lt;/p&gt;
&lt;p&gt;이어서 KUnit 을 위한 패키지를 깔아야 할텐데요, 커널 빌드에 필요한 패키지만 깔면
됩니다.  커널 빌드에 필요한 패키지에 대한 정보는 이 블로그의 커널 빌드 및
설치에 대한 [포스트] (/post/linux-kernel-build/) 를 참고해 주세요.&lt;/p&gt;
&lt;h1 id=&#34;test&#34;&gt;Test&lt;/h1&gt;
&lt;p&gt;커널 빌드 종속성 패키지까지 다 설치했다면 준비가 거의 끝났습니다.  잘 돌아가는지 확인해 보기 위해 kunit 에서 제공하는 예제 테스트들을 돌려봅시다.&lt;/p&gt;
&lt;p&gt;KUnit 을 돌리기 위해선 configuration 을 커널 트리 루트에 &lt;code&gt;kunitconfig&lt;/code&gt; 라는
이름의 파일로 써줘야 합니다.  이 설정은 어떤 테스트를 돌릴지 등을 지정합니다.
일단 아래 내용으로 해당 파일을 써줍시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd linux
$ echo CONFIG_KUNIT=y &amp;gt; kunitconfig
$ echo CONFIG_KUNIT_TEST=y &amp;gt;&amp;gt; kunitconfig
$ echo CONFIG_KUNIT_EXAMPLE_TEST=y &amp;gt;&amp;gt; kunitconfig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이제 다음의 간단한 명령만으로 KUnit 예제 테스트를 돌릴 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./tools/testing/kunit/kunit.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;아래와 같은 결과가 터미널에 뜰겁니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[11:31:47] Building KUnit Kernel ...
[11:32:12] Starting KUnit Kernel ...
[11:32:12] ==============================
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_init_resources
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_alloc_resource
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_free_resource
[11:32:13] [PASSED] kunit-resource-test:kunit_resource_test_cleanup_resources
[11:32:13] ==============================
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_try_catch_successful_try_no_catch
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_try_catch_unsuccessful_try_does_catch
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_generic_try_catch_successful_try_no_catch
[11:32:13] [PASSED] kunit-try-catch-test:kunit_test_generic_try_catch_unsuccessful_try_does_catch
[11:32:13] ==============================
[11:32:13] [PASSED] string-stream-test:string_stream_test_get_string
[11:32:13] [PASSED] string-stream-test:string_stream_test_add_and_clear
[11:32:13] ==============================
[11:32:13] [PASSED] example:example_simple_test
[11:32:13] ==============================
[11:32:13] Testing complete. 11 tests run. 0 failed. 0 crashed.
[11:32:13] Elapsed time: 26.005s total, 0.000s configuring, 25.736s building, 0.268s running.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;kunit-resource-test, kunit-try-catch-test, string-stream-tets, example&lt;/code&gt; 등의
예제 테스트가 돌아갔고, 모두 테스트를 통과해서 문제가 없음을 보여줍니다.&lt;/p&gt;
&lt;p&gt;KUnit 은 테스트를 위해 커널도 빌드하기 때문에 빌드 시간이 조금 길긴 합니다.  이
경우엔 26초 정도 걸렸네요.  하지만 이건 처음 빌드라 그렇고, 기존에 빌드를
해두고 파일 하나만 수정하는 경우엔 약 10초 정도 걸리는 것 같습니다.  하지만
이후 실제 테스트를 돌리는건 매우 짧은 시간을 필요로 합니다.  이 경우 0.27초
가량 걸렸군요!  따라서 테스트가 늘어나도 많은 시간을 요하지 않습니다.&lt;/p&gt;
&lt;p&gt;스스로를 위한 유닛 테스트를 추가하는 법은 Kunit 공식 문서[1] 를 참고하시기
바랍니다.  어렵지 않습니다 :)&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://google.github.io/kunit-docs/third_party/kernel/docs/start.html#writing-your-first-test&#34;&gt;https://google.github.io/kunit-docs/third_party/kernel/docs/start.html#writing-your-first-test&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;리눅스 커널을 위한 Unit test framework 인 KUnit 에 대한 간단한 소개와 사용법을
설명했습니다.  저도 최근 개발에 활용하고 있는데, TDD 의 장점을 오랫만에 느낄 수
있었습니다.  하루 빨리 업스트림에도 머지되었으면 좋겠네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gitlab docker install</title>
      <link>/post/gitlab_docker_install/</link>
      <pubDate>Tue, 19 Mar 2019 16:39:48 +0900</pubDate>
      <guid>/post/gitlab_docker_install/</guid>
      <description>&lt;p&gt;연구실 내부 사용을 위한 Gitlab 을 Docker 를 사용해서 구축하고 사용하고
있습니다만, 하도 예전이라 Gitlab official docker image 가 아니었고, docker
버전도 2.x 대라서 최신 버전으로 바로 업그레이드가 불가능하군요.&lt;/p&gt;
&lt;p&gt;지금은 gitlab 에서 자체적으로 정식 docker 이미지를 제공합니다.
이 포스트에서는 Ubuntu 18.04 서버 위에 gitlab 정식 docker 이미지를 사용해
설치하는 방법을 기록합니다.&lt;/p&gt;
&lt;h1 id=&#34;docker-&#34;&gt;Docker 설치&lt;/h1&gt;
&lt;p&gt;먼저 Docker 를 설치해야죠.  문서[1]를 참고해서 설치를 진행해 봅니다.&lt;/p&gt;
&lt;p&gt;먼저 apt 업데이트 후 종속 패키지들을 깔아줍니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이제 최신 docker 를 깔기 위해 docker repository 를 apt 에 추가해 주고요:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&amp;quot;
sudo apt update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;설치합시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install docker-ce
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;잘 깔렸는지 확인해 봅시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo docker run hello-world
Unable to find image &#39;hello-world:latest&#39; locally
latest: Pulling from library/hello-world
1b930d010525: Pull complete 
Digest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위와 같이 &lt;code&gt;Hello from Docker!&lt;/code&gt; 가 나오면 된겁니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04&#34;&gt;https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;gitlab-&#34;&gt;Gitlab 설치&lt;/h1&gt;
&lt;h2 id=&#34;-&#34;&gt;일단 시작&lt;/h2&gt;
&lt;p&gt;이제 Gitlab docker image 를 가져오고 돌려보죠.  Gitlab 쪽 문서[1]를 참고합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd $HOME; mkdir data
$ sudo docker run --detach --hostname gitlab.example.com \
		--publish 30443:443 --publish 30480:80 --publish 30422:22 \
		--name gitlab --restart always \
		--volume $HOME/data/srv/gitlab/config:/etc/gitlab \
		--volume $HOME/data/srv/gitlab/logs:/var/log/gitlab \
		--volume $HOME/data/srv/gitlab/data:/var/opt/gitlab \
		gitlab/gitlab-ce:11.8.2-ce.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 글 작성 시점 기준으로 가장 마지막 정식 릴리즈가 11.8 이므로 11.8.2 버전을
골랐고, 기존에 웹서버와 ssh 가 깔려있는 관계로 별도의 포트를 사용하게 했습니다.&lt;/p&gt;
&lt;p&gt;조금 기다렸다가 &lt;a href=&#34;http://gitlab.example.com:30480&#34;&gt;http://gitlab.example.com:30480&lt;/a&gt; 으로 들어가면 로그인 됩니다.
&lt;code&gt;$ sudo docker ps -a&lt;/code&gt; 명령을 통해 만든 컨테이너의 status 가 &lt;code&gt;starting&lt;/code&gt; 을
넘어갈 때까지만 기다리면 됩니다.
최초 로그인 시에는 관리자 패스워드를 바로 설정할 수 있습니다.
이후 root 계정에 지금 설정한 패스워드를 입력해 접속할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;-1&#34;&gt;설정 변경&lt;/h2&gt;
&lt;p&gt;몇가지 설정을 추가해야 합니다.  설정은 아래 명령으로 지금 띄운 컨테이너에
들어가 설정 파일을 수정하는 것으로 가능합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo docker exec -it gitlab /bin/bash
# vi /etc/gitlab/gitlab.rb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;--volume&lt;/code&gt; 으로 &lt;code&gt;$HOME/data/srv/gitlab/config&lt;/code&gt; 아래로 파일이 링크되어 있으므로
여기서 수정해도 괜찮습니다.&lt;/p&gt;
&lt;p&gt;해당 파일을 변경한 후에는 docker 를 재시작 해야 변경된 설정이 적용됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo docker restart gitlab
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;--&#34;&gt;포트 변경 적용&lt;/h2&gt;
&lt;p&gt;호스트의 80 포트, 22 포트, 443 포트를 점유할 수 없는 상황이므로 우린 30480,
30422, 30443 포트를 대신 사용하도록 했습니다.
이 경우 추가적인 설정이 필요합니다.
&lt;code&gt;gitlab.rb&lt;/code&gt; 파일에 아래 네줄을 추가합시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;external_url &#39;http://gitlab.example.com:30480&#39;
nginx[&#39;listen_port&#39;] = 80
nginx[&#39;listen_https&#39;] = false
gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] = 30422
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;두번째, 세번째 줄을 추가 안해주면 동작 안합니다[3].&lt;/p&gt;
&lt;h2 id=&#34;gmail-smtp-&#34;&gt;gmail smtp 설정&lt;/h2&gt;
&lt;p&gt;이어서 smtp 설정을 해야 합니다.&lt;/p&gt;
&lt;p&gt;우린 gmail smtp 를 사용하겠습니다.  이 설정 파일에 다음과 같은 내용을
추가합니다.  이 내용은 공식 문서의 예제[2]에서 가져왔습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gitlab_rails[&#39;smtp_enable&#39;] = true
gitlab_rails[&#39;smtp_address&#39;] = &amp;quot;smtp.gmail.com&amp;quot;
gitlab_rails[&#39;smtp_port&#39;] = 587
gitlab_rails[&#39;smtp_user_name&#39;] = &amp;quot;my.email@gmail.com&amp;quot;
gitlab_rails[&#39;smtp_password&#39;] = &amp;quot;my-gmail-password&amp;quot;
gitlab_rails[&#39;smtp_domain&#39;] = &amp;quot;smtp.gmail.com&amp;quot;
gitlab_rails[&#39;smtp_authentication&#39;] = &amp;quot;login&amp;quot;
gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true
gitlab_rails[&#39;smtp_tls&#39;] = false
gitlab_rails[&#39;smtp_openssl_verify_mode&#39;] = &#39;peer&#39; # Can be: &#39;none&#39;, &#39;peer&#39;, &#39;client_once&#39;, &#39;fail_if_no_peer_cert&#39;, see http://api.rubyonrails.org/classes/ActionMailer/Base.html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;여기서 &lt;code&gt;my.email&lt;/code&gt; 과 &lt;code&gt;my-gmail-password&lt;/code&gt; 는 당연히 실제 gmail 계정으로
바꿔야겠죠?  해당 gmail 계정도 gmail 설정에서 smtp 를 사용할 수 있게 설정해
줘야 합니다.&lt;/p&gt;
&lt;h2 id=&#34;--1&#34;&gt;가입 기능 제거&lt;/h2&gt;
&lt;p&gt;gitlab 첫페이지는 &lt;code&gt;sign in&lt;/code&gt; 과 &lt;code&gt;register&lt;/code&gt; 기능이 있습니다.  처음 사용하는
유저는 &lt;code&gt;register&lt;/code&gt; 를 사용하면 되는거죠.&lt;/p&gt;
&lt;p&gt;하지만 우린 폐쇄적으로 운영할 꺼라 계정을 관리자 통해서만 만들 수 있게 하고
싶습니다.  Admin area -&amp;gt; Settings -&amp;gt; General -&amp;gt; Sign-up restrictions 메뉴에서
Sign-up enabled 를 비활성화 시키고 변경사항 저장 버튼을 누릅니다.
이제 gitlab 첫페이지에 &lt;code&gt;register&lt;/code&gt; 기능이 사라져 있을 겁니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://docs.gitlab.com/omnibus/docker/&#34;&gt;https://docs.gitlab.com/omnibus/docker/&lt;/a&gt;
[2] &lt;a href=&#34;https://docs.gitlab.com/omnibus/settings/smtp.html&#34;&gt;https://docs.gitlab.com/omnibus/settings/smtp.html&lt;/a&gt;
[3] &lt;a href=&#34;https://gitlab.com/gitlab-org/omnibus-gitlab/issues/3535&#34;&gt;https://gitlab.com/gitlab-org/omnibus-gitlab/issues/3535&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc2</title>
      <link>/post/lkml_news_v5.1-rc2/</link>
      <pubDate>Tue, 19 Mar 2019 12:11:11 +0900</pubDate>
      <guid>/post/lkml_news_v5.1-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-v5-0019-convert-x86--arm64-to-use-generic-page-walk&#34;&gt;[PATCH v5 00/19] Convert x86 &amp;amp; arm64 to use generic page walk&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190321141953.31960-1-steven.price@arm.com&#34;&gt;https://lkml.kernel.org/r/20190321141953.31960-1-steven.price@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널이 &lt;code&gt;walk_page_range()&lt;/code&gt; 함수를 제공하긴 하지만 이 함수는 커널에 의해
사용되는 페이지 테이블은 볼수가 없기 때문에 각 아키텍쳐별로 페이지 테이블
순회를 위한 기능을 별도로 만들어 사용하고 있습니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 &lt;code&gt;walk_page_range()&lt;/code&gt; 가 커널의 페이지 테이블을 만질 수 있도록
확장함으로써 그런 불필요한 아키텍쳐별 파편화를 줄이려 합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v6-07-psi-pressure-stall-monitors-v6&#34;&gt;[PATCH v6 0/7] psi: pressure stall monitors v6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190319235619.260832-1-surenb@google.com&#34;&gt;https://lkml.kernel.org/r/20190319235619.260832-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시스템이 어떤 부분의 pressure 를 받는지 쉽게 확인하기 위한 pressure stall
monitor 구현 패치의 여섯 번째 버전입니다.  안드로이드는 이미 이 기능을 적용해서
모바일 기기의 메모리 부족 문제를 해결하고 있다는군요.&lt;/p&gt;
&lt;p&gt;파일 기반의 기존 인터페이스는 자주 들여다보면 오버헤드가 있기 때문에 유저가
&lt;code&gt;poll()&lt;/code&gt; 할 수 있는 형태로 인터페이스를 개선한 것 같습니다.&lt;/p&gt;
&lt;p&gt;이 패치 기반으로 안드로이드의 low memory killer daemon 을 개선했고, 결과 false
positive memory pressure 를 vmpressure signal 대비 약 10배까지 줄일 수 있었다고
합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-remove-support-for-deprecated-pf-and-pf-in-vsprintf&#34;&gt;[PATCH 0/2] Remove support for deprecated %pf and %pF in vsprintf&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190322132108.25501-1-sakari.ailus@linux.intel.com&#34;&gt;https://lkml.kernel.org/r/20190322132108.25501-1-sakari.ailus@linux.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;함수 포인터의 프린트를 위해 사용되는 프린트 포맷 지시어인 %pf 와 %pF 를 거의
같은 일을 하면서 ia64, ppc64, parisc64 아키텍쳐에선 좀 더 많은 일을 해주는 $ps
와 %pS 로 대체하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-010-another-approach-to-use-pmem-as-numa-node&#34;&gt;[RFC PATCH 0/10] Another Approach to Use PMEM as NUMA Node&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1553316275-21985-1-git-send-email-yang.shi@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/1553316275-21985-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 이 블로그에서도 소개한 바 있는 PMEM 을 매우 느린 NUMA node 로 쓰는 패치가
머지되었습니다.
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c221c0b0308fd01d9fb33a16f64d2fd95f8830a4&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c221c0b0308fd01d9fb33a16f64d2fd95f8830a4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그럼 이렇게 평범한 NUMA node 로 인식되는 PMEM 을 어떻게 잘 쓸 것인가? 하는
문제가 남아있는데, 이 패치셋은 이를 위한 패치입니다.&lt;/p&gt;
&lt;p&gt;기본적으로 DRAM 을 먼저 쓰게 만들고, 사용자가 기존의 방식대로 명시적으로 NUMA
인터페이스를 사용해 PMEM 을 요청하면 할당해 줍니다.  그리고, 자주 접근되는
페이지는 vma 단위로 조사해서 DRAM 으로 migrate 시킵니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51rc2&#34;&gt;Linux 5.1-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgg_PRWs3a6u2gnFLQjhxOJcrFkqqWVnLw60eQAwD-DNw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgg_PRWs3a6u2gnFLQjhxOJcrFkqqWVnLw60eQAwD-DNw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;두번째 rc 입니다.  아직 rc 라고 하기엔 고칠 문제도 찾지 못한 상태라고 할 수
있겠지만요.  따라서 토발즈는 열심히 테스트 해달라고 하네요.&lt;/p&gt;
&lt;p&gt;어쨌건 이번 릴리즈도 크게 특이한 사항은 없다고 합니다, 다만 이번 수정사항 중
2/3 가량이 tools/ 쪽에 집중되었다고 하네요.  perf 쪽의 변경 때문이라고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc1</title>
      <link>/post/lkml_news_v5.1-rc1/</link>
      <pubDate>Mon, 04 Mar 2019 13:07:30 +0900</pubDate>
      <guid>/post/lkml_news_v5.1-rc1/</guid>
      <description>&lt;p&gt;Linux v5.0 릴리즈 (2019-03-03) 부터 v5.1-rc1 릴리즈 (2019-03-17) 사이의 머지
윈도우 기간 LKML 에 올라온 흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;cma-allocation-failure&#34;&gt;CMA allocation failure&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/57e0bc63-0be9-498b-8ffc-3b073e01e299@email.android.com&#34;&gt;https://lkml.kernel.org/r/57e0bc63-0be9-498b-8ffc-3b073e01e299@email.android.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;제게도 GCMA 레이턴시 관련 문의를 보냈던 분인데, LKML 에도 관련 도움을 요청하는
메일을 보냈군요.&lt;/p&gt;
&lt;p&gt;왜 CMA 가 할당에 실패하는지 이유를 묻는 메일인데요, 답은 없습니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-using-xarray-to-manage-the-vma&#34;&gt;[LSF/MM TOPIC] Using XArray to manage the VMA&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/7da20892-f92a-68d8-4804-c72c1cb0d090@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/7da20892-f92a-68d8-4804-c72c1cb0d090@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MM 의 오랜 숙원 중 하나는 &lt;code&gt;mmap_sem&lt;/code&gt; 으로 인한 확장성 문제 해결이죠.  기존의 RB
tree 대신 XArray 를 사용하는 것으로 새로운 시도를 시작해 보는건 어떨지 LSFMM
에서 토의해보자는, speculative page fault 의 최근 메인테이너인 Laurent 의
메일입니다.
곧바로 XArray 메인테이너인 Matthew 의 답장이 오는군요.
꼭 해보려는 의지가 강력해 보입니다.&lt;/p&gt;
&lt;h2 id=&#34;mmcmac-high-latency-for-cma-allocation&#34;&gt;mm/cma.c: High latency for cma allocation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/SG2PR02MB3098E44824F5AA69BC04F935E8470@SG2PR02MB3098.apcprd02.prod.outlook.com&#34;&gt;https://lkml.kernel.org/r/SG2PR02MB3098E44824F5AA69BC04F935E8470@SG2PR02MB3098.apcprd02.prod.outlook.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이어지는 CMA 레이턴시에 대한 문의입니다.  제게 GCMA 레이턴시에 대해 온 문의에
대해서는 제 실험 환경을 보내주고 그쪽 환경에서 돌려본 후 결과를 알려달라
했는데, 아직 답이 없군요.
좀 더 자세한 분석 결과를 달라는 Michal 의 답변이 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-51rc1&#34;&gt;Linux 5.1-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wj1c_Tb-wwM6qaPLdggXtW3rOh1JzYUOs+O7PsHt-=+jg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wj1c_Tb-wwM6qaPLdggXtW3rOh1JzYUOs+O7PsHt-=+jg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v5.1 머지 윈도우가 종료되고 v5.1-rc1 이 릴리즈 되었습니다.  이번 릴리즈도 크게
다른 건 없고 매우 평범했다고 합니다.  좋은 징조인데요, 변경사항의 60%를 차지한
드라이버 가운데 habanalab 의 AI 가속기 칩 드라이버를 조금 특별한 변경사항으로
토발즈는 꼽네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0</title>
      <link>/post/lkml_news_v5.0/</link>
      <pubDate>Mon, 25 Feb 2019 13:16:39 +0900</pubDate>
      <guid>/post/lkml_news_v5.0/</guid>
      <description>&lt;p&gt;Linux v5.0-rc8 릴리즈 (2019-02-24) 부터 Linux v5.0 릴리즈 (2019-03-03) 사이
기간에 LKML 에 올라온 흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-05-v5-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;&lt;code&gt;[PATCH 0/5] [v5] Allow persistent memory to be used like normal RAM&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190225185727.BCBD768C@viggo.jf.intel.com&#34;&gt;https://lkml.kernel.org/r/20190225185727.BCBD768C@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 몇번 소개했던, persistent memory 를 좀 많이 느린 numa node 인 것처럼 해서
시스템이 사용할 수 있게 하는 접근법의 패치 다섯번째 버전입니다.
이제 개선은 어느정도 된 것 같으니 슬슬 머지되야하지 않겠냐고 주장하는군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-v50&#34;&gt;Linux v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjuG6HiGbD7DCGfvDvhr_1WZUR-eYF2qWGbYyn9k6unvg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjuG6HiGbD7DCGfvDvhr_1WZUR-eYF2qWGbYyn9k6unvg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;마침내 5.0 릴리즈입니다!  제 랩톱에도 바로 받아다가 설치했습니다! ;)  물론 5.0
릴리즈에 특별한 기능 추가라던지 하는건 없고 그저 시간이 꽤 지나서 이렇게
된거라곤 하지만 어쨌든 느낌은 새롭군요.&lt;/p&gt;
&lt;p&gt;rc8 릴리즈 후에도 양은 크게 줄었지만 패치가 좀 있었습니다.  그렇게 고쳐진 버그
중 하나로는 uninitialized variable 문제가 있었는데, gcc 가 알아서 초기화를
시켜주다보니 워닝이 안떴었군요.  물론 다른 컴파일러를 사용하면 문제가 생기게
되니 무쓸모한 변경은 아니었다 자평합니다.&lt;/p&gt;
&lt;p&gt;어쨌든, 이렇게 v5.0 커널이 정식으로 나왔고, v5.1 을 향한 여정이 시작되었습니다!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc8</title>
      <link>/post/lkml_news_v5.0-rc8/</link>
      <pubDate>Tue, 19 Feb 2019 08:33:37 +0900</pubDate>
      <guid>/post/lkml_news_v5.0-rc8/</guid>
      <description>&lt;p&gt;Linux v5.0-rc7 릴리즈 (2019년 2월 17일) 부터 v5.0-rc8 릴리즈 (2019년 2월 24일)
사이의 기간에 LKML 에 올라온 흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-attend-mm-track-numa-thp-locality-reclaim&#34;&gt;[LSF/MM ATTEND] MM track: NUMA, THP locality, reclaim&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190218143203.GW9565@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20190218143203.GW9565@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mel Gorman 의 LSF/MM 참여 메일입니다.  NUMA remote THP vs NUMA local non-THP,
NUMA, 메모리 계층 그리고 디바이스 메모리, NUMA rebalancing 과 메모리 reclaim 에
참여하고 싶다고 이야기 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-lsfmm-attend-readonly-mapping-of-program-text&#34;&gt;&lt;code&gt;[LSF/MM TOPIC ][LSF/MM ATTEND] Read-only Mapping of Program Text&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/379F21DD-006F-4E33-9BD5-F81F9BA75C10@oracle.com&#34;&gt;https://lkml.kernel.org/r/379F21DD-006F-4E33-9BD5-F81F9BA75C10@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 를 활용해 read-only text 를 매핑함으로써 성능을 높이려는 시도를 해오고
있는데, 하나의 base page 를 먼저 읽고 이어서 추가적인 page 를 읽는게 진짜로
사용될지 모르는 readahead 때문에 의논을 해보고 싶다고 하네요.
또, 파일시스템에게 컨텐츠가 큰 청크를 필요로 할지 알려주는 인터페이스가 있으면
좋겠다는군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-v50rc8&#34;&gt;Linux v5.0-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgtNhecfn_nOi0Yuy7XQSswfozz0CvRMn0WsQhk0YZfyw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgtNhecfn_nOi0Yuy7XQSswfozz0CvRMn0WsQhk0YZfyw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;rc8 이 나올지 바로 v5.0 이 나올지 궁금했는데, 결국 v5.0 릴리즈는 한주 더
미뤄지게 되었습니다.  rc7 때보다도 많은 패치가 이번 기간에 들어왔다는군요.&lt;/p&gt;
&lt;p&gt;그렇다고 아주 특별한 변경이 있었던 건 아니지만 그렇다고 서두를 것도 없으므로
그냥 rc8 을 릴리즈하기로 결정했다고 하네요.&lt;/p&gt;
&lt;p&gt;어쨌건 다음주에는 분명 v5.0 이 나오겠죠!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc7</title>
      <link>/post/lkml_news_v5.0-rc7/</link>
      <pubDate>Mon, 18 Feb 2019 12:30:24 +0900</pubDate>
      <guid>/post/lkml_news_v5.0-rc7/</guid>
      <description>&lt;h2 id=&#34;patch-v15-0018-block-support-multipage-bvec&#34;&gt;[PATCH V15 00/18] block: support multi-page bvec&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190215111324.30129-1-ming.lei@redhat.com&#34;&gt;https://lkml.kernel.org/r/20190215111324.30129-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시스템의 RAM 이 커지고 huge page 가 널리 사용되면서 물리적으로 연속된
페이지들의 I/O 가 흔해지고 있습니다.  이를 위해 &lt;code&gt;struct bio_bvec&lt;/code&gt; 이 물리적으로
연속된 여러 페이지를 다룰 수 있게 해주는 패치의 15번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;memory-management-facing-a-400gpbs-network-link&#34;&gt;Memory management facing a 400Gpbs network link&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/01000168e2f54113-485312aa-7e08-4963-af92-803f8c7d21e6-000000@email.amazonses.com&#34;&gt;https://lkml.kernel.org/r/01000168e2f54113-485312aa-7e08-4963-af92-803f8c7d21e6-000000@email.amazonses.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해 내로 400Gbps 인피니밴드가 가능해질 거라고 합니다!  이건 프로세서-메모리
사이의 밴드위쓰를 넘길 수 있는 스피드죠!  단일 하드웨어 쓰레드는 20GB/s 이기
때문입니다.  이 재미있는 트렌드를 커널은 어떻게 대처해야 할 것인가 하는
메일입니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-generating-physically-contiguous-memory&#34;&gt;[LSF/MM TOPIC] Generating physically contiguous memory&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CEDBC792-DE5A-42CB-AA31-40C039470BD0@nvidia.com&#34;&gt;https://lkml.kernel.org/r/CEDBC792-DE5A-42CB-AA31-40C039470BD0@nvidia.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GPU, FPGA, NIC, RDMA 같은 고성능 디바이스들에게 있어 물리적 연속 메모리는 매우
중요합니다.  이 디바이스들은 내부적으로 고밀도의 computation 을 하는데 tlb miss
와 이어지는 page table walk 로 인한 성능 문제가 CPU 에 비해서도 매우 크기
때문이라는군요.&lt;/p&gt;
&lt;p&gt;Boot time reservation 도, THP 도 유연성이 부족하기 때문에 새로운 패치도 만들고,
관련해서 LSF/MM 에서 논의해 보자는군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-v4-0017-kunit-introduce-kunit-the-linux-kernel-unit-testing-framework&#34;&gt;[RFC v4 00/17] kunit: introduce KUnit, the Linux kernel unit testing framework&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190214213729.21702-1-brendanhiggins@google.com&#34;&gt;https://lkml.kernel.org/r/20190214213729.21702-1-brendanhiggins@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널은 다양한 테스트를 가지고 있지만 unit test framework 은 아직 없었죠.
그걸 만든 패치입니다!&lt;/p&gt;
&lt;h2 id=&#34;linux-50rc7&#34;&gt;Linux 5.0-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgvF18PqBch4=56DFwCamYpy+owngTZXGnjVbFgKq467g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgvF18PqBch4=56DFwCamYpy+owngTZXGnjVbFgKq467g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;휴일을 끼고 시작된 머지 윈도우로 이래저래 걱정도 있던 5.0 릴리즈들이었습니다만
이번 rc 릴리즈는 정말 별다른 게 없네요.  매우 고요한 릴리즈였다고 합니다.
아마도 다음주에 5.0 정식 릴리즈가 될 걸로 보이네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc6</title>
      <link>/post/lkml_news_v5.0-rc6/</link>
      <pubDate>Mon, 11 Feb 2019 12:40:20 +0900</pubDate>
      <guid>/post/lkml_news_v5.0-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-v4-11-psi-introduce-psi-monitor&#34;&gt;[PATCH v4 1/1] psi: introduce psi monitor&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190206023446.177362-1-surenb@google.com&#34;&gt;https://lkml.kernel.org/r/20190206023446.177362-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시스템의 메모리 부족 등의 현상이 어떻게 일어나고 있는지 쉽게 파악할 수 있는
장치를 추가하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-address-space-isolation-inside-the-kernel&#34;&gt;[LSF/MM TOPIC] Address space isolation inside the kernel&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190207072421.GA9120@rapoport-lnx&#34;&gt;https://lkml.kernel.org/r/20190207072421.GA9120@rapoport-lnx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스의 어드레스 스페이스 기능은 유저스페이스 프로그램들이 서로에게 영향을
끼치지 못하게 해줘서 컨테이너 등에 쓰이고 있죠.  하지만 커널은 공유하기 때문에
커널 버그는 여전히 영향을 끼칠 수 있습니다.  커널 코드도 어드레스 스페이스를
어느정도 인식하고 코드 분류를 시킴으로써 그 문제를 줄여보자는 LSF/MM 토론 주제
제안입니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-2019-call-for-proposals-updated&#34;&gt;LSF/MM 2019: Call for Proposals (UPDATED!)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/4f5a15c1-4f9e-acae-5094-2f38c8eebd96@kernel.dk&#34;&gt;https://lkml.kernel.org/r/4f5a15c1-4f9e-acae-5094-2f38c8eebd96@kernel.dk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해 LSF/MM 에는 BPF 트랙이 있을 거라는군요.  이에 따른 공지 업데이트입니다.
BPF 의 상승세가 올해도 계속될 것 같군요!&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-bpf-for-block-devices&#34;&gt;[LSF/MM TOPIC] BPF for Block Devices&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/40D2EB06-6BF2-4233-9196-7A26AC43C64E@raithlin.com&#34;&gt;https://lkml.kernel.org/r/40D2EB06-6BF2-4233-9196-7A26AC43C64E@raithlin.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LSF/MM 에 BPF 라면 당연히 block device 와 BPF 의 결합을 이야기 해야하지
않겠냐는 LSF/MM 토론 제안입니다.  Computational Storage 개념을 이야기 하는데요,
I/O 레이어에서 간단한 연산을 처리해 줌으로써 성능을 높이자는 거죠.  그러기 위한
연산 요청에 BPF 를 쓰자는 것 같습니다.  말 되네요!&lt;/p&gt;
&lt;h2 id=&#34;linux-50rc6&#34;&gt;Linux 5.0-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whuSY_-hAU8ugVR7a=xz3uZeRrAPdhsoMZHmZ_7Qc49YQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whuSY_-hAU8ugVR7a=xz3uZeRrAPdhsoMZHmZ_7Qc49YQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이제 리눅스 5.0 정식 릴리즈가 얼마 남지 않았네요, 여섯번째 rc 가 나왔습니다.
그런데 이번 rc 는 토발즈가 바랬던 것보다는 조금 변경사항이 많았군요.  대부분
네트워킹 쪽 변경이었다고 합니다만, 그래도 나머지는 큰 문제 없어 보인다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc5</title>
      <link>/post/lkml_news_v5.0-rc5/</link>
      <pubDate>Mon, 04 Feb 2019 09:18:08 +0900</pubDate>
      <guid>/post/lkml_news_v5.0-rc5/</guid>
      <description>&lt;h2 id=&#34;lsfmm-topic-page-flags-can-we-free-up-space-&#34;&gt;[LSF/MM TOPIC] Page flags, can we free up space ?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190122201744.GA3939@redhat.com&#34;&gt;https://lkml.kernel.org/r/20190122201744.GA3939@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널의 page 정보는 &lt;code&gt;PG_&lt;/code&gt; 로 시작하는 플래그를 사용해 현재 상태를
알리는데요, 이걸 저장하는데 사용되는 공간을 더 줄일 수 있을지에 대한 논의를
해보고 싶다는 LSF/MM 제안입니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-use-nvdimm-as-numa-node-and-numa-api&#34;&gt;[LSF/MM TOPIC] Use NVDIMM as NUMA node and NUMA API&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/f0d66b0c-c9b6-a040-c485-1606041a70a2@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/f0d66b0c-c9b6-a040-c485-1606041a70a2@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;알리바바에서는 NVDIMM 을 클라우드 고객들에게 싼 비용의 메모리로 제공하려
한다는군요.  이를 위해 여러 필요성이 있고, 현재 NUMA API 로는 모든 경우를
커퍼하기가 어렵다고 합니다.  때문에, LSFMM 에서 어떤 use-case 와 needs 가
있는지 공유하고 더 나은 NUMA API 에 대해 논의하고자 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-memory-reclaim-with-numa-rebalancing&#34;&gt;[LSF/MM TOPIC] memory reclaim with NUMA rebalancing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190130174847.GD18811@dhcp22.suse.cz&#34;&gt;https://lkml.kernel.org/r/20190130174847.GD18811@dhcp22.suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NVDIMM 을 싸고 무척 느린 NUMA 노드로 인식되고 사용되게끔 하고자 하는 노력들이
있습니다.  이게 완벽하게 동작하려면 hot page 는 가깝고 빠른 NUMA node 에, cold
page 는 멀고 느린 NUMA node 에 위치되도록 커널이 조정해줄 필요가 있겠죠.  NUMA
balancing 기능이 있긴 하지만 cold page 를 멀고 느린 NUMA node 로 보내는 기능은
현재까지는 없습니다.  이에 대한 논의를 LSF/MM 에서 시작해 보자고 하네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-50rc5&#34;&gt;Linux 5.0-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjoGOgYFCbpazT2Fyv=zHaiagU5PhmiAfrZ5DOmE-y0rg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjoGOgYFCbpazT2Fyv=zHaiagU5PhmiAfrZ5DOmE-y0rg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아무래도 이번 릴리즈들은 머지 윈도우가 길고 연휴와 함께 있었던 탓인지
전체적으로 뭔가 변경사항이 줄지 않는듯 보였는데, 드디어 변경사항이 줄어들고
있다고 합니다.  좋은 신호죠.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the FAST&#39;19</title>
      <link>/post/fast2019_talk/</link>
      <pubDate>Sat, 02 Feb 2019 11:13:29 +0900</pubDate>
      <guid>/post/fast2019_talk/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.usenix.org/conference/fast19/wips&#34;&gt;FAST&#39;19 Work-in-progress 세션&lt;/a&gt;
에서 현재 진행중인 연구에 대해 발표하게 되었습니다.  발표 제목은 &amp;ldquo;Automated
Data Access Pattern Hint Instrumentation for System Performance and Durability
of Swap Storage&amp;rdquo; 입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc4</title>
      <link>/post/lkml_news_v5.0-rc4/</link>
      <pubDate>Mon, 28 Jan 2019 09:21:25 +0900</pubDate>
      <guid>/post/lkml_news_v5.0-rc4/</guid>
      <description>&lt;h2 id=&#34;patch-05-v4-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;&lt;code&gt;[PATCH 0/5] [v4] Allow persistent memory to be used like normal RAM&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190124231441.37A4A305@viggo.jf.intel.com&#34;&gt;https://lkml.kernel.org/r/20190124231441.37A4A305@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PMEM 을 평범한 RAM 처럼 접근할 수 있게 해주는 드라이버를 소개하는 패치셋의
네번째 버전입니다.  인터페이스적 측면에서 개선이 많이 됐고, 패치에 대한 소개도
많이 좋아졌네요.&lt;/p&gt;
&lt;p&gt;이 패치셋이 의도하는 PMEM 은 Intel Optane DC persistent memory 와 같은 NVDIMM
입니다.  휘발성이 없고, flash 보다 빠르고, RAM 에 비해 가격 경쟁력이 좋죠.&lt;/p&gt;
&lt;p&gt;RAM-based NVDIMM 은 의도한 대상이 아닙니다.  그것들은 RAM 대비 가격 경쟁력이
없기 때문이라는군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-numa-remote-thp-vs-numa-local-nonthp-under-madvhugepage&#34;&gt;[LSF/MM TOPIC] NUMA remote THP vs NUMA local non-THP under MADV_HUGEPAGE&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190129234058.GH31695@redhat.com&#34;&gt;https://lkml.kernel.org/r/20190129234058.GH31695@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;제목 그대로입니다.  NUMA remote THP 를 쓰는게 나을까요?  THP 를 포기하고 NUMA
local regular page 를 쓰는게 나을까요?  이에 대해서 LSF/MM 에서 이야기 하고
싶다는군요.&lt;/p&gt;
&lt;h2 id=&#34;linux-50rc4&#34;&gt;Linux 5.0-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgNph26eD1zhP91LQLrwB91QPy4=d82SPfvYmSexV7UpQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgNph26eD1zhP91LQLrwB91QPy4=d82SPfvYmSexV7UpQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어느새 네번째 rc.  이제 5.0 이 그리 멀지 않았네요.  주말 쯤에 갑자기 많은
패치가 밀려왔다고 하지만 큰 문제는 없었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc3</title>
      <link>/post/lkml_news_v5.0-rc3/</link>
      <pubDate>Mon, 21 Jan 2019 09:21:14 +0900</pubDate>
      <guid>/post/lkml_news_v5.0-rc3/</guid>
      <description>&lt;h2 id=&#34;lsfmm-2019-call-for-proposals&#34;&gt;LSF/MM 2019: Call for Proposals&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/51b4b263-a0f2-113d-7bdc-f7960b540929@kernel.dk&#34;&gt;https://lkml.kernel.org/r/51b4b263-a0f2-113d-7bdc-f7960b540929@kernel.dk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해의 LSF/MM 을 위한 발표 모집입니다.  올해는 푸에르토리코에서 4월 30일부터
5월 2일까지 열리는군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-numa-memory-hierarchy-and-device-memory&#34;&gt;[LSF/MM TOPIC] NUMA, memory hierarchy and device memory&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190118174512.GA3060@redhat.com&#34;&gt;https://lkml.kernel.org/r/20190118174512.GA3060@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LSF/MM 을 위한 발표 지원입니다.
NUMA API 가 다계층 메모리에 적용될 때의 단점에 대해서 이야기 해보겠다는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0022-increase-success-rates-and-reduce-latency-of-compaction-v3&#34;&gt;[PATCH 00/22] Increase success rates and reduce latency of compaction v3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190118175136.31341-1-mgorman@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20190118175136.31341-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mel Gorman 의 compaction 개선 패치셋 세번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-50rc3&#34;&gt;Linux 5.0-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whS=6Z_UxzoMjLANupOk3u-8ycERLPnaZxShMTviW0jkQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whS=6Z_UxzoMjLANupOk3u-8ycERLPnaZxShMTviW0jkQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.0 세번째 릴리즈입니다.  지난 릴리즈에서 여행 중이지만 항상 그렇듯 일요일
릴리즈를 하려 한다고 했는데, 이번에도 성공적이군요.  더불어 어디 여행 중인지도
나왔습니다, LCA 2019 여행 중이었군요.  여담이지만 올해 LCA 도 재밌는 발표가
많은 것 같습니다.&lt;/p&gt;
&lt;p&gt;지난 rc2 에서 머지하는 걸 빼먹은 네트워킹 쪽 풀리퀘스트를 이번에 머지했기
때문에 이번 rc3 는 조금 크다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc2</title>
      <link>/post/lkml_news_v5.0-rc2/</link>
      <pubDate>Tue, 15 Jan 2019 09:06:44 +0900</pubDate>
      <guid>/post/lkml_news_v5.0-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-v11-0026-speculative-page-faults&#34;&gt;[PATCH v11 00/26] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/8b0b2c05-89f8-8002-2dce-fa7004907e78@codeaurora.org&#34;&gt;https://lkml.kernel.org/r/8b0b2c05-89f8-8002-2dce-fa7004907e78@codeaurora.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SPF 패치에서 발견된 버그 레포트입니다.  ARM 위에서 데드락 문제가 발견되었군요.
버그 발견자가 패치도 같이 내놓았는데, 이에 대한 토론은 아직도 계속되고 있네요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v7-0016-add-support-for-exclusive-page-frame-ownership&#34;&gt;[RFC PATCH v7 00/16] Add support for eXclusive Page Frame Ownership&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/cover.1547153058.git.khalid.aziz@oracle.com&#34;&gt;https://lkml.kernel.org/r/cover.1547153058.git.khalid.aziz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lsquo;ret2dir&amp;rsquo; 보안 공격[1]에 대비하기 위한 패치입니다.  하지만 이로 인해 tlb 를 좀
많이 flush 해야 하는 문제가 있었고, 이 패치셋은 그에 대한 해결책도 의논하고
있습니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf&#34;&gt;http://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;patch-04-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;[PATCH 0/4] Allow persistent memory to be used like normal RAM&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190116181859.D1504459@viggo.jf.intel.com&#34;&gt;https://lkml.kernel.org/r/20190116181859.D1504459@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PMEM 을 사용하기 위해선 현재로썬 어플리케이션 코드를 수정해야 합니다.  그냥
평범한, 조금 느린 RAM 처럼 어플리케이션이 기존에 RAM 접근하듯 접근할 수 있게
하면 안될까요?  이 패치셋은 그런 경우를 위한 드라이버를 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-05-psi-pressure-stall-monitors-v2&#34;&gt;[PATCH v2 0/5] psi: pressure stall monitors v2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190110220718.261134-1-surenb@google.com&#34;&gt;https://lkml.kernel.org/r/20190110220718.261134-1-surenb@google.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LWN 에서도 소개된 pressure stall monitor 의 두번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-50rc2&#34;&gt;Linux 5.0-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wicCXd7nALwEz+022iNesJV3DUmejS+dzVRE0D3UGzs_g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wicCXd7nALwEz+022iNesJV3DUmejS+dzVRE0D3UGzs_g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.x 로 나아가는 두번째 릴리즈 후보가 나왔습니다.  이번 머지 윈도우가 휴일이
섞여 있었기 때문에 두번째 rc 를 위한 과정에 문제가 있지 않을까 싶었지만 별 문제
없었다는군요.  그리고 지금 토발즈는 여행중이라 현지시간으로는 항상 하는 일요일
릴리즈가 아니라 월요일 릴리즈라 합니다만, 뭐&amp;hellip; 큰 이슈는 아니죠 ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.0-rc1</title>
      <link>/post/lkml_news_v5.0-rc1/</link>
      <pubDate>Mon, 07 Jan 2019 11:18:50 +0900</pubDate>
      <guid>/post/lkml_news_v5.0-rc1/</guid>
      <description>&lt;h2 id=&#34;rfc-v3-03-test-driver-to-analyse-vmalloc-allocator&#34;&gt;[RFC v3 0/3] test driver to analyse vmalloc allocator&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190102085924.14145-1-urezki@gmail.com&#34;&gt;https://lkml.kernel.org/r/20190102085924.14145-1-urezki@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;vmalloc 의 성능과 스트레스 테스트를 위한 모듈을 구현한 패치입니다.  Selftests
에도 테스트 스크립트를 추가했군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-01-mm-add-a-warning-about-high-order-allocations&#34;&gt;[RFC PATCH 0/1] mm: add a warning about high order allocations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181225153927.2873-1-khorenko@virtuozzo.com&#34;&gt;https://lkml.kernel.org/r/20181225153927.2873-1-khorenko@virtuozzo.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;특정 노드의 메모리에 접근이 많이 되고 있는 상황에서 해당 메모리가 fragment 되어
있고 이 시점에서 high order allocation 이 요청되면 이걸 위해 compaction 등이
작동하니까 다른 태스크의 latency 가 떨어질 수 있습니다.  이런 상황을 모니터링
할 수 있게끔, 이 패치는 &lt;code&gt;vm.war_high_order&lt;/code&gt; 라는 값을 sysctl 통해 설정하면 이
값을 넘는 order 의 allocation 이 요청되었을 때 워닝을 뱉어 줍니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-introduce-pagesize&#34;&gt;[PATCH] mm: Introduce page_size()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181231134223.20765-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20181231134223.20765-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 의 존재로 인해 페이지의 실제 크기는 모두 똑같지가 않기 때문에 이를
판별할 방법이 필요하죠.  이 패치는 단순히 기존에 좀 복잡하게 직접 페이지 크기를
구하던 것을 별도의 wrapper function 으로 대체하기 위한 준비 작업입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-50rc1&#34;&gt;Linux 5.0-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wgKYnrL3LjhVkH2Fp+ecmWhLqezT9zmR6CzfcpwcJX0qA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/wgKYnrL3LjhVkH2Fp+ecmWhLqezT9zmR6CzfcpwcJX0qA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널 버전의 숫자가 큰 의미 없게 된지도 오래이긴 합니다만 그래도 메이저
버전 변경은 항상 뭔가 들뜨게 마련이죠.
드디어 5.x 커널의 시대가 시작되었습니다.&lt;/p&gt;
&lt;p&gt;연말/연처 휴일이 섞여 있는 덕에 꽤 오랫만의 릴리즈가 되었고, 그덕에 좀 늦게
풀리퀘스트가 온 것들도 있었지만 큰 문제는 없었다고 하네요.&lt;/p&gt;
&lt;p&gt;메이저 버전이 4.x 에서 5.x 로 바뀌긴 했지만 손가락 발가락 다 써도 4.21 의
버전은 셀수가 없기 때문에 5.x 로 바뀌었을 뿐 특별한 변경이나 새로운 기능은
없다는 점도 한번 더 공지합니다.
하지만 많은 기능들이 추가된 것도 사실이니 원하면 하나 꼽아들고 이거 때문에 5.x
로 업데이트 되었다고 생각해도 좋다고 하는군요.&lt;/p&gt;
&lt;p&gt;이번 릴리즈는 총 11000여개의 커밋을 받아들인 긴 머지 윈도우를 거쳤지만,
그렇다고 유별날 건 없다는군요.  절반 가량이 드라이버, 20%는 아키텍쳐, 10% 툴링,
나머진 여기저기.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perf symbol problem on Linux 4.19</title>
      <link>/post/perf_symbol_problem_4.19/</link>
      <pubDate>Fri, 21 Dec 2018 17:00:22 +0900</pubDate>
      <guid>/post/perf_symbol_problem_4.19/</guid>
      <description>&lt;p&gt;4.19 커널에서 오랫만에 perf 를 다시 빌드하고 써보려고 하니, &lt;code&gt;perf report&lt;/code&gt; 가
아래와 같이 제대로 된 symbol name 을 찾질 못합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo perf record -g ls
arch                     builtin-ftrace.c    builtin-report.c     Documentation       perf.data.old
bench                    builtin.h           builtin-sched.c      examples            perf.h
Build                    builtin-help.c      builtin-script.c     include             perf-read-vdso.c
builtin-annotate.c       builtin-inject.c    builtin-stat.c       jvmti               perf-sys.h
builtin-bench.c          builtin-kallsyms.c  builtin-timechart.c  Makefile            perf-with-kcore.sh
builtin-buildid-cache.c  builtin-kmem.c      builtin-top.c        Makefile.config     pmu-events
builtin-buildid-list.c   builtin-kvm.c       builtin-trace.c      Makefile.perf       python
builtin-c2c.c            builtin-list.c      builtin-version.c    MANIFEST            scripts
builtin-config.c         builtin-lock.c      check-headers.sh     perf-archive.sh     tests
builtin-data.c           builtin-mem.c       command-list.txt     perf.c              trace
builtin-diff.c           builtin-probe.c     CREDITS              perf-completion.sh  ui
builtin-evlist.c         builtin-record.c    design.txt           perf.data           util
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.025 MB perf.data (21 samples) ]
sjpark@hydra:~/linux/tools/perf$ sudo perf report --stdio
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 21  of event &#39;cycles:ppp&#39;
# Event count (approx.): 2712237
#
# Children      Self  Command  Shared Object      Symbol
# ........  ........  .......  .................  .................................
#
    59.39%     0.00%  ls       [unknown]          [k] 0xffffffffa8a00088
            |
            ---0xffffffffa8a00088
               |
               |--51.91%--0xffffffffa8004185
               |          |
               |          |--17.13%--0xffffffffa8212c8b
               |          |          0xffffffffa8212afe
               |          |          0xffffffffa821274a
               |          |          0xffffffffa81bb3c5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;왜이러지 하고 삽질하다가 알고보니 perf 쪽 최신 커밋인 edeb0c90df35 (&amp;ldquo;perf
tools: Stop fallbacking to kallsyms for vdso symbols lookup&amp;rdquo;) 이 만든 버그군요.
해당 커밋만 revert 하고 perf 를 다시 빌드하면 다시 잘 됩니다.&lt;/p&gt;
&lt;p&gt;저만 겪는 문제는 아닌지 버그질라에도 이에 대한 이슈가 올라와 있네요:
&lt;a href=&#34;https://bugzilla.kernel.org/show_bug.cgi?id=201551&#34;&gt;https://bugzilla.kernel.org/show_bug.cgi?id=201551&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News for v4.20</title>
      <link>/post/lkml_news_v4.20/</link>
      <pubDate>Fri, 21 Dec 2018 08:35:03 +0900</pubDate>
      <guid>/post/lkml_news_v4.20/</guid>
      <description>&lt;h2 id=&#34;patch-v5-03-mmkvmvfioppc64-migrate-compound-pages-out-of-cma&#34;&gt;[PATCH V5 0/3] mm/kvm/vfio/ppc64: Migrate compound pages out of CMA&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181219034047.16305-1-aneesh.kumar@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20181219034047.16305-1-aneesh.kumar@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ppc64 에서는 guest os page table 을 CMA area 내에 할당하는데, VFIO 를 쓰는 경우
이게 pinning 되어 있다 보니 CMA area 밖으로 migrate 하는데 실패해, guest os
page table 할당에 실패하고, 이로 인해 guest 시작조차 불가능하게 되는 문제가
있었습니다.&lt;/p&gt;
&lt;p&gt;이 패치는 compound page 에 대해서도 CMA area 밖으로의 migration 이 가능하게
합니다.&lt;/p&gt;
&lt;h2 id=&#34;resend-patch-v3-05-arm64mm-enable-hugetlb-migration&#34;&gt;[RESEND PATCH V3 0/5] arm64/mm: Enable HugeTLB migration&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1545121450-1663-1-git-send-email-anshuman.khandual@arm.com&#34;&gt;https://lkml.kernel.org/r/1545121450-1663-1-git-send-email-anshuman.khandual@arm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HugeTLB 를 통째로 migrate 할 수 있게 하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-02-hugetlbfs-use-immaprwsem-for-better-synchronization&#34;&gt;[PATCH v2 0/2] hugetlbfs: use i_mmap_rwsem for better synchronization&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181218223557.5202-1-mike.kravetz@oracle.com&#34;&gt;https://lkml.kernel.org/r/20181218223557.5202-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hugetlbfs 와 truncation 사이에 race conditional bug 가 존재해 왔는데, 이 패치는
&lt;code&gt;i_mmap_rwsem&lt;/code&gt; 을 사용해 동기화를 적용함으로써 이 race bug 를 제거합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-12-mm-swap-check-if-swap-backing-device-is-congested&#34;&gt;[RFC PATCH 1/2] mm: swap: check if swap backing device is congested&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1545115948-25467-1-git-send-email-yang.shi@linux.alibaba.com&#34;&gt;https://lkml.kernel.org/r/1545115948-25467-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Swap readahead 기능이 이미 다른 요청으로 바쁜 storage device 에 행해진다면 swap
자체 성능도 떨어지고 storage 를 더욱 바빠지게 해서 남들에게도 민폐가 됩니다.
&lt;code&gt;vma_cluster_radahead()&lt;/code&gt; 에서 먼저 storage 의 congestion 을 체크해 보게 하는
패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420-released&#34;&gt;Linux 4.20 released..&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wg0zF4wa87Q5rAhFe2es0t0eExX2UjvKD7-Pghvcbt5Vw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wg0zF4wa87Q5rAhFe2es0t0eExX2UjvKD7-Pghvcbt5Vw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;예정대로 4.20 이 정식 릴리즈 되었습니다.  원했던 것보단 조금 시끄러운
주간이었지만 어쨌건 연말 휴일을 방해하고 싶진 않고 정말 큰 문제가 있는 것 같아
보이진 않기에 릴리즈 했다고 합니다.&lt;/p&gt;
&lt;p&gt;이번 정식 릴리즈에서 개인적으로 눈길 가는건 XArray 입니다.  앞으로도 많은
영역에 쓰이고자 하는 것 같던데, 향후 행보도 궁금합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc7</title>
      <link>/post/lkml_news_v4.20-rc7/</link>
      <pubDate>Mon, 17 Dec 2018 09:16:11 +0900</pubDate>
      <guid>/post/lkml_news_v4.20-rc7/</guid>
      <description>&lt;h2 id=&#34;patch-v9-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V9 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181214062754.13723-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20181214062754.13723-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아직 머지되지 못한 THP swap in 패치셋의 아홉번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-03-reduce-thp-fault-thrashing&#34;&gt;[RFC 0/3] reduce THP fault thrashing&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181211142941.20500-1-vbabka@suse.cz&#34;&gt;https://lkml.kernel.org/r/20181211142941.20500-1-vbabka@suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP fault 로 인한 로컬 노드 thrashing 을 해결하기 위한 패치의 RFC 입니다.  THP
fault 성공률을 낮추는 부작용도 있긴 하군요.  아직 테스트도 안된 첫번째 RFC
이니, 이대로 머지되진 않겠지 싶긴 합니다만 재밌네요.&lt;/p&gt;
&lt;h2 id=&#34;linux-420rc76&#34;&gt;Linux 4.20-rc76&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whv9u9aTEPoCz8h83JJbVK4fmHELJF=GG01ht9=1_MaCQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=whv9u9aTEPoCz8h83JJbVK4fmHELJF=GG01ht9=1_MaCQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 버전의 릴리즈입니다&amp;hellip; 만, 이번엔 릴리즈 메일 제목에 오타가
있었군요.  전체적으로 일곱번째인만큼 변경사항이 적습니다.  릴리즈 하는 토발즈
입장에선 반가운 일이군요.  특히나 연휴가 다가오니까요.&lt;/p&gt;
&lt;p&gt;릴리즈 계획은 기존과 같이, 크리스마스 전에 4.20 버전을 릴리즈하고, 이후에 머지
윈도우를 가질텐데, 가급적이면 연휴 전에 미리미리 풀리퀘스트를 보내달라고
하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc6</title>
      <link>/post/lkml_news_v4.20-rc6/</link>
      <pubDate>Wed, 05 Dec 2018 08:20:36 +0900</pubDate>
      <guid>/post/lkml_news_v4.20-rc6/</guid>
      <description>&lt;h2 id=&#34;patch-memorymodel-03-updates-to-the-formal-memory-model&#34;&gt;[PATCH memory-model 0/3] Updates to the formal memory model&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181203230411.GA27476@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20181203230411.GA27476@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널 메모리 모델의 업데이트 입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;smp_mb__after_unlock_lock()&lt;/code&gt; 을 추가로 모델링했고, github 리트머스 테스트를
체크하기 위한 스크립트가 추가되었으며, &lt;code&gt;-j&lt;/code&gt; 옵션을 서포트 하게 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;tipcorercu-tracing-replace-synchronizesched-and-callrcusched&#34;&gt;[tip:core/rcu] tracing: Replace synchronize_sched() and call_rcu_sched()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/tip-7440172974e85b1828bdd84ac6b23b5bcad9c5eb@git.kernel.org&#34;&gt;https://lkml.kernel.org/r/tip-7440172974e85b1828bdd84ac6b23b5bcad9c5eb@git.kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronize_rcu()&lt;/code&gt; 가 이제는 RCU read-side 크리티컬 섹션 만이 아니라
preempt-disable 코드 영역도 기다리므로, &lt;code&gt;synchronize_sched()&lt;/code&gt; 를 대체할 수
있고, &lt;code&gt;call_rcu_sched()&lt;/code&gt; 도 &lt;code&gt;call_rcu()&lt;/code&gt; 로 대체될 수 있습니다.  이 패치는 이
대체를 진행하고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v8-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V8 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181207054122.27822-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20181207054122.27822-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그를 통해 여러번 공유한 THP 를 통째로 스왑아웃 / 스왑인 하는 패치입니다.
Daniel 에 의해 레포트된 버그 하나를 고쳐서 여덟번째 버전이 올라왔습니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420rc6&#34;&gt;Linux 4.20-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/wgHSX8x6mOB0xZibbg-xc3veqsQEnHZ1+3H2DbO5MU5Rw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/wgHSX8x6mOB0xZibbg-xc3veqsQEnHZ1+3H2DbO5MU5Rw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난 rc5 릴리즈는 평소와 달리 굉장히 규모가 컸기에 걱정이 있었죠.  이번
릴리즈에는 확연히 변경의 양이 줄어들었다고 합니다.  뭔가 다시 정상적으로 간다는
거죠.  토발즈는 어쨌건 4.20 릴리즈 전에 최소한 하나의 rc 릴리즈는 더 있을
거라고 하는군요.  하지만 여전히 크리스마스 휴일 시즌을 위해 크리스마스 전에
릴리즈를 마치고, 이후 일주일은 푹 쉴테니 그전에 풀리퀘스트도 준비해 두라고
하네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by 4.20-rc5</title>
      <link>/post/lkml_news_v4.20-rc5/</link>
      <pubDate>Thu, 29 Nov 2018 08:14:01 +0900</pubDate>
      <guid>/post/lkml_news_v4.20-rc5/</guid>
      <description>&lt;h2 id=&#34;patch-v12-0020-block-support-multipage-bvec&#34;&gt;[PATCH V12 00/20] block: support multi-page bvec&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181126021720.19471-1-ming.lei@redhat.com&#34;&gt;https://lkml.kernel.org/r/20181126021720.19471-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct bio_bvec&lt;/code&gt; 하나가 물리적으로 연속적인 여러개의 페이지를 담을 수 있게
해서 block layer 의 효율성을 높이기 위한 시도입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-aio-convert-ioctxtable-to-xarray&#34;&gt;[PATCH] aio: Convert ioctx_table to XArray&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181128183531.5139-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20181128183531.5139-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;aio 쪽의 &lt;code&gt;ioctx_table&lt;/code&gt; 이라는 자료구조가 스펙터에 취약한 자료구조인데, 인덱스
오버플로 문제가 없는 XArray 로 교체하는 패치입니다.  정말 코드가
깔끔해지는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-04v4-drop-the-mmapsem-when-doing-io-in-the-fault-path&#34;&gt;&lt;code&gt;[PATCH 0/4][V4] drop the mmap_sem when doing IO in the fault path&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181130195812.19536-1-josef@toxicpanda.com&#34;&gt;https://lkml.kernel.org/r/20181130195812.19536-1-josef@toxicpanda.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ps&lt;/code&gt; 등의 도구를 사용해 시스템 상황을 모니터링하는 커다란 어플리케이션을 사용
중인데, 이 과정에서 다른 &lt;code&gt;task&lt;/code&gt; 의 &lt;code&gt;mmap_sem&lt;/code&gt; 을 &lt;code&gt;down_read()&lt;/code&gt; 해야 하는 경우가
종종 생긴다는군요.  문제는 이 &lt;code&gt;mmap_sem&lt;/code&gt; 의 쓰기 권한을 얻어오는 과정이 사실상
mutex 와 동일하니 레이턴시가 크게 늘어날 때가 종종 생긴다고 합니다.  이 문제를
해결하기 위해 &lt;code&gt;retry&lt;/code&gt; 메커니즘을 적용하는 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-09-use-vminsertrange&#34;&gt;[PATCH v2 0/9] Use vm_insert_range&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181202061707.GA3070@jordon-HP-15-Notebook-PC&#34;&gt;https://lkml.kernel.org/r/20181202061707.GA3070@jordon-HP-15-Notebook-PC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;드라이버가 자신의 커널 메모리를 사용자 vma 로 매핑하는 방법은
&lt;code&gt;vm_insert_page()&lt;/code&gt; 를 사용하는 방식이었고, 여러 페이지를 매핑하려면 이 함수를
루프를 돌면서 수행해야 했는데요, 이게 좀 귀찮으므로 아예 &lt;code&gt;vm_insert_range()&lt;/code&gt;
라는 함수를 추가한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420rc5&#34;&gt;Linux 4.20-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wizcNrsoyCM1EXQqoswMCYsJaby2iAkZb9wBAzDEhvxNg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wizcNrsoyCM1EXQqoswMCYsJaby2iAkZb9wBAzDEhvxNg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;벌써 다섯번째 rc 릴리즈이므로 변경내용이 줄어들어야 할 타이밍이지만, 이상하게도
이번 릴리즈는 -rc1 을 제외하고는 가장 변경이 큰 릴리즈라는군요.  게다가 arch 쪽
변경사항이 꽤 많은데, 아마도 STIPB 쪽 성능 리그레션 때문인 것으로 보인다고
합니다.  아무튼 일반적인 모습은 아니다보니 릴리즈 일정이 변경될 가능성이
생겼는데요, 너무 미루면 연말연초 휴일에 머지 윈도우가 겹치게 되는데 토발즈는
휴일 동안 머지 윈도우 관리하기 싫고, 그렇다고 더 미루면 토발즈도 1월 후반에
여행 갈거고, 남들도 휴일에 머지 윈도우를 준비하기가 싫을 거라 고민이라
하는군요.&lt;/p&gt;
&lt;p&gt;결국 일단은 크리스마스 직전 쯤 4.20 을 릴리즈 하고, 남들도 머지 윈도우 준비를
그 전까지 마치는 걸 제안하고 있습니다.  물론, rc6 에서도 변경사항이 충분히
줄어들지 않는다면 릴리즈 일정은 더 늦춰질 수 있겠죠.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc4</title>
      <link>/post/lkml_news_v4.20-rc4/</link>
      <pubDate>Mon, 26 Nov 2018 08:06:40 +0900</pubDate>
      <guid>/post/lkml_news_v4.20-rc4/</guid>
      <description>&lt;h2 id=&#34;patch-v7-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V7 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181120085449.5542-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20181120085449.5542-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Transparent Huge Page 를 쪼개지 않고 swap out / swap in 함으로써 스왑 성능을
최적화 하는 패치의 일곱번째 버전입니다.  이 블로그에서도 소개한 바 있죠.  크게
바뀐 부분은 없지만 최신 버전에 맞춰 리베이스 되었고, Daniel 에 의해 발견된 주소
정렬 관련 문제를 해결했군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-05-fragmentation-avoidance-improvements-v5&#34;&gt;[PATCH 0/5] Fragmentation avoidance improvements v5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181123114528.28802-1-mgorman@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20181123114528.28802-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시스템이 충분히 오래 운영되거나 특정한 패턴의 워크로드가 동작하게 되면 시스템의
메모리는 fragment 되게 마련이어서, 장기적으로 물리적 연속 페이지 할당이
실패하게 됩니다.  이 패치셋은 메모리 분절화를 야기하는 워크로드 (이벤트)를
정의하고 그런 이벤트의 발생을 줄이는 내용을 담고 있습니다.&lt;/p&gt;
&lt;p&gt;최적화 방법은 다음과 같습니다.  먼저, lower id free list 가 사용 가능하면 high
order free list 를 쪼개기보다 그걸 먼저 사용합니다.  메모리 분절화 이벤트가
발생하면 임시적으로 워터마크를 높입니다.  kswapd 가 일어나서 적은양의 오래된
메모리를 리클레임하고, 이어서 kcompactd 가 일어나서 시스템 메모리 연속성을
복구시킵니다.  물론 이는 오버헤드를 추가합니다.  마지막으로, kswapd 가 진전을
일으킬 수 있도록 일부 movable 페이지 할당을 기다리게 합니다.  이 기다리는 시간
역시 오버헤드와 연관되므로 적절히 맞춰질 필요가 있겠죠.&lt;/p&gt;
&lt;p&gt;이 패치셋을 적용한 결과 94% 이상 메모리 분절화를 줄일 수 있었다고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;git-pull-xarray-updates&#34;&gt;[GIT PULL] XArray updates&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181124173209.GZ3065@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20181124173209.GZ3065@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XArray 는 작년 OSSummit 에서 처음 발표를 들은 후 주의 깊게 보고 있었는데 이번에
머지되었고 커널 서밋에서도 발표를 들었는데 매우 인상적이었습니다.  DAX 가
XArray 를 사용하도록 수정한 후 DAX 의 버그가 발견되었고, 그에 대한 수정을
포함한 수정사항들을 담은 풀 리퀘스트입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420rc4&#34;&gt;Linux 4.20-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgdsXyCaLsFEpyUpAeRqVS69u=xo4rzEN+cS=xwz2gajg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgdsXyCaLsFEpyUpAeRqVS69u=xo4rzEN+cS=xwz2gajg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.x 의 마지막이 될 예정인 4.20을 향한 네번째 rc 버전 릴리즈입니다.  변경의 60
퍼센트가 드라이버고, 나머진 네트워킹, 파일시스템쪽 수정과 arch, 문서화
업데이트고 xarray 쪽 수정도 있었군요.  평소와 다를바 없어서 평이한 릴리즈라 할
수 있지만, STIBP 수정이라던지 mm 쪽 수정에 대한 논의가 안끝났다던지 하는 부분은
남아있다는군요.&lt;/p&gt;
&lt;p&gt;한가지 지난 릴리즈 때 이야기 할 것을 빼먹은 것도 이야기 하는데, 풀 리퀘스트에
대한 응답 메일을 Konstantin 이 자동화 했기 때문에 더이상 토발즈 자신이 하나하나
답장을 보내지 않는다는 겁니다.  그리고 이 자동화의 구성상 LKML 의 &lt;code&gt;linux-*&lt;/code&gt;
그룹을 cc 하지 않으면 ack 을 주지 않는데, 그걸로 인해 혼동이 있을 수 있었겠다고
하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc3</title>
      <link>/post/lkml_news_v4.20-rc3/</link>
      <pubDate>Mon, 19 Nov 2018 16:53:04 +0900</pubDate>
      <guid>/post/lkml_news_v4.20-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-420rc3&#34;&gt;Linux 4.20-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiZmPvR64hDy-pcVJqcxoAwMRd4GrRhRjK04Mhng4nL4g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiZmPvR64hDy-pcVJqcxoAwMRd4GrRhRjK04Mhng4nL4g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리누스 토발즈의 개인적 여행이 있었다는 점을 제외하고는 이상할 것 없는
한주였습니다만, 이번 릴리즈의 변경 사항은 rc3 치고는 상당히 적었다고 하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc2</title>
      <link>/post/lkml_news_v4.20-rc2/</link>
      <pubDate>Mon, 12 Nov 2018 08:30:21 +0900</pubDate>
      <guid>/post/lkml_news_v4.20-rc2/</guid>
      <description>&lt;h2 id=&#34;patch-05-fragmentation-avoidance-improvements-v2&#34;&gt;[PATCH 0/5] Fragmentation avoidance improvements v2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181107183822.15567-1-mgorman@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20181107183822.15567-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;장시간 운영되는 시스템은 결국 메모리가 단편화 (fragmentation) 되게 되어
있습니다.  페이징을 사용하면 단일 페이지 단위 할당은 문제가 없지만, 물리적으로
연속적인 페이지를 할당받기가 어려워지죠.  Mel Gorman 의 이 패치는 이런 메모리
분절화를 좀 더 잘 막을 수 있는 방법을 포함하고 있습니다.&lt;/p&gt;
&lt;p&gt;첫번째 패치는 단일 페이지 또는 적은 물리적 연속 페이지들의 할당 시에 불필요하게
higher order free page zone 을 사용하지 않게 하고, 두번째와 세번째 패치는
kswapd 와 kcompactd 를 사용한 defragmentation 을 좀 더 적극적으로 하게 합니다.
네번째 패치는 movable allocation request 시에 kswapd 를 또 깨우고, kswapd 가
일을 마칠 때까지 멈춰서 기다려 줍니다.
마지막으로 다섯번째 패치는 분절화가 발생해야만 하는 경우, kcompactd 가 처리할
블록들로 해당 분절된 영역을 마크해 둡니다.&lt;/p&gt;
&lt;p&gt;물론 분절화를 막는 대신 오버헤드를 가져올 수 있겠고, Mel 은 이 기능들을 tuning
하거나 꺼버릴 수 있게 했군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-04-fragmentation-avoidance-improvements-v3&#34;&gt;[PATCH 0/4] Fragmentation avoidance improvements v3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181108091218.32715-1-mgorman@techsingularity.net&#34;&gt;https://lkml.kernel.org/r/20181108091218.32715-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mel 의 분절화 방지 패치셋은 오버헤드를 가질 수밖에 없었죠.  결국 얼마 되지 않아
세번째 버전의 패치셋[1]을 내놓았는데, 여기선 다섯번째 패치를 걍 없애버렸고,
네번째 패치도 그 오버헤드가 덜하게끔 만들었습니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-mm-thp-implement-thp-reservations-for-anonymous-memory&#34;&gt;[RFC PATCH] mm: thp: implement THP reservations for anonymous memory&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1541746138-6706-1-git-send-email-anthony.yznaga@oracle.com&#34;&gt;https://lkml.kernel.org/r/1541746138-6706-1-git-send-email-anthony.yznaga@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Transparent huge page (THP) 가 켜져 있는 경우, promotion 이 꽤나 급하게
이루어지기 때문에 huge page 를 할당받고는 정작 그 영역을 모두 접근하지 않는
경우엔 메모리 소모가 큽니다.  기존에 이 문제를 해결하기 위한 패치가 있었는데,
그에 대해 Mel Gorman 의 피드백이 있었고, 이 패치는 그 피드백을 받아들여 새로
작성된 패치셋입니다.&lt;/p&gt;
&lt;p&gt;Page fault 가 날 경우 huge page 를 할당할 수 있는 양의 페이지를 할당받되 페이지
한개만 map 해두고 나머지는 reserve 를 해두고, 이후 주변 영역에 fault 가 날
때마다 나머지 페이지들을 계속 map 해주다가 충분히 많은 영역이 fault 났을 경우에
huge page 로 promote 를 해주고, 그 전에 memory pressure 가 발생하면 reserve
해둔 페이지들을 reclaim 하는 형태입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-020-documentation-updates-for-v421v50&#34;&gt;[PATCH tip/core/rcu 0/20] Documentation updates for v4.21/v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181111195619.GA6958@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20181111195619.GA6958@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 문서 업데이트 패치셋입니다.  생각해 보면 리눅스 커널만큼 문서화 잘 된
프로젝트도 드물죠.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-08-automate-initrd-generation-for-v421v50&#34;&gt;[PATCH tip/core/rcu 0/8] Automate initrd generation for v4.21/v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181111200127.GA9511@linux.ibm.com&#34;&gt;https://lkml.kernel.org/r/20181111200127.GA9511@linux.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 테스트 프레임웍인 rcutorture 는 가상머신 환경을 사용하는데, 이를 위한
initrd 생성을 자동화 하는 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-v420rc2&#34;&gt;Linux v4.20-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/R7SW0SuwOMMMyRgTFGA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/R7SW0SuwOMMMyRgTFGA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;토발즈가 여행 중이란 걸 제외하고는 별 특이사항 없는 두번째 rc 버전
릴리즈입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the kernel summit</title>
      <link>/post/ksummit2018_talk/</link>
      <pubDate>Thu, 08 Nov 2018 06:11:48 +0900</pubDate>
      <guid>/post/ksummit2018_talk/</guid>
      <description>&lt;p&gt;지난 토요일, Theodore Ts&#39;o 로부터 올해 Linux Plumbers Conference 의 한 트랙으로
열리는 커널 서밋에서 GCMA 발표를 해줄 수 있겠냐는 제의를 받았고 물론
그러겠노라고 했습니다.  발표 일정의 [첫번째 드래프트][1]가 올라왔군요.  화요일
아침에 발표하게 됐습니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2018-November/006238.html&#34;&gt;https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2018-November/006238.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKMM Setup and Usage</title>
      <link>/post/lkmm-install/</link>
      <pubDate>Thu, 08 Nov 2018 04:30:42 +0900</pubDate>
      <guid>/post/lkmm-install/</guid>
      <description>&lt;p&gt;리눅스 커널은 Formalised and executable memory consistent model 을 제공합니다.
줄여서 linux kernel memory model (LKMM) 이라고 하죠.  이 글은 4.19 버전을
기준으로 LKMM 을 실제로 수행해 보기 위한 환경 셋업 과정과 간단한 실행 방법을
정리해 봅니다.  글 작성을 위한 테스트는 Ubuntu 16.04 서버가 설치된 가상머신에서
진행되었습니다.&lt;/p&gt;
&lt;h1 id=&#34;herd7-install&#34;&gt;herd7 install&lt;/h1&gt;
&lt;p&gt;LKMM 은 버전 7.49 의 &amp;ldquo;herd7&amp;rdquo; 과 &amp;ldquo;klitmus7&amp;rdquo; 을 필요로 합니다.  하지만 herd7 은
또 Ocaml 을 위한 패키지 매니저인 OPAM 을 설치할 것을 필요로 하죠.  우분투에선
패키지 시스템이 OPAM 을 지원하므로 아래와 같이 쉽게 설치할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt install opam
$ opam init
$ sudo opam update
$ sudo opam upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;두번째 커맨드 수행 중 다음과 같은 질문이 나오는데, 디폴트 선택을 주기 위해 그냥
엔터를 칩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Do you want OPAM to modify ~/.profile and ~/.ocamlinit?
(default is &#39;no&#39;, use &#39;f&#39; to name a file other than ~/.profile)
    [N/y/f]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;또한 &lt;code&gt;update&lt;/code&gt; 와 &lt;code&gt;upgrade&lt;/code&gt; 명령 시에 root 권한으로 이 커맨드를 수행하는 걸
권장하지 않는다고 하지만 정작 &lt;code&gt;sudo&lt;/code&gt; 없이 하면 권한 없어서 실패합니다.&lt;/p&gt;
&lt;p&gt;이제 다음 명령을 통해 herdtools 의 빌드와 설치를 진행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/herd/herdtools7 &amp;amp;&amp;amp; cd herdtools7
$ git checkout 7.49
$ make all
$ make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;빌드에 약 3분 10여초가 소요됐습니다.  설치가 잘 되었는지 아래와 같이 확인해
봅니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ herd7 -version
7.49, Rev: 93dcbdd89086d5f3e981b280d437309fdeb8b427
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;lkmm-download&#34;&gt;LKMM Download&lt;/h1&gt;
&lt;p&gt;LKMM 은 리눅스 소스 트리의 &lt;code&gt;tools/memory-model/&lt;/code&gt; 디렉토리에 있습니다.
&lt;code&gt;https://kernel.org&lt;/code&gt; 에서 다운받거나 해서 사용하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls ~/linux/tools/memory-model/
Documentation      linux-kernel.cat  linux-kernel.def  lock.cat  scripts
linux-kernel.bell  linux-kernel.cfg  litmus-tests      README
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;herd7-based-litmus-tests-execution&#34;&gt;Herd7 Based Litmus Tests Execution&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ herd7 -conf linux-kernel.cfg litmus-tests/SB+fencembonceonces.litmus
Test SB+fencembonceonces Allowed
States 3
0:r0=0; 1:r0=1;
0:r0=1; 1:r0=0;
0:r0=1; 1:r0=1;
No
Witnesses
Positive: 0 Negative: 3
Condition exists (0:r0=0 /\ 1:r0=0)
Observation SB+fencembonceonces Never 0 3
Time SB+fencembonceonces 0.01
Hash=d66d99523e2cac6b06e66f4c995ebb48
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;klistmus7-based-litmus-tests-execution&#34;&gt;Klistmus7 Based Litmus Tests Execution&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir klitmus_test
$ klitmus7 -o klitmus_test/ litmus-tests/SB+fencembonceonces.litmus
$ cd klitmus_test/
$ ls
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;$ make
$ sudo sh run.sh
$ sudo sh ./run.sh
[sudo] password for sjpark:
Thu Nov  8 04:55:44 KST 2018
Compilation command: klitmus7 -o klitmus_test/ litmus-tests/SB+fencembonceonces.litmus
OPT=
uname -r=4.19.0

Test SB+fencembonceonces Allowed
Histogram (3 states)
16580117:&amp;gt;0:r0=1; 1:r0=0;
16402936:&amp;gt;0:r0=0; 1:r0=1;
3016947 :&amp;gt;0:r0=1; 1:r0=1;
No

Witnesses
Positive: 0, Negative: 36000000
Condition exists (0:r0=0 /\ 1:r0=0) is NOT validated
Hash=d66d99523e2cac6b06e66f4c995ebb48
Observation SB+fencembonceonces Never 0 36000000
Time SB+fencembonceonces 1.40

Thu Nov  8 04:55:45 KST 2018
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc1</title>
      <link>/post/lkml_news_v4.20-rc1/</link>
      <pubDate>Wed, 07 Nov 2018 14:43:56 +0900</pubDate>
      <guid>/post/lkml_news_v4.20-rc1/</guid>
      <description>&lt;p&gt;리눅스 4.19 버전 릴리즈 후부터 4.20-rc1 버전의 릴리즈까지 LKML 에 오간 메일 중
흥미로운 메일들을 소개합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v4-0013-ktask-multithread-cpuintensive-kernel-work&#34;&gt;[RFC PATCH v4 00/13] ktask: multithread CPU-intensive kernel work&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181105165558.11698-1-daniel.m.jordan@oracle.com&#34;&gt;https://lkml.kernel.org/r/20181105165558.11698-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CPU intensive 한 커널의 일을 여러 work queue 를 이용해 병렬화 시키기 위한
새로운 프레임웍, ktask 구현 및 적용 패치입니다.  이 프레임웍을 이용해 병렬화
시킬 일은 여러가지가 있을텐데, 이 패치는 ktask 프레임웍의 구현과 함께 VFIO
페이지 pinning, 부팅 시점에서의 &lt;code&gt;struct page&lt;/code&gt; 초기화, &lt;code&gt;gigantic page&lt;/code&gt; 의
초기화, 그리고 &lt;code&gt;HugeTLB&lt;/code&gt; 페이지의 할당에 ktask 를 적용하고 있습니다.&lt;/p&gt;
&lt;p&gt;예전에도 올라온 패치인데 이번에 Linux Plumbers Conference 에서 발표할
예정이기에 기존 피드백을 반영한 버전을 올렸군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-09-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;[PATCH 0/9] Allow persistent memory to be used like normal RAM&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181022201317.8558C1D8@viggo.jf.intel.com&#34;&gt;https://lkml.kernel.org/r/20181022201317.8558C1D8@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;기존의 메인 메모리로 쓰이는 DRAM 과 달리 파워가 꺼져도 내용이 날아가지 않는
메모리를 Non-volatile memory 또는 persistent memory 라 하죠.  최근 들어서는
정말 상용으로도 나오고 있는데, 현재로썬 이 pmem 을 쓰려면 어플리케이션을 고쳐야
합니다.&lt;/p&gt;
&lt;p&gt;이 패치는 그러지 않고도 일반 RAM 처럼 pmem 을 사용할 수 있도록 하는 pmem 용
드라이버를 구현했습니다.&lt;/p&gt;
&lt;h2 id=&#34;git-pull-xarray-for-420&#34;&gt;[GIT PULL] XArray for 4.20&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181023200825.GA25444@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20181023200825.GA25444@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 여러번 소개한, XArray 의 4.20 버전을 향한 pull request 입니다.
4.19 때도 시도했지만 들어가지 못했죠.&lt;/p&gt;
&lt;p&gt;이번엔 일단 토발즈에 의해 pull 되었습니다.  그리고 토발즈도 XArray 의
인터페이스 덕에 코드가 한결 간결하고 깔끔해졌음을 이야기 하네요.  특히, dax 쪽
수정사항과 conflict 이 있었는데 이는 dax 쪽의 버그 수정에 의한 것으로, XArray
인터페이스를 쓰면 애초에 그 버그가 발생도 안한다고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;linux-420rc1&#34;&gt;Linux 4.20-rc1&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CAHk-=whDiwASMgw8Q7TNA2MJhf3s=ouK4+_3ioqmobs-yagnkQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;오랫만에 토발즈가 하는 릴리즈입니다.  3.19 다음 4.0 버전이 릴리즈 되었으니 이번
버전은 5.0 이 될 것인지, 4.20 이 될 것인지 흥미진진한 릴리즈였는데요.
결론적으로 4.20 이 되었습니다.  이제 버전을 셀 손가락도 발가락도 남지
않았으므로 다음 버전은 5.0 이 될 거라고 하는군요.&lt;/p&gt;
&lt;p&gt;꽤 많은 변경 사항이 있던 머지 윈도우였지만 그렇다고 기록적인 수준은 아닙니다.&lt;/p&gt;
&lt;p&gt;한편 2주일로 예정되는 머지 윈도우에서 첫번째 주에는 일반적인 풀리퀘스트를 받고,
좀 시간을 두고 들여다봐야 하겠다 싶은 패치들은 두번째 주까지 미뤄뒀다 천천히
보면서 머지하는게 토발즈의 작업 습관이고 다른 메인테이너들도 이 습관을 알고
암묵적으로 지켜왔던 모양인데, 이번엔 두번째 주 수요일에 새로운 풀 리퀘스트가
들어와 토발즈가 조금 불편했던 모양입니다.&lt;/p&gt;
&lt;p&gt;이걸 명시적인 규칙으로 만들어야 할지도 모르겠다 싶기 시작했는데, 빈번하게 있는
일도 아니므로 아직은 그래야 할 필요성이 있을지도 모르겠다 하는 수준의
이야기군요.&lt;/p&gt;
&lt;p&gt;그리고 이번 머지 윈도우에서는 Greg 이 그랬던 것처럼 토발즈도 풀리퀘스트에 ack
메일을 보냈었죠.  이런 작업 방식에 대해서 고민을 하는 이야기도 있었구요.
하지만 아무래도 몇개는 빼먹은 것 같다고 하는군요.  이런 경우 결론은 자동화.
다음 머지 윈도우까지는 이 ack 메일을 자동화 되길 바란다고 하네요.  물론,
토발즈의 바람대로 자동화가 잘 마무리 되지 않으면 운좋게도 토발즈로부터의 ack
메일을 받을 수 있겠습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19</title>
      <link>/post/lkml_news_v4.19/</link>
      <pubDate>Mon, 22 Oct 2018 17:45:08 +0900</pubDate>
      <guid>/post/lkml_news_v4.19/</guid>
      <description>&lt;h2 id=&#34;linux-419&#34;&gt;Linux 4.19&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181022073224.GA5658@kroah.com&#34;&gt;https://lkml.kernel.org/r/20181022073224.GA5658@kroah.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;드디어 9 주간의 안정화를 거쳐 4.19 버전이 릴리즈 되었습니다.  역시 토발즈가
쉬고 있는 관계로 Greg KroahHartman 이 릴리즈 했습니다.  지난 네번의 릴리즈
가운데 가장 큰 릴리즈군요.  그리고 이 버전은 &amp;ldquo;Long Tern&amp;rdquo; 커널 중 하나가 될
예정입니다.&lt;/p&gt;
&lt;p&gt;이번 릴리즈 메일은 토발즈가 잠시 쉬겠다고 했던 메일을 연상케 할정도로 내용이
긴데요, 꽤 많은 부분은 이번 버전 개발 과정에서 이야기 되었던, 새로운 커뮤니티
참여자들과의 관계와 태도에 대한 내용입니다.  Greg 이 매년 발표하고 있는 커널
커뮤니티의 작업 방식 이야기를 예로 들며 설명하네요.  관련해서는 다음주 영국에서
열리는 Maintainers Summit 에서도 좀 더 이야기 할 생각인가 봅니다.&lt;/p&gt;
&lt;p&gt;그리고, 릴리즈 메일의 말미에서 이렇게 이야기 하며 릴리즈 메일을 끝맺는군요:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;And with that, Linus, I&#39;m handing the kernel tree back to you.  You can
have the joy of dealing with the merge window :)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;토발즈가 돌아오려나요?  아니면 새로운 대리인이?&lt;/p&gt;
&lt;h2 id=&#34;git-pull-ack-emails&#34;&gt;Git pull ack emails..&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjS6cjjP+fkZWzzrdZ_fZ1F=PrAGcBc57vKCpNyoD73Vw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjS6cjjP+fkZWzzrdZ_fZ1F=PrAGcBc57vKCpNyoD73Vw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;앞서 4.19 릴리즈와 함께 Greg 이 토발즈의 대리인을 그만두기로 했다고 했지만,
그에 대한 토발즈의 공식적 답변은 없었습니다.  때문에 토발즈가 돌아오는건지,
또는 Greg 이 아닌 또다른 사람이 릴리즈 관리를 할지 애매했는데, 토발즈가
돌아왔습니다.&lt;/p&gt;
&lt;p&gt;이 메일을 이렇게 시작하는군요:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So I&#39;ve obviously started pulling stuff for the merge window,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;마침 Maintainers Summit 이 있었으니, 거의 Summit 직후 돌아왔다고 볼 수 있을 것
같네요.&lt;/p&gt;
&lt;p&gt;이 메일에선 이와 함께 Greg 이 pull request 마다 꼬박꼬박 응답을 보내줬던 걸
지속할지 말지에 대한 이야기를 하고 있습니다.  토발즈는 풀 리퀘스트를 받으면
일단 빌드 테스트를 진행하고, 그동안 다른 풀 리퀘스트를 보고 그 빌드 테스트도
병렬로 진행하는 파이프라인 형태의 작업 형태를 가지고 있는데, Greg 처럼 하나하나
순차적으로 응답하려면 좀 애매하기 때문입니다.  일단은 응답 보내보고, 그게 정말
중요한지 판단해 보겠다는군요.&lt;/p&gt;
&lt;p&gt;아무튼, 잘 돌아왔어요, 리누스!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc8</title>
      <link>/post/lkml_news_v4.19-rc8/</link>
      <pubDate>Mon, 15 Oct 2018 15:59:17 +0900</pubDate>
      <guid>/post/lkml_news_v4.19-rc8/</guid>
      <description>&lt;h2 id=&#34;linux-419rc8&#34;&gt;Linux 4.19-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181015064915.GA10710@kroah.com&#34;&gt;https://lkml.kernel.org/r/20181015064915.GA10710@kroah.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여덟번째 rc 버전입니다.  여전히 그렉이 릴리즈 하는군요.  여덟번째 rc 인만큼, 큰
변화는 없었고, 대부분 앞서 고친 것들에 대한 수정이었군요.  아마도 다음주에는
예상대로 4.19 버전이 나올 것 같다고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-v4-patch-05-eliminate-zonelock-contention-for-willitscalepagefault1-and-parallel-free&#34;&gt;[RFC v4 PATCH 0/5] Eliminate zone-&amp;gt;lock contention for will-it-scale/page_fault1 and parallel free&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181017063330.15384-1-aaron.lu@intel.com&#34;&gt;https://lkml.kernel.org/r/20181017063330.15384-1-aaron.lu@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4 KB 크기 페이지를 위한 &lt;code&gt;will-it-scale/page_fault1&lt;/code&gt; 워크로드를 2 소켓 112 코어
인텔 스카이레이크 서버에서 돌려보면 80% 의 CPU 시간이 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 을
기다리는데 소모된다고 합니다.  이는 &lt;code&gt;struct page&lt;/code&gt; 의 캐시 미스 때문이라는군요.
이 패치셋은 이런 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 오버헤드를 없애기 위한 RFC 입니다.&lt;/p&gt;
&lt;p&gt;일단 버디 얼로케이터에서 4 KB 크기 페이지의 머지를 건너뛰게 했는데,
이것만으로도 상기한 워크로드에서 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 소모시간이 35% 에서 1.1% 로
줄었다는군요.&lt;/p&gt;
&lt;p&gt;다음으로 페이지 할당 과정에서 &lt;code&gt;free_list&lt;/code&gt; 의 페이지들을 하나씩 만지지 않고
cluster 단위로 만지게 해서 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 오버헤드를 거의 없앴습니다.  하지만 이
cluster 단위 관리로 인한 오버헤드가 페이지 해제 과정에서의 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 경쟁을
0% 에서 25% 까지 증가시켰습니다.
하지만 이어지는 최적화로 이 증가된 오버헤드도 없앴군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc7</title>
      <link>/post/lkml_news_v4.19-rc7/</link>
      <pubDate>Mon, 08 Oct 2018 07:54:09 +0900</pubDate>
      <guid>/post/lkml_news_v4.19-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-419rc7&#34;&gt;Linux 4.19-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181007154529.GA4493@kroah.com&#34;&gt;https://lkml.kernel.org/r/20181007154529.GA4493@kroah.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;토발즈 없이 진행되는 4.19를 위한 일곱번째 rc 릴리즈입니다.  이번에도 그렉이
대신 하는군요.  이번 릴리즈는 후반부임에도 rc6 보다 조금 더 커졌습니다.  하지만
그렇게까지 큰 차이는 아니라고 하는군요.&lt;/p&gt;
&lt;p&gt;일반적이라면 다음 릴리즈가 4.19 정식 릴리즈일텐데, 10월에 컨퍼런스가 많이
있다보니 rc 릴리즈를 한번 더 할 생각이라는군요.  간만에 rc8 을 보겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v6-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V6 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181010071924.18767-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20181010071924.18767-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 를 한방에 swap out / swap in 하는 Huang Ying 의 패치, 여섯번째 버전입니다.
기존 버전 대비 달라진 점은 크지 않군요.  좀 더 최신 mmotm/master 위로 rebase 한
정도입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc6</title>
      <link>/post/lkml_news_v4.19-rc6/</link>
      <pubDate>Mon, 01 Oct 2018 12:20:27 +0900</pubDate>
      <guid>/post/lkml_news_v4.19-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-419rc6&#34;&gt;Linux 4.19-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180930150308.GA5010@kroah.com&#34;&gt;https://lkml.kernel.org/r/20180930150308.GA5010@kroah.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번주도 Greg 에 의해 여섯번째 rc 버전이 릴리즈 되었습니다.  평소 일정대로면
2주일 후 4.19 정식 버전이 릴리즈 될텐데, 아마도 그때까지도 Greg 이 릴리즈 하지
않을까 싶기도 하군요.
전체적으로 특이사항은 없고 Greg 의 시스템에서는 잘 동작하고 있으며 별다른
이슈를 보고받지도 못했다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc5</title>
      <link>/post/lkml_news_v4.19-rc5/</link>
      <pubDate>Mon, 24 Sep 2018 10:10:40 +0900</pubDate>
      <guid>/post/lkml_news_v4.19-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-419rc5&#34;&gt;Linux 4.19-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180923175547.GA4462@kroah.com&#34;&gt;https://lkml.kernel.org/r/20180923175547.GA4462@kroah.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난주 토발즈가 휴식을 선언한 이유로 한동안 릴리즈는 Greg 이 맡게 되었죠.  이번
릴리즈는 그래서 Greg 이 합니다.&lt;/p&gt;
&lt;p&gt;사회적으로야 이런저런 일이 많았지만 (토발즈의 휴가, Code of Conduct 머지에
관련해 갑론을박이 많군요.) 기술적으로는 별 일 없었던 한주라 평가되는군요.&lt;/p&gt;
&lt;p&gt;사소하지만 재밌는 건 Greg 의 자기 서명.
&lt;code&gt;greg &amp;quot;keeping the seat warm for a few weeks&amp;quot; k-h&lt;/code&gt; 라고 하는군요.
토발즈가 휴가 가있는 동안 의자를 뎁혀 두는 역할이라는 겸손함이 눈에 띄네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v5-resend-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V5 RESEND 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180925071348.31458-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180925071348.31458-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 의 Swap in/out 을 regular page 로 쪼개지 않고 한방에 하는 패치의 최신
버전입니다&amp;hellip; 만, 기존 대비 버전업이 되진 않았고 리뷰를 요청하기 위해 다시 한번
보냈군요.  그런데 아직 별다른 리뷰가 없네요&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc4</title>
      <link>/post/lkml_news_v4.19-rc4/</link>
      <pubDate>Mon, 17 Sep 2018 08:03:05 +0900</pubDate>
      <guid>/post/lkml_news_v4.19-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-419rc4-released-an-apology-and-a-maintainership-note&#34;&gt;Linux 4.19-rc4 released, an apology, and a maintainership note&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFy+Hv9O5citAawS+mVZO+ywCKd9NQ2wxUmGsz9ZJzqgJQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFy+Hv9O5citAawS+mVZO+ywCKd9NQ2wxUmGsz9ZJzqgJQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;한국시간 새벽 네시 좀 넘어 이 메일을 받았습니다.  평범한 릴리즈 메일이겠거니
했는데 제목이 뭔가 심상치 않군요.&lt;/p&gt;
&lt;p&gt;일단 4.19를 위한 네번째 release candidate 릴리즈가 되었습니다.  약 3주 후 정식 4.19 버전이 릴리즈 되겠군요.  하지만 이 메일은 그보다 많은 내용을 담고 있습니다.&lt;/p&gt;
&lt;p&gt;자유분방하고 형식에 구애되지 않는 해커 문화에 기원을 두고 있는 리눅스
커뮤니티는 조금 거친 언어 문화로 유명했습니다.  예를 들어 이상한 코드를 보내면
리누스 토발즈와 커뮤니티의 일부 사람들이 이 코드를 꾸짖을 수 있는데 그 과정에서
욕설도 있을 수 있다는 거죠.  어느새 5년이 넘게 흐른 사건이지만 토발즈는
공식석상에서 Nvidia 에 가운데 손가락을 펴서 보여주기도 했죠.  이로 인해 마음에
상처를 받았다는 사람도 꽤 되고, 7년간 리눅스에 패치를 올렸던 Sarah Sharp 라는
인텔의 프로그래머는 이를 이유로 들어 결국 리눅스 커뮤니티에서 빠지기로 해서[1]
한때 많은 논란이 있기도 했습니다.  당시 토발즈는 욕설을 멈출 생각이 없다고
강경하게 맞서기도 했죠[2].&lt;/p&gt;
&lt;p&gt;그랬던 토발즈가 생각이 바뀌었다고 합니다.  올해 커널 메인테이너 서밋은 Linux
Plumbers Conference 와 함께 열릴 예정이었는데 토발즈가 그걸 깜박하고 가족
휴가를 잡는 바람에 토론이 있었고, 이 토론 과정에서 토발즈는 자신의 행위가 커널
개발에 정말로 악영향을 끼치고 있다고 느낀 것 같습니다.  이로 인해 토발즈는 이
메일을 통해 자신의 행위가 잘못되었음을 인정하고 그로 인해 상처 받은 사람들에게
공식적으로 사과를 하고 있습니다.  또한 앞으로 그런 행위를 반복하지 않기 위해
커널 개발에서 잠시 손을 떼고 거울 속의 자신을 바라보며 더 낫게 행동할 수 있도록
하는 시간을 갖겠다고 하는군요.&lt;/p&gt;
&lt;p&gt;리누스 토발즈가 커널 개발에서 손을 떼는건 과거 git 개발을 위해 손을 뗐던
사건[3] 후 처음입니다.  이 사이의 릴리즈 작업은 Greg Kroah-Hartman 에게
부탁했다고 하니 곧바로 전체 개발 작업이 멈추진 않겠습니다.&lt;/p&gt;
&lt;p&gt;이 휴식 시간이 아주 길지는 않을 거고, 토발즈 자신은 너무 지쳐 더이상 리눅스
커널 개발에 손을 데고 싶지 않다는 의도가 아니라고 합니다.  이건 얼마전 너무
지쳤다며 자비로운 종신 독재자 직을 그만둔 귀도 반 로썸의 예[4]와 비교되기도
하는군요, 토발즈도 이를 조금 의식한 거 아닐까 싶습니다.  토발즈는 자신은 여전히
리눅스 커널 개발을 하고 싶고, 잘하고 싶기 때문에 이 선택을 한 것 뿐이며, 어쩌면
단순히 욕설을 감지해 욕설이 포함된 메일은 자동으로 보내지 않는 메일
클라이언트를 개발하고 복귀하는 간단한 일이 될수도 있을 거라고 합니다.&lt;/p&gt;
&lt;p&gt;개인적인 감상은, 글쎄요.  조금 반갑기도 하고 조금 아쉽기도 합니다.  커널
커뮤니티가 거칠고 모욕적인건 사실이지만 어느정도의 긴장감은 필요하다고
생각하기도 했고, 어떤 면에선 더욱 자유분방한 그 분위기를 저는 좋아했던 것도
같아서일 겁니다.  특히 AOSP 와 같이 악플은 커녕 무플이 심한 프로젝트에 참여했던
경험이 있는 저로썬 무플보단 악플이 낫다는 주의를 가졌던 것도 한 이유겠죠.
분명한 건 이 선언은 리눅스 커뮤니티의 외연 확장을 크게 도울 것 같습니다.  그게
마냥 좋기만 한 일일지, 윤리에 대한 자기검열이 커뮤니티의 토론 열기를 식히지는
않을지 걱정되기도 하지만요.  그리고, 이 선언의 최종 결과가 어떨지를 떠나,
그정도 위치에 있고 과거에 뱉어놓은 말들이 많은 리누스 토발즈가 이렇게 깔끔하게
사과를 하는 것도 대단한 멘탈이라 생각됩니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://sarah.thesharps.us/2013/07/15/no-more-verbal-abuse/&#34;&gt;http://sarah.thesharps.us/2013/07/15/no-more-verbal-abuse/&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://arstechnica.com/information-technology/2013/07/linus-torvalds-defends-his-right-to-shame-linux-kernel-developers/&#34;&gt;https://arstechnica.com/information-technology/2013/07/linus-torvalds-defends-his-right-to-shame-linux-kernel-developers/&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://sjp38.github.io/post/git_origin_story_ko/&#34;&gt;https://sjp38.github.io/post/git_origin_story_ko/&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;https://www.i-programmer.info/news/216-python/11967-guido-van-rossum-quits-as-python-bdfl.html&#34;&gt;https://www.i-programmer.info/news/216-python/11967-guido-van-rossum-quits-as-python-bdfl.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc3</title>
      <link>/post/lkml_news_v4.19-rc3/</link>
      <pubDate>Tue, 11 Sep 2018 06:01:49 +0900</pubDate>
      <guid>/post/lkml_news_v4.19-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-419rc3&#34;&gt;Linux 4.19-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwSxCt0aKkTxcBstthYXqJ5LtxRbO-CDyqgNwU94Ldq+w@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwSxCt0aKkTxcBstthYXqJ5LtxRbO-CDyqgNwU94Ldq+w@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;세번째 rc 릴리즈입니다.  어느새 이번 안정화 기간도 중반을 향하는군요.  시간 참
빠릅니다.  전체적으로 평범한 릴리즈입니다.  딱히 언급할 거리가 없군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v2-08-lrulock-scalability-and-smp-list-functions&#34;&gt;[RFC PATCH v2 0/8] lru_lock scalability and SMP list functions&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180911004240.4758-1-daniel.m.jordan@oracle.com&#34;&gt;https://lkml.kernel.org/r/20180911004240.4758-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해 LSF/MM 서밋에서도 이야기되었던, &lt;code&gt;lru_lock&lt;/code&gt; 의 확장성을 개선하기 위한
노력의 정리입니다.  LRU 리스트에 여러 쓰레드가 실제 데이터를 겹쳐 쓰지 않는다면
동시에 접근할 수 있는 새로운 오퍼레이션 세개 (&lt;code&gt;smp_list_del()&lt;/code&gt;,
&lt;code&gt;smp_list_splice()&lt;/code&gt;, &lt;code&gt;smp_list_add()&lt;/code&gt;)을 추가했구요.  두번째로, &lt;code&gt;lru_lock&lt;/code&gt; 을
&lt;code&gt;spinlock&lt;/code&gt; 에서 &lt;code&gt;rwlock&lt;/code&gt; 으로 교체했군요.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;will-it-scale/page_fault1&lt;/code&gt; 이라는 마이크로 벤치마크를 사용해서 성능을
비교했는데, 44 코어 시스템에서 최대 73.8% 더 초당 페이지 폴트 처리량을 늘릴 수
있었다고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-09-improve-zone-lock-scalability-using-daniel-jordans-list-work&#34;&gt;[RFC PATCH 0/9] Improve zone lock scalability using Daniel Jordan&#39;s list work&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180911053616.6894-1-aaron.lu@intel.com&#34;&gt;https://lkml.kernel.org/r/20180911053616.6894-1-aaron.lu@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;바로 앞에서 설명한, 여러 쓰레드가 동시에 리스트에 접근할 수 있도록 새로
만들어진 메커니즘은 &lt;code&gt;zone lock&lt;/code&gt; 에도 도움이 될 수 있다고 LSF/MM 에서 여럿이
생각했다고 합니다.  이 패치셋은 실제로 이 기능들을 이용해 &lt;code&gt;zone lock&lt;/code&gt; 의
확장성을 개선했습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v5-resend-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V5 RESEND 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180912004414.22583-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180912004414.22583-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 를 덩어리째 스왑아웃 / 스왑인 하기 위한 패치, 다섯번째 버전입니다.
생각보다 쉽게 머지되지 못하고 있군요.  리뷰가 많지 않은 것도 한 이유 아닐까
싶습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Kernel Build</title>
      <link>/post/linux-kernel-build/</link>
      <pubDate>Fri, 07 Sep 2018 16:00:23 +0900</pubDate>
      <guid>/post/linux-kernel-build/</guid>
      <description>&lt;p&gt;제가 새 기계에서 리눅스 커널 빌드 환경을 셋업하고 실제 빌드, 설치하는 과정을
정리해 봅니다.  글 작성 과정에서 실제 커맨드를 수행한 환경은 Ubuntu 16.04.3
Server OS 를 설치한 &lt;code&gt;x86_64&lt;/code&gt; 가상머신입니다.&lt;/p&gt;
&lt;h1 id=&#34;install-dependent-packages&#34;&gt;Install Dependent Packages&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt install build-essential libncurses5-dev libssl-dev bc bison flex \
		libelf-dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;커널을 빌드하려면 컴파일러와 라이브러리 등이 필요하겠죠.  위 커맨드는
우분투에서 커널 빌드에 필요한 패키지들을 깔아줍니다.  커널 트리의
&lt;code&gt;Documentation/process/changes.rst&lt;/code&gt; 에도 커널 빌드에 필요한 패키지들이 나열되어
있으므로, 다른 환경이라면 이를 참고해 필요한 패키지를 설치합시다.&lt;/p&gt;
&lt;p&gt;페도라라면 아래와 같이 패키지를 깔면 됩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo dnf install ncurses-devel bison-devel bison flex-devel flex \
		elfutils-libelf-devel openssl-devel
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;fetch-linux-kernel-source-code&#34;&gt;Fetch Linux Kernel Source Code&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;빌드를 하려면 소스코드를 가져와야죠.  위 커맨드를 통해 토발즈의 리눅스
소스코드를 가져올 수 있습니다.  네트워크를 통해 가져오는데, 소스코드는 물론이고
개발 이력 정보를 모두 담고 있으므로 많은 데이터를 가져와야해 시간이 상당히
걸립니다.  이 글을 쓰는 2018년 9월 초 기준, 버전정보만 약 1.2 GiB 군요.&lt;/p&gt;
&lt;p&gt;토발즈는 github 에 [미러] (&lt;a href=&#34;https://github.com/torvalds/linux&#34;&gt;https://github.com/torvalds/linux&lt;/a&gt;) 를 두고 있으므로,
여길 이용하는 것도 생각해 볼 수 있고, 굳이 버전 정보는 필요하지 않다면
[&lt;code&gt;kernel.org&lt;/code&gt;] (&lt;a href=&#34;https://kernel.org&#34;&gt;https://kernel.org&lt;/a&gt;) 에서 tarball 로 소스코드만 받는것도 한
방법입니다.&lt;/p&gt;
&lt;p&gt;저는 아예 &lt;code&gt;.git&lt;/code&gt; 디렉토리를 압축해서 별도 저장소에
보관하기도 합니다.&lt;/p&gt;
&lt;h1 id=&#34;make-configuration-file&#34;&gt;Make Configuration File&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ cd linux
$ cp /boot/config-$(uname -r) ./.config
$ make menuconfig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;리눅스 빌드 설정 파일을 만들어야 합니다.  앞의 커맨드를 통해 배포판에서 제공한
커널을 빌드하는데 사용된 설정 파일을 기반으로 gui 환경에서 필요한 설정을
추가/제거 할 수 있습니다.  별달리 변경할 게 없다면 그냥 저장하고 나오면 됩니다.&lt;/p&gt;
&lt;p&gt;저는 빌드에 많은 시간이 걸리지 않고 저장 공간이 큰 시스템에서는 이 방법을
사용하고, 작은 가상머신 등의 환경에서는 &lt;code&gt;localmodconfig&lt;/code&gt; 빌드 타겟을 사용해
가벼운 설정 파일을 만드는 편입니다.&lt;/p&gt;
&lt;h2 id=&#34;seperated-build-directory&#34;&gt;Seperated Build Directory&lt;/h2&gt;
&lt;p&gt;이렇게 빌드를 하면 컴파일된 파일들이 소스코드와 같은 디렉토리에 위치하게
되는데, &lt;code&gt;grep&lt;/code&gt; 등을 할때 성가시고, 실수로 git 에 이렇게 만들어진 파일들을
추가하는 실수도 흔합니다.  리눅스 커널 빌드 시스템은 &lt;code&gt;make&lt;/code&gt; 커맨드에 &lt;code&gt;O&lt;/code&gt; 옵션을
제공하는데, 이 옵션의 인자로 빌드 디렉토리를 지정할 수 있습니다.  빌드 과정에서
만들어진 파일들은 이 디렉토리로 저장되므로, 소스코드 디렉토리를 깨끗하게 유지할
수 있습니다.  예를 들어 &lt;code&gt;/foo&lt;/code&gt; 라는 디렉토리에 빌드 과정에서 만들어진 파일을
저장하고 싶다면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ make O=/foo menuconfig
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;build&#34;&gt;Build&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ make -j $(grep &amp;quot;^processor&amp;quot; /proc/cpuinfo | wc -l)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 커맨드는 리눅스 커널을 빌드합니다.  이 때 뒤의 &lt;code&gt;-j&lt;/code&gt; 옵션을 통해 빌드 과정
작업을 한순간에 최대 몇개까지 수행해도 되는지 지정해주는데, 이 커맨드에선
빌드를 수행하는 시스템에 장착된 논리적 코어의 갯수를 줬습니다.  커널 빌드엔 긴
시간이 걸립니다.  프로세서 3개를 준 제 가상머신에서는 12분 30초 정도 걸렸군요.
이것도 &lt;code&gt;localmodconfig&lt;/code&gt; 를 해줬기 때문이고, 이런저런 모듈 다 빌드하라고 했다면
훨씬 많이 걸렸을 겁니다.&lt;/p&gt;
&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ sudo make modules_install install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 커맨드는 빌드한 모듈들과 커널 자체를 설치합니다.  커널 빌드 시스템은 이
과정에서 가장 최신의 커널로 grub 의 디폴트 부트 대상도 바꿔줍니다.  이제 기계를
껐다 켜되, grub 등에서 부트할 커널 버전을 해당 버전으로 선택하면 빌드한 커널로
부팅됩니다.  현재 시스템이 사용중인 커널의 버전은 &lt;code&gt;uname -r&lt;/code&gt; 로 알 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;이상으로 Ubuntu 16.04.3 을 기본으로 리눅스 커널을 빌드하고 설치하는 방법을
알아봤습니다.  총 일곱개의 커맨드 뿐.   쉽죠?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Chromebook Plus Purchase (크롬북 플러스 구매 결정기)</title>
      <link>/post/chromebook-plus-purchase/</link>
      <pubDate>Mon, 03 Sep 2018 13:52:00 +0900</pubDate>
      <guid>/post/chromebook-plus-purchase/</guid>
      <description>&lt;p&gt;&lt;em&gt;크롬북을 구매했습니다.  구매 결정 과정부터 사용기까지 내용을 정리해볼까 합니다.
이번 글에서는 크롬북을 구매하기까지의 고민과 과정을 정리합니다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;기본적으로 저는 글을 읽는걸 좋아하기도 하고 읽어야만 하기도 합니다.  그러다보니
여행을 가더라도 항상 어떤 책을 들고갈까 고르는게 설레기도 하지만 짜증나기도
하고, 마음만 앞서서 캐리어 무게를 책으로 꽉 채우기도 합니다.  그래서 예전부터
이북을 고려해 봤지만 너무 반응속도가 느리기도 하고 인쇄된 것에 비해선 가독성도
떨어지고 그 특유의 책을 넘겨가며 보는 반응은 아닌 것 같아 구매하지 않고
있었습니다.  하지만 슬슬 매번 책을 들고 다니는게 오히려 불편하다는 생각이 점점
늘어나고 있었습니다.&lt;/p&gt;
&lt;p&gt;한편으로는 랩톱만 들고 다니기에는 불편하다는 생각이 들었습니다.  저는 구글
핵페어에 출품을 하면서 넥서스7 1세대와 2세대를 얻게 되어 이 기기들을 사용해
왔습니다.  태블릿의 휴대성은 랩톱과 비교할 수 없는 것이었습니다.  특히 넥서스7
2세대는 해상도가 높아져 글을 읽기에도 편리했습니다.  다만, 7인치의 좁은, 특히
가로대비 세로가 매우 짧게 비디오에 특화된 화면비율은 많이 불편했습니다.  그래도
침대위 인터넷에는 쓸만했는데 작년 프라하에서 숙소에서 떨어뜨렸고, 디스플레이에
금이 가고 터치가 먹통이 되었습니다.&lt;/p&gt;
&lt;p&gt;있을 땐 그렇게 소중한지 몰랐지만 7인치짜리라도 태블릿이 없어지니 랩톱의 불편이
느껴졌습니다.  특히, 컨퍼런스 등에 가서 책상이 없는 자리에 앉을 때, 전원
플러그가 없을때 그렇습니다.  전력 등을 고려해 안쓰고 있을 때엔 랩톱을 닫고
있어야 하는데, 발표를 듣다가 뭔가 흥미로운 사이트 소개 등이 있어 잠시 인터넷을
하고 싶을때 랩톱을 열어야 합니다.  열고 나면 패스워드를 입력하거나 지문 인식을
해야 하는데, 이 짧은 인터럽트가 매우 불쾌하고 생각의 흐름을 끊어버립니다.&lt;/p&gt;
&lt;p&gt;한편, 최신 태블릿과 아이패드들을 만져보니 많이 발전되었다는 생각이 들었습니다.
그래서 하나 사는게 좋겠다 싶어 물건들을 알아보았습니다.  하지만 동시에 단점도
많이 눈에 띄더군요.&lt;/p&gt;
&lt;h1 id=&#34;heading&#34;&gt;요구사항&lt;/h1&gt;
&lt;p&gt;가격은 30만원선을 원합니다. 40을 넘어가면 지갑이 버티지 못합니다.&lt;/p&gt;
&lt;p&gt;랩톱과 함께 쓸만한 서브 디바이스를 원합니다.  따라서 커널을 빌드하거나 할
생각은 없으니 컴퓨팅 파워는 크게 중요하지 않습니다.  저장공간도 너무 클 필요
없습니다.  인터넷만 원활한 정도면 되겠습니다.&lt;/p&gt;
&lt;p&gt;책을 보고 싶고, 특히 논문도 볼 수 있길 바라기 때문에 화면이 크고 해상도가
높아야 합니다.  가로 비율이 너무 길어서 비디오에만 최적화 되어 있는 화면은 원치
않습니다.  적당한 pdf 뷰어도 지원이 되어야 합니다.&lt;/p&gt;
&lt;p&gt;오픈소스 운영체제로 돌아가는 기기면 좋겠습니다.  커널은 리눅스여야 합니다.
업스트림 커널을 설치할 수 있어 커널 테스트용으로 사용할 수 있다면 가산점이 크게
올라갑니다.  사실 가장 원하는건 데비안이나 우분투, 페도라 등이 깔린 리눅스 순정
태블릿이지만 적당한 기기가 없어 보입니다.&lt;/p&gt;
&lt;p&gt;리눅스 셸이 제공되면 좋겠습니다.  사실상 거의 모든 일을 거기서 할 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;heading1&#34;&gt;아이패드&lt;/h1&gt;
&lt;p&gt;결코 살 수 없습니다.  폐쇄성 때문입니다.  사용자 레벨에서도 폐쇄적이지만 독점
소프트웨어로 돌아가는 기기를 사고 싶지 않았습니다.&lt;/p&gt;
&lt;h1 id=&#34;-&#34;&gt;안드로이드 태블릿&lt;/h1&gt;
&lt;p&gt;안드로이드 태블릿은 하이엔드 제품의 경우 아이패드와 비슷한 성능이고, 일단은
오픈소스인 안드로이드 운영체제를 사용하고 있습니다.  리눅스 커널 기반이고,
수많은 안드로이드 앱중에는 적절한 pdf 뷰어 앱도 있습니다.  Termux 등을 사용하면
셸도 원활하게 사용할 수 있습니다.  업스트림 리눅스 커널을 직접 빌드해
설치하려면 까다롭긴 하지만 불가능한 것도 아니긴 합니다.&lt;/p&gt;
&lt;p&gt;한가지 치명적인 건 운영체제 업데이트가 원활치 않아 보이는군요.  가격을 생각해야
하니 나온지 오래된 모델들을 알아봤는데 하나같이 운영체제 업데이트가 되지 않고
있는 듯 했습니다.&lt;/p&gt;
&lt;h1 id=&#34;heading2&#34;&gt;크롬북&lt;/h1&gt;
&lt;p&gt;그렇게 이번에도 아이쇼핑만 하고 그만두려던 차에 크롬북이 눈에 들어왔습니다.
크롬북은 안드로이드보다 훨씬 개방적인 정책을 취한 오픈소스 운영체제인 크롬 OS
를 사용하고 있습니다.  리눅스 커널 기반이고, 최근들어 안드로이드 앱과 리눅스
네이티브 앱을 공식 지원하고 있습니다.  구글 정책상 대부분의 크롬 OS 디바이스가
최신 OS로 업데이트 됩니다.  과거에 잠시 셋업만 해봤는데 crouton 등을 사용하면
Ubuntu 등의 리눅스 배포판을 설치할 수 있고 Chrome OS 와의 전환도 키 하나만
누르면 되어서 매우 간편했던 기억이 있습니다.  문제라면 폼팩터가 랩톱의
폼팩터라는 것인데, 요즘 나오는 크롬북은 디스플레이를 360도 전환할 수 있어
태블릿 모드와 텐트 모드를 사용할 수 있는 제품이 대부분입니다.  가격도 매우
저렵한게 특징입니다.&lt;/p&gt;
&lt;p&gt;이거다 싶었습니다!&lt;/p&gt;
&lt;h1 id=&#34;-1&#34;&gt;크롬북 플러스&lt;/h1&gt;
&lt;p&gt;그렇게 크롬북 모델들을 찾아보니 삼성 크롬북 플러스[1] 가 눈에 들어왔습니다.
12.3인치 화면에 2400x1600 해상도.  책 읽기에 딱 적절해 보입니다.  스타일러스
펜도 있고, 6코어 프로세서는 ARM 프로세서지만 제게는 차고 넘쳐 보이더군요.
한가지 걸리는건 브랜드와 가격.  삼성에 대해 안좋은 인식이 있습니다.  그리고
가격이 약 450 달러.  한국에서 사려면 대략 50만원을 넘습니다.  40만원 미만을
원하던 걸 생각하면 가격이 조금 셉니다.&lt;/p&gt;
&lt;h1 id=&#34;-2&#34;&gt;최종 구입&lt;/h1&gt;
&lt;p&gt;혹시나 하고 아마존에서 크롬북 프로 검색을 해봤습니다.  중고 모델은 350불 정도
하는군요.  어차피 보조 디바이스라 중고인건 괜찮은데 가격이 여전히 좀 그렇군요.
망설이며 며칠을 보내다가 새로고침을 해보니 가격이 250불이 되어 있었습니다.
아마존은 이런식으로 핫딜이 있다고 하는군요.  이때가 아니면 언제 지르랴, 하고
질렀습니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://www.samsung.com/us/computing/chromebooks/12-14/xe513c24-k01us-xe513c24-k01us/&#34;&gt;https://www.samsung.com/us/computing/chromebooks/12-14/xe513c24-k01us-xe513c24-k01us/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc2</title>
      <link>/post/lkml_news_v4.19-rc2/</link>
      <pubDate>Mon, 03 Sep 2018 11:34:35 +0900</pubDate>
      <guid>/post/lkml_news_v4.19-rc2/</guid>
      <description>&lt;h2 id=&#34;linux-419rc2&#34;&gt;Linux 4.19-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 4.19 두번째 릴리즈 후보 버전의 릴리즈입니다.  첫번째 릴리즈 후보 버전
릴리즈 후엔 사람들이 좀 쉬게 마련이고 버그를 찾기엔 시간이 많지 않았기에 큰
변화는 없었습니다.  유럽사람들의 경우 아직 휴가기간인 사람도 많구요.  미국
OSSummit 이 지난주 진행된 것도 한 영향이겠네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v5-0021-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -V5 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180903072214.24602-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180903072214.24602-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;관심있게 지켜보고 있는, THP swapout/in 패치입니다.  다음 머지 윈도우에선 들어갈 수 있을까요?&lt;/p&gt;
&lt;h2 id=&#34;plumbers-2018--performance-and-scalability-microconference&#34;&gt;Plumbers 2018 - Performance and Scalability Microconference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1dc80ff6-f53f-ae89-be29-3408bf7d69cc@oracle.com&#34;&gt;https://lkml.kernel.org/r/1dc80ff6-f53f-ae89-be29-3408bf7d69cc@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;올해 Linux Plumbers Conference 에 &amp;lsquo;Performance and Scalability Microconference&amp;rsquo;
가 열립니다.  Huge page, mmap_sem, cpu 병렬화 등등 재밌는 주제가 많네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Paper about GCMA Accepted to TC</title>
      <link>/post/gcma_accepted_to_tc/</link>
      <pubDate>Wed, 29 Aug 2018 21:53:56 +0900</pubDate>
      <guid>/post/gcma_accepted_to_tc/</guid>
      <description>&lt;p&gt;A paper about &lt;a href=&#34;/post/gcma/&#34;&gt;GCMA project&lt;/a&gt; has accepted to a top-level computer science journal, Transactions on Computers[1].  It will be published soon.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;/post/gcma/&#34;&gt;GCMA&lt;/a&gt; 에 대한 논문이 컴퓨터 과학계의 최고 수준 저널인
Transactions on Computers[1] 에 Accept 되었습니다.  조만간 이를 통해 출간될
예정입니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://www.computer.org/web/tc&#34;&gt;https://www.computer.org/web/tc&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git Origin Story in Korean</title>
      <link>/post/git_origin_story_ko/</link>
      <pubDate>Wed, 29 Aug 2018 21:15:13 +0900</pubDate>
      <guid>/post/git_origin_story_ko/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;최근 흥미롭게 보았던 &lt;code&gt;Git Origin Story&lt;/code&gt; 라는 제목의 LinuxJournal.com 기사를
번역해 봅니다.  원본 기사는
&lt;a href=&#34;https://www.linuxjournal.com/content/git-origin-story&#34;&gt;https://www.linuxjournal.com/content/git-origin-story&lt;/a&gt; 에서 보실 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;수년간 리눅스 커널 개발자들이 사용해온 다양한 리비전 컨트롤 방법, Linus
Torvalds가 Bit keeper 를 사용하기로 한 결정과 그에 뒤따른 논쟁, 그리고 어떻게 Git
이 만들어졌는가에 대한 글입니다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;처음에, Linus Torvalds는 리비전 컨트롤을 아예 사용하지 않았습니다.  커널에
코드를 기여하고자 하는 사람은 Usenet 그룹에, 나중에는 메일링 리스트에 패치를
올렸고, Linus는 자신의 소스 트리에 그걸 적용했습니다.  나중에 Linus는
릴리즈를 통해 패치들 사이의 구분 없이 전체 소스 트리를 공개하는 식이었습니다.
Torvalds의 작업 이력을 알아낼 수 있는 유일한 방법은 전체 릴리즈 버전 사이의
거대한 diff 를 통하는 것 뿐이었습니다.&lt;/p&gt;
&lt;p&gt;이는 오픈소스 리비전 컨트롤 시스템이 없기 때문은 아니었습니다.  1980년대부터
CVS 가 있었고, 그 당시에도 가장 유명한 시스템이었습니다.  그 핵심 기능을
사용해서 기여자들이 패치를 중앙 저장소에 보낼 수 있었고 그 저장소로 들어가는
패치의 기록을 조사할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;하지만 CVS 에 대한 많은 불만이 있었습니다.  그 중 하나는 변경 사항을 파일별로
제공하고 커다란 패치는 하나의 버전으로 인식할 수 없어서, 다른 개발자들로부터의
과거의 기여를 해석하기가 어려웠습니다.  또한, 두개의 같은 파일을 수정하는
패치가 동시에 보내졌을 때 발생하는 레이스 컨디션 같은 고치기 어려운 버그들도
일부 있었습니다.&lt;/p&gt;
&lt;p&gt;Linus는 CVS 를 좋아하지 않았는데, 부분적으로는 다른 사람들의 불만과 같은 이유
때문이었고 부분적으로는 후에야 명확해진 그만의 이유 때문이었습니다.  그는 CVS
의 버그와 이상한 기능들을 해결하려는 목표를 가지고 2000년대 초부터 발전되어온
오픈소스 프로젝트인 SVN 도 좋아하지 않았습니다.&lt;/p&gt;
&lt;p&gt;많은 리눅스 커널 개발자들이 적당한 리비전 컨트롤의 부재에 불만족스러 했으며,
따라서 Linus가 사용 가능한 리비전 컨트롤 중에서 뭐든 하나를 고르길 바라는
커뮤니티로부터의 압력이 항상 있었습니다.  그리고, 2002년, Linus는 그렇게
했습니다.  충격적이고 당황스럽게도, Linus는 Larry McVoy 에 의해 운영되는
BitMover 라는 회사에 의해 개발된, 소스코드가 공개되어있지 않은 상업용 시스템인
BitKeeper 를 선택했습니다.&lt;/p&gt;
&lt;p&gt;리눅스 커널은 역사상 가장 중요한 오픈소스 프로젝트였고, Linus 그 스스로가
수십년간 다른 오픈소스 프로젝트들이 따라하게 되었고 지금까지도 그렇게 하고 있는
오픈소스 개발 방법을 처음으로 발견한 사람이었습니다.  Linus가 무슨 생각을 하는
거지?  어떻게 그가 그의 커뮤니티와 오픈소스 세계를 이렇게 배신할수가 있지?
이게 Linus가 처음 커널 개발에 BitKeeper 를 사용했을 때 대부분의
반응이었습니다.&lt;/p&gt;
&lt;p&gt;또한, BitMover 는 돈을 받지 않고 BitKeeper 를 사용할 수 있는 라이센스를
제공하는데 대한 대가로 리눅스 커뮤니티에 제한을 걸었습니다.  첫째, 리눅스
개발자들은 BitKeeper 를 사용하는 동안 다른 경쟁 리비전 컨트롤 시스템 개발
프로젝트에 참여할 수 없었습니다.  둘째, BitMover 는 라이센스에 대한 악용을 막기
위해 커널 프로젝트에 관계된 일부 메타데이터를 제어할 수 있었습니다.  이
메타데이터에 대한 접근이 불가능하면, 커널 개발자들은 다른 리비전 컨트롤
시스템에서의 중요한 표준적 기능인, 과거의 커널 버전들 사이의 비교를 할 수
없었습니다.&lt;/p&gt;
&lt;p&gt;Linus가 BitKeeper 를 사용한지 수년이 지나도 논쟁은 줄어들지 않았습니다.  그의
기본적 주장은, 그는 프리 소프트웨어 (Free Software) 광신도가 아니라는
것이었습니다.  그는 오픈소스 도구들이 같은 일을 하는 상업용 도구들에 비해
낫다면 그걸 사용할 거라고 했습니다.  하지만 상업용 도구가 더 낫다면, 그는 다른
도구를 고려하지 않을 거라고요.&lt;/p&gt;
&lt;p&gt;하지만, 많은 커널 개발자들이 실제로 프리 소프트웨어 광신도였습니다.  커뮤니티에
손상을 입히고 리눅스 커널 프로젝트의 fork 를 일으킬 만큼은 아니지만 Linus와
다른 개발자들간의 분노와 긴장이 심해졌습니다.  Alan Cox, Al Viro, David Miller,
Andrea Arcangeli, Andrew Morton 과 많은 수의 다른 사람들이 경쟁 프로젝트를
이끌만한 기술력을 가지고 있음이 분명했고, 심지어 일부는 상당수 커널 개발자들을
그들 쪽으로 끌어갈 명성을 가지고 있었습니다.  하지만 아무도 그러지 않았습니다.
이 긴장과 적대는 계속 유지되었습니다.&lt;/p&gt;
&lt;p&gt;BitKeeper 의 무엇이 그리 대단했을까요?  BitKeeper 에서 자랑한 건 분산시스템을
제공한다는 것으로, 모든 저장소가 쉽게 fork 되고 merge 될 수 있었습니다.  이게
핵심이었습니다.  이를 통해, 특정 하위 그룹의 커널 개발자들은 리비전 컨트롤의
이득을 얻으면서 그룹끼리 독자적으로 협업하고, 준비된 다음에 그들의 변경 사항을
Linus에게 전달할 수 있었습니다.  이를 통해, 전에는 Linus 한명의 어깨에 완전히
매여있던 수많은 작업이 Linus가 믿는 개발자들, 또는 그렇게 작업하기로 한
그룹들에게 분산될 수 있었습니다.  아키텍쳐별 코드, 드라이버, 그리고 커널의 하위
시스템들이 모두 어떻게든 독립적으로 개발되고, 이후 적절한 시점에 한번에 메인
커널에 병합될 수 있었습니다.&lt;/p&gt;
&lt;p&gt;슬슬 하는 이야기가 익숙하게 들릴 겁니다만, 2002년에 이건 새로운
아이디어였습니다.  CVS 와 Subversion 같은 당시 존재하던 프로젝트들에서 fork 와
merge 는 주인만 할 수 있고, 죽고 싶도록 시간이 오래 걸리는 작업이었습니다.
BitKeeper 를 통해, 이게 사소한 작업이 되었습니다.&lt;/p&gt;
&lt;p&gt;커널 개발 도구의 핵심부에 독점 소프트웨어를 사용하려는 Linus의 의지는 많은
사람들이 대안을 만드는데 더욱 노력하게 만들었습니다.  CVS 와 Subversion
프로젝트는 너무 많은 기초적 설계 오류가 있었고, 이미 너무 많이 개발이 진행되어
변경하기가 쉽지 않았습니다.  다른 프로젝트들 모두 마찬가지였습니다.  하지만
이제 그들은 Linus가 정말 원하는걸 알거나 안다고 생각했으므로, 정말로 코딩을
시작할 수 있었습니다.  그 결과 분산 개발 기능을 제공하는 많은 수의 리비전
컨트롤 시스템이 나왔습니다.&lt;/p&gt;
&lt;p&gt;그런 시스템들 중에 arch, darcs, 그리고 monotone 등이 있었습니다.  그들은
Bitkeeper 를 경쟁 상대라고 함으로써, Linus가 Bitkeeper 에 대한 대안으로 그들을
선택하라고 설득했습니다.&lt;/p&gt;
&lt;p&gt;많은 사람들이 시도했지만, 아무도 성공하지 못했습니다.  이는 부분적으로는
Linus가 CVS 와 Subversion 에 뭐가 빠져있는지 모두 이야기 하지 않았듯, 그
프로젝트들에 Linus가 더 필요로 하는 것이 무엇인지 모두 말하지 않았기
때문입니다.  그리고, Linus가 소스가 폐쇄된 도구를 사용하는것도 개의치 않는 것
같았으므로, 어떤 대안이 그에게 받아들여질만 하려면 그 대안은 BitKeeper 보다
훨씬 기술적으로 향상되어 있어야만 할 것이었습니다.  따라서, BitKeeper 전에도
오픈소스 툴의 기능은 충분하지 않았지만, BitKeeper 가 나타남으로써 오픈소스 툴이
맞춰야 할 기능의 목표가 더욱 높아진 셈입니다.&lt;/p&gt;
&lt;p&gt;수년간의 많은 노력 후에도, 어떤 오픈소스 대안도 Linus의 필요를 맞추기엔 CVS 나
Subversion 보다도 크게 나아지지 못했습니다.  만약 Samba 를 만들었고 rsync 의
공동 창시자인 Andrew Tridgell 이 아니었더라면 이 상황은 훨씬 오래 지속될 수
있었을 겁니다.  2005년, Andrew는 프리 소프트웨어인 대안을 만들기 위해 BitKeeper
네트워킹 프로토콜을 리버스 엔지니어링 하려 했습니다.  그가 아니었더라도,
누군가는 시도했을 겁니다 - 그건 그저 시간 문제였습니다.  Larry McVoy 는 누구든
이 시도를 했다면 당장 지원을 끊겠다고 리눅스 개발자들에게 경고했고, 실제로
그렇게 했습니다.  결국, 급작스럽게 BitKeeper 를 커널 개발에 사용될 수 없게
되었습니다.  전체 개발 도구와 분산 버전 컨트롤로부터 생겨난 개발 문화는 앞날을
알 수 없는 상황에 놓였습니다.&lt;/p&gt;
&lt;p&gt;이게 무슨 의미일까요?  Linus는 그의 과거 방식의 개발로 돌아가서 모든 패치를 그
자신에게 보내라고 했을까요?  그렇지 않다면, BitKeeper 의 오픈소스 대안들 가운데
하나를 선택했을까요?  만약 그가 그랬다면, 어떤 대안을 골랐을까요?&lt;/p&gt;
&lt;p&gt;이 시점에서, 놀라운 일이 발생했습니다.  Linus가 리눅스 커널 개발을 1991년
시작한 후 처음으로 작업을 완전히 멈췄습니다.  현존하는 어떤 도구도 그가 원하는
일을 해주지 못했으므로, 그는 자신의 것을 만들기로 결정했습니다.&lt;/p&gt;
&lt;p&gt;Linus의 주요 관심은, 사실 속도였습니다.  이것이 그가 기존에는 완전히, 적어도
현존하는 프로젝트들이 이해할 수 있는 방식으로는 이야기하지 않은 부분이었습니다.
전세계에서 전력을 다해 패치를 보내오는 수천명의 커널 개발자들을 위해, 그는
기존에는 상상할 수 없는 속도로 동작하는 무언가가 필요했습니다.  그는 가장
거대하고 가장 복잡한 작업이라 해도 완료하는데 몇초 이상 기다리는 걸 참을 수
없었습니다.  Arch 도, darcs, monotone 도, 그리고 어떤 다른 프로젝트도 이
요구사항을 맞추지 못했습니다.&lt;/p&gt;
&lt;p&gt;Linus는 잠시 은둔한 채 코딩을 했고, 그 후에 그의 새로운 계획을 세상에
알렸습니다.  2005년 6월에 그 프로젝트를 시작한 이래 몇일만에, Linus의 git
리비전 컨트롤 시스템은 git 소스코드의 리비전 컨트롤을 완전히 할 수 있게
되었습니다.  몇주 후, git 은 리눅스 커널 개발의 리비전 컨트롤을 맡을 준비가
되었습니다.  몇달 후, 완전한 기능을 갖추었습니다.  이 시점에서, Linus는 이
프로젝트의 관리 권한을 해당 프로젝트의 가장 열정적인 기여자, Junio C. Hamano
에게 넘기고 리눅스 개발에 다시 전념했습니다.&lt;/p&gt;
&lt;p&gt;이 도구에 놀란 프리 소프트웨어 개발자 커뮤니티는 이 괴상한 작업물을 이해하려
노력했습니다.  이것은 리비전 컨트롤 소프트웨어의 어떤 것도 닮지 않았습니다.
사실, 이것은 리비전 컨트롤 시스템보다는 낮은 단계의 파일시스템 오퍼레이션들의
집합에 가까워 보였습니다.  그리고 다른 시스템들이 패치를 저장하는 것과 달리,
이것은 각각의 변경된 파일의 버전을 모두 저장했습니다.  어떻게 이런 방식이
괜찮을 수 있을까요?  하지만, 이 도구는 fork 와 merge 를 번개같은 속도로 처리할
수 있고, 패치를 요청하자마자 만들어낼 수 있었습니다.&lt;/p&gt;
&lt;p&gt;점진적으로, Junio는 CVS 와 Subversion 의 것들을 닮은 높은 수준의 커맨드 집합을
만들었습니다.  Git 의 원래 커맨드들이 &amp;ldquo;배관&amp;rdquo; 이었다면, 새로운 커맨드들은
&amp;ldquo;도자기 제품&amp;rdquo; 이었습니다.  그리고, 결국 사용되게 되었습니다.&lt;/p&gt;
&lt;p&gt;BitKeeper 에 대한 논쟁과 분노가 있었던 만큼이나, git 의 계속된 개발을 향한
열망과 참여 의지가 많았습니다.  포팅, 확장 기능, 그리고 웹사이트들이 모든 것을
현재 상태로 끌어올렸습니다.  몇년만에, 거의 모든 사람들이 git 을 사용하게
되었습니다.  리눅스처럼, git 이 세상을 집어삼켰습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi 3 Serial Connection</title>
      <link>/post/rasp3-serial/</link>
      <pubDate>Mon, 27 Aug 2018 17:16:35 +0900</pubDate>
      <guid>/post/rasp3-serial/</guid>
      <description>&lt;p&gt;라즈베리 파이를 메인 컴퓨터로 사용하려는게 아니라면, 라즈베리 파이에 모니터와
키보드, 마우스를 연결하고 사용하는게 아무래도 번거롭습니다.  ssh 로 붙어서
작업하는 것도 한 방법이지만, 그게 여의치 않은 상황도 있습니다.  그저 터미널만
연결되면 되는 상황이라면, 가장 간단한 건 UART Serial 통신을 사용하는 겁니다.&lt;/p&gt;
&lt;p&gt;라즈베리 파이는 UART 통신을 지원하고 있는데, GPIO 핀 중 14번과 15번이[2] 각각
TX, RX 입니다.  호스트 컴퓨터와 이 두개의 핀을 연결하면 UART 통신을 할 수
있어서 라즈베리 파이의 터미널에 바로 접근할 수 있습니다.&lt;/p&gt;
&lt;p&gt;호스트 머신에 핀을 연결하는게 번거로울 수 있는데, 시리얼-USB 젠더를 여기저기서
저렴한 가격에 팝니다[1].  이걸 이용해 TX/RX 핀을 라즈베리 파이의 GPIO 14, 15번에
각각 연결하고 USB 를 호스트 머신에 연결합니다.&lt;/p&gt;
&lt;p&gt;이제 호스트 머신의 &lt;code&gt;/dev/&lt;/code&gt; 디렉토리에 &lt;code&gt;ttyUSB&lt;/code&gt; 로 시작하는 파일이 생겼을
겁니다.  제 경우 &lt;code&gt;ttyUSB0&lt;/code&gt; 라는 이름의 파일이 생겼군요.  이제, 시리얼 통신
프로그램인 &lt;code&gt;minicom&lt;/code&gt; 을 사용해서 이 포트로 연결해서 UART 통신을 합시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo minicom -D /dev/ttyUSB0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이제 라즈베리 파이를 부팅 시키면 부팅 로그부터 터미널에 나오고, 로그인 화면까지
뜹니다.&lt;/p&gt;
&lt;h1 id=&#34;3---&#34;&gt;라즈베리파이3 시리얼 문제와 해결법&lt;/h1&gt;
&lt;p&gt;하지만, 라즈베리 파이 3 에서는 내장으로 블루투스와 WiFi 가 들어가면서 GPIO 핀이
겹치게 되어 앞의 과정만으로는 시리얼 통신을 할 수 없습니다.  블루투스를 끄고
시리얼을 켜줘야 합니다.&lt;/p&gt;
&lt;p&gt;먼저, 다음과 같이 &lt;code&gt;/boot/config.txt&lt;/code&gt; 파일에 다음 두줄을 추가합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo echo &amp;quot;enable_uart=1&amp;quot; &amp;gt;&amp;gt; /boot/config.txt
$ sudo echo &amp;quot;dtoverlay=pi3-miniuart-bt&amp;quot; &amp;gt;&amp;gt; /boot/config.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;그리고 /boot/cmdline.txt 를 열어서 &lt;code&gt;console=tty1&lt;/code&gt; 이라는 내용을 추가해줍니다.&lt;/p&gt;
&lt;p&gt;준비가 끝났습니다.  재부팅 하면 &lt;code&gt;minicom&lt;/code&gt; 에 라즈비안 콘솔이 연결됩니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://www.devicemart.co.kr/29565&#34;&gt;https://www.devicemart.co.kr/29565&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://www.raspberrypi.org/documentation/usage/gpio/&#34;&gt;https://www.raspberrypi.org/documentation/usage/gpio/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc1</title>
      <link>/post/lkml_news_v4.19-rc1/</link>
      <pubDate>Mon, 27 Aug 2018 17:11:28 +0900</pubDate>
      <guid>/post/lkml_news_v4.19-rc1/</guid>
      <description>&lt;h2 id=&#34;linux-419rc1&#34;&gt;Linux 4.19-rc1&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CA+55aFw9mxNPX6OtOp-aoUMdXSg=gBkQudGGamo__sh_ts_LdQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이주일의 머지 윈도우가 끝나고 리눅스 4.19 버전을 향한 안정화 단계가
시작되었습니다.&lt;/p&gt;
&lt;p&gt;토발즈에겐 결코 즐겁지 않은 머지 윈도우였습니다 (frustrating merge window
였다고 표현하는군요).  일단 머지 윈도우 초기부터 L1TF 취약점 이슈가 나왔죠.
하지만 이슈가 처음 발견된 건 아니고 공식 보고된 거다보니 그 전부터 수정은 하고
있었기에 머지만 하면 됐습니다.  토발즈는 &lt;code&gt;-next&lt;/code&gt; 트리와 다양한 커널 테스트
시스템들이 잘 갖추어져 있다는 증거라고 이야기 합니다.&lt;/p&gt;
&lt;p&gt;또, TLB 슛다운 버그에 대한 보고가 있었군요.  결국은 큰 문제는 아니었다고
결론났음에도 토발즈의 신경을 많이 긁었다고 합니다.  이 과정에서 관련 코드가
매우 복잡하고 디버깅 하기 어렵다고 이야기 되었기에 차후 정리가 필요할 것
같다는군요.&lt;/p&gt;
&lt;p&gt;또한, 이번 릴리즈는 꽤 많은 변경이 있는 편이라고 합니다, 물론 커밋 수
기반으로요.&lt;/p&gt;
&lt;h2 id=&#34;rfcpatch-05-introduce-procpididlebitmap&#34;&gt;[RFC][PATCH 0/5] introduce /proc/PID/idle_bitmap&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180901112818.126790961@intel.com&#34;&gt;https://lkml.kernel.org/r/20180901112818.126790961@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/sys/kernel/mm/page_idle/bitmap&lt;/code&gt; 을 사용하면 시스템의 실제 워킹셋 페이지가
무엇무엇인지 알 수 있는데요, 이걸 &lt;code&gt;/proc/PID/idle_bitmap&lt;/code&gt; 으로 옮겨서 좀 더
finer-grained 하게 특정 프로세스의 워킹셋을 추적할 수 있게 하려는 RFC
패치입니다.  기존의 글로벌한 비트맵은 아무래도 사용하기에 오버헤드가 있기
때문이죠.  특히 NVIDMM 을 고려하면 수 테라바이트도 쉽게 보인다는 이야기를
하는군요.  저도 해당 bitmap 을 사용해 워킹셋 추적 프로그램을 만들었다가
오버헤드로 고민이 깊어져서 커널을 좀 고치긴 해야겠다 싶었는데, 잘 머지되면
좋겠습니다.&lt;/p&gt;
&lt;p&gt;이와 함께 인텔의 Apache Pass NVDIMM 에 대한 이야기도 하는군요.  옵테인 기반의
NVDIMM 제품인 거 같은데, NVDIMM 도 현물이 나오기 시작하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-lkmm-17-toolsmemorymodel-add-extra-ordering-for-locks-and-remove-it-for-ordinary-releaseacquire&#34;&gt;[PATCH RFC LKMM 1/7] tools/memory-model: Add extra ordering for locks and remove it for ordinary release/acquire&lt;/h2&gt;
&lt;p&gt;이 락킹 앞뒤의 액세스 순서를 지켜주는게 LKMM 에는 반영되어 있지 않습니다.
이걸로 몇명의 커널 프로그래머들이 항의했나 보네요.  이런 부분들을 추가하는
패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-06-documentation-updates-for-v420v50&#34;&gt;[PATCH tip/core/rcu 0/6] Documentation updates for v4.20/v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180829211637.GA20980@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180829211637.GA20980@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음 리눅스 머지 윈도우를 겨냥하는 RCU 쪽 문서 업데이트입니다.  다음 버전은
4.20이 될지 5.0이 될지 Paul 도 모르겠나보군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-03-srcu-updates-for-v420v50&#34;&gt;[PATCH tip/core/rcu 0/3] SRCU updates for v4.20/v5.0&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180829212036.GA22033@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180829212036.GA22033@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음 리눅스 머지 윈도우를 향한 SRCU 업데이트 입니다.  &lt;code&gt;call_srcu()&lt;/code&gt; 를 부팅
초기부터 사용할 수 있도록 하는군요.  테스트도 작성했습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-024-additional-rcuconsolidation-cleanups-for-v420v50&#34;&gt;[PATCH tip/core/rcu 0/24] Additional RCU-consolidation cleanups for v4.20/v5.0&lt;/h2&gt;
&lt;p&gt;RCU 는 여러 변종 (flavor) 들이 있는데, 이것들을 최대한 합치려 하고 있는 듯
하군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi 3 Model B Setup</title>
      <link>/post/rasp3-modelb-setup/</link>
      <pubDate>Mon, 27 Aug 2018 16:03:42 +0900</pubDate>
      <guid>/post/rasp3-modelb-setup/</guid>
      <description>&lt;p&gt;OSSE 2016 에서 받아온 라즈베리 파이3 셋업을 해봅니다.
셋업에 사용된 호스트 환경은 Ubuntu 16.04 데스크탑입니다.&lt;/p&gt;
&lt;p&gt;라즈베리 파이는 SD 카드를 저장소로 사용합니다.  따라서 여기에 운영체제를 깔아야
합니다.  다만, 라즈베리 파이를 구매하면 SD 카드는 따라오지 않습니다.  각자
알아서 사야 합니다.  전 예전에 사둔 16 GiB 짜리 SD 카드를 사용하겠습니다.&lt;/p&gt;
&lt;p&gt;라즈베리 파이를 지원하는 운영체제는 여러가지 있는데, 데비안 계열의 Raspbian 이
공식 운영체제입니다.  &lt;a href=&#34;https://www.raspberrypi.org/downloads/&#34;&gt;다운로드 페이지&lt;/a&gt;
에서 Raspbian stretch lite 를 다운받고 압축을 풀어줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls
2018-06-27-raspbian-stretch-lite.zip
$ unzip 2018-06-27-raspbian-stretch-lite.zip 
Archive:  2018-06-27-raspbian-stretch-lite.zip
  inflating: 2018-06-27-raspbian-stretch-lite.img  

$ ls
2018-06-27-raspbian-stretch-lite.img  2018-06-27-raspbian-stretch-lite.zip
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;압축 파일이 350 MiB, 압축 푼 이미지는 1.8 GiB 나 하는군요.&lt;/p&gt;
&lt;p&gt;이제 요걸 SD 카드에 써야하는데요, 일단 SD 카드를 데스크탑에 연결하고, &lt;code&gt;df&lt;/code&gt; 명령을 이용해 이게 어떤 디바이스 파일로 인식되었는지 봅시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            7.8G     0  7.8G   0% /dev
tmpfs           1.6G  174M  1.4G  11% /run
/dev/sda1       222G  127G   84G  61% /
tmpfs           7.8G  161M  7.7G   3% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           7.8G     0  7.8G   0% /sys/fs/cgroup
tmpfs           1.6G   68K  1.6G   1% /run/user/1000
/dev/sdb        917G  541G  330G  63% /media/sjpark/47f422d0-445f-4dfc-86ca-559b801eb9d3
/dev/sdc2        15G  4.7G  9.3G  34% /media/sjpark/f24a4949-f4b2-4cad-a780-a138695079ec
/dev/sdc1        56M   24M   33M  42% /media/sjpark/boot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;제가 사용한 SD 카드는 기존에 라즈베리파이2 모델 B+ 운영체제가 설치되어
있었습니다.  /&lt;code&gt;dev/sdc&lt;/code&gt; 로 SD 카드가 잡혔고, &lt;code&gt;/dev/sdc1&lt;/code&gt; 으로 부팅 파티션이,
&lt;code&gt;/dev/sdc2&lt;/code&gt; 로 데이터 파티션이 잡힌 것 같군요.&lt;/p&gt;
&lt;p&gt;이제 마운트된 파티션들을 언마운트하고, &lt;code&gt;dd&lt;/code&gt; 명령으로 이미지를 덮어씌웁시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo umount /media/sjpark/f24a4949-f4b2-4cad-a780-a138695079ec
$ sudo umount /media/sjpark/boot
$ sudo dd bs=4M if=./2018-06-27-raspbian-stretch-lite.img of=/dev/sdc
444+0 records in
444+0 records out
1862270976 bytes (1.9 GB, 1.7 GiB) copied, 199.44 s, 9.3 MB/s
$ sync
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;처음 두개 커맨드가 언마운트를 하고, 세번째 커맨드가 이미지를 덮어씌우는
커맨드입니다.  혹시 모르니 네번째 커맨드에서 &lt;code&gt;sync&lt;/code&gt; 해서 데이터가 확실히
씌워지게 했습니다.&lt;/p&gt;
&lt;p&gt;이제 라즈베리 파이의 HDMI 단자에 모니터를 연결하고 micro USB 포트에 스마트폰
충전하듯이 USB 를 연결해 전원을 인가해주면 라즈베리 파이가 라즈비안으로
부팅됩니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18</title>
      <link>/post/lkml_news_v4.18/</link>
      <pubDate>Mon, 13 Aug 2018 10:50:27 +0900</pubDate>
      <guid>/post/lkml_news_v4.18/</guid>
      <description>&lt;h2 id=&#34;linux-418&#34;&gt;Linux 4.18&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자, 오랫만에 rc 버전을 8개나 내며 긴 안정화 기간을 거친 4.18 버전이 릴리즈
되었습니다.  따라서 지난주는 조용해야 했고 실제로 조용했지만 그럼에도 불구하고
vfs 레이스 컨디션 문제 수정 등의 변경도 있긴 했습니다.  이번 정식 릴리즈로
포함된 기능 중 개인적으로는 Restartable Sequence 가 눈에 띄고 흥미롭군요.  아마
2015년? 인가에 서울에서 커널 서밋 열려서 거기서 발표 들었을 때부터
관심있었거든요.  유저스페이스에서 이 기능을 잘 사용하면 멀티코어 성능확장성에
큰 개선이 가능할 것 같습니다.&lt;/p&gt;
&lt;p&gt;어쨌건, 이로써 4.19 버전을 향한 머지 윈도우가 열렸습니다.  5.x 는 언제
시작되려나요?&lt;/p&gt;
&lt;h2 id=&#34;git-pull-xarray-for-419&#34;&gt;[GIT PULL] XArray for 4.19&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180813161357.GB1199@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20180813161357.GB1199@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 몇번 소개한 XArray 의 개발자, Matthew 가 충분히 리뷰도 받고
수정도 했다고 생각하는 것 같습니다.  4.18 릴리즈와 함께 열린 4.19 머지윈도우에
XArray 풀리퀘스트를 리누스 토발즈에게 던졌군요!&lt;/p&gt;
&lt;p&gt;이 풀리퀘스트는 XArray 의 구현과 &lt;code&gt;pagecache&lt;/code&gt; 가 XArray 를 사용하도록 하는
변경을 담고 있습니다.&lt;/p&gt;
&lt;p&gt;그러나, 리눅스는 이 패치셋을 받아들이지 않기로 결정했습니다.  XArray 자체에
문제가 있어서느 아니고, 이 패치셋이 &lt;code&gt;libnvdimm&lt;/code&gt; 소스트리 위에서 만들어졌기
때문입니다.  &lt;code&gt;-next&lt;/code&gt; 트리 관리자가 그렇게 하자고 조언한 것 같은데, 어쨌든
Mattew 에겐 안됐지만 다음 버전에서 머지되길 기대해야겠군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v3-03-docscoreapi-add-memory-allocation-guide&#34;&gt;[PATCH v3 0/3] docs/core-api: add memory allocation guide&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1534517236-16762-1-git-send-email-rppt@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1534517236-16762-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;메모리 관리쪽 커널 문서가 지속적으로 업데이트 되고 있습니다.  개인적으로는
커널을 공부할 때 공식 문서를 선호하는 편이라 반가운 일이군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.18-rc8</title>
      <link>/post/lkml_news_v4.18-rc8/</link>
      <pubDate>Mon, 06 Aug 2018 17:53:02 +0900</pubDate>
      <guid>/post/lkml_news_v4.18-rc8/</guid>
      <description>&lt;h2 id=&#34;linux-418rc8&#34;&gt;Linux 4.18-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;원래대로라면 오늘 4.18 정식 릴리즈가 있어야 했지만, 지난주 동안 여러 일이
있었고, 결국 여덟번째 rc 버전이 나오고 말았습니다.  VM 쪽 이슈가 큰 이유였고,
그것만 문제였으면 그냥 정식 릴리즈를 하려 했지만 네트워킹 쪽에서도 뒤늦은
문제가 터지고 VFS 쪽에도 이슈가 있었던 관계로 정식 릴리즈를 미루기로 결심했다고
합니다.&lt;/p&gt;
&lt;p&gt;8월에 휴가를 많이 떠나는 유럽 개발자들을 고려해서 토발즈는 휴가가 예정되어
있다면 그냥 원래 예상된 스케쥴대로 이번주부터 머지 윈도우 열렸다고 생각하고
풀리퀘스트 보내고 휴가 가라고 대인배라면 대인배 같은 면모를 보이는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-rfc-0010-introduce-lockless-shrinkslab&#34;&gt;[PATCH RFC 00/10] Introduce lockless shrink_slab()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/153365347929.19074.12509495712735843805.stgit@localhost.localdomain&#34;&gt;https://lkml.kernel.org/r/153365347929.19074.12509495712735843805.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 이야기 했던 &amp;ldquo;Improve shrink_slab() scalability&amp;hellip;&amp;rdquo; 패치의 머지
후, 성능 병목 지점이 &lt;code&gt;shrink_lab()&lt;/code&gt; 에서 &lt;code&gt;down_read_trylock()&lt;/code&gt; 으로
넘어갔습니다!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     &amp;gt; I created 255 memcgs, 255 ext4 mounts and made each memcg create a
     &amp;gt; file containing few KiBs on corresponding mount. Then in a separate
     &amp;gt; memcg of 200 MiB limit ran a fork-bomb.
     &amp;gt;
     &amp;gt; I ran the &amp;quot;perf record -ag -- sleep 60&amp;quot; and below are the results:
     &amp;gt; +  47.49%            fb.sh  [kernel.kallsyms]    [k] down_read_trylock
     &amp;gt; +  30.72%            fb.sh  [kernel.kallsyms]    [k] up_read
     &amp;gt; +   9.51%            fb.sh  [kernel.kallsyms]    [k] mem_cgroup_iter
     &amp;gt; +   1.69%            fb.sh  [kernel.kallsyms]    [k] shrink_node_memcg
     &amp;gt; +   1.35%            fb.sh  [kernel.kallsyms]    [k] mem_cgroup_protected
     &amp;gt; +   1.05%            fb.sh  [kernel.kallsyms]    [k] queued_spin_lock_slowpath
     &amp;gt; +   0.85%            fb.sh  [kernel.kallsyms]    [k] _raw_spin_lock
     &amp;gt; +   0.78%            fb.sh  [kernel.kallsyms]    [k] lruvec_lru_size
     &amp;gt; +   0.57%            fb.sh  [kernel.kallsyms]    [k] shrink_node
     &amp;gt; +   0.54%            fb.sh  [kernel.kallsyms]    [k] queue_work_on
     &amp;gt; +   0.46%            fb.sh  [kernel.kallsyms]    [k] shrink_slab_memcg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 패치셋은 계속해서 &lt;code&gt;shrink_slab()&lt;/code&gt; 의 멀티코어 성능 확장성을 위해 lock 을
사용하지 않게끔 경로를 최적화 하고 있습니다.&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;shrink_slab()&lt;/code&gt; 과 &lt;code&gt;unregister_shrinker()&lt;/code&gt; 사이의 동기화에 SRCU 를
사용하고, 그럴 수 없는 경우에는 &lt;code&gt;percpu_rw_semaphore&lt;/code&gt; 를 사용합니다.  그리고
&lt;code&gt;shrinker_rwsem&lt;/code&gt; 을 뮤텍스로 교체합니다.&lt;/p&gt;
&lt;p&gt;SRCU 를 사용함으로 인해 커널 바이너리 사이즈가 커지는 문제가 있는데, 과거에도
비슷한 시도가 이런 이유로 취소된 적 있었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Kernel Performance (LKP) Tests</title>
      <link>/post/lkp-tests/</link>
      <pubDate>Thu, 02 Aug 2018 17:20:10 +0900</pubDate>
      <guid>/post/lkp-tests/</guid>
      <description>&lt;p&gt;리눅스 커널의 개발은 커뮤니티 주도입니다.  개발의 한 부분인 테스트 역시
커뮤니티 주도적입니다.  여러 개인 또는 단체가 커널을 각자의 방식으로 테스트
하고 그 결과를 공유합니다.  인텔에서는 0-day 서비스[1] 라는 서비스를 자체적으로
돌리는데, 이 서비스는 최신 리눅스 커널을 가져다가 빌드하고 다양한 기능 / 성능
테스트를 돌리고 그 결과 발견된 regression 을 LKML 에 메일로 보내주는 일을
합니다.  말하자면 Continuous Integration (CI) 이죠.&lt;/p&gt;
&lt;p&gt;Linux Kernel Performance (LKP) Tests[2] 는 0-day 서비스에서 기능 / 성능 테스트를
수행하는데 사용되는 도구입니다.  다양한 테스트를 돌리기 위한 시스템 환경 구성,
테스트 프로그램과 그 종속 프로그램 / 라이브러리의 설치와 환경 구성, 테스트
수행과 결과 정리, 그리고 테스트 진행 사이의 시스템 상태 프로파일링 및
프로파일링 결과 정리를 대신해 줍니다.  0-day 서비스에 연결되어 있지만 lkp-tests
와 0-day 서비스 사이의 종속성이 없으며, 오픈소스 프로젝트로 개발이 진행되고
있어 그 소스코드를 누구나 사용할 수 있으며 개인이 사용하기에도 편리하게 되어
있어서 개인 개발자가 자신의 패치를 테스트할 목적으로 사용하기에도 좋습니다.  이
글에서는 이러한 lkp-tests 의 구조와 사용법을 간단히 설명합니다.  전체적으로
인텔의 관련 블로그 글[3] 을 참고했습니다.&lt;/p&gt;
&lt;h1 id=&#34;heading&#34;&gt;설치&lt;/h1&gt;
&lt;p&gt;먼저 다음 커맨드로 lkp-tests 소스코드를 얻어옵니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/intel/lkp-tests
$ cd lkp-tests
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;그리고 lkp-tests 자체를 설치.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 커맨드는 단순히 지금 소스코드를 땡겨온 lkp-tests 소스코드 디렉토리의
&lt;code&gt;bin/lkp&lt;/code&gt; 파일을 링크하는 &lt;code&gt;/usr/local/bin/lkp&lt;/code&gt; 심볼릭 링크를 만들 뿐입니다.
따라서 셸에서 &lt;code&gt;lkp&lt;/code&gt; 커맨드를 쓸 수 있게 해주죠.  이 &lt;code&gt;lkp&lt;/code&gt; 파일이 결국 lkp-tests
의 대부분의 일을 해주는 핵심 커맨드입니다.  이 프로그램의 간단한 사용법은
다음과 같이 확인할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ lkp
Usage: lkp &amp;lt;command&amp;gt; [options]

INSTALLATION

        install JOB                     install binary dependencies for JOB

JOB

        split JOB                       split JOB matrix
        compile JOB                     compile JOB into shell script

TESTING

        run JOB                         run test JOB locally
        qemu JOB                        run test JOB in QEMU virtual machine

RESULT

        result|rt|_rt|__rt PATTERNs     show result dirs
        ls|ll PATTERNs                  ls result dirs
        rm-path result                  remove result dirs
        _rm PATTERNs                    remove _result dirs

        stat [options]                  show result stats
        compare [options]               compare result stats

DEBUG

        irb                             run irb with lib/*.rb loaded
        pry                             run pry with lib/*.rb loaded

More commands can be found in /home/sjpark/lkp-tests/{bin,sbin,tools}/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;여기서 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 는 lkp-tests 소스코드 디렉토리 아래 &lt;code&gt;bin/&lt;/code&gt;, &lt;code&gt;sbin/&lt;/code&gt;,
&lt;code&gt;tools/&lt;/code&gt;, 또는 &lt;code&gt;lkp-exec/&lt;/code&gt; 아래 위치한 실행파일로, &lt;code&gt;lkp&lt;/code&gt; 는 단순히 그
실행파일을 수행하면서 인자를 넘길 뿐입니다.&lt;/p&gt;
&lt;h1 id=&#34;---&#34;&gt;테스트에 필요한 소프트웨어 설치&lt;/h1&gt;
&lt;p&gt;다음 커맨드는 lkp-tests 가 의존하고 있는 기본적 소프트웨어 패키지들을 모두
설치합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo lkp install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ubuntu 16.04 에서는 다음 패키지들을 까는군요:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bc gawk gzip kmod time automake bison bsdtar build-essential bzip2
ca-certificates cpio fakeroot flex gcc git libc6-dev libc6-dev:i386
libklibc-dev libtool linux-libc-dev linux-libc-dev:i386 linux-tools-generic
make openssl patch rsync ruby ruby-dev wget
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;lkptests---&#34;&gt;lkp-tests 내부 벤치마크 실행&lt;/h1&gt;
&lt;p&gt;이제 lkp-tests 에서 지원하는 벤치마크를 실제로 돌려봅시다.&lt;/p&gt;
&lt;h2 id=&#34;----&#34;&gt;테스트 수행에 필요한 환경 설정&lt;/h2&gt;
&lt;p&gt;실제 테스트를 돌리기 위해선 벤치마크를 깔고, 그 벤치마크가 사용하는 패키지를
깔고, 테스트에 사용될 도구들을 깔고, 여러 설정을 하는등의 작업이 필요합니다.&lt;/p&gt;
&lt;p&gt;다음 명령은 lkp-tests 에서 ebizzy 라는 벤치마크를 사용하는 테스트를 위해
필요한 프로그램들을 설치하고 수행 환경을 준비합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo lkp install jobs/ebizzy.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;job&#34;&gt;job&lt;/h2&gt;
&lt;p&gt;lkp-tests 에서 테스트 수행의 기본 단위는 &lt;code&gt;job&lt;/code&gt; 이라고 이야기 하는데, &lt;code&gt;jobs/&lt;/code&gt;
디렉토리 아래에 각 job 을 설명한 yaml 파일이 있습니다.  위의 커맨드에서 인자로
넣은 &lt;code&gt;ebizzy.yaml&lt;/code&gt; 은 ebizzy 를 사용한 테스트에 필요한 사항들이 들어있습니다.
이 커맨드는 내부적으로 이 테스트에 필요한 패키지를 설치하고 ebizzy 벤치마크도
소스코드를 인터넷에서 받아다가 컴파일해 설치합니다.&lt;/p&gt;
&lt;p&gt;Job 파일은 또한 해당 테스트가 어떤 시스템 환경들에서 어떤 벤치마크를 어떤
인자를 줘가며 수행해야할지 등에 대한 내용을 담고 있습니다.  예컨대
&lt;code&gt;jobs/aim7-fs-1brd.yaml&lt;/code&gt; job 은 &lt;code&gt;xfs&lt;/code&gt;, &lt;code&gt;ext4&lt;/code&gt;, &lt;code&gt;btrfs&lt;/code&gt;, &lt;code&gt;f2fs&lt;/code&gt; 파일 시스템
각각에 대해 aim7 을 돌려보도록 되어 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;-&#34;&gt;테스트 수행&lt;/h2&gt;
&lt;p&gt;다음 명령은 ebizzy job 으로 기술된 테스트를 실제 수행시킵니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo lkp run jobs/ebizzy.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;job-&#34;&gt;job 쪼개기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ebizzy.yaml&lt;/code&gt; 은 시스템 소유 CPU 코어 갯수 2배 갯수의 쓰레드를 사용해 ebizzy 를
10초간 돌리는 실험을 100번 반복하도록 되어 있습니다.  즉, 실험의 경우의 수가
하나입니다.  그러나, 앞서 설명한 &lt;code&gt;aim7-fs-1brd&lt;/code&gt; 와 같이 다양한 구성을 사용하게
되어 있는 경우, 한가지 구성에 대해서만 반복 실험을 하고 싶을 수 있을 겁니다.
이런 경우 다음 명령으로 job 을 쪼갤 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo lkp split jobs/ebizzy.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 커맨드는 인자로 넣은 job 파일을 쪼개서 현재 디렉토리에 쪼개진 job 파일들을
저장합니다.  어떤 구성이 쪼개졌는지는 파일 이름으로 볼 수 있습니다.
&lt;code&gt;ebizzy.yaml&lt;/code&gt; 을 쪼개면 &lt;code&gt;ebizzy-200%-100x-10s.yaml&lt;/code&gt; 라는 이름의 한개의 job
파일이 생성됩니다.  앞서 이야기한 &lt;code&gt;aim7-fs-1brd.yaml&lt;/code&gt; 을 쪼개면 다음과 같이
많은 수의 job 이 생성됩니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;aim7-fs-1brd-1BRD_48G-btrfs-creat-clo-4.yaml
aim7-fs-1brd-1BRD_48G-f2fs-creat-clo-1500.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_cp-1500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_cp-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_rd-9000.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_rd-9000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_rr-1500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_rr-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_rw-1500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_rw-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_src-500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_src-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-disk_wrt-1500.yaml
aim7-fs-1brd-1BRD_48G-f2fs-disk_wrt-3000.yaml
aim7-fs-1brd-1BRD_48G-btrfs-sync_disk_rw-10.yaml
aim7-fs-1brd-1BRD_48G-f2fs-sync_disk_rw-600.yaml
aim7-fs-1brd-1BRD_48G-ext4-creat-clo-1000.yaml
aim7-fs-1brd-1BRD_48G-xfs-creat-clo-1500.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_cp-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_cp-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_rd-9000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_rd-9000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_rr-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_rr-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_rw-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_rw-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_src-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_src-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-disk_wrt-3000.yaml
aim7-fs-1brd-1BRD_48G-xfs-disk_wrt-3000.yaml
aim7-fs-1brd-1BRD_48G-ext4-sync_disk_rw-600.yaml
aim7-fs-1brd-1BRD_48G-xfs-sync_disk_rw-600.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;--&#34;&gt;테스트 결과 확인&lt;/h1&gt;
&lt;p&gt;테스트에 사용된 벤치마크 수행의 결과와 테스트 동안의 시스템 프로파일링 결과는
&lt;code&gt;/lkp/result/&lt;/code&gt; 디렉토리 밑에 &lt;code&gt;&amp;lt;job name&amp;gt;/&amp;lt;configuration&amp;gt;/&amp;lt;host name&amp;gt;/&amp;lt;os distribution name&amp;gt;/&amp;lt;kernel config&amp;gt;/&amp;lt;gcc version&amp;gt;/&amp;lt;kernel version&amp;gt;/&amp;lt;unique id&amp;gt;&lt;/code&gt;
의 계층 구조로 저장됩니다.  또한, 이 실험 결과를 parsing 할 수 있는 경우엔
&lt;code&gt;.json&lt;/code&gt; 파일을 만들어 줘서 parsing 된 결과 값도 보여줍니다.&lt;/p&gt;
&lt;p&gt;또한, 최근의 테스트 결과는 테스트 돌린 디렉토리에 &lt;code&gt;result/&lt;/code&gt; 라는 이름의,
&lt;code&gt;/lkp/result/&lt;/code&gt; 아래 해당 디렉토리로의 심볼릭 링크를 만들어 줍니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;이렇게 lkp-tests 가 무엇인지, 그리고 어떻게 사용할 수 있는지 알아봤습니다.
이제, 리눅스 커널 개발 커뮤니티에서 사용하는 리그레션 테스트를 여러분의
환경에서도 손쉽게 돌려볼 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://01.org/lkp/documentation/0-day-test-service&#34;&gt;https://01.org/lkp/documentation/0-day-test-service&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://github.com/intel/lkp-tests&#34;&gt;https://github.com/intel/lkp-tests&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://01.org/blogs/jdu1/2017/lkp-tests-linux-kernel-performance-test-and-analysis-tool&#34;&gt;https://01.org/blogs/jdu1/2017/lkp-tests-linux-kernel-performance-test-and-analysis-tool&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;https://wiki.archlinux.org/index.php/makepkg&#34;&gt;https://wiki.archlinux.org/index.php/makepkg&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Release History</title>
      <link>/post/linux_release_history/</link>
      <pubDate>Mon, 30 Jul 2018 09:14:08 +0900</pubDate>
      <guid>/post/linux_release_history/</guid>
      <description>&lt;h2 id=&#34;linux-419rc2&#34;&gt;Linux 4.19-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyG0GbDfoghEhAmKBPcZCiPu6CCpPRz9GwjCzLuP_Vv5Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018-09-02 14:45 PDT&lt;/p&gt;
&lt;h2 id=&#34;linux-419rc1&#34;&gt;Linux 4.19-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw9mxNPX6OtOp-aoUMdXSg=gBkQudGGamo__sh_ts_LdQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFw9mxNPX6OtOp-aoUMdXSg=gBkQudGGamo__sh_ts_LdQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018-08-26 14:49 PDT&lt;/p&gt;
&lt;h2 id=&#34;linux-418&#34;&gt;Linux 4.18&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzos7tr=OLju10Oe-z7r=eB2dSaFa7vwz2ApGO13B=z_g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018-08-12 14:10:49 PDT&lt;/p&gt;
&lt;h2 id=&#34;linux-418rc8&#34;&gt;Linux 4.18-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFw49Bh9u3KvGsMbnSLfHvevpWPuqgrWQT0tC0XCajNwzA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018-08-05 12:58 PDT&lt;/p&gt;
&lt;h2 id=&#34;linux-418rc7&#34;&gt;Linux 4.18-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018-07-29 22:09 UTC&lt;/p&gt;
&lt;h2 id=&#34;linux-418rc6&#34;&gt;Linux 4.18-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018-07-23 20:46 UTC&lt;/p&gt;
&lt;h2 id=&#34;linux-418rc5&#34;&gt;Linux 4.18-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018-07-15 20:28 UTC&lt;/p&gt;
&lt;h2 id=&#34;linux-418rc4&#34;&gt;Linux 4.18-rc4&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lore.kernel.org/lkml/CA+55aFwXGyZ1Yx+Z8a93gpvb596ZRJ5ppiQL_+-k7gjeQLtcsQ@mail.gmail.com/T/#u&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2018-07-08 23:57 UTC&lt;/p&gt;
&lt;h2 id=&#34;linux-418rc3&#34;&gt;Linux 4.18-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwGk-pWKKCtp+kQUN_hov9tW+vUo6Wgob91bewwBL17fA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwGk-pWKKCtp+kQUN_hov9tW+vUo6Wgob91bewwBL17fA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018-07-01 23:46 UTC&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.18-rc7</title>
      <link>/post/lkml_news_v4.18-rc7/</link>
      <pubDate>Mon, 30 Jul 2018 08:49:12 +0900</pubDate>
      <guid>/post/lkml_news_v4.18-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-418rc7&#34;&gt;Linux 4.18-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxpFefwVdTGVML99PSFUqwpJXPx5LVCA3D=g2t2_QLNsA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 릴리즈입니다.  별다른 일 없으면 다음주에 4.18이 릴리즈 되겠다고
토발즈도 이야기 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-06-kmallocreclaimable-caches&#34;&gt;[PATCH v4 0/6] kmalloc-reclaimable caches&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180731090649.16028-1-vbabka@suse.cz&#34;&gt;https://lkml.kernel.org/r/20180731090649.16028-1-vbabka@suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;내부적으로 SLAB 할당자를 사용하는 kmem cache 들은 &lt;code&gt;SLAB_RECLAIM_ACCOUNT&lt;/code&gt;
플래그를 가지고 생성될 경우에 시스템 메모리가 부족한 경우 기존에 할당받은
오브젝트들을 회수해도 좋다고 알리게 됩니다.&lt;/p&gt;
&lt;p&gt;일반적인 kmem cache 들은 이 플래그 없이 생성되서는 시스템의 메모리가 부족한
경우에 회수되어도 좋은 오브젝트의 할당에 사용되기도 하는데, 다양한 크기의
오브젝트들은 &lt;code&gt;SLAB_RECLAIM_ACCOUNT&lt;/code&gt; 플래그를 가진 하나의 kmem cache 에서 처리될
수 없기 때문이죠.  &lt;code&gt;dcache&lt;/code&gt; 의 &lt;code&gt;external name&lt;/code&gt; 들이 그 예입니다.&lt;/p&gt;
&lt;p&gt;이와 비슷한 경우들을 해결하기 위해 이 패치셋은 kmalloc cache 에
SLAB_RECLAIM_ACCOUNT  와 비슷한 특성을 갖는 변종을 kmalloc-rcl-x 라는 이름으로
만들었습니다.  kmalloc() 시에 &lt;code&gt;__GFP_RECLAIMABLE&lt;/code&gt; 플래그를 넣으면 이 캐시에서
메모리가 할당됩니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-swap-use-trytoreclaimswap-in-freeswapandcache&#34;&gt;&lt;code&gt;[PATCH] swap: Use __try_to_reclaim_swap() in free_swap_and_cache()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180803123014.15431-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180803123014.15431-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;스왑 엔트리를 회수하는 코드 경로는 &lt;code&gt;free_swap_and_cache()&lt;/code&gt; 가 있고
&lt;code&gt;__try_to_reclaim_swap()&lt;/code&gt; 이 있는데, 코딩 스타일 빼고는 실제 하는 일이 거의
똑같습니다.  이 패치는 &lt;code&gt;free_swap_and_cache()&lt;/code&gt; 에서 내부적으로
&lt;code&gt;__try_to_reclaim_cache()&lt;/code&gt; 를 사용하게 함으로써 코드의 가독성을 높이고 잠재적
버그를 줄였습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.18-rc6</title>
      <link>/post/lkml_news_v4.18-rc6/</link>
      <pubDate>Tue, 24 Jul 2018 06:19:53 +0900</pubDate>
      <guid>/post/lkml_news_v4.18-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-418rc6&#34;&gt;Linux 4.18-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzMheDA-2z=MdGgJrz-REcrknb+4OEvRKaJipm+x6xEhw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 rc는 평소보다 조금 크게 되었는데, 네트워킹 쪽 메인테이너인 David 가 많은
수정사항을 아직 보내지 않았다가 이번에 모아서 보냈기 때문이라는군요.  그렇다
해도 그렇게 큰 양까진 아니라는 토발즈의 설명입니다.&lt;/p&gt;
&lt;p&gt;지난 rc5 작업 주간을 귀찮게 했던 VM 버그에 대한 두줄의 수정이 rc5 에
들어갔었지만 32비트 환경에 대한 고려가 없었기에 이번에 그 수정이
들어갔다는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-07-memory-management-documentation-updates&#34;&gt;[PATCH 0/7] memory management documentation updates&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1532517970-16409-1-git-send-email-rppt@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1532517970-16409-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;메모리 관리 부분 문서화 업데이트입니다.  sphinx 기반 문서화 업데이트를 일부
메인테이너들은 반기지 않는 것도 사실이지만, 확실히 가독성이 좋아진 덕에 이런
문서화 노력이 더 활발해 지는 것 아닌가 하는 생각도 드는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Alpine for LKML</title>
      <link>/post/alpine-for-lkml/</link>
      <pubDate>Wed, 18 Jul 2018 21:09:54 +0900</pubDate>
      <guid>/post/alpine-for-lkml/</guid>
      <description>&lt;p&gt;리눅스 커널 커뮤니티는 버그 레포팅, 패치 업로드, 리뷰, 릴리즈, 토론 등등 모든
활동은 이메일을 통해 이루어집니다.  이 포스트에서는 리누스 토발즈도 쓰는 이메일
클라이언트인 Alpine 을 gmail 과 연동하는 방법을 알아봅니다.&lt;/p&gt;
&lt;p&gt;먼저 alpine 설치는 대부분 리눅스 배포판의 패키지 시스템에 등록되어 있으므로
해당 패키지 시스템을 사용해 쉽게 설치할 수 있습니다.  데비안 계열이면 &lt;code&gt;apt install alpine&lt;/code&gt;, 페도라 계열이면 &lt;code&gt;dnf install alpine&lt;/code&gt; 이죠.&lt;/p&gt;
&lt;h1 id=&#34;gmail-imap--&#34;&gt;gmail imap 정보 입력&lt;/h1&gt;
&lt;p&gt;S (Settings) -&amp;gt; L (collectionLists) -&amp;gt; A (Add Cltn)&lt;/p&gt;
&lt;p&gt;Nickname: gmail or anything
Server: &lt;a href=&#34;mailto:imap.gmail.com/ssl/user=sj@gmail.com&#34;&gt;imap.gmail.com/ssl/user=sj@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;^X (Commit change)
E (Exit Setup)&lt;/p&gt;
&lt;h1 id=&#34;smtp--&#34;&gt;SMTP 서버 설정&lt;/h1&gt;
&lt;p&gt;S (Setup) -&amp;gt; C (config)&lt;/p&gt;
&lt;p&gt;SMTP server: &lt;a href=&#34;mailto:smtp.gmail.com/tls/user=sj@gmail.com&#34;&gt;smtp.gmail.com/tls/user=sj@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;--&#34;&gt;쓰레드 기반 소팅&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;[Sort key]&lt;/code&gt;: tHread (enter)&lt;/p&gt;
&lt;h2 id=&#34;----&#34;&gt;리눅스 커널 커뮤니티에서 요구하는 설정&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;[Sending Preferences]&lt;/code&gt;: Do Not Send Flowed Text, Strip Whitespace Before Sending&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://harbhag.wordpress.com/2010/07/14/configure-alpine-to-sendreceive-emails-from-gmail/&#34;&gt;https://harbhag.wordpress.com/2010/07/14/configure-alpine-to-sendreceive-emails-from-gmail/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc5</title>
      <link>/post/lkml_news_v4.18-rc5/</link>
      <pubDate>Mon, 16 Jul 2018 06:07:33 +0900</pubDate>
      <guid>/post/lkml_news_v4.18-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-418rc5&#34;&gt;Linux 4.18-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwfMr2D2A_yesUyt_Lo3XMRk9epzgeBMt2HxMHiXMDYcg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다섯번째 rc 릴리즈입니다.  토발즈 개인적으로는 조금 바쁘단 느낌이 있었지만
숫자로 보면 평범한 rc 릴리즈 주간이었다는 평입니다.&lt;/p&gt;
&lt;p&gt;토발즈를 귀찮게 만들었던 건 VM 쪽 버그로, 단 두줄의 수정으로 고쳐졌다는데,
아무래도 아래 패치인 것 같군요:
&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bce73e4842390f7b7309c8e253e139db71288ac3&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bce73e4842390f7b7309c8e253e139db71288ac3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그리고 repeatable sequence 에 대한 cleanup 도 있었군요.&lt;/p&gt;
&lt;h2 id=&#34;git-pull-rcunext-rcu-commits-for-419&#34;&gt;[GIT PULL rcu/next] RCU commits for 4.19&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180716175125.GA4287@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180716175125.GA4287@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.19 리눅스 릴리즈를 위한 RCU 쪽 변경사항들 pull request 입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc4</title>
      <link>/post/lkml_news_v4.18-rc4/</link>
      <pubDate>Mon, 09 Jul 2018 10:01:05 +0900</pubDate>
      <guid>/post/lkml_news_v4.18-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-418rc4&#34;&gt;Linux 4.18-rc4&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CA+55aFwXGyZ1Yx+Z8a93gpvb596ZRJ5ppiQL_+-k7gjeQLtcsQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;어느덧 네번째 RC 버전 릴리즈입니다.  지루할 정도로 평범한 릴리즈라는군요.
대부분 드라이버쪽 업데이트이고, bpf, cifs, ext4, 스케쥴러, 그리고 일부 arch
업데이트가 대부분입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v9-0017-improve-shrinkslab-scalability-old-complexity-was-on2-new-is-on&#34;&gt;[PATCH v9 00/17] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/153112469064.4097.2581798353485457328.stgit@localhost.localdomain&#34;&gt;https://lkml.kernel.org/r/153112469064.4097.2581798353485457328.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shrink_slab()&lt;/code&gt; 의 compexity 를 O(n^2) 에서 O(n) 으로 낮춰 확장성을 높인 패치의
아홉번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-cma-remove-unsupported-gfp-mask-parameter&#34;&gt;[PATCH 0/2] CMA: remove unsupported gfp mask parameter&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180709122018eucas1p277147b1e6385d552b5a8930d0a8ba91c~-sqSan6292733527335eucas1p2-@eucas1p2.samsung.com&#34;&gt;https://lkml.kernel.org/r/20180709122018eucas1p277147b1e6385d552b5a8930d0a8ba91c~-sqSan6292733527335eucas1p2-@eucas1p2.samsung.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cma_alloc()&lt;/code&gt; 과 &lt;code&gt;dma_alloc_from_contiguous()&lt;/code&gt; 함수는 gfp mask 패러미터를
받지만 실질적으론 &lt;code&gt;__GFP_NORARN&lt;/code&gt; 플래그만을 지원하고 있습니다.  이 패치는
따라서 해당 패러미터를 &lt;code&gt;no_warn&lt;/code&gt; 이란 이름의 boolean 타입으로 교체합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-mm-pagealloc-double-zones-batchsize&#34;&gt;[RFC PATCH] mm, page_alloc: double zone&#39;s batchsize&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180711055855.29072-1-aaron.lu@intel.com&#34;&gt;https://lkml.kernel.org/r/20180711055855.29072-1-aaron.lu@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널 페이지 할당자는 잘 알려진 Buddy allocator 입니다만, 멀티 CPU
환경에서의 컨텐션을 줄이기 위해 per-CPU pageset 이란 걸 존별로 가지고 있어서
Buddy allocator 로부터는 한번에 듬뿍 페이지를 할당받아와 CPU 별 pageset 에
넣어두고서 여기서 한동안 할당받고, 이게 텅 비었을 때 buddy allocator 에게 다시
여러개 page 를 할당받습니다.  이런 형태를 batching 이라고 하죠.&lt;/p&gt;
&lt;p&gt;이 batch 크기, 즉 한번에 buddy allocator 에서 할당받는 페이지의 갯수는 적정해야
합니다.  이 값이 10년전에 두배로 커져 31이 된 후 유지되고 있습니다.  따라서
오늘날에는 이 값이 너무 작다는 생각이 있어 다시 한번 두배로 늘리는 (31에서 63
으로) 패치입니다.&lt;/p&gt;
&lt;p&gt;will-it-scale/page_fault1, ebizzy, oltp, kbuild, pigz, netperf, vm-scalability
등의 벤치마크를 사용했군요.&lt;/p&gt;
&lt;p&gt;전체적으로 성능 향상이 있었지만 batch 크기가 커진만큼 실제 buddy allocator 에게
할당을 요청할 때 반응시간이 느려지는 문제가 있긴 합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-kvmx86-inform-rcu-of-quiescent-state-when-entering-guest-mode&#34;&gt;[PATCH v2] kvm/x86: Inform RCU of quiescent state when entering guest mode&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180711180101.3711464-1-dwmw2@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180711180101.3711464-1-dwmw2@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU reader critical section 은 가능한 빨리 끝나야 합니다.  그렇지 않으면 grace
period 가 길어져 시스템 메모리 사용량이 늘어날 수 있죠.  RCU reader critical
section 내에서의 sleeping 을 하지 못하게 함으로써 리눅스 커널은 이를 가능하게
합니다만, VM 환경에서는 reader critical section 내에서 VM 자체가 CPU 를 놓을 수
있으므로 critical section 이 길어지는 문제가 가능합니다.  이 패치는 guest mode
에 들어갈 때 이에 관한 정보를 알림으로써 이 문제를 해결할 수 있게 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc3</title>
      <link>/post/lkml_news_v4.18-rc3/</link>
      <pubDate>Mon, 02 Jul 2018 11:18:24 +0900</pubDate>
      <guid>/post/lkml_news_v4.18-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-418rc3&#34;&gt;Linux 4.18-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwGk-pWKKCtp+kQUN_hov9tW+vUo6Wgob91bewwBL17fA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwGk-pWKKCtp+kQUN_hov9tW+vUo6Wgob91bewwBL17fA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.18 을 향하는 세번째 릴리즈입니다.  그간 일본에 중국을 방문하고 있던 토발즈가
집에 돌아와서 이번엔 평소처럼 한국시간으로는 월요일 아침 릴리즈가 되었군요.&lt;/p&gt;
&lt;p&gt;큰 이상은 없고 드라이버, arch, 파일시스템 등에 변경이 있군요.&lt;/p&gt;
&lt;p&gt;그리고, 오늘이 리누스 토발즈가 리눅스 파운데이션 소속으로 일하게 된지
15주년이라는군요.  리눅스 파운데이션도 리눅스도 오래오래 건강했으면 좋겠습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-02-x86numaemulation-introduce-uniform-split-capability&#34;&gt;[PATCH v2 0/2] x86/numa_emulation: Introduce uniform split capability&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/153089327581.27680.11402583130804677094.stgit@dwillia2-desk3.amr.corp.intel.com&#34;&gt;https://lkml.kernel.org/r/153089327581.27680.11402583130804677094.stgit@dwillia2-desk3.amr.corp.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;X86 에서는 커널 패러미터를 줘서 NUMA emulation 이 가능한데, 각 NUMA node 의
메모리 사이즈를 모두 똑같게 하기보다는 요청된 NUMA node 수를 맞추는걸 우선시
하고 있습니다.  이 패치는 해당 커널 패러미터에 &amp;lsquo;U&amp;rsquo; suffix 를 주면 사이즈를
동일하게 맞추는 걸 우선시하게 만들어주도록 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc2</title>
      <link>/post/lkml_news_v4.18-rc2/</link>
      <pubDate>Mon, 25 Jun 2018 08:45:22 +0900</pubDate>
      <guid>/post/lkml_news_v4.18-rc2/</guid>
      <description>&lt;h2 id=&#34;linux-418rc2&#34;&gt;Linux 4.18-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/alpine.LFD.2.21.999.1806242116240.20621@xps13.linux-foundation.org&#34;&gt;https://lkml.kernel.org/r/alpine.LFD.2.21.999.1806242116240.20621@xps13.linux-foundation.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번주도 지난주처럼 평소보단 빠른 릴리즈입니다.  토발즈가 여전히
여행중이라는군요.  지난주엔 일본이었고, 이번주는 중국이라는군요.  그런고로 중국
시간으로 일요일 저녁의 rc 릴리즈입니다.&lt;/p&gt;
&lt;p&gt;이번 rc 에서도 큰 변경은 없고 평범한 rc 입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-040-rcu-gpseq-conversion-for-v419&#34;&gt;[PATCH tip/core/rcu 0/40] RCU -&amp;gt;gp_seq conversion for v4.19&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180626000841.GA15696@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180626000841.GA15696@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 의 &lt;code&gt;-&amp;gt;gpnum&lt;/code&gt; 과 &lt;code&gt;-&amp;gt;completed&lt;/code&gt; 필드를 하나의 &lt;code&gt;-&amp;gt;gp_seq&lt;/code&gt; 로 대체하는
패치입니다.  그동안 &lt;code&gt;-&amp;gt;gpnum&lt;/code&gt; 과 &lt;code&gt;-&amp;gt;completed&lt;/code&gt; 로 grace period 를 관리해오고
있지만 사실상 &lt;code&gt;-&amp;gt;gpnum&lt;/code&gt; 과 &lt;code&gt;-&amp;gt;completed&lt;/code&gt; 는 수가 똑같거나 하나 차이이니 하나의
bit 으로도 같은 정보를 처리할 수 있을 뿐더러 로드 횟수를 두번에서 한번으로 줄일
수 있다는 거죠.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.18 Rc1</title>
      <link>/post/lkml_news_v4.18-rc1/</link>
      <pubDate>Sun, 17 Jun 2018 11:59:59 +0900</pubDate>
      <guid>/post/lkml_news_v4.18-rc1/</guid>
      <description>&lt;h2 id=&#34;linux-418rc1&#34;&gt;Linux 4.18-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFw34Dh6p0qAZ_Ja=fjuJ89ojZZTWtmrRPKmB1QuP3C7hw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFw34Dh6p0qAZ_Ja=fjuJ89ojZZTWtmrRPKmB1QuP3C7hw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;평소보다 많이 빠르게 4.18 머지윈도우가 닫혔습니다.  토발즈가 지금 일본에 있기 때문에 자기는 이미 일요일이고, 오후엔 뱃놀이 하러 갈거라서 일찍 릴리즈 한다네요.&lt;/p&gt;
&lt;p&gt;전체적으로 크기에서도 한 일에 있어서도 평범한 릴리즈입니다.  4.17 에서 더이상 사용되지 않는 과거 코드 삭제를 많이 했던 것처럼 이번에도 미사용 코드 제거가 좀 있군요, 하지만 4.17 때만큼 큰 변화는 아닙니다.&lt;/p&gt;
&lt;p&gt;제거된 컴포넌트들 가운데 특이할만한 점은 Lustre 의 제거군요.  Staging 트리에서 머물던 Lustre 는 계속 out of tree 로 개발이 진행되어왔고, Staging 딱지를 떼지 못한채 커널 소스트리에서 제거되게 되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v7-rebased-0017-improve-shrinkslab-scalability-old-complexity-was-on2-new-is-on&#34;&gt;[PATCH v7 REBASED 00/17] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/152931465724.27697.12828290733260370115.stgit@localhost.localdomain&#34;&gt;https://lkml.kernel.org/r/152931465724.27697.12828290733260370115.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난번에도 소개한 패치의 v7 입니다.  시스템에 여러 shrinker 들과 memcg cgroup
이 등록되어 있는 경우 이 shrinker 의 갯수를 n 이라 할 때 O(n^2) 의 time
complexity 로 &lt;code&gt;shrink_slab()&lt;/code&gt; 수행시간이 늘어나게 되어있는데 이 문제를 해결한
패치입니다.  이 문제를 보기 위해 다음과 같은 테스트를 사용했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$echo 1 &amp;gt; /sys/fs/cgroup/memory/memory.use_hierarchy
$mkdir /sys/fs/cgroup/memory/ct
$echo 4000M &amp;gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes
$for i in `seq 0 4000`;
        do mkdir /sys/fs/cgroup/memory/ct/$i;
        echo $$ &amp;gt; /sys/fs/cgroup/memory/ct/$i/cgroup.procs;
        mkdir -p s/$i; mount -t tmpfs $i s/$i; touch s/$i/file;
done
$time echo 3 &amp;gt; /proc/sys/vm/drop_caches
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ct/0 부터 ct/4000 까지 4001개의 메모리 cgroup 들을 만들어 놓고 tmpfs 를 만든 후
거기 파일을 만들어 메모리를 소모하게 한 후 &lt;code&gt;drop_caches&lt;/code&gt; 를 통해
&lt;code&gt;shrink_slab()&lt;/code&gt; 이 발동되게 했군요.  패치 저자의 환경에서의 테스트 결과는
다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.00user 13.78system 0:13.78elapsed 99%CPU
0.00user 5.59system 0:05.60elapsed 99%CPU
0.00user 5.48system 0:05.48elapsed 99%CPU
0.00user 8.35system 0:08.35elapsed 99%CPU
0.00user 8.34system 0:08.35elapsed 99%CPU
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 패치셋은 time complexity 가 O(n) 이 되도록 합니다.  패치셋이 적용된 후의
테스트 결과는 다음과 같이 548배 이상 개선되었습니다!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.00user 1.10system 0:01.10elapsed 99%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;patch-0011-docsmm-add-boot-time-memory-management-docs&#34;&gt;[PATCH 00/11] docs/mm: add boot time memory management docs&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1529341199-17682-1-git-send-email-rppt@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1529341199-17682-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;초기 부팅 시점에서의 메모리 관리에 대한 문서화를 개선하고 이에 대한 문서를
추가하는 패치입니다.  추가된 문서는 Documentation/core-api/boot-time-mm.rst 에
있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17</title>
      <link>/post/lkml_news_v4.17/</link>
      <pubDate>Mon, 04 Jun 2018 11:29:16 +0900</pubDate>
      <guid>/post/lkml_news_v4.17/</guid>
      <description>&lt;h2 id=&#34;linux-417&#34;&gt;Linux 4.17&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxhx_tKGm02UySguvbyfB_7oTF31QfgOHCK0YkBvmfV0g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxhx_tKGm02UySguvbyfB_7oTF31QfgOHCK0YkBvmfV0g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.17 버전 리눅스 릴리즈입니다.  지난주에 토발즈가 이야기한 것처럼 별다른 지연
없이 릴리즈 되었군요.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git object&lt;/code&gt; 의 갯수라던지 릴리즈를 위한 스크립트 등이 리눅스 5.x 버전으로의
메이저 버전 업데이트가 될 준비가 되었다고 하지만 토발즈는 딱히 5.x 로 아직은
넘어갈 생각이 없군요.  너무 멀지 않은 미래에 넘어가겠지만, 적어도 지금은
아니라고 합니다.&lt;/p&gt;
&lt;p&gt;항상 그렇듯 이 릴리즈는 4.18을 위한 머지 윈도우의 시작이기도 한데, 토발즈는
두번째 주에 여행을 갈거라 가능하면 첫째주에 중요한 머지를 마무리 했으면 한다고
하네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v13-0072-convert-page-cache-to-xarray&#34;&gt;[PATCH v13 00/72] Convert page cache to XArray&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180611140639.17215-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180611140639.17215-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Radix tree 를 대체하기위한 목적으로 Matthew Wilcox 가 개발중인 XArray 의 구현과
Page cache 가 이 자료구조를 사용하도록 변경하는 패치의 13번째 버전입니다.  작년
OSSummit Europe 에서 처음 XArray 에 대한 발표를 들었는데 계속 발전중인 것
같군요.&lt;/p&gt;
&lt;h2 id=&#34;re-417-regression-performance-drop-on-kernel417-visible-on&#34;&gt;Re: [4.17 regression] Performance drop on kernel-4.17 visible on&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180607110713.GJ32433@dhcp22.suse.cz&#34;&gt;https://lkml.kernel.org/r/20180607110713.GJ32433@dhcp22.suse.cz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 대비 4.17 의 NUMA 시스템에서 Stream, Linpack, NAS 벤치마크 성능이 크게
떨어졌다는 레포트입니다.  최대 50% 까지의 성능 하락이 있었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>머신러닝 학습/실습 환경 (Jupyter Notebook &amp; Google Colab)</title>
      <link>/post/ml-study-env/</link>
      <pubDate>Mon, 28 May 2018 19:51:49 +0900</pubDate>
      <guid>/post/ml-study-env/</guid>
      <description>&lt;p&gt;이 글은 머신러닝 학습 환경으로도 널리 사용되는 Jupyter Notebook 과 Google Colab
에 대해 간단히 설명합니다.&lt;/p&gt;
&lt;h1 id=&#34;jupyter-notebook&#34;&gt;Jupyter Notebook&lt;/h1&gt;
&lt;p&gt;Jupyter Notebook [1] 은 대화형으로 프로그래밍 언어를 공부하고 실습해 볼 수
있도록 만들어진 개발 / 학습 환경입니다.  이 환경은 크게 노트북 문서, Jupyter
Notebook App, Notebook kernel, 그리고 Notebook Dashboard 로 구성됩니다.&lt;/p&gt;
&lt;h2 id=&#34;-&#34;&gt;노트북 문서&lt;/h2&gt;
&lt;p&gt;노트북 문서는 프로그램 코드 조각들과 Rich text (이걸 한글로 뭐라 해야 할지&amp;hellip;),
그리고 각 코드 조각의 수행 결과 로 구성됩니다.  백문이 불여일견, 이
&lt;a href=&#34;https://colab.research.google.com/github/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&#34;&gt;링크&lt;/a&gt;
를 따라가 보시기 바랍니다.  링크는 간단한 파이썬 교육을 위해 만들어진 노트북
문서로,  코드를 수정하고 수행해 볼 수 있습니다.  텍스트도 수정할 수 있습니다.
문서에 코드 또는 텍스트 셀을 추가해 코드 셀에는 코드를, 텍스트 셀에는 텍스트를
작성할 수 있으며, 텍스트 셀에 작성할 수 있는 텍스트는 단순한 평문이 아니라
강조, 이탤릭 등의 효과를 포함할 수 있습니다.  Jupyter Notebook 환경은 노트북
문서들을 읽어들여 Rich Text 를 저자가 의도한 모습대로 렌더링 해주고, 코드 셀을
사용자가 원하면 셀별로 수행시켜줍니다.  코드 셀의 좌측에 수행 버튼이 떠서, 이를
클릭하면 해당 셀을 수행하는 형태입니다.  문서 상의 모든 코드 셀의 일괄 수행
역시 가능합니다.  이 때, 앞서 수행된 코드 셀의 수행 결과는 다음에 수행되는 코드
셀에 영향을 끼칩니다.  예를 들어 특정 셀에서 전역 변수의 값을 변경했다면 다음에
수행하는 셀에 변경된 전역 변수의 값이 보입니다.&lt;/p&gt;
&lt;p&gt;이를 통해 Jupyter Notebook 사용자는 노트북 문서를 사용해 타인에게 학습시킬
문서를 작성하고 학습자가 곧바로 하나씩 수행해 볼 수 있게 해줄 수 있으며, 스스로
공부하는 사람도 자신이 공부한 내용을 쉽게 정리할 수 있게 해줍니다.&lt;/p&gt;
&lt;h2 id=&#34;jupyter-notebook-app&#34;&gt;Jupyter Notebook App&lt;/h2&gt;
&lt;p&gt;Jupyter Notebook App 은 Jupyter 노트북 문서를 읽어들여 작성자가 원한 모습으로
보여주고 코드의 수행 등을 대신해 주고, 또한 노트북 문서를 새로 작성할 수 있는
에디터 역할을 합니다.  서버-클라이언트 구조로 되어 있어 로컬 컴퓨터에 서버를
띄우고 웹브라우저로 접속해서 작업할 수도, 다른 컴퓨터에 띄워진 서버에
웹브라우저로 접속해 작업할 수도 있습니다.  일부 공개 Jupyter Notebook 서버도
서비스 되고 있습니다.  Google Colab 역시 그런 형태입니다.&lt;/p&gt;
&lt;p&gt;Github 은 웹인터페이스 상에서 Notebook 문서를 렌더링 해 보여주는 기능을
제공하고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;notebook-kernel--notebook-dashboard&#34;&gt;Notebook kernel 과 Notebook Dashboard&lt;/h2&gt;
&lt;p&gt;실제 코드의 수행을 담당하는게 Notebook kernel, 각 노트북 문서의 관리를 담당해
주는 인터페이스가 Dashboard 입니다.  커널은 프로그램이 언어별로 존재하며,
Jupyter Notebook 에서는 다양한 언어의 커널을 지원하고 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;google-colab&#34;&gt;Google Colab&lt;/h1&gt;
&lt;p&gt;Jupyter Notebook 은 앞서 설명했듯 자신의 컴퓨터에 설치하고 서버를 띄울수도,
다른 컴퓨터에 설치하고 서버를 띄울 수도 있습니다.  &lt;code&gt;...  as a Service&lt;/code&gt; 의
시대인 만큼, Jupyter Notebook Server 를 서비스하는 회사들이 많습니다.  Google
Colab[2] 은 그런 서비스 중 하나입니다.  이 프로젝트는 머신러닝 교육과 연구를
돕기 위해 만들어진 Google 의 연구 프로젝트로, 결국은 하나의 Jupyter notebook
환경일 뿐인데, 어떠한 셋업도 필요 없고 구글 클라우드 위에서 동작합니다.&lt;/p&gt;
&lt;p&gt;노트북 문서는 구글 드라이브에 저장하고 불러올 수 있으며, Github 에 있는 노트북
문서도 읽어올 수 있습니다.  참고로 노트북 문서는 &lt;code&gt;.ipynb&lt;/code&gt; 라는 확장자를
사용하는 텍스트 파일입니다.  Colab 에서 작성한 노트북 문서를 &lt;code&gt;.ipynb&lt;/code&gt; 확장자
파일로 곧바로 다운받을 수 있으므로 구글 드라이브로 공유하기 부담스러운 경우는
github 을 통해 공유해도 좋겠습니다.  뿐만 아니라 읽기만 하므로 다른 사람의
Jupyter Notebook 문서도 공개되어 있다면 얼마든지 불러올 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;github----&#34;&gt;Github 의 노트북 문서 불러오기&lt;/h2&gt;
&lt;p&gt;Github 의 노트북 파일을 불러오는 방법은 간단합니다.  먼저 Github 웹
인터페이스에 들어가 Google Colab 에서 읽고자 하는 문서의 github 상에서의 주소를
파악합니다.  대략
&lt;a href=&#34;https://github.com/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&#34;&gt;https://github.com/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&lt;/a&gt; 와
같은 형태가 될겁니다.  여기서 &lt;code&gt;https://&lt;/code&gt; 를 제거하고 &lt;code&gt;github.com&lt;/code&gt; 에서 &lt;code&gt;./com&lt;/code&gt;
을 제거한 후, &lt;a href=&#34;https://colab.research.google.com/&#34;&gt;https://colab.research.google.com/&lt;/a&gt; 뒤에 붙여줍니다.  그러면 대략
&lt;a href=&#34;https://colab.research.google.com/github/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&#34;&gt;https://colab.research.google.com/github/sjp38/jupyternb_hello/blob/master/jupyternb_hello.ipynb&lt;/a&gt;
같은 모습이 되겠죠.  이 주소를 웹브라우저에 입력하면, Colab 에 해당 노트북이
열리고 수행도 해볼 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;
&lt;p&gt;머신러닝 학습에 많이 사용되는 Jupyter Notebook 과 머신러닝을 위한 Jupyter
Notebook 서비스 중 하나인 Google Colab 에 대해 알아봤습니다.  저도 최근에야
알게 된 프로젝트인데, 코드와 그에 대한 설명을 정말 쉽고 효과적으로 공유할 수
있는 획기적 방법 같습니다.  다른 분야에도 널리 퍼지면 좋겠군요.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html&#34;&gt;http://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://colab.research.google.com/notebooks/welcome.ipynb&#34;&gt;https://colab.research.google.com/notebooks/welcome.ipynb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after 4.17-rc7</title>
      <link>/post/lkml_news_v4.17-rc7/</link>
      <pubDate>Mon, 28 May 2018 10:41:50 +0900</pubDate>
      <guid>/post/lkml_news_v4.17-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-417rc7&#34;&gt;Linux 4.17-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwUqz9z1Rf4Wwr29W7DeKxQ67qKEW5xty+JPyCY3aNQ=A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwUqz9z1Rf4Wwr29W7DeKxQ67qKEW5xty+JPyCY3aNQ=A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 입니다.  지난 몇주보다는 조금 변경사항이 있었지만 그렇다 해도
그렇게 심한 정도는 아니었기에 아마도 이게 마지막 rc 일 거라는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0013-introdue-iolatency-io-controller-for-cgroups&#34;&gt;[PATCH 00/13] Introdue io.latency io controller for cgroups&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180529211724.4531-1-josef@toxicpanda.com&#34;&gt;https://lkml.kernel.org/r/20180529211724.4531-1-josef@toxicpanda.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cgroup 에 응답시간 (latency) 기반의 I/O 컨트롤러를 추가하는 패치셋입니다.
Cgroup 은 용량 기반의 컨트롤러는 많지만 응답시간 기반의 컨트롤러가 부족하다고
느껴왔는데, 역시 추가되어 가는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc6</title>
      <link>/post/lkml_news_v4.17-rc6/</link>
      <pubDate>Mon, 21 May 2018 10:19:16 +0900</pubDate>
      <guid>/post/lkml_news_v4.17-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-v417rc6&#34;&gt;Linux v4.17-rc6&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CA+55aFxxYQFL3mwsQcC+__R23ZmO8c3F0SThi6r44TdK0ePNDQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;여섯번째 release candidate 버전입니다.  이번 릴리즈에도 특기할 만한 일은
없었습니다.  이제 충분히 안정화 되었을 거라고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-v3-0021-mm-thp-swap-swapoutswapin-thp-in-one-piece&#34;&gt;[PATCH -mm -V3 00/21] mm, THP, swap: Swapout/swapin THP in one piece&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180523082625.6897-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180523082625.6897-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이전에도 이 시리즈로 소개했던, THP 의 swap out 과 swap in 최적화 마지막 단계
패치의 세번째 버전입니다.  마지막 단계 이야기 하니 문득 인피니티워의 오역
논란이 떠오르는군요 ;)  두번째 버전 이후 특정 컨피규레이션에서의 빌드 버그를
수정했고, mmotm/master 브랜치의 5월 18일자 버전으로 rebase 한게 차이점의
전부군요.&lt;/p&gt;
&lt;p&gt;RAM 으로 PMEM 을 시뮬레이션 하는 환경에서 vm-scalability 라는 벤치마크를 사용해
16개 프로세스가 anonymous page 를 상당량 할당받고 반복해서 접근하는 워크로드로
성능 차이를 비교했습니다.  이로 인해 패치 전 대비 워크로드 처리량 (throughput)
이 992.8% 향상되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v3-04-fixes-cleanups-for-rcudev&#34;&gt;[PATCH v3 0/4] fixes, cleanups for rcu/dev&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180521044220.123933-1-joel@joelfernandes.org&#34;&gt;https://lkml.kernel.org/r/20180521044220.123933-1-joel@joelfernandes.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 코드의 주석, 변수 사용, 변수 이름 등의 개선 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;resend-patch-v5-0033-block-support-multipage-bvec&#34;&gt;[RESEND PATCH V5 00/33] block: support multipage bvec&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180525034621.31147-1-ming.lei@redhat.com&#34;&gt;https://lkml.kernel.org/r/20180525034621.31147-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;하나의 &lt;code&gt;struct bio_bvec&lt;/code&gt; 이 물리적으로 연속적인 복수개의 페이지를 가질 수 있게
하는 패치입니다.  시스템의 메모리가 거대해지고 THP 등이 널리 쓰임에 따라 이런
변화가 필요했다는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-mm-04-mm-huge-page-copy-target-subpage-last-when-copy-huge-page&#34;&gt;[PATCH -V2 -mm 0/4] mm, huge page: Copy target sub-page last when copy huge page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180524005851.4079-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180524005851.4079-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Huge page 의 복사 시에는 source 와 destination page 각각에 접근을 해야 하므로,
2 MiB huge page 를 사용한다 가정하면 총 4 MiB 데이터 액세스가 필요합니다.
예컨대 Xeon E5 v3 2699 CPU 는 18개의 코어, 36개 쓰레드, 그리고 45 MiB Last
Level Cache 를 가지므로 코어별로는 2.5 MiB, 쓰레드별로는 1.25 MiB 의 Last Level
Cache 밖에 갖지 못하므로, 여기서 huge page 복사가 일어나면 자신의 Last Level
Cache 를 모조리 접근해서 데이터가 flooding 나고 이후 데이터 접근은 cache miss
가 날 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;이 패치셋은 target huge page 의 sub-page 를 마지막에 복사하도록 복사 시의
데이터 접근 순서를 약간 바꿔서 대부분의 경우에는 캐시 미스를 좀 더 줄일 수
있도록 했습니다.&lt;/p&gt;
&lt;p&gt;vm-scalability 의 anon-cow-seq 테스트 케이스를 2 socket Xeon E5 v3 2699
시스템에서 돌려본 결과, 약 16.6% 까지의 성능 향상이 있었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc5</title>
      <link>/post/lkml_news_v4.17-rc5/</link>
      <pubDate>Mon, 14 May 2018 10:23:45 +0900</pubDate>
      <guid>/post/lkml_news_v4.17-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-417rc5&#34;&gt;Linux 4.17-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxi-Q6hvdHn+JwYSQ9b3feNGoFM3eeAuKNhpkfxVNAGpA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxi-Q6hvdHn+JwYSQ9b3feNGoFM3eeAuKNhpkfxVNAGpA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.17을 향한 다섯번째 rc 릴리즈입니다.  이번 릴리즈도 여느 때와 다름없이
평범하군요.  대부분 드라이버 변경들이고, amd gpu 쪽 변경이 있지만 나머지
부분들은 그렇게 많지 않고 대부분 한두줄 짜리 변경들입니다.  이대로라면 이번
4.17 릴리즈는 꽤 무난무난하게 끝나겠군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v11-0026-speculative-page-faults&#34;&gt;[PATCH v11 00/26] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1526555193-7242-1-git-send-email-ldufour@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1526555193-7242-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 몇차례 소개한, speculative page fault 의 11번째 버전입니다.
지난 LSFMM 에서도 관련해 논의를 한 것 같던데, 아주 긍정적 반응은 아니었던 것
같습니다만, 어쨌든 오랫만에 올라온 새로운 버전의 패치셋이군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v6-0017-rearrange-struct-page&#34;&gt;[PATCH v6 00/17] Rearrange struct page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180518194519.3820-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180518194519.3820-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct page&lt;/code&gt; 의 구조를 좀 더 사용하기 쉽게 개선하는 패치의 여섯번째
버전입니다.  LSFMM 에서는 그 구조를 구글 문서[1]를 사용해 그림으로 그려가며
설명했고, 꽤 괜찮은 반응을 얻었던 것 같더군요.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&#34;&gt;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>QEMU 를 사용한 리눅스 커널 디버깅</title>
      <link>/post/qemu_kernel_debugging/</link>
      <pubDate>Mon, 07 May 2018 18:21:01 +0900</pubDate>
      <guid>/post/qemu_kernel_debugging/</guid>
      <description>&lt;p&gt;토발즈는 좋아하지 않지만, 리눅스 커널 프로그래밍에도 디버거를 사용할 수
있습니다.  저도 디버거 사용을 좋아하지는 않는 편이지만, 경우에 따라선 디버거를
사용하는게 좋을 때도 있고 취향은 존중되어야죠. ;)&lt;/p&gt;
&lt;p&gt;커널 디버깅 방법은 여러가지가 있는데, 그 중 하나는 QEMU 등을 이용한 리눅스 가상
머신을 띄워 두고, 호스트 머신에서 해당 가상 머신의 리눅스 커널을 디버깅 하는
방법입니다.  이 글에선 이렇게 디버깅 하는 방법을 간단히 정리해 봅니다.&lt;/p&gt;
&lt;h1 id=&#34;-&#34;&gt;테스트 환경&lt;/h1&gt;
&lt;p&gt;글 작성 과정에서 테스트에 사용한 주요 소프트웨어들과 버전은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu 16.04.3 Server&lt;/li&gt;
&lt;li&gt;gdb 7.11.1&lt;/li&gt;
&lt;li&gt;QEMU v2.11.0-dirty&lt;/li&gt;
&lt;li&gt;Linux v4.16&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;-1&#34;&gt;커널 빌드&lt;/h1&gt;
&lt;p&gt;디버깅할 커널을 빌드합니다.  이 때 &lt;code&gt;CONFIG_GDB_SCRIPTS&lt;/code&gt; 는 켜고
&lt;code&gt;CONFIG_DEBUG_INFO_REDUCED&lt;/code&gt; 는 끄고, 타겟 아키텍쳐가 &lt;code&gt;CONFIG_FRAME_POINTER&lt;/code&gt; 를
지원한다면 켜야 합니다.&lt;/p&gt;
&lt;h1 id=&#34;--&#34;&gt;가상 머신 부팅&lt;/h1&gt;
&lt;p&gt;빌드가 완료되면 해당 커널을 사용해 QEMU 가상 머신을 부팅시킵니다.  가상 머신
위에 커널을 설치하는 방법도 있겠고, QEMU 에 &lt;code&gt;-kernel&lt;/code&gt; 과 &lt;code&gt;-append&lt;/code&gt;, &lt;code&gt;-initrd&lt;/code&gt;
등을 사용해서 호스트에서 빌드한 리눅스 커널로 부팅시키는 방법도 있을 겁니다.
이 때, &lt;strong&gt;kaslr&lt;/strong&gt; 을 꺼야 합니다.  커널 패러미터에 &lt;code&gt;nokaslr&lt;/code&gt; 을 추가하는 걸로 끌
수 있습니다.  kaslr 이 켜진 채로 디버깅 해야 한다면 다른 방법이 있는데, 여기선
다루지 않겠습니다.&lt;/p&gt;
&lt;p&gt;QEMU 가상 머신을 시작할 때 QEMU 에 &lt;code&gt;-s&lt;/code&gt; 옵션을 주거나 QEMU monitor console 에서
&lt;code&gt;gdbserver&lt;/code&gt; 라고 명령을 입력해 줍니다.  이 명령은 가상머신에서 gdbserver 를
시작시켜서 gdbserver 가 &lt;code&gt;tcp::1234&lt;/code&gt; 에서 접속을 기다리게 함으로써 QEMU 의 gdb
기능을 활성화 시켜줍니다.  &lt;code&gt;-nographic&lt;/code&gt; 옵션을 주거나 해서 QEMU 를 수행시켰다면
화면에 QEMU monitor console 이 아니라 가상머신의 console 로 연결되었을 텐데,
&lt;code&gt;Ctrl+a c&lt;/code&gt; 키 조합으로 QEMU monitor console 로 이동할 수 있습니다.  여기서
가상머신 콘솔로 돌아가려면 &lt;code&gt;Ctrl+a c &amp;lt;enter&amp;gt;&lt;/code&gt; 를 입력해 줍니다.&lt;/p&gt;
&lt;h1 id=&#34;gdb-&#34;&gt;gdb 시작&lt;/h1&gt;
&lt;p&gt;호스트 머신에서 디버깅할 커널의 빌드 디렉토리로 이동해서 &lt;code&gt;gdb vmlinux&lt;/code&gt; 명령어를
입력해 빌드된 리눅스 심볼과 디버깅 정보를 사용해 gdb 가 켜지도록 합니다.
우분투나 일부 배포본에서는 이 때 &lt;code&gt;vmlinux-gdb.py&lt;/code&gt; 를 읽어들이는데 실패할 수
있을 겁니다.  gdb 에서도 에러메세지를 띄워 주겠지만, 홈디렉토리의 &lt;code&gt;.gdbinit&lt;/code&gt;
파일에 다음 한줄을 추가해 주고 앞서 설명한 커맨드로 gdb 를 다시 시작합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;add-auto-load-state-path /path/to/linux-build
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이후, gdb 세션에서 다음과 같은 명령어를 입력해 QEMU 가상머신에 연결합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) target remote :1234
Remote debugging using :1234
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&amp;quot;sti; hlt&amp;quot;: : :&amp;quot;memory&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이와 함께 QEMU 가상 머신은 동작이 멈출 겁니다.  여기서부터 gdb 를 평소에
사용하듯이 사용해 리눅스 커널의 변수를 보거나 중단점 (breakpoint) 를 설정하거나
한단계씩 코드를 수행시키거나 할 수 있습니다.  예를 들어 다음과 같이 특정 함수에
breakpoint 를 설정할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) b cma_alloc
Breakpoint 1 at 0xffffffff81240f10: file /home/sjpark/linux/mm/cma.c, line 399.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;예를 들어 수행이 멈춰 있는 가상머신의 수행을 다시 가능하게 하려면 다음과 같이 c
를 입력해 줍니다.  가상머신의 커널 수행이 재개되며, Breakpoint 가 설정되어 있고
해당 위치 코드가 수행되면 다시 수행이 멈출 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) c
Continuing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다시 멈추려면 gdb 에서 Ctrl+C 를 누릅시다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;^C
Thread 1 received signal SIGINT, Interrupt.
0xffffffff818cce92 in native_safe_halt () at /home/sjpark/linux/arch/x86/include/asm/irqflags.h:54
54              asm volatile(&amp;quot;sti; hlt&amp;quot;: : :&amp;quot;memory&amp;quot;);
(gdb)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;-gdb-helper-&#34;&gt;리눅스 gdb helper 사용하기&lt;/h1&gt;
&lt;p&gt;사실은 앞 단계에서 &lt;code&gt;.gdbinit&lt;/code&gt; 를 굳이 수정하지 않아서 gdb가 &lt;code&gt;vmlinux-gdb.py&lt;/code&gt; 를
읽어들이는데 실패하더라도 gdb 를 평범하게 사용할 수 있습니다.  &lt;code&gt;vmlinux-gdb.py&lt;/code&gt;
는 사실 gdb 위에서 리눅스 커널을 디버깅하는걸 편리하게 해줄 수 있는 일부
스크립트, 즉 gdb helper 를 담고 있습니다.  이걸 사용하면 보다 쉽게 커널
디버깅을 할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;helper--&#34;&gt;helper 스크립트 리스트업&lt;/h2&gt;
&lt;p&gt;사용 가능한 helper 스크립트는 lx로 시작하는 규칙을 갖고 있습니다.  다음
명령으로 사용 가능한 스크립트 목록과 간단한 설명을 볼 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gdb) apropos lx
function lx_current -- Return current task
function lx_module -- Find module by name and return the module variable
function lx_per_cpu -- Return per-cpu variable
function lx_task_by_pid -- Find Linux task by PID and return the task_struct variable
function lx_thread_info -- Calculate Linux thread_info from task variable
function lx_thread_info_by_pid -- Calculate Linux thread_info from task variable found by pid
lx-cmdline --  Report the Linux Commandline used in the current kernel
lx-cpus -- List CPU status arrays
lx-dmesg -- Print Linux kernel log buffer
lx-fdtdump -- Output Flattened Device Tree header and dump FDT blob to the filename
lx-iomem -- Identify the IO memory resource locations defined by the kernel
lx-ioports -- Identify the IO port resource locations defined by the kernel
lx-list-check -- Verify a list consistency
lx-lsmod -- List currently loaded modules
lx-mounts -- Report the VFS mounts of the current process namespace
lx-ps -- Dump Linux tasks
lx-symbols -- (Re-)load symbols of Linux kernel and currently loaded modules
lx-version --  Report the Linux Version of the current kernel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;참 쉽죠? ;)&lt;/p&gt;
&lt;h1 id=&#34;-2&#34;&gt;참고 자료&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/v4.11/dev-tools/gdb-kernel-debugging.html&#34;&gt;커널 디버깅 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.alexlambert.com/2017/12/18/kernel-debugging-for-newbies.html&#34;&gt;참고할만한 영문 블로그 글&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/Server.html&#34;&gt;gdbserver 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc4</title>
      <link>/post/lkml_news_v4.17-rc4/</link>
      <pubDate>Mon, 07 May 2018 12:12:32 +0900</pubDate>
      <guid>/post/lkml_news_v4.17-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-417rc4&#34;&gt;Linux 4.17-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyry0qeZvYjU5pf8a6zvb_ALmP-2T9+HZH2DHK93P6rQg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyry0qeZvYjU5pf8a6zvb_ALmP-2T9+HZH2DHK93P6rQg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어느새 네번째 rc 버전입니다.  v4.17 을 향한 여정이 절반을 넘어가는군요.  이번 릴리즈도 특이사항 없이 평범합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc3</title>
      <link>/post/lkml_news_v4.17-rc3/</link>
      <pubDate>Mon, 30 Apr 2018 12:59:19 +0900</pubDate>
      <guid>/post/lkml_news_v4.17-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-417rc3&#34;&gt;Linux 4.17-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyu=y0SBesB+vx3JZFGcOhP+tuVG7sjfrkfBhXHTe0Skg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyu=y0SBesB+vx3JZFGcOhP+tuVG7sjfrkfBhXHTe0Skg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;세번째 rc 버전이 나왔습니다.  평소보다 좀 일찍 왔군요.  rc2 에 비해 커다란
릴리즈이긴 한데, 그렇다 해도 평범한 릴리즈라고 리누스는 이야기 합니다.
대부분의 변경 사항이 드라이버 쪽 수정이기 때문이라고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0016-rearrange-struct-page&#34;&gt;[PATCH v4 00/16] Rearrange struct page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180430202247.25220-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180430202247.25220-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 블로그에서도 소개했던, Matthew Wilcox 의 &amp;lsquo;struct page&amp;rsquo; 정리 패치의 네번째
버전입니다.  지난주 LSFMM 에서도 소개한 모양인데, 이 변화의 전/후를 google
spread sheet 로 정리한 문서도 여기서 공개했나보군요:
&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&#34;&gt;https://docs.google.com/spreadsheets/d/1tvCszs_7FXrjei9_mtFiKV6nW1FLnYyvPvW-qNZhdog/edit?usp=sharing&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-04-interface-for-higher-order-contiguous-allocations&#34;&gt;[PATCH v2 0/4] Interface for higher order contiguous allocations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180503232935.22539-1-mike.kravetz@oracle.com&#34;&gt;https://lkml.kernel.org/r/20180503232935.22539-1-mike.kravetz@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mmap(MAP_CONTIG)&lt;/code&gt; 를 추가하자는 아이디어가 있었습니다.  현재 리눅스 커널에서
연속된 메모리 공간 할당에 사용되기 위해 만들어진 인터페이스는 CMA가 있는데, 그
목적이 좀 특수한 상황에 맞춰져 있다보니 좀 더 범용적 인터페이스가 있으면
어떻겠나 하는 이야기가 나와, 그런 인터페이스를 만들어 제시하는 패치입니다.
제안하는 인터페이스는 다음과 같습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct page *find_alloc_contig_pages(unsigned long nr_pages, gfp_t gfp,
                                        int nid, nodemask_t *nodemask)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;rfc-distinguish-vmalloc-pages&#34;&gt;[RFC] Distinguish vmalloc pages&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180502152733.GB2737@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20180502152733.GB2737@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VMalloc 페이지는 유저스페이스에 매핑될 수도 있으므로 성능 분석과 memory leak
문제 분석의 편의를 위해  page-&amp;gt;mapping 값에 이를 가리키는 표식과 해당 페이지를
가리키는 &lt;code&gt;vm_struct&lt;/code&gt; 와 그 안에서의 &lt;code&gt;offset&lt;/code&gt; 을 저장하는 RFC 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;introduce-atomicdecandlockirqsave&#34;&gt;Introduce atomic_dec_and_lock_irqsave()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180504154533.8833-1-bigeasy@linutronix.de&#34;&gt;https://lkml.kernel.org/r/20180504154533.8833-1-bigeasy@linutronix.de&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;local_irq_save()&lt;/code&gt; + &lt;code&gt;atomic_dec_and_lock()&lt;/code&gt; 조합을 써야 하던 코드를 위해 이를
감싸는 새로운 함수, &lt;code&gt;atomic_dec_and_lock_irqsave()&lt;/code&gt; 를 만들고 기존의 코드가
이를 사용하도록 고친 패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc2</title>
      <link>/post/lkml_news_v4.17-rc2/</link>
      <pubDate>Mon, 23 Apr 2018 12:03:23 +0900</pubDate>
      <guid>/post/lkml_news_v4.17-rc2/</guid>
      <description>&lt;h2 id=&#34;linux-v417rc2&#34;&gt;Linux v4.17-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwzkGuq5ASF-vhYj7mEX26V0K+uZCLWi1BLYq+9F1n-Rw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwzkGuq5ASF-vhYj7mEX26V0K+uZCLWi1BLYq+9F1n-Rw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;두번째 rc 버전의 릴리즈입니다.  &lt;code&gt;perf&lt;/code&gt; 와 테스트 스크립트 쪽에 변경사항이 좀
많긴 하지만 평소와 크게 다르지 않은 추이라는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.17-rc1</title>
      <link>/post/lkml_news_v4.17-rc1/</link>
      <pubDate>Mon, 16 Apr 2018 10:59:58 +0900</pubDate>
      <guid>/post/lkml_news_v4.17-rc1/</guid>
      <description>&lt;h2 id=&#34;linux-v417rc1&#34;&gt;Linux v4.17-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFx62iBkj+hOmhLksUtvjwTcm_o1dwcyvaNnVpJ-AmvzVQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFx62iBkj+hOmhLksUtvjwTcm_o1dwcyvaNnVpJ-AmvzVQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2주간의 머지 윈도우가 지나고, v4.17-rc1 이 릴리즈 되었습니다.  크게 특별할 것
없이 평범한 머지 윈도우였다고 토발즈는 평하는군요.  그리고 이번에 git objects
mark 가 4백만을 넘겼습니다.  따라서 다음 커널이 v5.0 이어도 될 것 같은데, 꼭
다음 버전에서 그렇게 할지는 모르겠다는군요.  리눅스 커널에서 버전은 그저 시간이
흘렀음을 의미할 뿐, 큰 변화가 있어서 메이저 버전 넘버가 바뀌는게 아니기
때문이죠.  참고로 v3.0 과 v4.0 은 각각 git objects mark 2백만과 4백만에서
이루어졌군요.&lt;/p&gt;
&lt;p&gt;암튼 언젠가는 v5.0 을 릴리즈 하겠지만 너무 큰 의미를 부여하지 말아달라고 이야기 하고 있습니다.&lt;/p&gt;
&lt;p&gt;토발즈는 또한 이번 머지 윈도우에서의 변화로 몇가지를 꼽는데요.
오래된 아키텍쳐인 backfin, cris, frv, m32r, metag, mn10300, score, tile
아키텍쳐의 지원을 끊기로 했고 nds32 라는 새로운 아키텍쳐를 지원하게 되었군요.
해당 아키텍쳐에 지원이 더 필요하다면 언제든 되살려도 좋지만 본인이 잘 관리할 수
있음을 증명해야 함을 한번 더 언급하고 있습니다.&lt;/p&gt;
&lt;p&gt;또한, 이번 머지 윈도우에선 클린업이 꽤 있었습니다.  staging 드라이버들 몇개가
제거되었고, spdx 를 사용함으로써 카피라이트 문구도 많이 줄었습니다.
pre-shipped lexer / parser 파일들도 사라졌구요.&lt;/p&gt;
&lt;p&gt;결국, 이번 릴리즈는 추가된 코드 라인보다 삭제된 코드 라인이 많았던 릴리즈군요.
프로젝트 관리자로써 토발즈가 속시원할 것 같습니다.  이런 경우는 커널 릴리즈
역사상 처음이라는군요.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 13538 files changed, 627723 insertions(+), 818855 deletions(-)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;patch-v10-0025-speculative-page-faults&#34;&gt;[PATCH v10 00/25] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1523975611-15978-1-git-send-email-ldufour@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1523975611-15978-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어느새 열번째 버전의 speculative page faults 패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-0012-improve-shrinkslab-scalability-old-complexity-was-on2-new-is-on&#34;&gt;[PATCH v2 00/12] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/152397794111.3456.1281420602140818725.stgit@localhost.localdomain&#34;&gt;https://lkml.kernel.org/r/152397794111.3456.1281420602140818725.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;많은 memort shrinker 들 또는 메모리 cgroups 를 가진 시스템에서는 그 수의 제곱에
비례해 &lt;code&gt;shrink_slab()&lt;/code&gt; 의 수행시간이 증가하는데, 이 문제를 해결하고자 하는
패치셋입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/code&gt; 의 수행시간을 사용해 성능 차이를
측정했군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0021-mm-thp-swap-swapoutswapin-thp-as-a-whole&#34;&gt;[PATCH 00/21] mm, THP, swap: Swapout/swapin THP as a whole&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180417020230.26412-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180417020230.26412-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP (Transparent Huge Page) 는 swap out 되기 전에 regular page 로 쪼개져야
했습니다.  이 작업에 많은 시간이 걸렸기에 한번에 THP 를 swap out 하기 위한
작업을 Huang Ying 이 해왔고 일단 쪼개는 작업은 최후로 미뤄뒀는데 마침내 완전히
THP 단위로 swap out 을 행하는 패치셋을 올렸습니다.&lt;/p&gt;
&lt;p&gt;RAM 으로 PMEM swap device 를 시뮬레이션 해서 vm-scalability 벤치마크의
swap-w-seq 테스트를 16개 프로세스로 실험한 결과, 약 10배의 성능 개선을
보았군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-021-contention-reduction-for-v418&#34;&gt;[PATCH tip/core/rcu 0/21] Contention reduction for v4.18&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180423030258.GA23370@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180423030258.GA23370@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 의 루트 &amp;lsquo;rcu_node&amp;rsquo; 구조체로의 락 컨텐션을 줄이는 Paul McKenney 의
패치셋입니다.  별 문제 없으면 4.18 버전에 들어가겠군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16</title>
      <link>/post/lkml_news_v4.16/</link>
      <pubDate>Mon, 02 Apr 2018 07:13:40 +0900</pubDate>
      <guid>/post/lkml_news_v4.16/</guid>
      <description>&lt;h2 id=&#34;linux-416&#34;&gt;Linux 4.16&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyxn0bu5jOAJvO_63GHaGMkJ0uA=bVBm2T3HVX9SimZzw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyxn0bu5jOAJvO_63GHaGMkJ0uA=bVBm2T3HVX9SimZzw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;릴리즈 마지막 주 치고는 네트워킹 쪽에 조금 변경사항이 있었습니다만, 큰 문제가
될 정도는 아니었습니다.  결과, 4.16이 드디어 릴리즈 되었습니다!  동시에 4.17
머지 윈도우가 시작되는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-move-kfreercu-out-of-rcu-code-and-use-kfreebulk&#34;&gt;[PATCH 0/2] Move kfree_rcu out of rcu code and use kfree_bulk&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522647064-27167-1-git-send-email-rao.shoaib@oracle.com&#34;&gt;https://lkml.kernel.org/r/1522647064-27167-1-git-send-email-rao.shoaib@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kfree_rcu() 대신 kfree_bulk() 라는 새로 만들어진, 더 효율적인 기능을 사용하도록
하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-01-mm-support-multiple-kswapd-threads-per-node&#34;&gt;[RFC PATCH 0/1] mm: Support multiple kswapd threads per node&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522661062-39745-1-git-send-email-buddy.lumpkin@oracle.com&#34;&gt;https://lkml.kernel.org/r/1522661062-39745-1-git-send-email-buddy.lumpkin@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NUMA 아키텍쳐에서 리눅스 커널은 NUMA 노드당 하나의 kswapd 쓰레드를 띄웁니다.
노드당 kswapd 쓰레드 수를 늘려 성능을 높이려는 쓰레드입니다.  결국은 이런
움직임이 있어야 할거라고 봅니다만, 당장 이 패치에 대해서는 수정 요청 의견도 꽤
있군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-group-struct-page-elements&#34;&gt;[RFC] Group struct page elements&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180408142334.GA29357@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20180408142334.GA29357@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널에서 페이지를 관리하는 구조체인 &lt;code&gt;struct page&lt;/code&gt; 는 매우 복잡한 구조로
되어있고, 페이지가 어떤 목적으로 쓰이느냐에 따라 같은 필드가 다른 목적으로
쓰이기도 합니다.
이 RFC 패치는 이 혼란스러운 구조를 좀 개선해 보려는 시도를 담고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-12-slab-gfpzero-is-incompatible-with-a-constructor&#34;&gt;[PATCH 1/2] slab: &lt;code&gt;__GFP_ZERO&lt;/code&gt; is incompatible with a constructor&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180410125351.15837-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180410125351.15837-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시작은 김민찬 님의 null pointer dereference 문제에 대한 수정을 담은
패치셋이었습니다
(&lt;a href=&#34;https://lkml.kernel.org/r/20180409015815.235943-1-minchan@kernel.org)&#34;&gt;https://lkml.kernel.org/r/20180409015815.235943-1-minchan@kernel.org)&lt;/a&gt;.
이걸 Matthew 는 근본적인 실수가 있었던 것 같다고 보고 이 패치셋을 내놓았습니다.
메모리 할당 요청에 &lt;code&gt;__GFP_ZERO&lt;/code&gt; 플래그를 넣으면 메모리 영역을 0으로 초기화 해서
할당을 해줍니다.  그런데 constructor 가 있다면 초기화 작업을 constructor 에서
해야 하기에 &lt;code&gt;__GFP_ZERO&lt;/code&gt; 플래그를 여기에 넣는건 뭔가 이상하죠.
이 패치셋은 그런 경우는 모두 실수에 의한 것이라 보고 경고를 표시해 주도록
합니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-tiplockinglockdep-v6-2020-lockdepselftest-add-a-test-case-for-srcu&#34;&gt;[RFC tip/locking/lockdep v6 20/20] lockdep/selftest: Add a test case for SRCU&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180411135721.22723-1-boqun.feng@gmail.com&#34;&gt;https://lkml.kernel.org/r/20180411135721.22723-1-boqun.feng@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널의 락킹 관련 문제 추적 기능인 &lt;code&gt;lockdep&lt;/code&gt; 이 SRCU 를 지원하게 하는
패치와 함께 올라온 패치입니다.
&lt;code&gt;lockdep&lt;/code&gt; 을 위한 selftest 에 SRCU 기능 역시 테스트하도록 테스트를
추가했습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc7</title>
      <link>/post/lkml_news_v4.16-rc7/</link>
      <pubDate>Mon, 26 Mar 2018 08:45:19 +0900</pubDate>
      <guid>/post/lkml_news_v4.16-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-416rc7&#34;&gt;Linux 4.16-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxpxHnWBeTXN+DKqwCMW_=T2cR8UxSBVk_6c8LL7Et5JQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxpxHnWBeTXN+DKqwCMW_=T2cR8UxSBVk_6c8LL7Et5JQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16을 향한 일곱번째 rc 가 릴리즈 되었습니다.  평소대로라면 이게 마지막 rc 여야
할텐데, 평소와 다름없거나 변경사항이 적은 편이던 그동안의 rc와 달리 이번 rc 는
좀 변경사항이 많군요.  그렇다곤 해도 아마도 네트워킹 쪽 코드 머지가 늦었기
때문으로 보이며 rc8을 릴리즈할 생각은 아직은 없다고 토발즈는 이야기 하네요.&lt;/p&gt;
&lt;p&gt;더불어, 토발즈가 rc 릴리즈 때마다 변경 사항들을 정리하기 위해 주로 사용하는 git
사용 스크립트를 공개했습니다.&lt;/p&gt;
&lt;p&gt;다음주는 4.16이 릴리즈 될까요?  아니면, rc8이?&lt;/p&gt;
&lt;h2 id=&#34;patch-mmlistlru-replace-spinlock-with-rcu-in-listlrucountone&#34;&gt;[PATCH] mm/list_lru: replace spinlock with RCU in &lt;code&gt;__list_lru_count_one&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522137544-27496-1-git-send-email-lirongqing@baidu.com&#34;&gt;https://lkml.kernel.org/r/1522137544-27496-1-git-send-email-lirongqing@baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list_lru_count_one()&lt;/code&gt; 이 스핀락을 잡기 때문에 &lt;code&gt;shrink_slab()&lt;/code&gt; 이 많은 시간을
소모하게 되는데, 이를 스핀락 대신 RCU 를 사용하게 해서 최적화 시킨 패치입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dd&lt;/code&gt; 를 사용해 커다란 메모리를 사용한 후 파일을 제거하고서
&lt;code&gt;/cgroup/memory/test/memory.limit_in_bytes&lt;/code&gt; 의 크기를 작게 잡아 인위적으로
reclaim 을 유발시키고 여기에 걸리는 시간을 측정했군요.  기존 0.415초에서 최적화
후 0.395초로 개선되었습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v10-0062-convert-page-cache-to-xarray&#34;&gt;[PATCH v10 00/62] Convert page cache to XArray&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180330034245.10462-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20180330034245.10462-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XArray 패치 중 일부가 이미 Andrew Morton 의 -next 트리에 들어갔습니다.  Matthew
Wilcox 는 XArray 를 활용하는 패치를 이어서 계속 올리고 있군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-limit-a-process-rss&#34;&gt;[PATCH] mm: limit a process RSS&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1522386674-12047-1-git-send-email-lirongqing@baidu.com&#34;&gt;https://lkml.kernel.org/r/1522386674-12047-1-git-send-email-lirongqing@baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ulimit -m&lt;/code&gt; 명령을 이용해 프로세스의 최대 RSS (Resident Set Size) 를 제어할 수
있는 인터페이스가 있지만 실제로 커널이 제한을 하고 있진 않습니다.  제한하도록
구현하는 패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc6</title>
      <link>/post/lkml_news_v4.16-rc6/</link>
      <pubDate>Mon, 19 Mar 2018 10:19:34 +0900</pubDate>
      <guid>/post/lkml_news_v4.16-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-416rc6&#34;&gt;Linux 4.16-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzV1nffUeriZLksK90noD49T+w+WmgBsYMAO13rTbn3Pg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzV1nffUeriZLksK90noD49T+w+WmgBsYMAO13rTbn3Pg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 여섯번째 rc 버전이 나왔습니다.  4.16을 향한 이번 사이클은 상당히 순탄하게
진행되는군요.  rc7 까진 만들 예정이라고 하는데, 그 후엔 4.16이 안정적으로
나오게 될 것 같습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc5</title>
      <link>/post/lkml_news_v4.16-rc5/</link>
      <pubDate>Mon, 12 Mar 2018 10:08:11 +0900</pubDate>
      <guid>/post/lkml_news_v4.16-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-416rc5&#34;&gt;Linux 4.16-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxXAMHeD8zz1BLv9r_2rjWJ6xE=cNGVAoWOvQJog7oz9A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxXAMHeD8zz1BLv9r_2rjWJ6xE=cNGVAoWOvQJog7oz9A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여전히 특이사항 없는 한주를 거쳐 다섯번째 rc 버전이 나왔습니다.  이번 릴리즈가
기존의 rc5 단계보단 조금 크지만 특이할 정도는 아닌 모양이군요.  개인적으로 눈에
띈 부분은, overlayfs, xfs 등의 파일시스템의 변경, 그리고 perf 와 selftest 쪽
변경이 있군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v9-0024-speculative-page-faults&#34;&gt;[PATCH v9 00/24] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1520963994-28477-1-git-send-email-ldufour@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1520963994-28477-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Speculative page faults 의 9번째 패치셋입니다.  Michael Hocko 가 이거 너무 자주
올리는 거 아니냐고 한마디 했고, 패치 저자인 Laurent Dufour 도 오케이 했네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0032-docsvm-convert-to-rest-format&#34;&gt;[PATCH 00/32] docs/vm: convert to ReST format&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1521660168-14372-1-git-send-email-rppt@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1521660168-14372-1-git-send-email-rppt@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널 문서의 ReST 화는 많은 사람들이 반기고 있는 변화지만 일부 메인테이너는 썩
반기지 않기도 합니다.  vm/ 쪽 문서를 모두 ReST 로 바꾸는 패치가 올라왔습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc4</title>
      <link>/post/lkml_news_v4.16-rc4/</link>
      <pubDate>Mon, 05 Mar 2018 10:50:48 +0900</pubDate>
      <guid>/post/lkml_news_v4.16-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-416rc4&#34;&gt;Linux 4.16-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxXg8hi+T_DNCG_OrAotqSheyREw-Njf9XgUD1vXqAyHQ@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxXg8hi+T_DNCG_OrAotqSheyREw-Njf9XgUD1vXqAyHQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;벌써 개발 단계의 중반이라 할 수 있는 rc4 의 릴리즈입니다.  4.16 버전의 릴리즈도
얼마 남지 않았군요.  여전히 충분히 조용한 한주였습니다.  다만 여기저기에 조금씩
변경사항이 골고루 있군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0034-v3-pti-support-for-x32&#34;&gt;[PATCH 00/34 v3] PTI support for x32&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1520245563-8444-1-git-send-email-joro@8bytes.org&#34;&gt;https://lkml.kernel.org/r/1520245563-8444-1-git-send-email-joro@8bytes.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;x86-32 를 위한 Page Table Isolation 패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.16 Rc3</title>
      <link>/post/lkml_news_v4.16-rc3/</link>
      <pubDate>Mon, 26 Feb 2018 18:38:53 +0100</pubDate>
      <guid>/post/lkml_news_v4.16-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-416rc3&#34;&gt;Linux 4.16-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxk5KBxL9DvRtBivP3hKT-aOAzvSA_B47L1+y0P2GLe_A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxk5KBxL9DvRtBivP3hKT-aOAzvSA_B47L1+y0P2GLe_A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 세번째 rc 버전이 릴리즈 되었습니다.  rc2 보단 변경사항이 많지만, rc2 때
이야기 했듯 rc2 때는 대부분의 경우 고칠 것들을 찾지도 못했기 때문이 크기
때문이죠.  즉, 스펙터와 멜트다운으로 끔찍했던 4.15 때와 달리, 모든게 정상적이고
예상대로라고 합니다.&lt;/p&gt;
&lt;p&gt;대부분의 변경은 드라이버이고, 네트워킹 쪽 변경도 좀 크군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-05-srcu-updates&#34;&gt;[PATCH tip/core/rcu 0/5] SRCU updates&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180226215614.GA31616@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180226215614.GA31616@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU critical section 안에서 sleep 을 할 수 있는 SRCU 의 간단한 업데이트
패치셋입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-012-torturetest-updates&#34;&gt;[PATCH tip/core/rcu 0/12] Torture-test updates&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180226220225.GA32136@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180226220225.GA32136@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 등의 동기화 도구의 동시성 버그를 찾는데 사용되는 torture test 의 업데이트
패치셋입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lkml_news_v4.16 Rc2</title>
      <link>/post/lkml_news_v4.16-rc2/</link>
      <pubDate>Mon, 19 Feb 2018 11:09:15 +0900</pubDate>
      <guid>/post/lkml_news_v4.16-rc2/</guid>
      <description>&lt;h2 id=&#34;linux-416rc2&#34;&gt;Linux 4.16-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwDnBq9V6TVbc82DzVYpf-ELF7UcYzHuY0ei1Xjnob+0A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwDnBq9V6TVbc82DzVYpf-ELF7UcYzHuY0ei1Xjnob+0A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 두번째 rc 버전의 릴리즈입니다.  이번 한주는 매우 조용한 한주였군요.  머지
윈도우가 끝나고 사람들이 좀 쉬기 때문일수도, 아직 버그를 찾지 못해서일 수도
있고 일반적으로 rc2 는 조용한 편이지만, 어쨌든 토발즈는 만족스러운 눈치입니다.
4.15 에서의 spectre &amp;amp; meltdown 때문에 더 그럴지도 모르겠지만요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.16-rc1</title>
      <link>/post/lkml_news_v4.16-rc1/</link>
      <pubDate>Tue, 13 Feb 2018 13:56:47 +0900</pubDate>
      <guid>/post/lkml_news_v4.16-rc1/</guid>
      <description>&lt;h2 id=&#34;linux-416rc1&#34;&gt;Linux 4.16-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzXVqgCMhPL9EaMW_D9E=HCQ9+JSQAbBPe3Oa_iQtky=g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzXVqgCMhPL9EaMW_D9E=HCQ9+JSQAbBPe3Oa_iQtky=g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;어느덧 2주일이 지났습니다.  머지 윈도우가 닫히고 4.16 첫번째 rc 버전이
나왔습니다.  4.15는 역시 토발즈에게 고통스러웠던 시간이었던지 이번 머지
윈도우는 4.15 보다 훨씬 나았다는 토발즈의 이야기입니다.&lt;/p&gt;
&lt;p&gt;이번 릴리즈에서는 GPU 쪽 변경 사항이 많고 대부분은 드라이버라 아주 큰 변화는
거의 없지만, 여전히 arch 쪽에도, 네트워킹과 파일시스템 등에도 변경이 없지는
않다고 정리하고 있습니다.
스펙터 / 멜트다운 이슈에 대한 x86 외 아키텍쳐의 변경사항들도 들어왔군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v8-0024-speculative-page-faults&#34;&gt;[PATCH v8 00/24] Speculative page faults&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1518794738-4186-1-git-send-email-ldufour@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/1518794738-4186-1-git-send-email-ldufour@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 릴리즈와 함께 4.15 위로 포팅된 Speculative page faults 패치가 계속
올라오고 있습니다.  이 패치셋은 예전부터 제가 관심을 두고 보고 있는 패치인데,
page fault handling 을 speculative 하게 함으로써 병렬성을 높이려는 패치입니다.
아이디어가 시작된 건 오래되었고 그 아이디어를 이어와 다시 제안되고 있는
패치이죠.  이번엔 업데이트 될런지 궁금하네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-v5-resend-mm-swap-fix-race-between-swapoff-and-some-swap-operations&#34;&gt;[PATCH -mm -v5 RESEND] mm, swap: Fix race between swapoff and some swap operations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180213014220.2464-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180213014220.2464-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;swapin 작업과 swapoff 작업 사이를 락으로 보호하지 않고 있기 때문에 segmentation
fault 문제가 있을 수 있습니다.  swapoff 가 자주 불리진 않다보니 이 문제가 크게
불거진 적 없는데, 어쨌건 race 는 race 라 고쳐야 한다는 Huang Ying 의
패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15</title>
      <link>/post/lkml_news_v4.15/</link>
      <pubDate>Mon, 29 Jan 2018 09:20:38 +0900</pubDate>
      <guid>/post/lkml_news_v4.15/</guid>
      <description>&lt;h2 id=&#34;linux-415&#34;&gt;Linux 4.15&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzARtx-nA=d1j7vLOLf4FHMJLyRiQ-PKkoexJuTUHogdw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzARtx-nA=d1j7vLOLf4FHMJLyRiQ-PKkoexJuTUHogdw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;드디어 4.15 버전이 릴리즈 되었습니다.  지난 한주는 매우 조용하고 변경된 사항이
거의 없었다는군요.&lt;/p&gt;
&lt;p&gt;이렇게 meltdown/spectre 로 시끄럽고 길었던, 평범하지 않았던 릴리즈 사이클이
끝났습니다.
하지만, meltdown/spectre 관련한 일이 아주 끝난 건 아니라고 이야기 하는군요.
특히, indirect bracnh mitigation 을 위한 가장 큰 수정사항을 반영받기 위해선
커널만 업데이트 해선 안되고 컴파일러의 &amp;ldquo;retpoline&amp;rdquo; 지원이 있어야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /sys/devices/system/cpu/vulnerabilities/spectre_v2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;로 컴파일러 지원이 있는지 알 수 있는데, 컴파일러 지원이 없다면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vulnerable: Minimal generic ASM retpoline
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이란 출력이 뜰겁니다.&lt;/p&gt;
&lt;p&gt;한가지 더 이야기 해둬야 할건, 이번 릴리즈에 meltdown/spectre 가 많은 영향을
끼치긴 했지만 그래도 다른 부분들은 평범하게 업데이트가 진행되었다는 겁니다.
즉, 이번 릴리즈는 좀 평범하지 않기 했지만 그렇다고 아주 이상하기만 한 릴리즈도
아니었다는 거죠.&lt;/p&gt;
&lt;p&gt;어쨌든 4.15 버전이 드디어 나왔습니다!&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-addressing-mmapsem-contention&#34;&gt;[LSF/MM TOPIC] Addressing mmap_sem contention&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/4c20d397-1268-ca0f-4986-af59bb31022c@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/4c20d397-1268-ca0f-4986-af59bb31022c@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널에서 메모리 매핑은 mmap_sem 이라는 reader-writer semaphor 를 이용해
race condition 으로부터 보호되고 있습니다.  당연하게도, 쓰레드가 많은 환경에선
여기 부하가 심하게 걸리고 성능 확장을 저해하게 됩니다.  Peter Zijlstra 의
Speculative Page Fault 패치는 페이지 폴트 시에 메모리 매핑을 할 때 mmap_sem 을
잡지 않고 매핑하려 시도해보고 중간에 동시에 같은 영역을 매핑하려 한 쓰레드가
존재하면 abort &amp;amp; retry 를 하는식으로 이 문제를 완화시킵니다.
해당 패치셋은 최근 Laurent 에 의해 다시 포팅되어 커뮤니티에 올라오기도 했죠.
실제로 ebizzy[1] 와 같이 쓰레드를 많이 쓰는 벤치마크에서는 두배가까이 성능
향상이 있었다고 하구요.&lt;/p&gt;
&lt;p&gt;하지만 Speculative Page Fault 만으로는 모든 문제가 해결되지 않기에 mmap_sem
자체에 대한 논의를 LSFMM 에서 하고 싶다는 메일입니다.&lt;/p&gt;
&lt;p&gt;병렬 프로그래밍에 관심있는 제게도 흥미로운 주제네요.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://ebizzy.sourceforge.net/&#34;&gt;http://ebizzy.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-lrulock-scalability&#34;&gt;[LSF/MM TOPIC] lru_lock scalability&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/2a16be43-0757-d342-abfb-d4d043922da9@oracle.com&#34;&gt;https://lkml.kernel.org/r/2a16be43-0757-d342-abfb-d4d043922da9@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;최근에 덜 사용된 (Least Recently Used) 페이지를 가려내기 위해 사용되는
&lt;code&gt;lru_lock&lt;/code&gt; 은 메모리 집중적 벤치마크를 돌릴 때 커널에서 가장 뜨거워지는 락들
가운데 하나입니다.
당연히 확장성 문제가 있죠.&lt;/p&gt;
&lt;p&gt;이걸 배칭 또는 페이지 개별적 락킹을 통해 해결해 보자는 안을 내놓고 이에 대해
LSFMM 에서 이야기 해보자는 메일입니다.&lt;/p&gt;
&lt;p&gt;RFC 패치가 벌써 올라왔네요:
&lt;a href=&#34;https://lkml.kernel.org/r/20180131230413.27653-1-daniel.m.jordan@oracle.com&#34;&gt;https://lkml.kernel.org/r/20180131230413.27653-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;git-pull-rcu-changes-for-v416&#34;&gt;[GIT PULL] RCU changes for v4.16&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180129100051.ndq4osy45fz3g26a@gmail.com&#34;&gt;https://lkml.kernel.org/r/20180129100051.ndq4osy45fz3g26a@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From: Ingo Molnar &lt;a href=&#34;mailto:mingo@kernel.org&#34;&gt;mingo@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.16 머지 윈도우가 열렸으니 Ingo 가 4.16 을 위한 rcu 쪽 변경사항을 리누스에게
풀리퀘스트 보냈습니다.
사실 이건 별로 흥미로운 메일은 아닐 수 있지만, 4.16 에서 RCU 가 어떻게 변경될지
알 수 있겠죠.
그리고, 제가 작년 프라하와 상해에서 만들어 올렸던, 패치 9개가 있습니다 ;)&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-0064-mm-towards-parallel-address-space-operations&#34;&gt;[RFC PATCH 00/64] mm: towards parallel address space operations&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180205012754.23615-1-dbueso@wotan.suse.de&#34;&gt;https://lkml.kernel.org/r/20180205012754.23615-1-dbueso@wotan.suse.de&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lsquo;mmap_sem&amp;rsquo; 은 커널의 메모리 관리에서 자주 사용되는 락으로, 많은 scalability
문제의 중심에 있습니다.  이 패치셋은 mmap_sem 을 range locking 기법을 활용해서
바꿔냄으로써 병렬성을 확보하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-v2-mm-swap-frontswap-fix-thp-swap-if-frontswap-enabled&#34;&gt;[PATCH -mm -v2] mm, swap, frontswap: Fix THP swap if frontswap enabled&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180207070035.30302-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180207070035.30302-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;zswap 은 THP 를 고려하지 않기 때문에 THP 가 켜진 상태에서 zswap 이 frontswap
으로 동작할 경우 일부 어플리케이션은 segfault 와 memory corruption 을 낼 수
있는 문제가 있었습니다.  커밋 bd4c82c22c367e068 (&amp;ldquo;mm, THP, swap: delay
splitting THP after swapped&amp;rdquo;) 때문에 발생한 문제였구요.  이를 고치기 위한
패치입니다.
out&amp;rdquo;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc9</title>
      <link>/post/lkml_news_v4.15-rc9/</link>
      <pubDate>Tue, 23 Jan 2018 12:16:07 +0900</pubDate>
      <guid>/post/lkml_news_v4.15-rc9/</guid>
      <description>&lt;h2 id=&#34;not-final-415-this-weekend&#34;&gt;&lt;em&gt;Not&lt;/em&gt; final 4.15 this weekend&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxzQBH5gnG92ah-PREfOqb5_rjWriLH3fWHMWS1=BSQFw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxzQBH5gnG92ah-PREfOqb5_rjWriLH3fWHMWS1=BSQFw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;원래대로라면 4.15 정식 버전의 릴리즈가 될 타이밍이었습니다만&amp;hellip;
아직 충분히 안정화 되지 않은 것 같다는 토발즈의 판단 아래 이번주에도 rc 버전이
나왔습니다.  rc9 입니다.
2011년의 3.1-rc9 이후 처음 나온 rc9 이네요.&lt;/p&gt;
&lt;p&gt;이번 릴리즈는 x86, arm powerpc, mips 쪽의 arch 업데이트, 드라이버, 그리고
네트워킹 핵심부 업데이트가 주된 변경이군요.&lt;/p&gt;
&lt;p&gt;다음주에는 꼭 4.15를 릴리즈 하고 싶다고 하는데, 아마도 다음주에는 4.15 정식
버전이 릴리즈되길 빕니다.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-topic-cma-and-larger-page-sizes&#34;&gt;[LSF/MM TOPIC] CMA and larger page sizes&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/3a3d724e-4d74-9bd8-60f3-f6896cffac7a@redhat.com&#34;&gt;https://lkml.kernel.org/r/3a3d724e-4d74-9bd8-60f3-f6896cffac7a@redhat.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Contiguous Memory Allocator (CMA) 는 할당에 사용되는 메모리 영역을 비트맵으로
관리하는데, 페이지 하나에 비트 하나씩 주면 비트맵을 traverse 하는데 너무 많은
시간이 걸리므로, 하나의 비트가 여러개의 페이지를 담당하도록 되어있습니다.
이게 CMA 의 응답시간에는 큰 도움이 되지만, fragmentation 으로 인한 메모리
낭비가 심합니다.  Laura Abbott 은 이걸 LSFMM 에서 논의해보고 싶어하는군요.&lt;/p&gt;
&lt;h2 id=&#34;git-pull-tools-linux-kernel-memory-model&#34;&gt;[GIT PULL tools] Linux kernel memory model&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180125093440.GA875@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20180125093440.GA875@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Paul McKenney 의 리눅스 커널 메모리 모델이 리눅스 커널 소스트리의 &lt;code&gt;tools/&lt;/code&gt;
디렉토리로 머지될 것 같습니다!
이 모델은 &lt;code&gt;cat&lt;/code&gt; 언어로 쓰여져서 &lt;code&gt;herd7&lt;/code&gt; 시뮬레이터로 실행될 수 있어서, 동시성을
갖는 코드가 실제로 어떻게 동작할지 검사할 수 있게 해줍니다.
과장 좀 보태서 자동화된 memory-barriers.txt 라고도 할 수 있죠.&lt;/p&gt;
&lt;p&gt;이미 Ingo Molnar 가 풀 했군요.  별다른 문제 없다면 정식 버전으로는 4.17
버전에서 볼 수 있겠습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc8</title>
      <link>/post/lkml_news_v4.15-rc8/</link>
      <pubDate>Tue, 16 Jan 2018 13:26:26 +0900</pubDate>
      <guid>/post/lkml_news_v4.15-rc8/</guid>
      <description>&lt;h2 id=&#34;linux-415rc8&#34;&gt;Linux 4.15-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFz=PcxdARFpCTyQCJKaJcBwVUB9y6XAXM8VyyxnbRD=bw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFz=PcxdARFpCTyQCJKaJcBwVUB9y6XAXM8VyyxnbRD=bw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;마침내 여덟번째 rc 버전의 릴리즈입니다.  스펙터 버그를 성능 저하 없이 막기 위한
구글의 해결책, Retpoline 지원이 들어갔군요.  그 외에는 드라이버 업데이트여서
일단 rc8 에 걸맞는 조용함이긴 하다고 토발즈는 평하네요.  자, 다음주에는 4.15 가
릴리즈될런지?  아니면 rc9 이 나오고 말런지?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc7</title>
      <link>/post/lkml_news_v4.15-rc7/</link>
      <pubDate>Sat, 13 Jan 2018 10:30:13 +0900</pubDate>
      <guid>/post/lkml_news_v4.15-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-415rc7&#34;&gt;Linux 4.15-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwbmKznuQZe_VemxXJPSmB-9yy8uyWsMZcrkA4T=m8xkw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwbmKznuQZe_VemxXJPSmB-9yy8uyWsMZcrkA4T=m8xkw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Meltdown 과 Spectre 로 떠들썩했던 시간을 지나 4.15 의 일곱번째 rc 버전이 릴리즈
되었습니다.  지난 여섯번째 릴리즈 때도 상당히 안정화에 신경써야 할 시점임에도
x86 pti (page table isolation) 업데이트 패치가 많이 머지되어 의아했는데, 이게
Meltdown 과 Spectre 버그 때문이었음도 밝혀졌죠.
그렇다곤 해도 그 외의 부분은 예상대로 상당히 안정화 되어가고 있다고 합니다.&lt;/p&gt;
&lt;p&gt;더불어, Thomas Geixner 등의 인텔쪽 커널 개발자들의 노력 덕에 pti 등 Meltdown 과
Spectre 버그를 위한 패치가 잘 관리되어 비교적 쉽게 머지될 수 있었음에 리누스가
감사를 표하네요.  욕할땐 욕하고 칭찬할 땐 칭찬하고. ;)&lt;/p&gt;
&lt;p&gt;아무튼, 이때문에 4.15 는 rc8 까지 릴리즈 할 계획이라고 합니다.  4.15 는 2주일
후에나 릴리즈 되겠군요.&lt;/p&gt;
&lt;h2 id=&#34;lsfmm-2018-call-for-proposals&#34;&gt;LSF/MM 2018: Call for Proposals&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180115163952.GB26120@cmpxchg.org&#34;&gt;https://lkml.kernel.org/r/20180115163952.GB26120@cmpxchg.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 스토리지, 파일 시스템, 메모리 관리 쪽 개발자들의 모임인 LSFMM 서밋 2018
을 위한 CFP 가 공개되었습니다.  올해도 4월에 하네요.  장소는 유타입니다.  1월
31일까지 토론하고 싶은 주제를 메일로 보내면 흥미로운 주제를 바탕으로 주제를
꾸미고, 그 외에도 그냥 참가하고 싶은 사람도 메일 보내면 내부적으로 심사 후
초대를 해주는 것 같네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc6</title>
      <link>/post/lkml_news_v4.15-rc6/</link>
      <pubDate>Tue, 02 Jan 2018 13:34:11 +0900</pubDate>
      <guid>/post/lkml_news_v4.15-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-415rc6&#34;&gt;Linux 4.15-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzU_Q04CVEABo50x24yeTaP-yzzrB1wTPeOiOgAbSKiDA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzU_Q04CVEABo50x24yeTaP-yzzrB1wTPeOiOgAbSKiDA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;한국시간으로는 1월 1일, 토발즈의 현지 시각으로는 2017년의 마지막날, 4.15 의
여섯번째 rc 버전이 릴리즈 되었습니다.&lt;/p&gt;
&lt;p&gt;지난주는 크리스마스 등의 연휴 때문인지 참 조용했죠.  덕분에 이번 릴리즈의
변경사항도 많지 않습니다.
다만 x86 pti 쪽 업데이트가 있었기 때문에 이번엔 rc8 까지 릴리즈 할수도 있을 것
같다고 하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>spec cpu2006 벤치마크 수정하기</title>
      <link>/post/spec_cpu2006_modification/</link>
      <pubDate>Sun, 24 Dec 2017 17:30:12 +0900</pubDate>
      <guid>/post/spec_cpu2006_modification/</guid>
      <description>&lt;p&gt;경우에 따라서 SPEC CPU2006 의 벤치마크 중 일부의 소스코드를 수정하고 싶을 수
있습니다.  예를 들어 특정 벤치마크가 구체적으로 어떻게 동작하는지 알아보기 위해
디버깅 메세지를 추가하고자 할수도 있고, 코드 변경을 통해 성능을 높인다거나 해볼
수도 있겠죠.  그러나, SPEC CPU2006 은 엄정한 벤치마크 수트이기 때문에
소스코드는 물론, 소스코드를 사용하는 도구가 변경된 경우 에러 메세지를 내고
수행을 거부합니다.  수정된 소스코드로 얻어진 결과는 벤치마크 결과로 적합하지
않기 때문이죠.&lt;/p&gt;
&lt;p&gt;때문에, 어쩔 수 없이 수정이 필요하면서도 기존의 수행 방법을 따르려면 이 에러를
내는 곳을 없애는 게 한가지 방법이 될 수 있습니다.  다음의 패치를 적용하면
이 검증 코드가 사라져서 수정된 코드로도 벤치마크를 돌릴 수 있게 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff --git a/bin/formatter/setup_common.pl b/bin/formatter/setup_common.pl
index 36170cda1649..b21890972dbd 100755
--- a/bin/formatter/setup_common.pl
+++ b/bin/formatter/setup_common.pl
@@ -278,13 +278,13 @@ sub check_important_files {
     return if (   $::suite_version &amp;gt; 4
                &amp;amp;&amp;amp; !$ENV{&#39;SPEC_CHECK&#39;});
     $::check_integrity = 1;
-    foreach my $important_file (jp(&#39;bin&#39;, basename($0)),
-                                grep { m/$re/ } keys %::file_md5) {
-        if (!check_files(\%::file_md5, $important_file)) {
-            print STDERR &amp;quot;\n\nPart of the tools ($important_file) is corrupt!\nAborting...\n\n&amp;quot;;
-            exit 1;
-        }
-    }
+#    foreach my $important_file (jp(&#39;bin&#39;, basename($0)),
+#                                grep { m/$re/ } keys %::file_md5) {
+#        if (!check_files(\%::file_md5, $important_file)) {
+#            print STDERR &amp;quot;\n\n Part of the tools ($important_file) is corrupt!\nAborting...\n\n&amp;quot;;
+#            exit 1;
+#        }
+#    }
 }
 
 1;
diff --git a/bin/setup_common.pl b/bin/setup_common.pl
index 36170cda1649..d9dbe214d498 100755
--- a/bin/setup_common.pl
+++ b/bin/setup_common.pl
@@ -219,9 +219,9 @@ sub md5filedigest {
 sub load_module {
     my ($module, $quiet) = @_;
 
-    if ($::check_integrity &amp;amp;&amp;amp; !check_files(\%::file_md5, jp(&#39;bin&#39;, $module))) {
-	die &amp;quot;\n\nPart of the tools ($module) is corrupt!  Aborting...\n\n&amp;quot;;
-    }
+#    if ($::check_integrity &amp;amp;&amp;amp; !check_files(\%::file_md5, jp(&#39;bin&#39;, $module))) {
+#	die &amp;quot;\n\nPart of the tools ($module) is corrupt!  Aborting...\n\n&amp;quot;;
+#    }
     eval &amp;quot;require \&amp;quot;$module\&amp;quot;;&amp;quot;;
     print &#39;.&#39; unless ($quiet);
     if ($@) {
@@ -278,13 +278,13 @@ sub check_important_files {
     return if (   $::suite_version &amp;gt; 4
                &amp;amp;&amp;amp; !$ENV{&#39;SPEC_CHECK&#39;});
     $::check_integrity = 1;
-    foreach my $important_file (jp(&#39;bin&#39;, basename($0)),
-                                grep { m/$re/ } keys %::file_md5) {
-        if (!check_files(\%::file_md5, $important_file)) {
-            print STDERR &amp;quot;\n\nPart of the tools ($important_file) is corrupt!\nAborting...\n\n&amp;quot;;
-            exit 1;
-        }
-    }
+#    foreach my $important_file (jp(&#39;bin&#39;, basename($0)),
+#                                grep { m/$re/ } keys %::file_md5) {
+#        if (!check_files(\%::file_md5, $important_file)) {
+#            print STDERR &amp;quot;\n\nPart of the tools ($important_file) is corrupt!\nAborting...\n\n&amp;quot;;
+#            exit 1;
+#        }
+#    }
 }
 
 1;
diff --git a/bin/util.pl b/bin/util.pl
index ccf4a72477c0..c8c0cd786522 100755
--- a/bin/util.pl
+++ b/bin/util.pl
@@ -211,11 +211,11 @@ sub copy_tree {
                     offer_verify_advice();
 		    return 0;
 		}
-		if ($sumhash-&amp;gt;{$sf} ne md5filedigest($sf)) {
-		    Log(0, &amp;quot;\n$sf is corrupt!\n&amp;quot;);
-                    offer_verify_advice();
-		    return 0;
-		}
+#		if ($sumhash-&amp;gt;{$sf} ne md5filedigest($sf)) {
+#		    Log(0, &amp;quot;\n$sf is corrupt!\n&amp;quot;);
+#                    offer_verify_advice();
+#		    return 0;
+#		}
 	    }
             if ($sf =~ /\.bz2$/) {
               copy_bz2_file($sf, $file, [$target], 0);
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc5</title>
      <link>/post/lkml_news_v4.14-rc4/</link>
      <pubDate>Sun, 24 Dec 2017 14:24:13 +0900</pubDate>
      <guid>/post/lkml_news_v4.14-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-415rc5&#34;&gt;Linux 4.15-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFy1U+uBLEAoCWU3=BqEbROW6rsbaHUdYJArR6iYQQWo_A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFy1U+uBLEAoCWU3=BqEbROW6rsbaHUdYJArR6iYQQWo_A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 다섯번째 rc 버전이 평소 스케쥴보다 하루 일찍 릴리즈 되었습니다.
원래대로라면 내일일텐데, 미국 시간으로는 크리스마스 이브라서 그냥 오늘 릴리즈
한다는군요.&lt;/p&gt;
&lt;p&gt;이번 rc5 의 변경 사항들도 지난 릴리즈의 rc5 와 비슷했다고 하는데, 다만 x86 의
커널 페이지 테이블 격리화 관련 작업이 진행 중인 게 좀 예외라고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-v3-patch-05-eliminate-zonelock-contention-for-willitscalepagefault1-and-parallel-free&#34;&gt;[RFC v3 PATCH 0/5] Eliminate zone-&amp;gt;lock contention for will-it-scale/page_fault1 and parallel free&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180509085450.3524-1-aaron.lu@intel.com&#34;&gt;https://lkml.kernel.org/r/20180509085450.3524-1-aaron.lu@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;패치셋 저자는 112개 CPU를 갖는 Intel Skylake 서버에서 will-it-scale/page_fult1
워크로드를 돌려보았고 80% CPU 가 zone-&amp;gt;lock 에서 스핀하며 시간을 보내고 있음을
파악했습니다.  이 문제를 해결하기 위한 RFC 패치의 세번째 버전입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0013-improve-shrinkslab-scalability-old-complexity-was-on2-new-is-on&#34;&gt;[PATCH v4 00/13] Improve shrink_slab() scalability (old complexity was O(n^2), new is O(n))&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/152586686544.3048.15776787801312398314.stgit@localhost.localdomain&#34;&gt;https://lkml.kernel.org/r/152586686544.3048.15776787801312398314.stgit@localhost.localdomain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shrink_slab()&lt;/code&gt; 의 복잡도가 O(n^2) 이기 때문에 많은 shrinker 와 메모리 cgroups
를 갖는 기계에서는 확장성의 병목이 될 수 있습니다.  이를 간단한 스크립트로
보이는데요.  먼저 다음과 같이 4000개의 memory cgroup 들을 만들고,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$echo 1 &amp;gt; /sys/fs/cgroup/memory/memory.use_hierarchy
$mkdir /sys/fs/cgroup/memory/ct
$echo 4000M &amp;gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes
$for i in `seq 0 4000`;
        do mkdir /sys/fs/cgroup/memory/ct/$i;
        echo $$ &amp;gt; /sys/fs/cgroup/memory/ct/$i/cgroup.procs;
        mkdir -p s/$i; mount -t tmpfs $i s/$i; touch s/$i/file;
done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;아래와 같이 drop cache 를 다섯번 수행하며 여기 걸리는 시간을 측정했습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$time echo 3 &amp;gt; /proc/sys/vm/drop_caches

0.00user 13.78system 0:13.78elapsed 99%CPU
0.00user 5.59system 0:05.60elapsed 99%CPU
0.00user 5.48system 0:05.48elapsed 99%CPU
0.00user 8.35system 0:08.35elapsed 99%CPU
0.00user 8.34system 0:08.35elapsed 99%CPU
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;반복해서 drop cache 를 할 뿐이기 때문에 뒤따르는 drop cache 들은 실질적으로
cache 를 비우진 않고 그저 shrinker 와 memcg 를 둘러볼 뿐입니다.  그럼에도 최소
5.48초가 걸렸군요.  그만큼 병목이 심하단 이야기죠.&lt;/p&gt;
&lt;p&gt;패치는 shrink_slab() 의 복잡도를 O(n)으로 고쳤고, 이후 다음과 같이 오버헤드가 거의 사라지는 결과를 내놓았습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.00user 1.10system 0:01.10elapsed 99%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
0.00user 0.00system 0:00.01elapsed 64%CPU
0.00user 0.01system 0:00.01elapsed 82%CPU
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;약 548배의 성능 향상이군요!&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-v2-0021-mm-thp-swap-swapoutswapin-thp-as-a-whole&#34;&gt;[PATCH -mm -V2 00/21] mm, THP, swap: Swapout/swapin THP as a whole&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180509083846.14823-1-ying.huang@intel.com&#34;&gt;https://lkml.kernel.org/r/20180509083846.14823-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난번에도 소개한, THP 를 2 MiB 그대로 한번에 swap out / swap in 하는
패치입니다.  기존에는 THP 를 regular page 로 쪼개서 swap out / swap in
했었거든요.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-mm-thp-doc-add-document-for-thpswpoutthpswpoutfallback&#34;&gt;[PATCH -mm] mm, THP, doc: Add document for thp_swpout/thp_swpout_fallback&lt;/h2&gt;
&lt;p&gt;https:/lkml.kernel.org/r/20180509082341.13953-1-ying.huang@intel.com&lt;/p&gt;
&lt;p&gt;앞에 설명한 THP swap 관련 최적화는 단계별로 적용되고 있는데, 그와 함께
&lt;code&gt;/proc/vmstat&lt;/code&gt; 에는 &lt;code&gt;thp_swpout&lt;/code&gt; 과 &lt;code&gt;thp_swpout_fallback&lt;/code&gt; 필드가
추가되었습니다.  그에 대한 문서화가 아직 안들어와 있었는데, 이를 추가하는
패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc5</title>
      <link>/post/lkml_news_v4.15-rc5/</link>
      <pubDate>Sun, 24 Dec 2017 14:24:13 +0900</pubDate>
      <guid>/post/lkml_news_v4.15-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-415rc5&#34;&gt;Linux 4.15-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFy1U+uBLEAoCWU3=BqEbROW6rsbaHUdYJArR6iYQQWo_A@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFy1U+uBLEAoCWU3=BqEbROW6rsbaHUdYJArR6iYQQWo_A@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 다섯번째 rc 버전이 평소 스케쥴보다 하루 일찍 릴리즈 되었습니다.
원래대로라면 내일일텐데, 미국 시간으로는 크리스마스 이브라서 그냥 오늘 릴리즈
한다는군요.&lt;/p&gt;
&lt;p&gt;이번 rc5 의 변경 사항들도 지난 릴리즈의 rc5 와 비슷했다고 하는데, 다만 x86 의
커널 페이지 테이블 격리화 관련 작업이 진행 중인 게 좀 예외라고 하는군요.&lt;/p&gt;
&lt;h2 id=&#34;re-about-the-try-to-remove-crossrelease-feature-entirely-by-ingo&#34;&gt;Re: About the try to remove cross-release feature entirely by Ingo&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171229014736.GA10341@X58A-UD3R&#34;&gt;https://lkml.kernel.org/r/20171229014736.GA10341@X58A-UD3R&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lockdep 의 cross release 기능은 너무 느렸고, false positive 가 많다는 이유로,
특히 false positive 가 너무 많다는 이유로 Ingo Molnar 에 의해 제거되려 하고
있습니다.  관련해서 이 블로그에서도 일단 default 로는 disable 되는 변경이 v4.14
에 있었음을 이야기 했죠.&lt;/p&gt;
&lt;p&gt;Cross release 의 개발자인 박병철님께서 이에 대해 다른 의견을 내놓는 메일입니다.&lt;/p&gt;
&lt;h2 id=&#34;re-hang-with-v415rc-trying-to-swap-back-in&#34;&gt;Re: Hang with v4.15-rc trying to swap back in&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1514407817.4169.4.camel@HansenPartnership.com&#34;&gt;https://lkml.kernel.org/r/1514407817.4169.4.camel@HansenPartnership.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;스왑 레이어를 최적화하는 많은 변경이 최근에 있었는데, 그 중 하나가 시스템 행을
일으키는군요.  관련된 패치들을 발본색원해서 레포팅 한 메일입니다.  충분히 빠른
swap device 에 대해서는 swapcache 를 건너뛰게 한게 원인이 되었군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc4</title>
      <link>/post/lkml_news_v4.15-rc4/</link>
      <pubDate>Mon, 18 Dec 2017 17:46:23 +0900</pubDate>
      <guid>/post/lkml_news_v4.15-rc4/</guid>
      <description>&lt;h2 id=&#34;linux-415rc4&#34;&gt;Linux 4.15-rc4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFysmVGm_shBvK4kmaS+_PsMEt3Mz_b+Dm0SDrmVtUofbA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFysmVGm_shBvK4kmaS+_PsMEt3Mz_b+Dm0SDrmVtUofbA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 네번째 rc 버전입니다.  지난 rc 버전들이 생각보다 커서 토발즈가 좀
걱정했는데, 이번 릴리즈에 들어서는 평범한 네번째 rc 만큼이나 변화가 많이 없어
충분히 안정화 되기 시작한 것 같다고 하는군요.&lt;/p&gt;
&lt;p&gt;이번에 가장 눈에 띌만한 변화는 suspend/resume 처리를 정리하고 고친 것이라고
합니다.  크로스 락킹 디버깅 기능은 부팅 시간을 늘리는 문제 등도 있어선지 이번에
일단 제거되었네요.  나중에 다시 되살릴 계획은 있는 것 같습니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-11-move-kfreecallrcu-to-slabcommonc&#34;&gt;[PATCH v2 1/1] Move kfree_call_rcu() to slab_common.c&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513895570-28640-1-git-send-email-rao.shoaib@oracle.com&#34;&gt;https://lkml.kernel.org/r/1513895570-28640-1-git-send-email-rao.shoaib@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 의 modularity 를 개선하는 패치입니다.  몇가지 쟁점이 있긴 하지만 기본
아이디어는 받아들여지는 분위기군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc3</title>
      <link>/post/lkml_news_v4.15-rc3/</link>
      <pubDate>Mon, 11 Dec 2017 11:25:13 +0900</pubDate>
      <guid>/post/lkml_news_v4.15-rc3/</guid>
      <description>&lt;h2 id=&#34;linux-415rc3&#34;&gt;Linux 4.15-rc3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFz9O9R8u3ori-QNPz4ALU+0B=Es0gd+oWmsce5qxugxXA@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFz9O9R8u3ori-QNPz4ALU+0B=Es0gd+oWmsce5qxugxXA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 세번째 rc 버전입니다.  지난주보단 조금 늦게 릴리즈 되었네요.&lt;/p&gt;
&lt;p&gt;일반적으로 rc3 릴리즈는 좀 변경사항이 많지만 이번엔 그중에서도 변경사항이 많은
편이라 걱정된다고 하는군요.  대부분은 드라이버쪽 변경인데 perf 쪽 변경도 꽤
있고 core, networking, kvm, arch, 문서 업데이트도 물론 있습니다.  어쨌든
토발즈는 이제는 정말 안정화가 되어가길 바라는 마음이라는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-mmslab-do-not-hash-pointers-when-debugging-slab&#34;&gt;[PATCH v2] mm/slab: Do not hash pointers when debugging slab&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513179267-2509-1-git-send-email-geert+renesas@glider.be&#34;&gt;https://lkml.kernel.org/r/1513179267-2509-1-git-send-email-geert+renesas@glider.be&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번 버전에 들어와 포인터 값을 기반으로 한 예측을 통해 공격이 들어오는 걸
방지하기 위해 &amp;lsquo;%p&amp;rsquo; 가 포인터를 그냥 출력하는게 아니라 hash 한 다음에 출력하도록
바뀌었죠.  때문에 디버깅이 좀 까다로워졌구요.  디버깅을 위해 온전한 포인터가
필요한 곳에선 &amp;lsquo;%pX&amp;rsquo; 를 써야 합니다.  일단 slab 쪽에서도 그게 필요하기에 DEBUG
옵션이 켜졌을 때에는 &amp;lsquo;%pX&amp;rsquo; 를 사용하도록 하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-mm-unclutter-thp-migration&#34;&gt;[RFC PATCH] mm: unclutter THP migration&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171207124815.12075-1-mhocko@kernel.org&#34;&gt;https://lkml.kernel.org/r/20171207124815.12075-1-mhocko@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Transparent Huge Page 를 위한 Michal Hocko 의 패치입니다.&lt;/p&gt;
&lt;p&gt;THP 마이그레이션을 위한 메모리 할당 콜백은 THP 가 한꺼번에 마이그레이션 될 수
있는지 보고, 마이그레이션 될 곳에 메모리가 부족해 불가능하거나 하다면 평범한
페이지를 할당받습니다.  이어서 unmap_and_mov() 가 THP 를 평범한 페이지로
쪼개고, 그사이 THP 의 head page 는 split_huge_page() 를 통해 LRU 리스트에
들어갑니다.  같은 일이 THP 할당에 실패할 때도 이러나는데, 이건 에러가 나기 쉬운
행위라고 Michal 은 봅니다.&lt;/p&gt;
&lt;p&gt;LRU 리스트에 split_huge_page() 를 행하는 것도 잘못된 행위인데, 모든 tail page
들이 마이그레이션 되지 않았기 때문이죠.  이로 인해 발생하는 문제는 사용자가
각각 처리해야 했습니다.&lt;/p&gt;
&lt;p&gt;Michal 은 이 패치를 통해 THP 처리를 위한 특수한 부분들을 migrate_pages() 단계로
올려서 이 상황을 정리하고자 합니다. 여기서 unmap_and_move() 가 ENOMEM 으로
실패하면 THP 페이지를 쪼개고 현재 존재하는 리스트로 옮깁니다.  이렇게 함으로써
우리는 모든 THP 서브페이지들을 항상 마이그레이션 하고 특정한 migrate_pages()
사용자들은 앞서 이야기한 경우를 별도로 처리할 필요가 없어지는 것이죠.&lt;/p&gt;
&lt;h2 id=&#34;patch-lockinglockdep-make-configlockdepcrossrelease-and-configlockdepcompletions-optional&#34;&gt;[PATCH] locking/lockdep: Make CONFIG_LOCKDEP_CROSSRELEASE and CONFIG_LOCKDEP_COMPLETIONS optional&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513062681-5995-1-git-send-email-byungchul.park@lge.com&#34;&gt;https://lkml.kernel.org/r/1513062681-5995-1-git-send-email-byungchul.park@lge.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아직 락들의 classification 이 잘 되어있지 않아 너무 많은 false positive 가
나오고 있어 lockdep 의 CROSSRELEASE 와 COMPLETIONS 를 기본 활성에서 옵셔널로
바꾸는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-reduce-memory-bloat-with-thp&#34;&gt;[PATCH] mm: Reduce memory bloat with THP&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513301359-117568-1-git-send-email-nitin.m.gupta@oracle.com&#34;&gt;https://lkml.kernel.org/r/1513301359-117568-1-git-send-email-nitin.m.gupta@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 는 굉장히 aggressive 하게 huge page 를 선호하기 때문에 메모리 사용량을
증가시키는 문제가 있습니다.  Redis 등에서는 그런 이유로 THP 를 꺼버리라고
하기도 하죠.&lt;/p&gt;
&lt;p&gt;이 패치는 어플리케이션이 특정 메모리 영역에 MADV_DONTNEED 를 보내면, 이 영역은
&amp;ldquo;space-efficient&amp;rdquo; 로 마크되어서 해당 영역은 항상 huge page 를 사용하는게 아니라
khugepaged 가 해당 영역이 정말로 매핑되어 있고 사용되고 있는지에 따라 huge page
로 승격을 시키도록 합니다.  어플리케이션이 다시 MADV_HUGEPAGE 를 해당 영역에
내면, 해당 영역은 다시 non-space-efficient 로 마크되어 원래대로 동작합니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-rcutorture-add-basic-arm64-support-to-run-scripts&#34;&gt;[PATCH v2] rcutorture: Add basic ARM64 support to run scripts&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1513070365-13436-1-git-send-email-lianglihao@huawei.com&#34;&gt;https://lkml.kernel.org/r/1513070365-13436-1-git-send-email-lianglihao@huawei.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 를 테스트하는 rcutorture 드라이버의 드라이버 ;) 스크립트에 aarch64 지원을
추가하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v5-0078-xarray-v5&#34;&gt;[PATCH v5 00/78] XArray v5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171215220450.7899-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20171215220450.7899-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Matthew Wilcox 의 XArray 다섯번째 버전 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-08-restructure-struct-page&#34;&gt;[PATCH 0/8] Restructure struct page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171216164425.8703-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20171216164425.8703-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct page&lt;/code&gt; 는 매우 민감한 구조체죠.  요걸 구조를 살짝 바꾸려는 패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc2</title>
      <link>/post/lkml_news_v4.15-rc2/</link>
      <pubDate>Mon, 04 Dec 2017 13:38:11 +0900</pubDate>
      <guid>/post/lkml_news_v4.15-rc2/</guid>
      <description>&lt;h2 id=&#34;linux-415rc2&#34;&gt;Linux 4.15-rc2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxPBszFBt91KRNBrsQdJ10b+6fh9ySNzSKSX7JOq4WRPw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxPBszFBt91KRNBrsQdJ10b+6fh9ySNzSKSX7JOq4WRPw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 의 두번째 rc 버전이 나왔습니다.&lt;/p&gt;
&lt;p&gt;동부 지방을 여행 중인가 보군요.  평소보다 좀 이른 시간에 릴리즈가 됐습니다.
원하던 것보단 큰 릴리즈가 되어버렸지만 대부분 fixup 이기에 큰 문제는 없는 것
같다는군요.  Kernel ASLR leak 을 막기 위해 모든 &amp;ldquo;%P&amp;rdquo; 로 프린트되는 어드레스
주소를 해시해 버린다고 하네요.  이럼 디버깅할 때 좀 짜증날 수 있긴 하겠지만
다른 방법이 별로 없었다고&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v3-07-ktask-multithread-cpuintensive-kernel-work&#34;&gt;[RFC PATCH v3 0/7] ktask: multithread CPU-intensive kernel work&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171205195220.28208-1-daniel.m.jordan@oracle.com&#34;&gt;https://lkml.kernel.org/r/20171205195220.28208-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CPU-intensive 한 작업을 커널 내에서 병렬로 진행하도록 도와주는 새로운 프레임웍,
ktask 의 RFC 패치입니다.  예를 들어, 부팅 시에 &lt;code&gt;struct page&lt;/code&gt; 들을 초기화 하는
작업은 현재 하나의 쓰레드가 처리하게 되어 booting 시간이 길어지는데, 멀티코어
시스템이라면 ktask 를 이용해 이 작업을 자동으로 병렬화 할 수 있다는 겁니다.
기존에도 workqueue, kthread_worker 와 같이 병렬 작어을 위한 커널 기능들이
존재하지만, workqueue 는 작업을 쓰레드별로 나누는 걸 대신 해주지는 않고,
kthread_worker 는 하나의 쓰레드만 지원하기 때문에 ktask 를 새로 만들었다고
하네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v4-0073-xarray-version-4&#34;&gt;[PATCH v4 00/73] XArray version 4&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171206004159.3755-1-willy@infradead.org&#34;&gt;https://lkml.kernel.org/r/20171206004159.3755-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XArray 네번째 버전의 패치가 올라왔습니다.  LinuxCon Europe 에서도 관련 발표를
재밌게 들었었는데요.  XArray 는 Radix tree 의 API 를 대체할 목적으로 만들어진
새로운 자료구조 인터페이스입니다.  이번 버전의 패치를 통해 page cache 가 완전히
Radix tree 에서 XArray 로 갈아타게 했다는군요.  하지만 여전히 문제들도 많아서
바로 머지되진 않을 것 같다고 패치의 작성자도 이야기하네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.15-rc1</title>
      <link>/post/lkml_news_v4.15-rc1/</link>
      <pubDate>Mon, 27 Nov 2017 11:09:15 +0900</pubDate>
      <guid>/post/lkml_news_v4.15-rc1/</guid>
      <description>&lt;h2 id=&#34;linux-415rc1&#34;&gt;Linux 4.15-rc1&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFzcudOPSwbD9XfVxBgFsQOhBjyncyYnGDYwZUEHOGUwcw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFzcudOPSwbD9XfVxBgFsQOhBjyncyYnGDYwZUEHOGUwcw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;예정대로 2주만에 4.15 의 첫번째 rc 버전이 나왔습니다.&lt;/p&gt;
&lt;p&gt;지난주는 추수감사절이라 다들 휴가인 사람이 많았기에 첫번째 주에 최대한 많이
풀리퀘스트를 받았고 지난주는 좀 더 까다롭게 풀리퀘스트를 검사했군요.  토발즈는
두번째 주 동안 랩톱 들고 여행중이었고, 랩톱에서는 전체 모듈 빌드를 하지 않기
때문이라 합니다.  메인테이너들도 가능한 첫번째 주에 중요 플리퀘스트를 보내는
식으로 협조를 해줬다고 합니다.  그네들도 두번째주는 휴가가고 싶었을테니&amp;hellip; ;)&lt;/p&gt;
&lt;p&gt;4.14 가 LTS 였기에 이번 머지윈도우에는 변화가 크지 않을 것으로 예상했는데
생각보다 많은 풀리퀘스트가 있었다고 합니다.  4.9 때와는 다른 경향인데, 4.9 에
비해 4.14 가 변화가 크지 않았기 때문 아니겠냐고 토발즈는 생각하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v3-04-introduce-getuserpageslongterm&#34;&gt;[PATCH v3 0/4] introduce get_user_pages_longterm()&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/151197872943.26211.6551382719053304996.stgit@dwillia2-desk3.amr.corp.intel.com&#34;&gt;https://lkml.kernel.org/r/151197872943.26211.6551382719053304996.stgit@dwillia2-desk3.amr.corp.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;커널스페이스에서 꽤 오랜시간 페이지를 잡아둬야 하는 경우를 위한, 예를 들어
dma-to-dax vs truncate 문제를 위한, get_user_pages() 의 변종의 추가입니다.
실제 이를 사용하는 패치는 나중에 올라올 것 같군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-0018-introduce-a-new-tool-valid-access-checker&#34;&gt;[PATCH 00/18] introduce a new tool, valid access checker&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1511855333-3570-1-git-send-email-iamjoonsoo.kim@lge.com&#34;&gt;https://lkml.kernel.org/r/1511855333-3570-1-git-send-email-iamjoonsoo.kim@lge.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Valid access checker (Vchecker) 라는 이름의 새로운 메모리 에러 탐색 도구의
소개입니다.  Out of bound access, use after free 같은, 의도되지 않은 메모리
접근을 잡아낼 수 있게 해준다고 하는군요.  Kernel Address SANitizer (KASAN) 의
기능에 많이 의존하고 있기 때문에 KASAN 메인테이너 중 하나인 Dmitry 는 이게
별도의 도구로 머지되어야 할지 의문스럽다며 머지될 예정이면 한번 더 이야기
해달라고 하네요.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-03-mmcma-manage-the-memory-of-the-cma-area-by-using-the-zonemovable&#34;&gt;[PATCH v2 0/3] mm/cma: manage the memory of the CMA area by using the ZONE_MOVABLE&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1512114786-5085-1-git-send-email-iamjoonsoo.kim@lge.com&#34;&gt;https://lkml.kernel.org/r/1512114786-5085-1-git-send-email-iamjoonsoo.kim@lge.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CMA 를 위한 영역은 하나의 zone 내에 위치하게 되는데, 이 zone 내에 다양한 특성의
페이지들이 혼재되어있다보니 이런저런 문제가 생깁니다.  CMA 영역을 MOVABLE zone
만 쓰도록 함으로써 이 문제를 해결하는 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-tipcorercu-021-deemphasize-smpreadbarrierdepends&#34;&gt;[PATCH tip/core/rcu 0/21] De-emphasize {smp_,}read_barrier_depends&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171201195053.GA23494@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171201195053.GA23494@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RCU 패치는 일단 Paul 의 트리에 머지된 후, tip 트리로 머지되고 나서야 토발즈의
트리에 들어갑니다.  이번에도 tip 트리로 머지되기 위한 패치들이 올라왔습니다.
그중에서도 이 시리즈는 READ_ONCE() 에 들어간 smp_read_barrier_depends() 의
architecture independent 한 코드로부터의 제거를 담고 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSSummit 2017 Attendence - 05</title>
      <link>/post/osse2017_05/</link>
      <pubDate>Sun, 26 Nov 2017 12:40:11 +0900</pubDate>
      <guid>/post/osse2017_05/</guid>
      <description>&lt;p&gt;컨퍼런스 둘째날부터는 kernel summit track 이 시작됩니다.  이번 컨퍼런스 참가는
아무래도 kernel summit 에서의 시끄럽고 정신없는 토론에 참여하고 싶기
때문이었기에 오늘부터가 제게는 가장 재밌는 시간입니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/1.jpg)&lt;/p&gt;
&lt;p&gt;아침 일찍 일어나 컨퍼런스 장소로 출발합니다.  10명이 함께 묵는 방을 사용하고
있기에 일찍 일어나지 않으면 샤워를 제시간에 하기 어려우므로 조금 일찍
일어났습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/2.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/3.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/4.jpg)&lt;/p&gt;
&lt;p&gt;일찍 출발한 만큼 일찍 도착.  아직 부스에 사람도 없고 조용하네요.  한동안 부스
한켠에 준비된 휴식 공간에 앉아 커널 메일링 리스트도 읽고 코드도 보고 했습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/5.jpg)&lt;/p&gt;
&lt;p&gt;아침식사가 차려졌습니다.  간단하게 커피에 빵.  저 호밀빵이 담백하고 맛있더군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/6.jpg)&lt;/p&gt;
&lt;p&gt;키노트.  키노트에 나선 분들이 속한 회사나 단체의 미래에 대한 전망과 상황을 알
수 있어 재밌습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/7.jpg)&lt;/p&gt;
&lt;p&gt;키노트 끝나고 커피타임.  샌드위치류가 나왔는데 역시 호텔 음식은 맛있습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/8.jpg)&lt;/p&gt;
&lt;p&gt;오늘 오후부터 kernel summit track 이 진행되었습니다.  kernel summit track 은
다른 세션들처럼 친절한 발표 형태가 아니라 한명이 앞에서 토론을 진행하고
중간중간 나머지 개발자들이 끼어들어 질문하고 토론합니다.  딸랑 한두장
슬라이드만 들고 나오는 발표자도 많습니다.  참여한 사람들이 초대받은 커널
메인테이너기 때문이죠.  다만 2015년부터는 kernel summit 을 다른 이벤트와 함께
열고, 함께 열린 이벤트의 참가자들이 참여할 수 있게 하고 있습니다.  덕분에 더
많은 토론이 가능해졌죠.&lt;/p&gt;
&lt;p&gt;근데 또 덕분에 너무 많은 사람들이 참여하다보니 좀 토론의 질이 떨어진다고
생각했는지, 올해부터는 kernel summit 이 technical summit 과 maintainer summit
으로 나뉘었습니다.  technical summit 은 기존의 kernel summit 처럼 개방 형태로
진행하고 maintainer summit 은 메인테이너 중에도 메인테이너만 모아서 기존처럼
폐쇄된 초대 형식으로 진행합니다.  누굴 초대해야 하나 기준에 대해서도 많은
토론이 있었습니다.  최종적으로는 약 30명만 초대해서 진행했다더군요.  maintainer
summit 은 마지막날에 진행되었습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/9.jpg)&lt;/p&gt;
&lt;p&gt;한 세션이 끝나고 정리중인 모습.  유명한 메인테이너들이 많이 보입니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/10.jpg)&lt;/p&gt;
&lt;p&gt;차려진 스폰서들의 부스를 돌아다니며 각 부스에서 사인을 받아 빙고를 두개 이상
만들어 제출한 사람들에 대해 추첨을 통해 선물을 주는 이벤트가 진행되고
있었습니다.  그렇잖아도 부스 방문하는거 좋아하는 제게는 아주 제격인 이벤트죠!
사정이 있는건지 열리지 않은 부스도 있었기에 모두 사인을 채우지는 못했지만 열린
부스는 하나도 빼놓지 않고 모두 돌아다니며 사인을 받았습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/11.jpg)&lt;/p&gt;
&lt;p&gt;오후에 있던 세션 중 하나로 John Corbet 의 주최로 커널 개발자들과의 토론 시간이
있었습니다.  메일링 리스트에서 보던 이름의 주인들을 이렇게 직접 보니
반갑더군요.  말미에 테스트 어떻게 하느냐고 질문도 던졌는데, 다들 다양한
방법으로 테스트를 하고 계시더군요.  특히 인텔의 자동 테스트 bot 이 유용하게
사용되고 있는 것 같더군요.  커뮤니티를 위한 큰 기여인 것 같습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/12.jpg)&lt;/p&gt;
&lt;p&gt;어제는 이브닝 이벤트인 career fair 에서 술이 무제한으로 계속 나오기에 한잔씩
마시며 회사에서 오신 분들이랑 농담 따먹기 하고 기술적 이야기도 하면서 두시간이
넘게 놀았는데, 오늘의 이브닝 이벤트는 좀 애매합니다.  술도 맥주 한잔밖에
안줘요! :&#39;(
그래서 그런지 좀 일찍 이브닝 이벤트가 끝났습니다.  덕분에 어제보다 꽤 일찍
숙소에 돌아와 버리게 되었습니다.  이 기회에 첫날 아쉬웠던 프라하 구경을 밤중에
다시 나와봤습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/13.jpg)&lt;/p&gt;
&lt;p&gt;한결 여유가 생겨서 그런지 이런저런 이국적 느낌 나는 가게들도 둘러볼 수 있어
좋았습니다.  여기는 뭔가 나무로 만든 물건들을 전문으로 판매하는 것 같던데
신기한 물건들이 많더군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/14.jpg)&lt;/p&gt;
&lt;p&gt;체코는 꼭두각시 인형이 유명하다죠?  하나 기념으로 사고 싶었고 가격도 꽤
저렴했지만 사면 둘곳도 없어서 그냥 나왔습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/15.jpg)&lt;/p&gt;
&lt;p&gt;그렇다 해도 멀리까지 걸어갈 시간도 안되고 해서 그냥 카를교[1]에 다시 왔습니다.
다시 봐도 아름답네요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/16.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_05/17.jpg)&lt;/p&gt;
&lt;p&gt;오늘의 마무으리는 마트에서 산 소세지와 Kozel 맥주로.  소세지 가격이 한국 돈으로
단돈 5백원.  우리나라면 천하장사 얇은거 하나 먹을까 말까한 가격인데 실하고
뽀드득거리는 식감에 육즙도 많더군요.  프라하 물가 아주 칭찬합니다.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://en.wikipedia.org/wiki/Charles_Bridge&#34;&gt;https://en.wikipedia.org/wiki/Charles_Bridge&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSSummit 2017 Attendence - 04</title>
      <link>/post/osse2017_04/</link>
      <pubDate>Sun, 26 Nov 2017 12:13:00 +0900</pubDate>
      <guid>/post/osse2017_04/</guid>
      <description>&lt;p&gt;드디어 컨퍼런스 첫날입니다.  아침 8시부터 아침식사와 등록이 시작되므로, 7시에
숙소에서 나왔습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/1.jpg)&lt;/p&gt;
&lt;p&gt;어제는 날이 흐리더니, 오늘은 비도 옵니다.  우산을 챙겨 나옵니다.  그래도 어제
미리 학회장에 들렀던 덕에 길을 헤매지 않고 찾아갈 수 있었습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/2.jpg)&lt;/p&gt;
&lt;p&gt;빗길을 따라 한참을 걸어서 도착했습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/3.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/4.jpg)&lt;/p&gt;
&lt;p&gt;도착하니 7시 반 정도.  공식 스케쥴은 8시부터 시작이라 아직 한산합니다.  스폰서
부스도 아직 준비중인 곳이 많고, 아직 준비가 덜된 곳도 많습니다.  돌아다니며
인사도 하고 간단한 스몰토크도 하면서 시간을 보냈습니다.  만나면 &amp;ldquo;how are you?&amp;rdquo;
하고 간단한 이야기를 시작할 수 있는 서구문화는 개인적으로 참 맘에 드는
문화입니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/5.jpg)&lt;/p&gt;
&lt;p&gt;아침식사입니다.  체제비는 지원받지 못하기에 이런걸로 끼니를 잘 때워야 합니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/6.jpg)&lt;/p&gt;
&lt;p&gt;키노트가 시작되었습니다.  오랜만의 리눅스 파운데이션 행사라 짐 젬린의 반가운
얼굴도 보고 좋았네요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/7.jpg)&lt;/p&gt;
&lt;p&gt;키노트가 끝나고 커피 타임에 나온 간식.  믿고 먹는 연어가 올라간 샌드위치입니다.
요런게 가볍게 먹기 좋죠.  먹는중에 샌프란시스코에서 온 흑인 시스어드민 분께서
먼저 말을 걸어 주셔서 대화를 했는데 매우 즐거운 대화였습니다.  사진도
찍혔더군요. 하하.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/8.jpg)&lt;/p&gt;
&lt;p&gt;세션은 CloudOpen Track, ContainerCon Track, Embedded Linux Conference, LinuxCon
Track 등등으로 나뉘어 동시진행되었는데요.  아무래도 커널 프로그래밍을 하는
위주의 이야기는 LinuxCon 에 모여있더군요.  흥미로운 발표가 많았습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/9.jpg)&lt;/p&gt;
&lt;p&gt;오후 휴식시간.  사람이 정말 많더군요.  참고로 컨퍼런스는 지하부터 2층까지,
3층을 모두 빌려서 진행되었습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/10.jpg)&lt;/p&gt;
&lt;p&gt;오후 휴식시간엔 고기가 나왔습니다.  이걸로 오늘의 저녁을 때운다는 각오로 열심히
먹습니다&amp;hellip; 만, 사람이 원체 많아서 음식이 빨리 동납니다.  그래도 그간 컨퍼런스
다니면서 획득한 눈치밥으로 어떻게든 남은 음식을 찾아서 배를 채웠습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/11.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/12.jpg)&lt;/p&gt;
&lt;p&gt;원래 저녁은 먹지 않으려 했는데, perf 등의 프로파일러를 개발하고 계신 송태웅님을
만나서 함께 저녁을 먹게 되었습니다.  배가 불러서 전 간단히 수프 한접시만.
타지에서 만난 한국 사람과 즐겁게 이야기 나누면서 맥주도 한잔 기울였습니다.&lt;/p&gt;
&lt;p&gt;식사 후에는 Career fair 이브닝 이벤트가 있어 또 가봤는데, 사진이 없네요.  아직
취업 준비중이 아니라 그냥 흥미로 들어가봤는데 유익한 정보가 많았습니다.  맥주
한잔 하면서 이야기 나누는 형태였는데, 덕분에 적당한 취기와 함께 농담 따먹기도
많이 하고 기술적인 이야기도 많이 나눴습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/13.jpg)&lt;/p&gt;
&lt;p&gt;이브닝 이벤트가 너무 즐거웠기에 돌아가는 길이 아쉬울 정도.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/14.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_04/15.jpg)&lt;/p&gt;
&lt;p&gt;그냥 돌아가기엔 시간이 좀 있기에 시내를 조금 둘러보면서 좀 걸었습니다.  프라하
역사도 복잡하고 해서 뭔가 와닿지는 않은 도시인데, 그래도 아름다움 하나는
인정할만 한 것 같습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14</title>
      <link>/post/lkml_news_v4.14/</link>
      <pubDate>Mon, 13 Nov 2017 17:07:44 +0900</pubDate>
      <guid>/post/lkml_news_v4.14/</guid>
      <description>&lt;h2 id=&#34;linux-414&#34;&gt;Linux 4.14&lt;/h2&gt;
&lt;p&gt;htpps://lkml.kernel.org/r/CA+55aFwqXh4rgJJ3T98k8wa-JYF7t8mWuwUjdxkbZyOyDEcGzQ@mail.gmail.com&lt;/p&gt;
&lt;p&gt;드디어 v4.14 의 릴리즈입니다.  이번 버전은 또하나의 LTS 커널이 될 예정이군요.&lt;/p&gt;
&lt;p&gt;동시에, v4.15 를 위한 머지 윈도우가 열렸습니다.  이번 머지 윈도우는 thanks
giving 이랑 겹치게 되었는데, 이때문에 머지 윈도우를 연장할지 아니면 아예 1주일
줄일지 토발즈는 고민중인 것 같네요.&lt;/p&gt;
&lt;h2 id=&#34;rfc-patch-v11-for-415-0124-restartable-sequences-system-call&#34;&gt;[RFC PATCH v11 for 4.15 01/24] Restartable sequences system call&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171114200414.2188-2-mathieu.desnoyers@efficios.com&#34;&gt;https://lkml.kernel.org/r/20171114200414.2188-2-mathieu.desnoyers@efficios.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;몇년전부터 올라오고 있으나 아직 머지되지 못한, restartable sequence 패치의 최신
버전이 또 올라왔습니다.  유저스페이스의 크리티컬 섹션을 커널에게 제어할 수
있도록 도와주는 기능입니다.  이번엔 머지될런지?&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-selftestvm-add-test-case-for-mmap-across-128tb-boundary&#34;&gt;[PATCH V2] selftest/vm: Add test case for mmap across 128TB boundary.&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171123030313.6418-1-aneesh.kumar@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171123030313.6418-1-aneesh.kumar@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;128TB mmap() 에 대한 테스트 케이스가 kselftest 에 추가되었습니다.  x86_64 와
powerpc64 를 지원하는군요.&lt;/p&gt;
&lt;p&gt;이후 몇가지 코멘트를 받고 v3 도 올라왔습니다:
&lt;a href=&#34;https://lkml.kernel.org/r/20171123165226.32582-1-aneesh.kumar@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171123165226.32582-1-aneesh.kumar@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;xarray-documentation&#34;&gt;XArray documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171124011607.GB3722@bombadil.infradead.org&#34;&gt;https://lkml.kernel.org/r/20171124011607.GB3722@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난 ossummit europe 에서 흥미롭게 발표를 들었던 XArray 의 문서입니다.  radix
tree 를 대체할 만한 인터페이스를 목표로 하고있다고 하더군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-mm-do-not-stall-registershrinker&#34;&gt;[PATCH] mm: Do not stall register_shrinker&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1511481899-20335-1-git-send-email-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/1511481899-20335-1-git-send-email-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;메모리가 부족할 때 깨어나 일을 하게 되는 shrinker 의 등록 시 메모리가 부족해서
다른 것들에 의해 shink_slab() 에서 시간을 보내느라 register_shrinker() 에서
수십초씩이나 시스템을 멈춰있게 만드는 문제가 있었는데, shrink_slab() 에서
shrinker 등록 여부를 rwsem 에 대한 contention 확인으로 파악하고 slab shrinking
을 멈춰주도록 수정했습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc8</title>
      <link>/post/lkml_news_v4.14-rc8/</link>
      <pubDate>Wed, 08 Nov 2017 04:19:47 +0900</pubDate>
      <guid>/post/lkml_news_v4.14-rc8/</guid>
      <description>&lt;h2 id=&#34;linux-414rc8&#34;&gt;Linux 4.14-rc8&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/738207/&#34;&gt;https://lwn.net/Articles/738207/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;v4.14 를 향한 (아마도) 마지막 rc 버전의 릴리즈입니다.&lt;/p&gt;
&lt;p&gt;정말로 별다른 일 없었다면 그냥 이번에 v4.14 릴리즈를 할 계획이었지만 그정도는
아니었다고 하는군요.
어쨌든 rc8 덕분에 v4.15 merge window 는 thanksgiving week 를 포함하게 되었는데
토발즈는 이때 가족과 휴가를 갈 계획이라 랩톱 가지고 휴가다니는 동안에도 머지를
잘 할 수 있길 바라지만 문제가 생기면 merge window 를 연장할 수도 있겠다고
하네요.  일단 어떻게 될지 두고보자는군요.&lt;/p&gt;
&lt;p&gt;이번 릴리즈에 포함된 변경은 대부분 드라이버 쪽 변경이고, SPDK 관련 소스코드에
라이센스 추가 등을 한 사소하지만 커다란 양의 변경이 있습니다.  또 하나, 4.13
버전에서 /proc/cpuinfo 가 CPU frequency 를 부정확하게 표시하게 하는 중대한
버그가 있었는데, 다행히 이번에 고쳐졌군요.&lt;/p&gt;
&lt;h2 id=&#34;page-allocator-bottleneck&#34;&gt;Page allocator bottleneck&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/cef85936-10b2-5d76-9f97-cb03b418fd94@mellanox.com&#34;&gt;https://lkml.kernel.org/r/cef85936-10b2-5d76-9f97-cb03b418fd94@mellanox.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;차세대 고속 NIC 에 의해 두각이 드러나는 소프트웨어쪽 bottleneck 을 찾다보니
page allocator 쪽에 오버헤드가 있다는 이야기로 시작된 쓰레드로, 9월부터 시작된
쓰레드인데 요즘 다시 답변이 활기차게 붙고 있습니다.&lt;/p&gt;
&lt;p&gt;ConnectX-5 100 Gbps NIC, Xeon CPU E5-2680 v3 @ 2.50GHz CPU 의 시스템에서
super_netperf 를 사용, 128개 TCP 스트림을 RX queue 갯수 바꿔가며 돌려가며 BW 를
측정했습니다.  mlx5 드라이버를 다음과 같이 수정, 사용했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1) RX page cache disabled, 2 packets per page.
2) RX page cache disabled, one packet per page.
3) Huge RX page cache, one packet per page.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;두번째 드라이버는 200Gbps NIC 을 시뮬레이션 하기 위한 변경입니다.
첫번째, 세번째 드라이버는 RX queue
갯수에 따라 BW 가 증가, line rate 까지 도달하는데 두번째 드라이버는 그렇지
못하고 8개 RX queue 부터는 오히려 BW 가 줄어들었습니다.
이때 perf top 은
&lt;code&gt;85.58% [kernel] [k] queued_spin_lock_slowpath&lt;/code&gt; 를 보여, 페이지 할당 메커니즘의
자체적 성능도 문제고, 확장성도 문제라고 이슈를 최초 제기했습니다.&lt;/p&gt;
&lt;p&gt;PCP (per-CPU) allocator 를 사용해 성능이 좋아지는 걸 확인하고 쓰레드가 닫히는
것 같았는데, 11월 2일자로 다시 새로운 실험 결과를 가지고 왔습니다.
PCP allocator 내의 페이지가 남아있을 동안은 문제가 없지만, 이후부터는 페이지가
할당된 코어와 해제되는 코어가 달라서 buddy allocator 에 부담을 주더란
이야기입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-x86selftests-add-test-for-mapping-placement-for-5level-paging&#34;&gt;[PATCH] x86/selftests: Add test for mapping placement for 5-level paging&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171108102250.38609-1-kirill.shutemov@linux.intel.com&#34;&gt;https://lkml.kernel.org/r/20171108102250.38609-1-kirill.shutemov@linux.intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;x86 의 5-level paging 을 위한 selftest 가 추가되었네요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSSummit 2017 Attendence - 03</title>
      <link>/post/osse2017_03/</link>
      <pubDate>Sat, 04 Nov 2017 10:20:16 +0900</pubDate>
      <guid>/post/osse2017_03/</guid>
      <description>&lt;p&gt;OSSummit 등록도 마쳤고, 남은 하루는 프라하 성 쪽을 둘러보기로 했습니다.
내일부터는 OSSummit 발표를 아침부터 오후까지 들어야 하므로, 프라하 관광을 해가
떠있을 때 하는건 오늘이 마지막이니 부지런히 걸어야 합니다.
어떻게 생각해 보면 꽤 강행군이기도 하고, 아침 일찍 도착하길 다행이다 싶습니다.&lt;/p&gt;
&lt;h1 id=&#34;vltava1&#34;&gt;Vltava[1]&lt;/h1&gt;
&lt;p&gt;![foo]
(/img/osse_03/4.jpg)&lt;/p&gt;
&lt;p&gt;OSSummit 컨퍼런스 회장인 힐튼 프라하 호텔은 프라하 시내의 동북쪽에 위치해
있어서 조금만 걸으면 아침에 심카드 사고 나서 걸었던 블타바 강이 나옵니다.
아까 지나갔던 코스지만 한번 더 걸어가기로 합니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/5.jpg)&lt;/p&gt;
&lt;p&gt;프라하에 있는 동안 날씨가 계속 흐렸습니다.
해가 뜬걸 본적이 많지 않군요.
햇빛에 약한 편이라 다행이기도 하지만 맑은 날씨면 더 멋진 모습을 볼 수 있을 것
같아 아쉬웠습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/6.jpg)&lt;/p&gt;
&lt;p&gt;블타바 강에는 백조 등의 새가 꽤 많습니다.
암스테르담에서도 느낀거지만 백조는 크기가 참 큽니다.
백조 왕자 이야기에서 왕자들이 백조가 된다는 상상은 그 크기에서 비롯된 거 아닐까
하는 실없는 생각도 해봅니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/7.jpg)&lt;/p&gt;
&lt;p&gt;블타바 강에는 유람선도 많이 다닙니다.
강 건너편의 풍경과 잘 어울립니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/8.jpg)&lt;/p&gt;
&lt;p&gt;아침에는 여기서 블타바 강을 떠났지만, 이번엔 유명한 다리인 카를교를 지나 프라하
성까지 갈 계획이므로 강변을 따라 더 걸어갑니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/9.jpg)&lt;/p&gt;
&lt;p&gt;뭔지 모를 조형물도 있는데 가이드가 사람들 모아놓고 설명하고 있는걸 보면 뭔가가
있나봅니다.&lt;/p&gt;
&lt;h1 id=&#34;charles-bridge2&#34;&gt;Charles Bridge[2]&lt;/h1&gt;
&lt;p&gt;![foo]
(/img/osse_03/10.jpg)&lt;/p&gt;
&lt;p&gt;저멀리 카를교가 보이기 시작합니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/11.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/12.jpg)&lt;/p&gt;
&lt;p&gt;드디어 카를교에 다왔습니다.
카를교는 1357년 카를 5세의 명령으로 착공, 15세기 초에 완성된 블타바강의
다리입니다.
다리의 길이는 총 520m 로, 프라하 성과 구시가지를 연결하고 있으며,
여러 아름다운 동상들이 다리 위에 있어서 동상들의 다리라고 부르는 사람들도 있는
것 같습니다.
동상들은 원본은 박물관에 모셔다 두었다고 하고, 현재 다리 위에 있는 건
모조품이라고 하는 것 같더군요.
프라하에서 가장 유명한 관광지 중 하나라고 할 수 있는 것 같습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/13.jpg)&lt;/p&gt;
&lt;p&gt;이런 느낌의 동상들이 있습니다.
종교가 있으면 좀 더 다른 느낌으로 프라하를 즐길 수 있었을지도 모르겠습니다.
실제로 프라하는 종교적 의미가 많이 있는 도시 같더군요.
하지만 저랑 종교는 별로 연이 없어서&amp;hellip;&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/14.jpg)&lt;/p&gt;
&lt;p&gt;이 동상은 어떤 규칙을 따라 만지면 어떤 소원을 이뤄준다고 적혀 있더군요.
프라하에 한번 더 올 수 있게 해준댔다&amp;hellip;
아직 프라하에 그정도 감정까진 싹트지 않았기도 하고 해서 딱히 만지진 않았습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/15.jpg)&lt;/p&gt;
&lt;p&gt;다리 위 곳곳에는 미술품, 기념품 등을 파는 노점들이 많이 있습니다.
가장 유명한 관광지 중 하나인 만큼 관광객들도 매우 많습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/16.jpg)&lt;/p&gt;
&lt;p&gt;긴 다리를 건너길 마무리 할쯤 보이는 모습입니다.
저기엔 어떤 사람들이 살까요?  여기 사는 사람들은 어떤 기분일까요?&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/17.jpg)&lt;/p&gt;
&lt;p&gt;다리를 건너오고나선 주욱 오르막길입니다.
오르막길을 따라 한참을 올라가면 프라하 성이 있습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/18.jpg)&lt;/p&gt;
&lt;p&gt;중간중간 아름다운 건축물이 계속 나옵니다.
걸그룹 보고 &amp;lsquo;예쁜애 옆에 예쁜애 옆에 예쁜애&amp;rsquo; 뭐 이런식으로 수식하는 것 같은데,
프라하는 &amp;lsquo;예쁜 건축물 옆에 예쁜 건축물 옆에 예쁜 건축물&amp;rsquo; 이라 해도 과언이 아닐
것 같습니다.
어디든 조금만 걷다보면 사진찍고 싶은 건축물이 나옵니다.&lt;/p&gt;
&lt;h1 id=&#34;prague-castle3&#34;&gt;Prague Castle[3]&lt;/h1&gt;
&lt;p&gt;![foo]
(/img/osse_03/19.jpg)&lt;/p&gt;
&lt;p&gt;프라하 성으로 들어가기 직전 오르막길의 끝에서 걸어온 길을 바라보고 찍은
사진입니다.
올라오면서 크게 느끼지 못했는데 이렇게 보니 꽤 올라왔구나 싶더군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/20.jpg)&lt;/p&gt;
&lt;p&gt;높은 지대인만큼 프라하 성에서는 프라하 시내를 바라볼 수 있습니다.
당연하게도 쌍안경도 있구요.
적당히 찍었더니 구글 포토가 이어붙여서 파노라마 사진을 만들어줬습니다.
날씨가 맑았다면 더 멋졌을텐데, 조금 아쉽기도 하지만, 전망이 멋졌습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/21.jpg)&lt;/p&gt;
&lt;p&gt;프라하 성은 매우 넓습니다.
일부 정원과 공간들은 입장권을 구매해야 들어갈 수 있습니다.
하지만 이번 프라하 여행의 주 목적은 관광이 아니기도 하고, 시간도 많지 않으므로
그런 곳은 스킵합니다.&lt;/p&gt;
&lt;h1 id=&#34;strahov-monastic-brewery4&#34;&gt;Strahov Monastic Brewery[4]&lt;/h1&gt;
&lt;p&gt;![foo]
(/img/osse_03/22.jpg)&lt;/p&gt;
&lt;p&gt;제 목표는 어디까지나 스트라호프 수도원 맥주 양조장입니다.
스트라호프 수도원은 1142년에 건립된 수도원으로, 1628년엔 여기 양조장이
생겼습니다.
한동안 폐업한 적도 있다지만 지금은 다시 부활되어 긴 역사를 자랑하는 맥주
양조장이 지금까지도 영업을 하고 있게 된겁니다.
솔직히 프라하의 역사와 문화가 좀 생경했는데, 이것만큼은 친숙하죠.
놓칠 수 없습니다.&lt;/p&gt;
&lt;p&gt;벌써 해가 지기 시작했습니다.
스트라호프 수도원 표지판을 따라 계속해서 걸어갑니다.
한참을 더 걸어야 합니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/23.jpg)&lt;/p&gt;
&lt;p&gt;어김없이 오는길에 길을 잃고 헤맸습니다.
하마터면 전혀 다른 음식점에 들어갈 뻔 했습니다.
하지만, 드디어 스트라호프 수도원에 도착했습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/24.jpg)&lt;/p&gt;
&lt;p&gt;그리고, 양조장을 가리키는 표지판이 보입니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/25.jpg)&lt;/p&gt;
&lt;p&gt;기다리고 기다리던 양조장입니다.
실내는 물론이고 실외에도 사람이 가득했습니다.
잠깐의 웨이팅을 거쳐 다른 테이블에 합석했습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/2.jpg)&lt;/p&gt;
&lt;p&gt;양조장에서 직접 만든 맥주가 3종이 있는 것 같습니다.
Amber, Dark, 그리고 IPA.
호박은 좋아하지 않으므로 Dark 와 IPA 를 한잔씩, 그리고 안주로 야채 샐러드를
주문했습니다.
가장 싼 안주이긴 하지만, 맥주 포함해서 가격은 한국돈으로 2만원이 안됩니다.
프라하의 물가에 건배하며 맥주를 마셔봅니다.&lt;/p&gt;
&lt;p&gt;하지만 10월 말인데다 해가 이미 졌고 산위라 그런지 찬바람이 마구 들어옵니다.
오들오들 떨면서도 천천히 다 마셨습니다.
다 마시고 계산하려 하는데 맥주 더 마시겠냐고 하더군요.
맘같아서야 그러고 싶지만 추워서 &amp;ldquo;no thanks&amp;rdquo; 이야기 하고 나왔습니다.&lt;/p&gt;
&lt;h1 id=&#34;back-to-old-town-of-prague&#34;&gt;Back to Old Town of Prague&lt;/h1&gt;
&lt;p&gt;![foo]
(/img/osse_03/26.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/27.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/1.jpg)&lt;/p&gt;
&lt;p&gt;해가 완전히 져서 돌아오는 길은 완전히 밤입니다.
프라하는 야경도 유명합니다.
돌아오는 길에 프라하 성에 다시 올라가 야경을 감상했습니다.
특히 블타바 강에 비치는 불빛이 멋지더군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/28.jpg)&lt;/p&gt;
&lt;p&gt;곧바로 숙소로 돌아가기도 그러니 밤중의 프라하도 즐겨보기로 하고 구시가 거리를
천천히 거닐어 봅니다.&lt;/p&gt;
&lt;h1 id=&#34;finish-of-the-day&#34;&gt;Finish of the Day&lt;/h1&gt;
&lt;p&gt;![foo]
(/img/osse_03/29.jpg)&lt;/p&gt;
&lt;p&gt;아쉽지만 숙소 도착.
낮에 봤던 노점들도 이제 영업을 종료하고 있습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_03/3.jpg)&lt;/p&gt;
&lt;p&gt;맥주가 유명한 곳인만큼 (호스텔 벽에도 써있습니다.  프라하는 맥주가 물보다
싸니까 맥주 많이 마시라고.  전 지역 주민의 충고를 잘 받아들입니다 하하),
체코에서의 매일밤 마무리는 맥주와 함께 해야겠다고 생각했습니다.
그래서 점심에 심카드 사면서 봐두었던 마트에 가서 소세지와 맥주를 사왔습니다.
소세지는 앞의 포스트에서 사진으로도 올려뒀던 소세지 진열대에서 사왔는데, 무게를
재고 가격표를 붙여야 하는데 이걸 해주는 여성분은 영어를 못하시는 것 같더군요.
바디랭귀지로 주문하는데 뭔가 짜증을&amp;hellip;
가장 저렴한 편인 소세지를 샀습니다.  한 조각에 한국돈으로 오백원 정도밖에
안합니다.
우리나라에서 오백원이면 천하장사 소세지 젓가락굵기만한거나 살텐데, 역시 체코
물가 리스펙트합니다.
소세지 맛은 좀 짠 편인데 전 짠걸 잘 먹기도 하거니와, 짠만큼 맥주를 더 마시면 덜
짭니다.&lt;/p&gt;
&lt;p&gt;체코하면 필스너라는 인식이 있는 것 같은데 저 염소 맥주라고도 불리는 Kozel
맥주도 유명하다고 하더군요.
왠지 염소가 맘에 들어 샀는데, 한국돈으로 천원이 안됩니다.
맛은 탁월.&lt;/p&gt;
&lt;p&gt;이렇게 호스텔 휴게공간에서 맥주에 소세지를 함께 하며 하루를 마무리 합니다.&lt;/p&gt;
&lt;p&gt;하루동안 새삼 느낀게, 한국인 여행객이 정말 많더군요.
한시간 이상 한국말 못들은 경우가 많지 않은 거 같습니다.
호스텔에서도 꽤 많은 한국인이 있어서 휴게 공간에서 맥주 마시는 사이에도
앞자리에 한국인 커플과 모녀가 이야기를 나누더군요.&lt;/p&gt;
&lt;p&gt;이제 내일부터 OSSummit 이 시작됩니다.
어떤 흥미진진한 세션들이 있을지, 어떤 재밌는 이벤트가 준비되어 있을지, 커널
커뮤니티에서 메일로만 만났던 커널 개발자들과 만나서 어떤 이야기를 나눌지
기대하며 잠자리에 들었습니다.&lt;/p&gt;
&lt;p&gt;[&lt;code&gt;*&lt;/code&gt;] 이 다음 글부터는 OSSummit 이야기가 본격적으로 시작됩니다.  거꾸로,
프라하 여행 정보는 거의 없을 겁니다.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EB%B8%94%ED%83%80%EB%B0%94_%EA%B0%95&#34;&gt;https://ko.wikipedia.org/wiki/%EB%B8%94%ED%83%80%EB%B0%94_%EA%B0%95&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://en.wikipedia.org/wiki/Charles_Bridge&#34;&gt;https://en.wikipedia.org/wiki/Charles_Bridge&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://en.wikipedia.org/wiki/Prague_Castle&#34;&gt;https://en.wikipedia.org/wiki/Prague_Castle&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;https://www.tripadvisor.com/Attraction_Review-g274707-d634219-Reviews-The_Strahov_Monastic_Brewery-Prague_Bohemia.html&#34;&gt;https://www.tripadvisor.com/Attraction_Review-g274707-d634219-Reviews-The_Strahov_Monastic_Brewery-Prague_Bohemia.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSSummit 2017 Attendence - 02</title>
      <link>/post/osse2017_02/</link>
      <pubDate>Sat, 04 Nov 2017 04:58:24 +0900</pubDate>
      <guid>/post/osse2017_02/</guid>
      <description>&lt;h1 id=&#34;immigration&#34;&gt;Immigration&lt;/h1&gt;
&lt;p&gt;![immigration]
(/img/osse_02/14.jpg)&lt;/p&gt;
&lt;p&gt;먼저 공항에서 입국심사를 거쳐야 합니다.  한글 표지판이 많이 있어서 영어에
익숙지 않은 분들도 비교적 쉽게 적응할 수 있겠다 싶었습니다.&lt;/p&gt;
&lt;p&gt;제가 가장 많이 다녀온 외국은
미국인데요.   대한민국 여권 소지자는 미국에 갈 때 비자가 필요없지만 E-SATA 로
등록을 해야 하고, 언젠가부터 E-SATA 등록비도 몇만원 정도 생겼죠.  또, 미국은
입국심사가 왠지 날카롭다는 인상입니다.  입국할 때 입국심사 카드도 써야하고 여기
숙소 주소 등도 적어야 하고, 지문도 찍어야 하죠.  공항 보안검색대에선
투시카메라로 사진도 찍고.  그래도 뭐 간편하게 가는 편이라 생각했었습니다만
프라하 공항에서 생각이 바뀌었습니다.  대한민국 여권 소지자는 프라하에 갈때에도
비자가 필요없습니다.  입국심사를 위한 카드 작성도 없습니다.  입국심사관은 거의
아무것도 묻질 않습니다.  숙소가 어딘지도 알릴 필요 없고, 뭐하러 왔는지 꼬치꼬치
묻지도 않습니다.  지문도 찍지 않는군요.  정말 편하다는 인상을 받았습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/18.jpg)&lt;/p&gt;
&lt;p&gt;공항 사진입니다.  그렇게 크진 않네요.  아담한 크기의 공항입니다.
그래도 무료 와이파이도 잘 됩니다.&lt;/p&gt;
&lt;p&gt;프라하는 코룬이라는 단위의 통화를 사용합니다.  유로를 받는 곳도 있다고 하지만
왠만하면 코룬을 쓰는게 좋은 것 같습니다.  한국에서도 코룬 환전이 된다고 하는데,
급하게 오느라 미리 하지 못했습니다.  다른 여행객들도 프라하에서 직접 환전하는
경우가 많다고 하는군요.  공항 환전소는 환율이 좋지 않고 시내의 일부 환전소가
괜찮으므로, 공항에서는 시내 가는 교통비 정도만 환전하고, 시내의 추천 환전소에
가서 나머지를 환전하는게 좋다는 이야기가 많더군요.  일단 교통비와 심카드 살
돈을 생각해서 3만원 정도를 환전했습니다.
코룬 환율은 당시 1 코룬당 50원 정도.  수수료를 떼고 약 540 코룬이 제게
떨어졌습니다.  역시 공항 환전은 가성비가 좋지 않네요.&lt;/p&gt;
&lt;h1 id=&#34;to-the-hostel&#34;&gt;To The Hostel&lt;/h1&gt;
&lt;p&gt;이제 환전도 했으니 숙소로 이동을 해야겠습니다.
컨퍼런스 참가 지원 여부가 늦게 발표된 만큼 숙소도 늦게 잡았습니다.  하지만
특가로 나온 방이 있어 매우 저렴하게 구할 수 있었습니다.  외국에 혼자 나가면
호스텔을 예약하는 편입니다.  저렴한 가격에 각지의 여행객과 만날 수 있어
이득보는 느낌이거든요.&lt;/p&gt;
&lt;p&gt;사실 호스텔에 대한 처음 인상은 별로 좋지 않았습니다.  유럽 여행 가서 호스텔에서
변태 만나고 벼룩에 고생했다는 친구의 이야기도 있었고, 처음 이용했던 호스텔은
2014년에 Google I/O 가서 이용해 봤는데, 방도 엄청 좁고 시설이 열악했거든요.
하지만 두번째로 암스테르담에서 이용했던 호스텔 이후 인식이 완전 바뀌었습니다.
넓고 인테리어도 좋고 함께 방을 썼던 친구들도 유쾌해서 매우 즐거웠던
경험이었습니다.&lt;/p&gt;
&lt;p&gt;어쨌든 이번에 구한 숙소는 프라하 중심가에 위치한 호스텔.  그 가격에 이런
위치라니 시설이 얼마나 안좋길래 이렇게 나머지 조건이 좋은 걸까 걱정이 되기도
했습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/19.jpg)&lt;/p&gt;
&lt;p&gt;프라하에서는 버스, 지하철, 트램 등이 모두 하나의 교통권을 사용합니다.  교통권은
사용 시간대별로 가격이 매겨지며, 그 시간 내에는 환승이 모두 무료.  즉, 30분짜리
교통권을 사면 버스를 한대 타든 두대 타든 지하철을 갈아타든 30분 내에는 추가로
돈을 지불할 일이 없습니다.
전 119번 버스를 타고 나가서 지하철을 타고 시내로 이동할 계획입니다.
구글맵이 그렇게 추천했거든요.
구글맵은 약 40분 걸린다고 이야기 하는군요.
교통권 자판기에서 90분짜리를 뽑습니다.  32 코룬입니다.  한국돈으로 약
1,600원이군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/20.jpg)&lt;/p&gt;
&lt;p&gt;뽑은 교통권입니다.
유효 시간이 90분이라고 적혀 있습니다.&lt;/p&gt;
&lt;p&gt;공항을 나서기전 마지막으로 무료 와이파이를 이용해 필요한 정보를 최대한 미리
검색해두고 폰에 다운로드 받아둡니다.
여길 나서면 숙소에 도착하기 전까지는 인터넷이 불가능하니까요.  심각한 길치인
저로썬 큰 모험입니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/21.jpg)&lt;/p&gt;
&lt;p&gt;여행자들 가는길이 다 거기서 거기인지
여행자인 분들이 함께 움직입니다.
제가 프라하에 도착한 시각은 아침 9시 무렵.
전날 비가 왔는지 땅이 젖어있습니다.
일기예보로는 제가 머무르는 동안 계속 흐리고 때때로 비가 올 예정이더군요.&lt;/p&gt;
&lt;p&gt;프라하 버스 정류장은 모니터로 버스가 어디쯤 오고 있는지 자세히 표시됩니다.
한국 대중교통이 이런 시스템이 잘되어있기로 유명하다고 들었는데, 여긴 더 자세한
것 같다는 인상을 받았습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/22.jpg)&lt;/p&gt;
&lt;p&gt;도착한 버스를 탔습니다.  버스에 타면 승차권을 넣는 기계가 있는데, 거기
집어넣으면 위 사진처럼 집어넣은 시간이 찍힙니다.
표는 중간중간 검표원이 검사를 하게 되는데, 이 때 여기 찍힌 시간과 검사 시각
사이의 시간이 표에 적힌 유효시간 내인지를 보게 된다고 합니다.
버스기사는 딱히 표를 보거나 하지 않습니다.
신뢰를 기반으로 운영되는 시스템인거죠.
검표원을 만나진 못했습니다만, 무임승차 같은 짓은 하지 않기로 합시다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/23.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/24.jpg)&lt;/p&gt;
&lt;p&gt;버스에서 내리고 지하철 타는 길도 여행객들이 다들 우루루 움직여서 그냥 따라가도
되었습니다.
지하철도 상당히 노선이 간단해서 큰 어려움 없이 승차할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/25.jpg)&lt;/p&gt;
&lt;p&gt;지하철에서 내려 땅위로 나왔습니다.
길치가 인터넷으로부터의 실시간 도움 없이 숙소를 찾아야 하는 시간이 왔습니다.
숙소까지는 걸어서 3분 거리인데 역시 헤맸습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/26.jpg)&lt;/p&gt;
&lt;p&gt;길을 헤매는 와중에도 신기한 구경거리는 있습니다.
역시 프라하, 역시 시내 중심지입니다.
지나가는 관광객도 무척 많습니다.
단체 관광객, 가이드를 따라 투어중인 관광객도 많더군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/27.jpg)&lt;/p&gt;
&lt;p&gt;그래도 어찌어찌 숙소를 찾았습니다.
호스텔이 쇼핑몰처럼 생긴 건물 안에 있더군요.
의외의 위치선정이라 많이 헤맸습니다.
체크인 수속은 먼저 밟을 수 있지만, 방 청소 시간이 남아있어서 실질 체크인은 오후
두시부터 가능합니다.
등록데스크에 짐을 맡길 수 있으므로, 짐을 맡겨두고 체크인 시간까지 좀
돌아다니기로 합니다.
하지만 먼저 등록데스크의 무료 와이파이에 붙어 최대한 주변 정보를 받아둡니다.
일단 다음 목표는 시내 통신사 대리점에 가서 심카드를 구매하는 겁니다.&lt;/p&gt;
&lt;h1 id=&#34;sim-card-for-the-internet&#34;&gt;SIM Card for the Internet&lt;/h1&gt;
&lt;p&gt;![foo]
(/img/osse_02/28.jpg)&lt;/p&gt;
&lt;p&gt;거리에선 인터넷이 안되지만 숙소 위치는 파악했고 숙소까지 가면 인터넷이 됩니다.
조금 마음이 편안해지니 주변 경치도 눈에 들어옵니다.
프라하에서 심카드를 구매할 수 있는 통신사로 보다폰, O2, 그리고 T-mobile 이
있습니다만, T-mobile 을 많이들 추천하더군요.
미국 여행 시에도 T-mobile 에서 구매해서 나름 편하게 사용했으므로 T-mobile
대리점을 찾아갔습니다.
그런데, 아뿔싸.  일요일이라 쉬는 날이네요.
숙소로 돌아가 다시 인터넷 검색을 하니 좀 떨어진 위치에 큰 쇼핑몰이 있고 거기에
T-mobile 대리점이 있습니다.
조금 먼 길이라 인터넷 없이 찾아가려니 걱정되지만 일단 출발합니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/29.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/30.jpg)&lt;/p&gt;
&lt;p&gt;그래도 다운받아진 구글 지도가 있고 GPS 가 있으니 생각보다 어렵지 않게 길을
찾아갈 수 있었습니다.
점원 분께 여행자고 심카드를 구매하고자 한다고 하니 능숙하게 안내를
해주시는군요.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;데이터가 필요한가요?  문자는 필요한가요?&amp;rdquo;  &amp;ldquo;전 데이터만 있으면 되요!&amp;rdquo;&lt;/p&gt;
&lt;p&gt;통화, 문자 없이 1 GB 데이터를 LTE 속도로 30일간 사용할 수 있는 심카드를 약 200
코룬에 구매했습니다.
1 GB 데이터가 너무 많은거 아닌가 싶고 국내에서도 3G 쓰는데 LTE 가 필요한가
싶지만 이게 가장 저렴한 버전이라고 하시는군요.
생각해보면 제가 쓰는 폰인 넥서스5 는 LTE 지원함에도 국내에선 3G 데이터를
썼는데, 외국에서 오히려 LTE 써보네요.
아이러니&amp;hellip;&lt;/p&gt;
&lt;p&gt;개인적으로 외국 나갈때 자주 사용하는 선불심 판매소에서 파는 데이터 유심은
무제한 데이터에 대략 만원 후반대 가격인데, 200 코룬이면 약 만원이니 가성비도
나쁘지 않습니다.
심카드를 꽂고 폰을 재부팅 합니다.
도브리덴! 하는 안내문자가 날아오고 (도브리덴은 체코어로 인사말이라고 합니다),
인터넷이 됩니다.  할렐루야!&lt;/p&gt;
&lt;h1 id=&#34;local-foods-of-prague&#34;&gt;Local Foods of Prague&lt;/h1&gt;
&lt;p&gt;대리점을 나오니 바로 앞에 식료품 마트가 있습니다.
많은 외국은 인건비가 비싸서 그런지 음식점에서 사먹는 비용은 비싸지만 식재료는
무척 저렴해서, 직접 요리해 먹으면 우리나라보다도 훨씬 싸게 식사를 해결할 수 있는
경우가 많습니다.
때문에 저는 외국에 나오면 식료품 마트에서 먹을거리를 자주 사먹습니다.
여기가 제 식사의 대부분을 충당할 가능성이 큰 곳이므로 한번 둘러봤습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/2.jpg)&lt;/p&gt;
&lt;p&gt;체코하면 맥주입니다.
체코는 독일을 제치고 일인당 맥주 소비량이 가장 많은 나라입니다.
필스너 우르켈을 만든 나라이기도 하구요.
물보다도 맥주가 싼 가격인 것도 특징입니다.
정말 쌉니다.  대부분의 맥주가 한병에 한국돈으로 천원을 넘지 않습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/1.jpg)&lt;/p&gt;
&lt;p&gt;맥주하면 또 소세지죠!
소세지도 저렴합니다.
여행중 매일밤 여기서 맥주와 소세지를 사서 맥주 한잔씩 하며 하루를 마무리
했습니다.&lt;/p&gt;
&lt;h1 id=&#34;sightseeing-before-checkin&#34;&gt;Sightseeing before Check-in&lt;/h1&gt;
&lt;p&gt;이제 급한 불은 모두 껐습니다.
숙소도 찾았고, 인터넷도 되고.
하지만 아직도 오후 12시를 조금 넘긴 시간.
체크인도 오후 두시부터이고, OSSummit pre-registration 도 오후 세시부터
시작입니다.
일단 무작정 시내를 돌아다녀 보기로 하고 걸었습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/3.jpg)&lt;/p&gt;
&lt;p&gt;걷다보니 블타바강이 나왔습니다.
강 건너편으로 프라하 성이 아름답게 보입니다.
강변으로 산책로도 조성되어 있고, 강에 선박 레스토랑도 많습니다.
일단 강변을 따라 걸어봅니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/4.jpg)&lt;/p&gt;
&lt;p&gt;천천히 걷다보니 좀 시간이 흐릅니다.
슬슬 체크인 시간이 다가옵니다.
강변에서 빠져나와 숙소쪽으로 천천히 걸어갔습니다.
어디로 걷는지도 모르고 그냥 걸었는데 여기저기 멋진 게 많습니다.
알고보니 여기가 중심지더군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/5.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/6.jpg)&lt;/p&gt;
&lt;p&gt;광장입니다.  암스테르담에 갔을때 봤던 중앙 광장이 떠올랐습니다.
사람도 많고 관광객도 많고 볼거리도 많습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/7.jpg)&lt;/p&gt;
&lt;p&gt;나름 유명한 시계 같더군요.
정각엔 인형들이 튀어나와서 뭔가 하고 들어간다는데 이게 몇백년된 시계라고 했던
것 같습니다.
정각에 여기 있질 않아서 인형들이 움직이는건 보지 못했습니다.ㅜㅜ&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/8.jpg)&lt;/p&gt;
&lt;p&gt;길치의 특성 중 하나는 자꾸 샛길로 빠지려는 본능이 있다는 점 아닐까 싶습니다.
반듯이 숙소로 가다가도 자꾸 옆길이 보이니 들어가보고 싶습니다.
장점은 그렇게 발견하는 재미진 곳이 많다는 거죠.
그렇게 발가는대로 걸어보니 재래시장 같은 곳이 나타났습니다.
먹을거리도 팔고, 꼭두각시 인형도 팔고, 기념품도 많이 있습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/9.jpg)&lt;/p&gt;
&lt;p&gt;기내식을 많이 먹었지만 맛깔나게 담아둔 과일이 맛있어 보이더군요.
그래도 돈이 별로 없어서 그냥 참고 지나갑니다.&lt;/p&gt;
&lt;h1 id=&#34;back-to-the-hostel&#34;&gt;Back to the Hostel&lt;/h1&gt;
&lt;p&gt;![foo]
(/img/osse_02/10.jpg)&lt;/p&gt;
&lt;p&gt;드디어 숙소 근처에 도착.  곧 체크인 시간입니다.
잠깐 숙소 근처 거리를 천천히 둘러봤습니다.
이제야 정신차리고 보니 숙소는 바츨라프 광장의 아래쪽에 있었더군요.
그래서인지 숙소 건물 앞 길거리에는 노점이 여럿 있고 관광객들이 거기서
먹을거리와 맥주를 즐기고 있었습니다.
시선과 후각을 강렬하게 끌어당긴 것 중 하나는 이 장작불에 빙글빙글 돌아가며
구워지는 고기!
체코 전통 요리 중 하나인 것 같은데, 주문하면 곧바로 칼로 고기를 일부분 썰어서
빵과 함께 주는 시스템 같습니다.
여기다 맥주까지 함께 판매하니, 안먹고 버티기 힘들정도로 침이 줄줄 흐르더군요.
그래도 전 환전한 돈도 얼마 안되고 해서 참았습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/11.jpg)&lt;/p&gt;
&lt;p&gt;어쨌든 드디어 체크인 시간이 되었으니 숙소로 들어갑니다.
제가 예약한 방은 10인 혼성 도미토리 (dormitory) 룸.
위 사진처럼 다섯개의 이층침대가 있습니다.
일찍 체크인한 덕인지 제가 첫번째인가봅니다. 창가 1층 자리를 선점했습니다.
어쩌면 이 넓은 방을 혼자 쓸수도&amp;hellip;? 했는데 밤에 다들 체크인 하더군요. 하하.
어쨌든 아주 넓진 않지만 좁지 않고 깨끗했습니다. 대만족!
잠깐 인터넷도 하고 간단히 세수도 하고, 이제 뭐할지 계획을 짜봅니다.&lt;/p&gt;
&lt;p&gt;내일부터 OSSummit 시작이니, 낮에 관광을 하는건 오늘이 마지막입니다.
일단 나가서 좀 돌아다녀보고, 컨퍼런스 회장으로 이동해 pre-registration 도 하고,
이어서 프라하 성을 돌아보기로 계획했습니다.&lt;/p&gt;
&lt;h1 id=&#34;journey-to-ossummit-preregistration&#34;&gt;Journey to OSSummit Pre-registration&lt;/h1&gt;
&lt;p&gt;![foo]
(/img/osse_02/12.jpg)&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/13.jpg)&lt;/p&gt;
&lt;p&gt;가장 먼저 숙소 바로 앞의 바츨라프 광장을 둘러봤습니다.
약간 경사가 져 있어서 바츨라프 광장 끝의 동상 앞에서 뒤를 돌아보면 프라하
시내가 보이는 경치가 좋더군요.
바츨라프 광장은 서울 광화문 광장과 비슷한데, 민주화 관련 운동도 있었다고 하니
촛불이 가득 채웠던 광화문과 더욱 비슷한 느낌이 들었습니다.&lt;/p&gt;
&lt;p&gt;근데 프라하랑은 개인적으로 딱히 접점이 없어서일까요, 역사라던지가 머리에 잘
들어오지 않습니다.
암스테르담 같은 경우 민주화, 다양성 존중 등이 발전되어 있고 파이썬 창시자인
귀도 반 로썸 아저씨의 고향이라 그런지 꽤 하나하나가 와닿았는데 말이죠.
그래선지 어디가 어딘지도 잘 모르겠고 그냥 헤매듯이 정처없이 거닐었습니다.
그래도 어딜 가든 다 아름답고 멋집니다.  건축물들이 예술입니다.
근데 그래서 더 특색을 모르겠더군요.  저랑 프라하는 잘 안맞나봐요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/31.jpg)&lt;/p&gt;
&lt;p&gt;그렇게 걷다보니 만난 작은 공원.
공원을 원래 좋아하는터라 반가웠습니다.
공원의 반대편은 프라하 중앙역에 연결되어 있더군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/32.jpg)&lt;/p&gt;
&lt;p&gt;컨퍼런스 회장으로 이동 중 만난. 뭔지 모를 곳.
낡은 건물이었는데 그 안은 천장이 뚫려있고 기차같은게 운행되고 있더군요.
뭔지 모르겠는데 멋졌습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/17.jpg)&lt;/p&gt;
&lt;p&gt;마침내 도착한 컨퍼런스 회장!  힐트 프라하입니다.
정식 일정은 내일부터지만 오늘도 미리 등록을 할 수 있습니다.
내일 와서 줄서긴 싫기도 하고, 미리 준비중인 회장을 구경하고 싶어서 왔습니다.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/33.jpg)&lt;/p&gt;
&lt;p&gt;등록 부스입니다.  아주 한산할 줄 알았는데 생각보다 사람이 있더군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/15.jpg)&lt;/p&gt;
&lt;p&gt;등록 완료했습니다.
이 네임택 하나가, 그렇게 갖고 싶었습니다. 크흑.&lt;/p&gt;
&lt;p&gt;빨간 딱지는 선물 증정 부스에 제출해서 티셔츠 하나, 그리고
리셉션 때 맥주와 바꿀 수 있는 쿠폰을 받을 수 있게 되어 있더군요.&lt;/p&gt;
&lt;p&gt;![foo]
(/img/osse_02/16.jpg)&lt;/p&gt;
&lt;p&gt;스폰서 기업들이 부스를 차리고 있는 분주한 모습도 볼 수 있었습니다.
내일은 이곳이 어떻게 꾸며질까 미리 어느정도 예상도 할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;이제 어느덧 오후 4시가 되어갑니다만, 아침 9시부터 움직였으니 꽤 많은 일이
있었습니다.
일단 여기서 여행기의 두번째 포스트를 마무리 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc7</title>
      <link>/post/lkml_news_v4.14-rc7/</link>
      <pubDate>Fri, 03 Nov 2017 14:51:35 +0900</pubDate>
      <guid>/post/lkml_news_v4.14-rc7/</guid>
      <description>&lt;h2 id=&#34;linux-414rc7&#34;&gt;Linux 4.14-rc7&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwhgxivTE3k88nshbrH9nd-4nhmhXGzw-MxRVGxf-R8Eg@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFwhgxivTE3k88nshbrH9nd-4nhmhXGzw-MxRVGxf-R8Eg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일곱번째 rc 버전의 릴리즈입니다.&lt;/p&gt;
&lt;p&gt;OSSE 와 kernel summit 으로 프라하를 방문했던 토발즈인데, 집에 잘
돌아왔다는군요.  이번 rc 버전은 기존의 rc7 보다도 작은 편에 가깝다고 합니다만,
다음 한주간이 정말 조용하지 않는한은 rc8 릴리즈를 할 생각이라는군요.&lt;/p&gt;
&lt;h2 id=&#34;re-page-allocator-bottleneck&#34;&gt;Re: Page allocator bottleneck&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1c218381-067e-7757-ccc2-4e5befd2bfc3@mellanox.com&#34;&gt;https://lkml.kernel.org/r/1c218381-067e-7757-ccc2-4e5befd2bfc3@mellanox.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;멜라녹스의 빠른 네트워크 카드를 사용하는 환경에서는 page allocator 의 속도가
bottleneck 이 된다는 이야기에 대한 업데이트입니다.  여전히 해당 부분이
bottleneck 이며, queued_spin_lock_slowpath() 가 85 % 가까이 CPU 를 차지하고
있군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-swap-readahead-clean-up&#34;&gt;[PATCH 0/2] swap readahead clean up&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1509514103-17550-1-git-send-email-minchan@kernel.org&#34;&gt;https://lkml.kernel.org/r/1509514103-17550-1-git-send-email-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Swap layer 는 swap in 시에, 연속된 물리 주소의 페이지들을 한번에 읽어들이는
read-ahead 기법을 사용하고 있습니다.  후에 근접한 페이지도 접근될 확률이 높다는
거죠.  하지만 fragmentation 이 심한 환경에서는 꼭 그렇지 않을 수 있습니다.
때문에 virtual address space 에서 연속된 페이지들을 read ahead 하는 패치가
최근에 들어왔는데, 이에 대한 코드 정리 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-v2-ftracedocs-add-documentation-on-how-to-use-ftrace-from-within-the-kernel&#34;&gt;[PATCH v2] ftrace/docs: Add documentation on how to use ftrace from within the kernel&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171031100705.573531cd@gandalf.local.home&#34;&gt;https://lkml.kernel.org/r/20171031100705.573531cd@gandalf.local.home&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;jprobe 가 사라지고 ftrace 가 대신 사용될 예정입니다.  이를 위한 문서의 추가
패치입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSSummit 2017 Attendence - 01</title>
      <link>/post/osse2017_01/</link>
      <pubDate>Sun, 29 Oct 2017 16:55:24 +0900</pubDate>
      <guid>/post/osse2017_01/</guid>
      <description>&lt;p&gt;![pargue!]
(/img/osse_01/8.jpg)&lt;/p&gt;
&lt;p&gt;Open Source Summit Europe 과 Embedded Linux Conference Europe, 그리고 Annual
Kernel Summit 이 합동으로 열린 프라하에 다녀왔습니다.  이에 대한 기록을
남겨봅니다.&lt;/p&gt;
&lt;h1 id=&#34;the-event&#34;&gt;The Event&lt;/h1&gt;
&lt;p&gt;리눅스 재단에서는 다양한 컨퍼런스를 개최합니다.  2015년까지는 한국에서도 Korea
Linux Forum 이라는 행사를 매년 열었죠.  특히 2015년에는 커널 서밋도 함께해서
특히 특별했던 기억입니다.
이런 이벤트들 중에서도 가장 큰 이벤트는 오픈소스 서밋이 아닐까 싶습니다.  이
이벤트는 기존의 리눅스콘 등 행사들이 합쳐진 행사입니다.  가장 큰 이벤트가
오픈소스 서밋이라면 가장 중요한 행사는 커널 서밋이라 할 수 있지 않을까
싶습니다.  커널 서밋은 커널 개발에 중요한 역할을 하는 메인테이너들이 모여 현재
개발 상의 이슈를 공유, 해결책을 토론하고 차후 개발을 위한 회의를 하는
자리입니다.  당연하지만 토발즈도 이 자리에 함께 합니다.  중요 개발자들끼리만
모이는 자리인 만큼 초대 형식으로만 참가할 수 있었는데, 2015년부터는 다른
이벤트와 함께 개최되어서 초반 몇일은 함께 열린 이벤트의 참가자들도 토의에
참여할 수 있게 되었습니다.&lt;/p&gt;
&lt;p&gt;올해는 프라하에서 오픈소스 서밋 유럽지역 행사와 임베디드 리눅스 컨퍼런스
유럽지역 행사, 그리고 커널 서밋이 함께 열렸습니다.  당연히 최신 정보를 얻고
다른 개발자들과 네트워킹을 할 수도 있고, 제 프로젝트인 GCMA 를 홍보할 수도 있는
기회이기에 꼭 참여해야겠다 싶었습니다.&lt;/p&gt;
&lt;p&gt;KOSSLAB 에서는 오픈소스 개발자들의 해외 컨퍼런스 참여를 지원합니다.  자원이
한정되어 있는 만큼 지원이 좀 까다롭습니다.  지원 신청은 발표자 또는 초대장을
받은 사람에 한정되며, 지원은 비행기표 비용이며, 발표자의 경우 호텔비 이틀치를
추가로 지원합니다.  즉, 컨퍼런스 등록비, 숙식을 위한 비용은 각자 부담해야
합니다.  지원한 모두를 지원하는 것도 아니고 내부 심사가 있습니다.  그래도
지원을 받는데 성공하면 매우 큰 도움이 되죠.&lt;/p&gt;
&lt;p&gt;저는 초대장을 받아 신청하게 되었는데, 지원 여부 결과가 꽤 늦게까지 발표되지
않았습니다.  초조하게 기다리고 있다가 어차피 각자 결제 후 차후 영수증을 통한
증빙을 통한 지원이라 전해듣고, 에라 모르겠다 하고 자비로 비행기표 등을 모두
구매했는데 다음날 아침, 지원을 해주기로 결정했다는 전화를 받았습니다.  다시
한번 KOSSLAB 에 감사한 마음을 전합니다 :D&lt;/p&gt;
&lt;h1 id=&#34;to-incheon-airport&#34;&gt;To Incheon Airport&lt;/h1&gt;
&lt;p&gt;![Incheon Airport]
(/img/osse_01/1.jpg)&lt;/p&gt;
&lt;p&gt;토요일 밤 인천 공항에서 출발해 이스탄불에서 한번 환승하고 프라하로 가는
터키항공 편을 구매했습니다.  빨래를 하고 짐을 싸며 낮시간을 보냈습니다.  인터넷
연결이 어려울 테니 볼만한 영화도 다운받고, 읽을거리도 인쇄해두고, 참여/관리중인
프로젝트들의 소스코드도 랩톱 안에 최신으로 땡겨둡니다.  해가 질 무렵, 공항으로
출발했습니다.  인천공항 가는길은 지하철을 사용합니다.&lt;/p&gt;
&lt;h1 id=&#34;to-istanbul&#34;&gt;To Istanbul&lt;/h1&gt;
&lt;p&gt;알고보니 터키항공은 서비스가 좋기로 유명한 모양입니다.  상도 받았다는 것
같더군요.&lt;/p&gt;
&lt;p&gt;출발한 후에 승객들에게 파우치를 하나씩 주는데, 열어보면 안대와 슬리퍼, 귀마개,
칫솔, 립밤 등이 들어있습니다.&lt;/p&gt;
&lt;p&gt;![to_istanbul]
(/img/osse_01/2.jpg)&lt;/p&gt;
&lt;p&gt;좌석에 제공되는 서비스도 좋은 편입니다.  의자에 USB 가 있어 핸드폰과 태블릿
등을 충전할 수 있고고, 좌석마다 달린 디스플레이를 통해 영화, 뉴스, 기내정보,
음악 등을 즐길 수 있습니다.  한글 자막이 제공되진 않지만 한국어 더빙 영화는
일부 있는 것 같습니다.  영어 자막은 대부분의 영화가 제공하므로 대충 누가
나쁜놈이고 착한놈인지 정도는 알아들을 수 있었습니다.&lt;/p&gt;
&lt;p&gt;요즘 비행기는 다들 이정도는 제공하는 것 같기도 하지만, 제 경우는 출장 때 외에는
비행기 타는 일이 거의 없고, 출장갈 때마다 가능한 저렴한 표를 구하는 편이다보니
(내가 힘들게 가는만큼 다른 친구들이 이득보겠거니 해서 그러는데, 굳이 그럴
필요는 없나 싶기도 하군요.) 좋은 비행기 타본 적이 없어서 디스플레이가 있는
비행기는 대략 3년만에 처음입니다.  감동의 눈물이 흘렀습니다.ㅜㅜ 근데
디스플레이 없는 비행기에 이미 너무 익숙해졌는지 영화를 잘 안보게 되는군요.&lt;/p&gt;
&lt;p&gt;![to_istanbul_first_food]
(/img/osse_01/3.jpg)&lt;/p&gt;
&lt;p&gt;첫번째 기내식은 비빔밥과 파스타가 제공되었습니다.  한국에서 출발하는 만큼
비빔밥을 준비한 준비성은 좋지만 개인적으로 외국 여행중에는 외국 음식을 먹자는
편이고 고기류를 좋아하는 편이라 파스타를 먹으며 눈물을 흘렸습니다.  신기한건
와인을 주문하면 병째로 줍니다.  하지만 작은 병이라 컵 하나에 가득 따른 정도의
양과 비슷합니다.  한국계 항공사에서 주는것보단 많은 양이지만 델타 등의 미국계
항공사에서 주는 것과 비슷한 정도 같습니다.&lt;/p&gt;
&lt;p&gt;![to_istanbul_second_food]
(/img/osse_01/4.jpg)&lt;/p&gt;
&lt;p&gt;내리기 전 제공되는 기내식은 오므라이스와 샌드위치입니다.  가볍게 먹기
좋았습니다.&lt;/p&gt;
&lt;p&gt;![istanbul_airport]
(/img/osse_01/5.jpg)&lt;/p&gt;
&lt;p&gt;이스탄불 공항은 화려한 편이었습니다.  화장실은 좀 더러웠지만&amp;hellip;  특히 중간에
터키 아이스크림을 파는 가게가 있었는데, 고객을 놀려대며 즐거움을 주는 모습을
오프라인으로는처음 봤습니다.  신기하더군요.
아쉬운건 무료 와이파이가 없습니다.  정확히는, 있긴 한데 사용을 위해선
패스워드를 SMS 를 통해 받아야 합니다.  로밍을 켤 돈이 없어 그냥 버텼습니다.
환승 시간이 길지 않아 다행이었습니다.&lt;/p&gt;
&lt;p&gt;환승을 위해 게이트에 도착해 기다리는데 함께 기다리는 사람들 중 일부 한국
사람들이 게이트가 바뀌었다며 갑자기 뛰어갑니다.  확인해보니 정말로 바뀌어
있더군요.  이동하는 중에 이에 대한 내용이 뒤늦게 방송으로 나왔습니다.  외국인
분들은 뒤늦게 헐레벌떡 오시더군요.  저도 헐레벌떡이었지만.&lt;/p&gt;
&lt;p&gt;신기한게 게이트에서 여권 검사를 합니다.  덕분에 게이트에 들어가는데에도 줄이
생겼습니다.  머리가 길어 눈이 가려서 그런지 검사하는 분이 같은 사람 맞냐며 생일
등을 물어보는데 좀 긴장되더군요.
그래도 큰 문제 없이 통과.  비행기는 출발합니다.&lt;/p&gt;
&lt;h1 id=&#34;to-prague&#34;&gt;To Prague&lt;/h1&gt;
&lt;p&gt;![to_prague]
(/img/osse_01/6.jpg)&lt;/p&gt;
&lt;p&gt;환승 비행기도 터키항공.  이번 여행은 계속 터키항공만 이용합니다.&lt;/p&gt;
&lt;p&gt;![to_pargue_food]
(/img/osse_01/7.jpg)&lt;/p&gt;
&lt;p&gt;두시간 가량의 짧은 비행이지만 기내식이 나옵니다.  이번에도 오므라이스와
샌드위치.&lt;/p&gt;
&lt;p&gt;![pargue!]
(/img/osse_01/8.jpg)&lt;/p&gt;
&lt;p&gt;먹고 놀고 책도 읽고 하다보니 프라하에 도착합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc6</title>
      <link>/post/lkml_news_v4.14-rc6/</link>
      <pubDate>Wed, 25 Oct 2017 12:56:27 +0200</pubDate>
      <guid>/post/lkml_news_v4.14-rc6/</guid>
      <description>&lt;h2 id=&#34;linux-414rc6&#34;&gt;Linux 4.14-rc6&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFxSJGeN=2X-uX-on1Uq2Nb8+v1aiMDz5H1+tKW_N5Q+6g@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFxSJGeN=2X-uX-on1Uq2Nb8+v1aiMDz5H1+tKW_N5Q+6g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여섯번째 rc 버전의 릴리즈입니다.&lt;/p&gt;
&lt;p&gt;토발즈 집 인터넷 문제로 평소보다 늦은 릴리즈였군요.
이번 rc 버전은 기대보다는 좀 많은 내용이 추가되었는데, 때문에 어쩌면 rc8 까지
나올지도 모르겠다고 하는군요.  물론 확정되거나 한건 아니라고 합니다.&lt;/p&gt;
&lt;h2 id=&#34;re-git-pull-rcunext-rcu-commits-for-415&#34;&gt;Re: [GIT PULL rcu/next] RCU commits for 4.15&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20171023204502.GA2776@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171023204502.GA2776@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.15 에 들어가야 할 RCU 쪽 커밋들의 풀리퀘스트 입니다.&lt;/p&gt;
&lt;p&gt;문서, RCU CPU Stall warning 업데이트, rcutorture 쪽 업데이트가 포함되었네요.&lt;/p&gt;
&lt;h2 id=&#34;git-pull-dealpha-make-core-code-not-need-to-know-about-alpha-for-v415&#34;&gt;[GIT PULL de-alpha] Make core code not need to know about Alpha for v4.15&lt;/h2&gt;
&lt;p&gt;코어 커널 코드에서 Alpha 를 위한 예외 케이스를 제거하기 위한 작업의 첫번째
결과물이 v4.15 를 향합니다.&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;ACCESS_ONCE()&lt;/code&gt; 를 모두 &lt;code&gt;READ_ONCE()&lt;/code&gt; 와 &lt;code&gt;WRITE_ONCE()&lt;/code&gt; 로 변경하고,
&lt;code&gt;READ_ONCE()&lt;/code&gt; 와 Alpha 의 값을 리턴하는 &lt;code&gt;_release&lt;/code&gt; 와 &lt;code&gt;_relaxed&lt;/code&gt; atomic RMW
오퍼레이션들에 &lt;code&gt;smp_read_barrier_depends()&lt;/code&gt; 를 내장시키며, 따라서 필요없어진
&lt;code&gt;lockless_dereference()&lt;/code&gt; 는 수정된 &lt;code&gt;READ_ONCE()&lt;/code&gt; 로 대체되게 했습니다
(lockless_dereference() 는 사실 READ_ONCE() 플러스 smp_read_barrier_depends()
였는데 smp_read_barrier_depends() 는 Alpha 외의 아키텍쳐에서는 NOOP 이라 Alpha
만을 위해 괜히 복잡했거든요).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.14-rc5</title>
      <link>/post/lkml_news_v4.14-rc5/</link>
      <pubDate>Tue, 17 Oct 2017 20:54:24 +0900</pubDate>
      <guid>/post/lkml_news_v4.14-rc5/</guid>
      <description>&lt;h2 id=&#34;linux-414rc5&#34;&gt;Linux 4.14-rc5&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFyKgEL3dj7XGYsPQd8y_z0GWx91TLZPSQAxjrua1aWOLw@mail.gmail.com&#34;&gt;https://lkml.kernel.org/r/CA+55aFyKgEL3dj7XGYsPQd8y_z0GWx91TLZPSQAxjrua1aWOLw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다섯번째 rc 버전의 릴리즈입니다.&lt;/p&gt;
&lt;p&gt;Lazy TLB flushing 변경은 지나치게 게으르게 TLB flushing 을 해서 AMD 칩 일부에서
문제를 일으키기도 했었다는군요.&lt;/p&gt;
&lt;p&gt;일부 서브시스템에서 fuzzing 을 통한 문제 발견과 수정이 있었는데 좋은
현상이라고도 언급합니다.&lt;/p&gt;
&lt;p&gt;전체적으로 x86, powerpc, mips 에의 arch 업데이트, gpu, networking, usb, sound,
misc 드라이버 업데이트, lockdep, networking, mm 쪽 코어 커널 업데이트, 그리고
perf 와 selftest 에의 업데이트가 있었다고 이번 릴리즈를 정리하는군요.&lt;/p&gt;
&lt;h2 id=&#34;patch-02-mm-thp-introduce-dedicated-transparent-huge-page&#34;&gt;[PATCH 0/2] mm, thp: introduce dedicated transparent huge page&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1508145557-9944-1-git-send-email-changbin.du@intel.com&#34;&gt;https://lkml.kernel.org/r/1508145557-9944-1-git-send-email-changbin.du@intel.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;THP 의 메모리 할당은 좀 복잡하게 여기저기 코드 복사로 구현되어 있습니다.
HugeTLB 는 별도 인터페이스가 있구요. THP 에도 HugeTLB 처럼 별도 인터페이스를
사용하도록 제안한 패치입니다.&lt;/p&gt;
&lt;h2 id=&#34;patch-12-lockdep-introduce-crossreleasestacktrace-and-make-it&#34;&gt;[PATCH 1/2] lockdep: Introduce CROSSRELEASESTACKTRACE and make it&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1508318006-2090-1-git-send-email-byungchul.park@lge.com&#34;&gt;https://lkml.kernel.org/r/1508318006-2090-1-git-send-email-byungchul.park@lge.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;지난번 Johan Hovold 가 이야기한 lockdep crossrelease 에 의한 성능 문제 (부팅
시간이 17초에서 35초까지 늘어났죠)에 대한 해결책입니다.&lt;/p&gt;
&lt;p&gt;stack unwind 를 너무 자주 해서 생긴 문제이므로 이를 선택적으로 할 수 있게 하고
그 디폴트 값을 자주 하지 않도록 수정했네요.&lt;/p&gt;
&lt;p&gt;작은 qemu 머신에서 부팅시간이 lockdep disabled 시 1.543 초, lockdep enabled 시
1.570 초, lockdep + crossrelease enabled 시 1.870 초를 보였는데, 이 패치를
적용한 후 마지막 환경에서 부팅시간이 1.574 초로 줄었습니다.&lt;/p&gt;
&lt;p&gt;패치를 보낸 박병철 님은 커널 로그의 타임스탬프를 통해 부팅 시간을 측정했는데,
Ingo Molnar 는 부팅 시간 테스트에 qemu 시작 스크립트에 init=/bin/true 과 같은
kernel parameter 를 줘서 부팅 완료와 함께 종료되게 하고서 perf &amp;ndash;null &amp;ndash;repeat
옵션을 사용해서 부팅 시간을 측정할 것을 제안했습니다. 유용한 팁 같습니다!&lt;/p&gt;
&lt;p&gt;Linux-kernel examples for LKMM recipes
&lt;a href=&#34;https://lkml.kernel.org/r/20171011223229.GA31650@linux.vnet.ibm.com&#34;&gt;https://lkml.kernel.org/r/20171011223229.GA31650@linux.vnet.ibm.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;리눅스 커널에서의 메모리 순서 규칙을 위한 리트머스 테스트들이 실제로 비슷한
패턴으로 사용된 예를 Linux Plumbers Conference 에서 요청받은 Paul E. Mckenney
가 이에 대한 내용을 문서로 만들어 업데이트 했습니다.&lt;/p&gt;
&lt;p&gt;해당 문서는 다음 링크에서도 얻을 수 있습니다:
&lt;a href=&#34;https://github.com/aparri/memory-model/blob/master/Documentation/recipes-LKcode.txt&#34;&gt;https://github.com/aparri/memory-model/blob/master/Documentation/recipes-LKcode.txt&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News - Intro</title>
      <link>/post/lkml_news_0000/</link>
      <pubDate>Tue, 10 Oct 2017 18:37:00 +0900</pubDate>
      <guid>/post/lkml_news_0000/</guid>
      <description>&lt;p&gt;LKML 을 모니터링 하면서 흥미가는 패치나 토론을 &lt;code&gt;lkml news&lt;/code&gt; 라는 카테고리로
묶어서 비정기적, 비형식적으로 간략히 정리하고 관련 소식을 업데이트 해보고자
합니다.  주로 모니터링 하는 메일은 메모리 매니지먼트 쪽과 rcu 관련 메일들이
될겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Idle Page Tracking Tools</title>
      <link>/post/idle_page_tracking/</link>
      <pubDate>Wed, 13 Sep 2017 13:46:00 +0900</pubDate>
      <guid>/post/idle_page_tracking/</guid>
      <description>&lt;p&gt;&lt;code&gt;idle_page_tracking&lt;/code&gt;[1] is a simple, stupid toolbox for idle pages tracking.
It can be used to get real working set size of a process.&lt;/p&gt;
&lt;h1 id=&#34;tools&#34;&gt;Tools&lt;/h1&gt;
&lt;p&gt;This section describes two tools in the box though more tools exists.  You can
get more description about each tool from the README in the repository[1].&lt;/p&gt;
&lt;h2 id=&#34;userprog&#34;&gt;userprog&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;userprog&lt;/code&gt; is a sample synthetic workload for test of other tools.  It
interactively allocates and access specified pages in the allocated pages.
After execution, it first asks how many pages to allocates.  Once you type in
how many pages to allocate, the program will repeatedly asks how many pages in
the allocated pages you want to do access.&lt;/p&gt;
&lt;h2 id=&#34;wspagessh&#34;&gt;wspages.sh&lt;/h2&gt;
&lt;p&gt;Now you can calculate working set size of a process using the tools.  To
simplify the life even more, &lt;code&gt;wspages.sh&lt;/code&gt; helps the complicated works.  It
requires pid, time interval, and target memory mapped regions as argument.  The
third argument can be ignored.  In the case, it uses heap, stack, and anonymous
pages as target memory region by default.  If you give the arguments well, this
tool will prints out number of pages accessed between the time interval.
Simple example of usage and output is as below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo ./wspages.sh `pidof userprog` 1 [heap]
3
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;wspgstatsh&#34;&gt;wspgstat.sh&lt;/h2&gt;
&lt;p&gt;Like &lt;code&gt;*stat&lt;/code&gt; programs (such as vmstat, iostat, &amp;hellip;), wspgstat.sh monitors and
print out number of pages in working set of specific process repeatedly.  It
requires pid of target program, delay between idleness check, and target memory
mapped regions as arguments.  The third argument is optional and has default
value as same as wspages.sh&#39;s same argument.  Simple example usage is as below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./wspgstat.sh `pidof mysqld` 5
1 17448
9 21536
18 21659
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;limitations&#34;&gt;Limitations&lt;/h1&gt;
&lt;p&gt;The tools use idle page tracking feature of the Linux kernel[2] internally.  It
means that the tools work on Linux systems that idle page tracking feature is
turned on.  You can check whether your system turned on or off the feature by
simply running the command below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ if [ -d /sys/kernel/mm/page_idle ]; \
        then echo &amp;quot;ON&amp;quot;; else echo &amp;quot;OFF&amp;quot;; fi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It also shares limitation of idle page tracking feature of the Linux kernel.
It tracks only userspace pages on LRU list of the kernel.&lt;/p&gt;
&lt;h1 id=&#34;license&#34;&gt;License&lt;/h1&gt;
&lt;p&gt;GPL v3&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://github.com/sjp38/idle_page_tracking&#34;&gt;https://github.com/sjp38/idle_page_tracking&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://www.kernel.org/doc/Documentation/vm/idle_page_tracking.txt&#34;&gt;https://www.kernel.org/doc/Documentation/vm/idle_page_tracking.txt&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TPC-H on MariaDB (MySQL)</title>
      <link>/post/tpch-on-mariadb/</link>
      <pubDate>Sun, 10 Sep 2017 10:54:24 +0900</pubDate>
      <guid>/post/tpch-on-mariadb/</guid>
      <description>&lt;p&gt;Database 를 위해 사용되는 벤치마크는 크게 OLTP vs OLAP 로 나뉩니다[1].  OLTP
계열의 대표주자는 TPC-C 이고, OLAP 계열의 대표주자 중 하나로 TPC-H[2] 가
있습니다.  이 글에서는 TPC-H 를 MariaDB 에서 돌리는 방법에 대해 설명합니다.&lt;/p&gt;
&lt;h1 id=&#34;environment-setup&#34;&gt;Environment Setup&lt;/h1&gt;
&lt;p&gt;이 글을 작성하면서 사용한 운영체제와 소프트웨어들의 버전은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu 16.04.2 Server&lt;/li&gt;
&lt;li&gt;MariaDB 10.2.8&lt;/li&gt;
&lt;li&gt;TPC-H toolkit 2.17.2&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;automated-scripts&#34;&gt;Automated Scripts&lt;/h1&gt;
&lt;p&gt;아래 설명할 모든 내용을 자동화 해서 손쉽게 TPC-H 를 돌릴 수 있도록 소스코드
변경부터 빌드, 수행까지 정리한 스크립트들을 github 에 올려 두었습니다:
&lt;a href=&#34;https://github.com/sjp38/tpch-mariadb&#34;&gt;https://github.com/sjp38/tpch-mariadb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;시간이 없다면 해당 스크립트를 사용하실 것을 권장합니다.&lt;/p&gt;
&lt;h1 id=&#34;tpch-spec&#34;&gt;TPC-H Spec&lt;/h1&gt;
&lt;p&gt;TPC-H 벤치마크 스펙은 TPC 웹사이트에서 얻을 수 있습니다[3].  하지만 여기서는
간단히 설명을 해봅니다.  간단한 설명인 만큼 내용이 엄밀히 말해서 맞다고 할수는
없으므로 엄밀한 내용은 정식 스펙 또는 다른 문서를 확인해 보시기 바랍니다.
TPC-H 는 8개의 테이블에 많은 데이터를 쌓아놓고, 이 데이터의 분석을 위한 22개의
쿼리를 수행하며 그 성능을 측정하는 형태로 구성되어 있습니다.  성능은 테이블에
데이터를 로드하는데 걸리는 시간, 22개의 쿼리 각각의 수행 시간, 그리고 여러
세션을 열어놓고 22개 쿼리를 각 세션에서 수행하면서 파악되는 처리량 (초당 처리된
쿼리의 갯수)으로 측정됩니다.&lt;/p&gt;
&lt;h1 id=&#34;get-tpch-toolkit&#34;&gt;Get TPC-H Toolkit&lt;/h1&gt;
&lt;p&gt;TPC-H 는 8개의 테이블에 데이터가 쌓인 상태에서, 이 데이터의 분석을 위한 22개의
쿼리들을 날리는 형태로 이루어져 있습니다.  테이블을 어떻게 만들고 거기에
데이터는 어떻게 넣어야 하며, 쿼리는 어떤 것들로 이루어져야 하는지에 대한
명세서를 TPC 에서 제공합니다.  이를 바탕으로 각자 TPC-H 를 구성해서 돌릴 수
있습니다.  하지만 이걸 각자 하는건 귀찮고 힘들기 때문에, 테이블과 테이블의
데이터, 그리고 쿼리들을 생성하는 도구를 TPC 에서 TPC-H Toolkit 이라는 이름으로
그 소스코드를 공식적으로 제공하고 있습니다.  TPC 의 해당 사이트[4]를 찾아가
개인정보를 입력하고 license 에 동의를 하면 다운로드 받을 수 있는 링크를 메일로
보내줍니다.&lt;/p&gt;
&lt;p&gt;이렇게 받은 파일은 zip 파일입니다.  압축을 풀어보면 아래와 같이 해당 버전명의
디렉토리가 나오고, 그 아래에 실제 소스 코드와 라이센스 파일이 있습니다.  여기서
우린 dbgen/ 디렉토리를 사용할 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ tree 2.17.2 -L 1
2.17.2
├── dbgen
├── dev-tools
├── EULA.txt
└── ref_data
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;build-source-code&#34;&gt;Build Source Code&lt;/h1&gt;
&lt;p&gt;dbgen 디렉토리 아래 dbgen 과 qgen 이라는, 우리가 사용하게 될 프로그램을 위한
소스코드가 있습니다.  여기 있는 makefile.suite 라는 파일은 &lt;code&gt;make&lt;/code&gt; 를 사용해 이
코드를 빌드하기 위한 규칙의 기본 골조를 담고 있습니다.  이 파일을 `makefile&amp;rsquo;
이라는 이름으로 복사하고 내용을 다음과 같이 수정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ diff -u makefile.suite makefile
--- makefile.suite      2017-04-21 06:01:08.000000000 +0900
+++ makefile    2017-09-10 11:10:12.563384756 +0900
@@ -100,15 +100,15 @@
 ################
 ## CHANGE NAME OF ANSI COMPILER HERE
 ################
-CC      =
+CC      = gcc
 # Current values for DATABASE are: INFORMIX, DB2, TDAT (Teradata)
 #                                  SQLSERVER, SYBASE, ORACLE, VECTORWISE
 # Current values for MACHINE are:  ATT, DOS, HP, IBM, ICL, MVS,
 #                                  SGI, SUN, U2200, VMS, LINUX, WIN32
 # Current values for WORKLOAD are:  TPCH
-DATABASE=
-MACHINE =
-WORKLOAD =
+DATABASE= SQLSERVER
+MACHINE = LINUX
+WORKLOAD = TPCH
 #
 CFLAGS = -g -DDBNAME=\&amp;quot;dss\&amp;quot; -D$(MACHINE) -D$(DATABASE) -D$(WORKLOAD) -DRNG_TEST -D_FILE_OFFSET_BITS=64
 LDFLAGS = -O
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이후, &lt;code&gt;$ make&lt;/code&gt; 명령으로 dbgen 과 qgen 이라는 프로그램이 빌드됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ make

...

 bm_utils.o qgen.o rnd.o varsub.o text.o bcd2.o permute.o speed_seed.o rng64.o -lm
$ file dbgen
dbgen: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=d0bca1a18c33947d85f5943c8325837faec7c95d, not stripped
$ file qgen
qgen: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=79a6216e04c446715b0e55f9c804586887b698c8, not stripped
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;tpch-toolkit-usage&#34;&gt;TPC-H Toolkit Usage&lt;/h1&gt;
&lt;p&gt;MariaDB 에 TPC-H 를 돌리기 위해선 여기서 몇가지 추가 수정을 해야합니다.  하지만
그에 앞서 &lt;code&gt;dbgen/&lt;/code&gt; 디렉토리 내의 파일들을 어떻게 사용해서 TPC-H 를 수행하는지
알아봅시다.&lt;/p&gt;
&lt;h2 id=&#34;data-preparation&#34;&gt;Data Preparation&lt;/h2&gt;
&lt;p&gt;먼저 dss.ddl 파일은 8개의 테이블 생성에 사용되는 sql 문을 담고 있습니다.  DB
에서 이 파일 내에 적힌 sql 문들을 그대로 수행하라고 하면 8개의 테이블이
생성됩니다.&lt;/p&gt;
&lt;p&gt;dbgen 은 테이블에 데이터를 로드하는 sql 문을 생성합니다.  dbgen 에 scale factor
등의 인자를 줘서 수행시키면 8개의 &lt;code&gt;.tbl&lt;/code&gt; suffix 를 갖는 파일이 생성됩니다.  이
파일들은 각각 파일명에 일치하는 이름의 테이블에 데이터를 insert 하는 query
문들로 구성되어 있습니다.  DB 에 이 파일 내의 sql 명령들을 수행하라고 하면
데이터가 로드되는 것입니다.&lt;/p&gt;
&lt;p&gt;dss.ri 는 테이블 인덱스 생성에 필요한 sql 문을 담고 있습니다.  DB 에 이 파일
내의 sql 명령들을 수행하라고 함으로써 테이블 인덱스 생성이 완료되어 TPC-H 의
쿼리들을 수행할 준비가 마쳐집니다.&lt;/p&gt;
&lt;h2 id=&#34;query-creation-and-execution&#34;&gt;Query Creation and Execution&lt;/h2&gt;
&lt;p&gt;qgen 은 TPC-H 의 분석 작업을 대표하는 22개의 쿼리를 생성해 줍니다.  22개의
쿼리라고 표현했지만 22 종류의 쿼리라고 하는게 옳을 겁니다.  동일한 쿼리의 경우
반복 수행되면 DB 에서 앞 쿼리의 결과를 캐시해 뒀다가 곧바로 리턴하기 때문에
인자 등은 달라야 하기 때문입니다.  이를 위해 dbgen/queries/ 디렉토리 아래에는
생성되어야 하는 22 종류 쿼리의 템플릿을 담고 있습니다.  qgen 은 이 템플릿을
참고하고 랜덤하게 인자를 생성해 최종적으로 DB 에서 수행될 수 있는 쿼리문을
생성합니다.  이 때 랜덤 시드는 dists.dss 라는 파일을 참고해 만들어집니다.&lt;/p&gt;
&lt;h1 id=&#34;modify-tpch-toolkit-for-mariadb&#34;&gt;Modify TPC-H Toolkit for MariaDB&lt;/h1&gt;
&lt;p&gt;DBMS 마다 query syntax 가 조금씩 다릅니다.  때문에 TPC-H Toolkit 은 지원하는
DBMS 마다 다르게 테이블 생성, 쿼리 생성을 하도록 짜여져 있습니다만, 지원하는
DBMS 목록에 MariaDB 는 포함되어 있지 않습니다.  따라서 MariaDB 에 TPC-H 를
돌리기 위해선 TPC-H Toolkit 의 일부분을 수정해야 합니다.&lt;/p&gt;
&lt;p&gt;수정해야 하는 파일은 dss.ddl, dss.ri, 그리고 queries/ 디렉토리 아래의 템플릿
등입니다.  하나하나 설명하는 것은 너무 내용이 길어지므로, 수정 내용을 patch
형태로 만들어 github 에 올려두었습니다[5].  이 패치 파일을 가져와서 다음과 같이
적용할 수 있습니다.  명령을 수행하는 디렉토리는 TPC-H Toolkit 소스코드 디렉토리
여야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wget https://raw.githubusercontent.com/sjp38/tpch-mariadb/07fdcbfa9ba1be26f437ff130338a223d0dbfecd/0001-Modify-for-MariaDB.patch
$ patch -p1 &amp;lt; 0001-Modify-for-MariaDB.patch
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위 변경 사항은 makefile 의 수정도 포함되어 있습니다.  적용 후 dbgen, qgen 을
빌드해 줍시다.&lt;/p&gt;
&lt;h1 id=&#34;data-creation&#34;&gt;Data Creation&lt;/h1&gt;
&lt;p&gt;dbgen/ 디렉토리로 들어가 dbgen 을 수행해 줍니다.  인자로 scale factor 등을 줄
수 있습니다.  -h 인자를 줘서 dbgen 의 수행 방법을 알 수 있으니 참고합시다.
수행이 마무리 되면 다음과 같이 8개의 .tbl suffix 를 갖는 파일들이 생성됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dbgen$ ls -ahl *.tbl
-rw-rw-r-- 1 sjpark sjpark 187M Sep  9 10:48 customer.tbl
-rw-rw-r-- 1 sjpark sjpark 5.8G Sep  9 10:48 lineitem.tbl
-rw-rw-r-- 1 sjpark sjpark 2.2K Sep  9 10:48 nation.tbl
-rw-rw-r-- 1 sjpark sjpark 1.4G Sep  9 10:48 orders.tbl
-rw-rw-r-- 1 sjpark sjpark 919M Sep  9 10:48 partsupp.tbl
-rw-rw-r-- 1 sjpark sjpark 186M Sep  9 10:48 part.tbl
-rw-rw-r-- 1 sjpark sjpark  389 Sep  9 10:48 region.tbl
-rw-rw-r-- 1 sjpark sjpark  11M Sep  9 10:48 supplier.tbl
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;참고로, 위 수행결과는 scale factor 값을 8로 준 결과입니다.&lt;/p&gt;
&lt;h1 id=&#34;load-data&#34;&gt;Load Data&lt;/h1&gt;
&lt;p&gt;이제 MariaDB 를 사용해 tpch 라는 이름의 데이터베이스를 생성하고 (line 1) 그
아래 테이블을 생성하고 (line 2) 각 테이블에 데이터를 로드한 후 (line 3-5) 각
테이블의 인덱스까지 만들어 줍시다 (line 6).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mysql -u root -p password -e &amp;quot;create database tpch;&amp;quot;
$ mysql -u root -p password &amp;lt; dss.ddl
$ for table in customer lineitem nation orders partsupp part region supplier \
	do mysql -u root -p -e \
		&amp;quot;LOAD DATA LOCAL INFILE &#39;$table.tbl&#39; FIELDS TERMINATED BY &#39;|&#39;;&amp;quot;
	done
$ mysql -u root -p password &amp;lt; ./dss.ri
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;create-queries&#34;&gt;Create Queries&lt;/h1&gt;
&lt;p&gt;이제 쿼리를 만들어 봅시다.  qgen 은 인자로 생성할 쿼리의 타입을 1-22 사이 숫자로 받아서 쿼리문을 생성, 화면에 뿌려줍니다.  다음과 같은 커맨드로 이를 따로 저장합니다.  아래 커맨드는 dbgen/ 디렉토리 아래에서 수행됨을 가정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd queries/
$ for i in {1..22}; do ../qgen $i &amp;gt; query-$i.sql; done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이제 dbgen/queries/ 디렉토리 아래에 &lt;code&gt;query-&lt;/code&gt; 라는 prefix 의 쿼리문을 담는 파일
22개가 생성되어 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;execute-queries&#34;&gt;Execute Queries&lt;/h1&gt;
&lt;p&gt;앞서 생성한 쿼리문 파일은 MariaDB 에 호환되는 sql 문으로 구성되어 있으므로,
아래와 같이 간단히 실행시키면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ for i in {1..22}; do mysql -u root -p password &amp;lt; dbgen/queries/query-$i.sql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;일부 쿼리는 수십초, 일부 쿼리는 1초도 걸리지 않아 수행되는 걸 확인할 수
있습니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;TPC-H 가 어떻게 구성되어 있고 어떻게 수행시키며, MariaDB 에서의 수행을 위해서는
어떤 수정이 필요한지 설명했습니다.  github 에 있는 자동화 스크립트[6]를
이용하면 이 과정을 손쉽게 한번에 해결할 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://datawarehouse4u.info/OLTP-vs-OLAP.html&#34;&gt;http://datawarehouse4u.info/OLTP-vs-OLAP.html&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;http://www.tpc.org/tpch/&#34;&gt;http://www.tpc.org/tpch/&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;http://www.tpc.org/tpc_documents_current_versions/pdf/tpc-h_v2.17.2.pdf&#34;&gt;http://www.tpc.org/tpc_documents_current_versions/pdf/tpc-h_v2.17.2.pdf&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;http://www.tpc.org/tpc_documents_current_versions/download_programs/tools-download-request.asp?bm_type=TPC-H&amp;amp;bm_vers=2.17.2&amp;amp;mode=CURRENT-ONLY&#34;&gt;http://www.tpc.org/tpc_documents_current_versions/download_programs/tools-download-request.asp?bm_type=TPC-H&amp;amp;bm_vers=2.17.2&amp;amp;mode=CURRENT-ONLY&lt;/a&gt;&lt;br&gt;
[5] &lt;a href=&#34;https://raw.githubusercontent.com/sjp38/tpch-mariadb/07fdcbfa9ba1be26f437ff130338a223d0dbfecd/0001-Modify-for-MariaDB.patch&#34;&gt;https://raw.githubusercontent.com/sjp38/tpch-mariadb/07fdcbfa9ba1be26f437ff130338a223d0dbfecd/0001-Modify-for-MariaDB.patch&lt;/a&gt;&lt;br&gt;
[6] &lt;a href=&#34;https://github.com/sjp38/tpch-mariadb&#34;&gt;https://github.com/sjp38/tpch-mariadb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 Server 위에 MariaDB 설치/사용하기</title>
      <link>/post/mariadb_setup/</link>
      <pubDate>Thu, 31 Aug 2017 14:37:07 +0900</pubDate>
      <guid>/post/mariadb_setup/</guid>
      <description>&lt;p&gt;악의 조직 Oracle 에서 Sun 을 인수한 후 이어진 반 open source 적 행보에 MySQL
개발자는 MySQL 을 fork 해서 MariaDB 를 개발하고 있습니다.  저작권을 악용해
중요한 기능은 천천히 릴리즈 하거나 유료 라이센스로만 공개하기도 하는 Oracle 의
MySQL 과 달리 MariaDB 는 예전 MySQL 처럼 공개적으로 개발되고 있어 새롭고
진보적인 기능도 많이 있는 편인 것 같습니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 Ubuntu 16.04 서버에 MariaDB 를 소스코드부터 가져와서 설치하고
사용하는 간단한 사용법을 정리해 봅니다.&lt;/p&gt;
&lt;h1 id=&#34;environment&#34;&gt;Environment&lt;/h1&gt;
&lt;p&gt;이 글에서는 Ubuntu 16.04.2 server 버전을 사용합니다.&lt;/p&gt;
&lt;h1 id=&#34;build-and-install&#34;&gt;Build and Install&lt;/h1&gt;
&lt;p&gt;MariaDB 는 대부분의 리눅스 배포본을 위한 패키징이 잘 되어 있어서 각 배포본의
패키징 시스템을 사용하면 한두줄의 커맨드로 쉽게 설치할 수 있습니다.  하지만
여기선 문서[1] 를 참고해 가며 소스 코드부터 가져와서 바닥부터 가장 최신 버전을
설치해 보기로 합시다.&lt;/p&gt;
&lt;p&gt;소스코드는 github 에 git repository 의 형태로 공개되어 있습니다.  아래의
명령어로 코드를 &lt;code&gt;mariadb/&lt;/code&gt; 디렉토리 아래에 가져올 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/MariaDB/server.git mariadb
$ cd mariadb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;git repository 인만큼 버전은 git 을 통해 tag 로 관리되고 있습니다.  이 글을
작성 중인 시점에서 가장 최신 stable 릴리즈는 10.2.8[2] 로, 2017년 8월 18일
자로 릴리즈 되었습니다.  다음 커맨드로 해당 버전의 코드를 checkout 할 수
있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout mariadb-10.2.8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이제 소스코드는 준비되었고, 빌드할 차례입니다.  &lt;code&gt;cmake&lt;/code&gt; 를 사용해 어떻게
빌드할지 등을 설정할 수 있는데, 여기선 release 할때 사용하는 설정을 사용해
보겠습니다.  &lt;code&gt;cmake&lt;/code&gt; 가 실패하는 경우는 대부분 필요 패키지가 설치되지 않은
경우입니다.  &lt;code&gt;libaio-dev&lt;/code&gt;, &lt;code&gt;libjemalloc-dev&lt;/code&gt;, &lt;code&gt;libgnutls-dev&lt;/code&gt; 등의 패키지가
설치되어 있어야 합니다.&lt;/p&gt;
&lt;p&gt;해당 패키지 설치 후에도 같은 에러 메세지가 나올 수 있는데, cmake 의 기존 결과가
캐싱되어 재사용되기 때문입니다.  &lt;code&gt;CMakeCache.txt&lt;/code&gt; 와 &lt;code&gt;CMakeFiles/&lt;/code&gt; 디렉토리를
제거해주면 캐싱된 내용은 사라집니다.&lt;/p&gt;
&lt;p&gt;이어서 간단히 &lt;code&gt;make&lt;/code&gt; 를 사용해 빌드하고 설치를 할 수 있습니다.
설치는 super user 권한이 필요하기 때문에 &lt;code&gt;sudo&lt;/code&gt; 를 사용해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cmake . -DBUILD_CONFIG=mysql_release
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;어떤 사양의 머신에서 빌드하느냐에 따라 다르겠지만 빌드하는데 꽤 긴 시간이
걸립니다.  이 글을 작성하며 사용한 72 코어 / 144 쓰레드 머신에서는 &lt;code&gt;-j144&lt;/code&gt;
옵션을 줘서 빌드할 경우 1분 5초 걸렸습니다.  별다른 에러 메세지가 없다면 빌드에
성공한 것입니다.&lt;/p&gt;
&lt;h1 id=&#34;initialize-mariadb-server&#34;&gt;Initialize MariaDB Server&lt;/h1&gt;
&lt;p&gt;이제 MariaDB 의 기본 설치는 마무리 되었지만, 아직 MariaDB 구동을 위한 준비가
모두 끝나진 않았습니다.  MariaDB 가 제대로 동작하기 위해서는 test database,
default user 등등의 최소 데이터를 생성하는 초기화 작업을 진행해야 합니다.  앞의
설치는 MariaDB 실행파일을 만들어 시스템에 설치한 것이고, 이 초기화 작업은
MariaDB 서비스의 설치라고 생각하면 이해가 조금 편할 수도 있겠습니다.&lt;/p&gt;
&lt;p&gt;super user 권한의 남용은 보안적으로 위험할 수 있으므로, MariaDB 는 기본적으로
별개의 사용자 계정을 사용할 것을 권장합니다.  다음 예에서는 mysql 이라는 이름의
user 를 생성하고 이 사용자 계정을 사용하도록 해서 초기화를 진행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo adduser mysql
$ sudo chown -R mysql /usr/local/mysql/
$ cd /usr/local/mysql/
$ sudo -u mysql ./scripts/mysql_install_db --user=mysql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;순조롭게 진행되었다면 다음과 같은 메세지를 볼 수 있을 겁니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Installing MariaDB/MySQL system tables in &#39;./data&#39; ...
OK

To start mysqld at boot time you have to copy
support-files/mysql.server to the right place for your system

PLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER !
To do so, start the server, then issue the following commands:

&#39;./bin/mysqladmin&#39; -u root password &#39;new-password&#39;
&#39;./bin/mysqladmin&#39; -u root -h hydra password &#39;new-password&#39;

Alternatively you can run:
&#39;./bin/mysql_secure_installation&#39;

which will also give you the option of removing the test
databases and anonymous user created by default.  This is
strongly recommended for production servers.

See the MariaDB Knowledgebase at http://mariadb.com/kb or the
MySQL manual for more instructions.

You can start the MariaDB daemon with:
cd &#39;.&#39; ; ./bin/mysqld_safe --datadir=&#39;./data&#39;

You can test the MariaDB daemon with mysql-test-run.pl
cd &#39;./mysql-test&#39; ; perl mysql-test-run.pl

Please report any problems at http://mariadb.org/jira

The latest information about MariaDB is available at http://mariadb.org/.
You can find additional information about the MySQL part at:
http://dev.mysql.com
Consider joining MariaDB&#39;s strong and vibrant community:
https://mariadb.org/get-involved/
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;starting-mariadb&#34;&gt;Starting MariaDB&lt;/h1&gt;
&lt;p&gt;이제 준비가 끝났습니다.  앞의 초기화 과정 이후 나온 메세지에서도 알 수 있듯이,
다음 커맨드로 MariaDB 서버를 시작할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo -u mysql /usr/local/mysql/bin/mysqld_safe --datadir=&#39;./data&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;connect-to-local-mariadb-server&#34;&gt;Connect to Local MariaDB Server&lt;/h1&gt;
&lt;p&gt;MariaDB 는 여러가지 방법으로 접근해 사용할 수 있는데, 관리 목적 등으로는 local
shell 을 사용하는게 가장 간단합니다.  다음 커맨드로 local shell 을 열 수
있습니다.  이 커맨드는 같은 기계 위에 띄워져 있는 MariaDB 서버 프로세스에
접속해 해당 서버에 sql 쿼리를 날릴 수 있는 프롬프트를 띄워 줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ /usr/local/mysql/bin/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위 커맨드에 &amp;ndash;version 인자를 주면 현재 mariadb 의 버전도 볼 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ /usr/local/mysql/bin/mysql --version
/usr/local/mysql/bin/mysql  Ver 15.1 Distrib 10.2.8-MariaDB, for Linux (x86_64) using readline 5.1
s
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;kill-mariadb-server&#34;&gt;Kill MariaDB Server&lt;/h1&gt;
&lt;p&gt;서버를 끝낼 수도 있어야겠죠.  다음의 커맨드로 mysql 서버 프로세스에게 SIGTERM
시그널을 날려서 서버 프로세스를 종료시킬 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo -u mysql kill -SIGTERM `pidof mysqld`
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;basical-usage&#34;&gt;Basical Usage&lt;/h1&gt;
&lt;p&gt;프롬프트에서 다음과 같이 기본적인 sql 쿼리를 날릴 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo /usr/local/mysql/bin/mysql
&amp;gt; create database sj_db;
&amp;gt; create table sjtable ( id INT PRIMARY KEY, name VARCHAR(20) );
&amp;gt; insert into sjtable values ( 1, &#39;Will&#39; );
&amp;gt; select * from sjtable;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;그 외의 MariaDB sql 문법을 위해서는 MariaDB basic sql statement 문서[3] 를
참고합시다.&lt;/p&gt;
&lt;h1 id=&#34;mycnf-configuration&#34;&gt;my.cnf configuration&lt;/h1&gt;
&lt;p&gt;mysql 과 마찬가지로 MariaDB 역시 my.cnf 파일을 사용해[1] 대부분의 설정을
구성합니다.  기본적으로 /etc/my.cnf, /etc/mysql/my.cnf &amp;hellip; 순으로 설정 파일을
찾게 되며, mysqld_safe 실행파일 실행 시에 &amp;ndash;defaults-file 인자로 파일 경로를
줄수도 있습니다.  소스 코드 디렉토리의 support-files/ 디렉토리 아래에
my-huge.cnf, my-large.cnf, my-medium.cnf 등의 예제 설정도 있습니다.&lt;/p&gt;
&lt;p&gt;앞의 과정을 따라서 설치하면 /etc/ 아래에 my.cnf 파일이 없을 겁니다.  이 때의
기본 설정은 어떻게 되는지는 다음 커맨드를 통해 알 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ /usr/local/mysql/bin/mysql -NBe &#39;SHOW VARIABLES&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;askapache.com 에서는[5] 이를 이용해 기본 my.cnf 를 추출하는 커맨드도 소개하고
있으니 필요하면 참고하시기 바랍니다.&lt;/p&gt;
&lt;h1 id=&#34;data-directory-specification&#34;&gt;Data Directory Specification&lt;/h1&gt;
&lt;p&gt;실험용으로 MariaDB 를 사용하는 경우라면 MariaDB 데이터를 최초 상태로 백업해
두거나 서로 다른 설정의 데이터를 유지해야 할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;MariaDB 의 default data directory 는 /usr/local/mysql/data/ 로, 프롬프트에서&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; select @@datadir;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;명령으로 현재 띄워진 MariaDB 서버 프로세스가 사용중인 data directory 의 경로를
볼 수 있습니다.  이 경로는 my.cnf 상에서 수정할 수도 있고, mysqld_safe 실행 시
&amp;ndash;datadir 옵션으로 지정할 수도 있습니다.  주의할 점은, 이때 &amp;ndash;datadir 인자로
주는 데이터 디렉토리는 한번은 scripts/mysql_install_db 를 실행해준 디렉토리여야
한다는 것입니다.  mysql_install_db 명령에도 &amp;ndash;datadir 인자를 줄수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;MariaDB 최신 버전의 소스코드를 가져와 빌드하고 설치해서 사용하는 방법을
알아봤습니다.  하나의 예제로 정리해 보자면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/MariaDB/server.git mariadb
$ cd mariadb
$ git checkout mariadb-10.2.8
$ cmake . -DBUILD_CONFIG=mysql_release
$ make
$ sudo make install
$ sudo adduser mysql
$ sudo chown -R mysql /usr/local/mysql/
$ cd /usr/local/mysql/
$ sudo -u mysql ./scripts/mysql_install_db --datadirr=&#39;./data&#39; &amp;amp;
$ /usr/local/mysql/bin/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://mariadb.com/kb/en/mariadb/generic-build-instructions/&#34;&gt;https://mariadb.com/kb/en/mariadb/generic-build-instructions/&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://downloads.mariadb.org/mariadb/+releases/&#34;&gt;https://downloads.mariadb.org/mariadb/+releases/&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://mariadb.com/kb/en/mariadb/basic-sql-statements/&#34;&gt;https://mariadb.com/kb/en/mariadb/basic-sql-statements/&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;https://mariadb.com/kb/en/mariadb/configuring-mariadb-with-mycnf/&#34;&gt;https://mariadb.com/kb/en/mariadb/configuring-mariadb-with-mycnf/&lt;/a&gt;&lt;br&gt;
[5] &lt;a href=&#34;https://www.askapache.com/mysql/view-mysql-variables-my-cnf/&#34;&gt;https://www.askapache.com/mysql/view-mysql-variables-my-cnf/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang 1.9 install on Fedora 26</title>
      <link>/post/golang1.9_fedora26/</link>
      <pubDate>Sat, 26 Aug 2017 10:54:24 +0900</pubDate>
      <guid>/post/golang1.9_fedora26/</guid>
      <description>&lt;p&gt;현재 사용중인 랩탑에 설치한 OS 는 Fedora 24 였는데, 너무 오래되었고 지원도
얼마전 끝났기에[0] 이번에 Fedora 26 으로 새로 설치했습니다.  마침 go 언어도 1.9 가
최근에 릴리즈 되었기에 개인적으로 go 언어를 설치하는 방법을 기록해 둡니다.&lt;/p&gt;
&lt;p&gt;여기선 소스 코드만 가지고 빌드, 설치하는 방법을 기록합니다.&lt;/p&gt;
&lt;h1 id=&#34;get-source-code&#34;&gt;Get Source Code&lt;/h1&gt;
&lt;p&gt;go 언어는 오픈소스입니다.  다음 커맨드를 통해 구글로부터 소스코드를 받아올 수
있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://go.googlesource.com/go
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;기다리면 &lt;code&gt;go/&lt;/code&gt; 디렉토리에 소스코드가 딸려옵니다.&lt;/p&gt;
&lt;h1 id=&#34;golang-14-build--install&#34;&gt;golang 1.4 Build &amp;amp; Install&lt;/h1&gt;
&lt;p&gt;go 언어를 빌드한다는 건 go 언어 컴파일러와 기본 라이브러리 등과 같은, go 언어로
짠 프로그램을 빌드하고 수행하는데 필요한 도구들을 빌드한다는 이야기입니다.
이런 기본 도구는 go 언어로 짜여져 있기 때문에 go 언어를 소스코드로부터
빌드하려면 go 언어가 미리 설치되어 있어야 합니다.  따라서 1.4 버전의 go 언어를
먼저 빌드, 설치합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cp -R go go1.4
$ cd go1.4/src
$ git checkout go1.4.3
$ CGO_ENABLED=0 ./all.bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;앞서 받아온 소스코드를 &lt;code&gt;go1.4/&lt;/code&gt; 디렉토리로 복사하고 (line 1) 그리로 이동해서
(line 2) git 을 사용해 1.4 버전들 중 가장 마지막 버전인 1.4.3 버전의 코드를
꺼낸 후 (line 3) 마지막 줄에서 빌드를 하는 명령들입니다.&lt;/p&gt;
&lt;p&gt;참고로 CGO_ENABLED=0 를 빼먹으면 빌드에 실패합니다[1].  go 개발팀에선 그냥
바이너리로 최신 go 를 짜기 위한 go 를 설치하길 권장하지만[2], 전 소스
코드만으로 설치를 하고 싶으므로 이렇게 합니다.&lt;/p&gt;
&lt;h1 id=&#34;golang-19-build--install&#34;&gt;golang 1.9 Build &amp;amp; Install&lt;/h1&gt;
&lt;p&gt;역시 간단합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ../go/src
git checkout go1.9
./all.bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;앞서 받아둔 go 소스 코드로 돌아가서 (line 1), 1.9 버전의 소스코드를 꺼내고
(line 2), 마지막으로 빌드 / 설치를 진행합니다 (line 3).&lt;/p&gt;
&lt;p&gt;다음과 같은 메세지를 보게 되면 빌드 / 설치에 성공한 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
ALL TESTS PASSED

---
Installed Go for linux/amd64 in /home/sjpark/go
Installed commands in /home/sjpark/go/bin
*** You need to add /home/sjpark/go/bin to your PATH.
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;test-installation&#34;&gt;Test Installation&lt;/h2&gt;
&lt;p&gt;설치가 잘 되었는지 마지막으로 테스트 해봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go version
go version devel +bad6b6fa91 Fri Aug 25 23:29:55 2017 +0000 linux/amd64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위와 같이 결과가 나오면 잘 설치된 것입니다.&lt;/p&gt;
&lt;h1 id=&#34;additional-configuration&#34;&gt;Additional Configuration&lt;/h1&gt;
&lt;p&gt;추가적으로 go 바이너리의 위치를 PATH 에 넣어주고, 사용할 GOPATH 를 지정해
줍니다.  golang 은 개발 코드의 위치와 go 언어로 짜여진 프로그램의 설치 위치
규칙을 기본적으로 권장하는 규칙이 있는데, 이를 위해 사용되는 디렉토리의
꼭대기가 GOPATH 입니다.  나만의 방식으로 go 언어를 다루겠다면 굳이 지정할 필요
없지만, 전 그정도 규칙은 따르는 편이므로 다음 내용을 홈 디렉토리의 .bashrc 에
추가해 이를 지정해 줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export GOPATH=$HOME/gopath
export PATH=$PATH:$HOME/go/bin
export PATH=$PATH:$GOPATH/bin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;GOPATH 아래 &lt;code&gt;bin/&lt;/code&gt; 디렉토리는 일반적으로 설치한 go 언어 프로그램의 실행파일을
위치시키는 곳이므로 역시 PATH 에 추가해줬습니다 (line 3).&lt;/p&gt;
&lt;p&gt;이 규칙을 이해하기 쉽게 다음과 같이 제가 만든 &lt;code&gt;hn&lt;/code&gt; 이라는 프로그램을 설치해
보고, 이 명령이 GOPATH 를 어떻게 사용하는지 보면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go get github.com/sjp38/hn
$ tree gopath/
gopath/
├── bin
│   └── hn
└── src
    └── github.com
        └── sjp38
            └── hn
                ├── hn.go
                ├── LICENSE
                └── README.md

5 directories, 4 files
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[0] &lt;a href=&#34;https://fedoramagazine.org/fedora-24-eol/&#34;&gt;https://fedoramagazine.org/fedora-24-eol/&lt;/a&gt;&lt;br&gt;
[1] &lt;a href=&#34;https://github.com/golang/go/issues/18156#issuecomment-264389887&#34;&gt;https://github.com/golang/go/issues/18156#issuecomment-264389887&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://github.com/golang/go/issues/18156#issuecomment-264492152&#34;&gt;https://github.com/golang/go/issues/18156#issuecomment-264492152&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kernel text addresses removed from calltrace</title>
      <link>/post/kernel-text-addresses-removed-from-calltrace/</link>
      <pubDate>Fri, 16 Jun 2017 16:46:09 +0900</pubDate>
      <guid>/post/kernel-text-addresses-removed-from-calltrace/</guid>
      <description>&lt;p&gt;최근 커널은 stakc dump 에서 콜 트레이스(Call Trace) 에 각 코드의 메모리
어드레스를 찍어주지 않습니다.  이에 대해 포스팅을 해봅니다.&lt;/p&gt;
&lt;h1 id=&#34;call-trace&#34;&gt;Call Trace&lt;/h1&gt;
&lt;p&gt;커널은 문제가 발생하거나 하면 문제의 원인을 찾을 수 있는 다양한 정보를 담고
있는 stack dump 를 로그로 뿌려 줍니다.  문제의 원인을 찾는데 매우 소중한
정보입니다.  그 정보 중에서도 중요한 것 중 하나가 콜 트레이스로, 이 문제의
순간에 오기까지 어느 함수의 어느 지점에서 어느 함수를 호출해서 여기까지
왔는가를 담는 정보입니다.&lt;/p&gt;
&lt;p&gt;디버깅 정보를 담아 빌드된 커널이라면 다음과 같이 사람 눈으로 곧바로 어느정도 알
수 있는 수준의 콜 트레이스가 나옵니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Call Trace:
 [&amp;lt;c12ba080&amp;gt;] ? dump_stack+0x44/0x64
 [&amp;lt;c103ed6a&amp;gt;] ? __warn+0xfa/0x120
 [&amp;lt;c109e8a7&amp;gt;] ? module_put+0x57/0x70
 [&amp;lt;c109e8a7&amp;gt;] ? module_put+0x57/0x70
 [&amp;lt;c103ee33&amp;gt;] ? warn_slowpath_null+0x23/0x30
 [&amp;lt;c109e8a7&amp;gt;] ? module_put+0x57/0x70
 [&amp;lt;f80ca4d0&amp;gt;] ? gp8psk_fe_set_frontend+0x460/0x460 [dvb_usb_gp8psk]
 [&amp;lt;c109f617&amp;gt;] ? symbol_put_addr+0x27/0x50
 [&amp;lt;f80bc9ca&amp;gt;] ? dvb_usb_adapter_frontend_exit+0x3a/0x70 [dvb_usb]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;콜 트레이스는 어떻게 이 순간에 이르게 되었는가를 역순으로 보여줍니다.  즉,
dvd_usb_adapter_frontend_exit() 에서 symbol_put_addr() 를 호출했고, 여기서
gp8psk_fe_set_frontend() 를 호출했고, &amp;hellip; 반복되어 dump_stack() 함수에 의해 이
메세지가 뜬 것이죠.  함수 이름 옆의 &lt;code&gt;0xaa/0xbb&lt;/code&gt; 와 같은 숫자들은 각각 함수
내에서 해당 순간 코드까지의 오프셋, 그리고 해당 함수의 전체 크기를 나타냅니다.&lt;/p&gt;
&lt;p&gt;이것만으로도 많은 정보를 알 수 있지만 해당 함수의 정확히 몇번째 라인에서 문제가
났는지는 이것만으로 알수가 없습니다.  코드를 한줄한줄 눈으로 보고 로그를
추가해보고 하면서 찾을 수도 있겠지만 복장이 터지겠죠.  가장 왼쪽 &lt;code&gt;[&amp;lt;&lt;/code&gt; 와 &lt;code&gt;&amp;gt;]&lt;/code&gt;
사이의 16진수는 메모리 상에서 해당 코드의 주소를 의미합니다.  따라서 디버깅
정보가 있다면 이 주소를 가지고 해당 코드가 어느 파일의 몇번째 라인인지 파악할
수 있습니다.&lt;/p&gt;
&lt;p&gt;이 작업을 위한 도구가 여럿 있는데, &lt;code&gt;addr2line&lt;/code&gt;[1] 도 많이 사용되는 도구 중
하나입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ addr2line -e ../linux.out/vmlinux 0xffffffff810e91f0
linux/arch/x86/include/asm/rwsem.h:83
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;-e&lt;/code&gt; 옵션을 통해 커널 디버깅 정보를 담고 있는 커널 이미지가 위치한 경로를
넘겨주고 마지막 인자로 앞의 콜 트레이스에서 얻어온 주소를 주면 어느 파일의
몇번째 라인을 가리키는지 쉽게 알 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;text-address-removed-from-stack-dump&#34;&gt;Text Address Removed from Stack Dump&lt;/h1&gt;
&lt;p&gt;그런데, 2016년 말 후에 릴리즈된 x86 용 커널은 콜 트레이스에서 위의 addr2line
에 넘겨줘야 할, 어드레스 정보가 더이상 콜 트레이스에 없습니다.  해당되는
커널에서는 다음과 같은 콜 트레이스가 나올 겁니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Call Trace:
 dump_stack+0x85/0xc2
 bad_page+0xc1/0x120
 free_pages_check_bad+0x7a/0x80
 __free_pages_ok+0x32a/0x3e0
 __free_pages+0x19/0x30
 shrink_huge_zero_page_scan+0x50/0x60
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이는 2016년 10월 25일자로 Josh Poimboeuf 에 의해 만들어진 커밋[2] 에 의한
겁니다.  코드의 메모리상 어드레스가 추측 가능할 경우엔 해당 영역에 코드를
바꾼다거나 하는 여러 공격이 들어올 수 있어 보안상 좋지 않습니다.  때문에 최근
시스템은 동일한 프로그램이라 하더라도 메모리에 적재될 때마다 코드의 위치가
바뀌거나 하도록 하는 기능을 갖추고 있습니다.  Address randomization[3] 이 한
예입니다.  따라서 Address randomization 이 가줘져 있다고는 하지만 해당
어드레스를 누구나 볼 수 있는 커널 로그에 뿌리는 것도 좋은 행위는 아닐 뿐더러,
이렇게 나온 정보는 시스템에 따라 무효할 것이기 때문에 적어도 커밋 메세지에는
존재할 필요가 없는데 버그 레포팅 할때 사람들이 뿌려대서 귀찮기만 하다는 것이죠.&lt;/p&gt;
&lt;h2 id=&#34;how-to-find-out-the-line-now&#34;&gt;How to find out the Line, now?&lt;/h2&gt;
&lt;p&gt;문제는, 이렇게 되니 기존의 addr2line 을 이용해 한방에 해결되던 위치 찾기가 좀
복잡해진다는 겁니다.  먼저 해당 함수의 메모리 상 위치를 찾아내고, 그 다음
오프셋을 더해서 해당 코드의 메모리 상 주소를 찾아내어서 다시 addr2line 등을
사용해야 하는 것이죠.&lt;/p&gt;
&lt;p&gt;이게 귀찮다면 만능 도구 &lt;code&gt;gdb&lt;/code&gt; 를 사용할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gdb ../linux.out/vmlinux

...

(gdb) list *(free_pages_check_bad+0x7a)
0xffffffff811daf1a is in free_pages_check_bad (/home/sjpark/linux/mm/page_alloc.c:941).
936     #ifdef CONFIG_MEMCG
937             if (unlikely(page-&amp;gt;mem_cgroup))
938                     bad_reason = &amp;quot;page still charged to cgroup&amp;quot;;
939     #endif
940             bad_page(page, bad_reason, bad_flags);
941     }
942
943     static inline int free_pages_check(struct page *page)
944     {
945             if (likely(page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;하지만 이 방법은 동일한 이름의 심볼이 두개 존재하는 경우 첫번째 심볼에 대해서만
보여줍니다.  따라서 사려 깊은 Josh Poimboeuf 는 저처럼 addr2line 을 좋아하는
사람들을 위해 대체할 도구를 만들었습니다.  그 이름은 faddr2line 으로, 커널
소스의 &lt;code&gt;scripts/&lt;/code&gt; 디렉토리 아래에 있습니다.  다음과 같이 사용할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./scripts/faddr2line ../linux.out/vmlinux free_pages_check_bad+0x7a
free_pages_check_bad+0x7a/0x80:
free_pages_check_bad at mm/page_alloc.c:941
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;두번째 인자로 디버깅 정보 담긴 이미지파일 경로, 그 뒤로 찾고자 하는 코드의
함수와 함수로부터 해당 코드까지의 오프셋을 주면 됩니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;보안적 이유와 쓸모없음으로 인해 2016년 말 후의 커널은 콜 트레이스에서 각 코드의
메모리 어드레스를 제거하고 &lt;code&gt;func_name+0x123/0x456&lt;/code&gt; 포맷으로만 코드 위치를
제공하게 되었습니다.  이로 인해 해당 코드의 파일 내에서의 위치를 찾는데에
예전처럼 &lt;code&gt;addr2line&lt;/code&gt; 을 더 사용할 수는 없게 되었지만 커널 모드의
&lt;code&gt;scripts/faddr2line&lt;/code&gt; 도구를 사용해 예전처럼 쉽게 콜 트레이스의 각 위치의 파일
내에서의 위치를 파악할 수 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://www.skrenta.com/rt/man/addr2line.1.html&#34;&gt;http://www.skrenta.com/rt/man/addr2line.1.html&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;http://lkml.kernel.org/r/69329cb29b8f324bb5fcea14d61d224807fb6488.1477405374.git.jpoimboe@redhat.com&#34;&gt;http://lkml.kernel.org/r/69329cb29b8f324bb5fcea14d61d224807fb6488.1477405374.git.jpoimboe@redhat.com&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://en.wikipedia.org/wiki/Address_space_layout_randomization&#34;&gt;https://en.wikipedia.org/wiki/Address_space_layout_randomization&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lkml livestream</title>
      <link>/post/lkml_go/</link>
      <pubDate>Sun, 28 May 2017 17:51:43 +0900</pubDate>
      <guid>/post/lkml_go/</guid>
      <description>&lt;p&gt;I wrote a simple, stupid program[1] that showing LKML[2] mails in terminal
briefly like twitter livestream in Go language.  It is just an early version
and so many things to be complemented exists, though.  Nevertheless, now it
just works as I wanted at first.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://github.com/sjp38/lkml&#34;&gt;https://github.com/sjp38/lkml&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://en.wikipedia.org/wiki/Linux_kernel_mailing_list&#34;&gt;https://en.wikipedia.org/wiki/Linux_kernel_mailing_list&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parsec 3.0 설치 / 사용법</title>
      <link>/post/parsec_3_howto/</link>
      <pubDate>Fri, 19 May 2017 06:23:15 +0900</pubDate>
      <guid>/post/parsec_3_howto/</guid>
      <description>&lt;p&gt;PARSEC 은 멀티쓰레드 프로그램들로 구성된 benchmark suite 입니다.  멀티쓰레드로
구성되어 있기 때문에 멀티코어 시스템에서의 multi core scalability 를 테스트
하기에도 적합합니다.  이 글에선 현재 최신 버전인 3.0 버전의 PARSEC 을 Ubuntu
16.04 server 에 설치하면서 겪는 문제의 해결법과 간단한 사용법을 정리해 봅니다.&lt;/p&gt;
&lt;h1 id=&#34;toolbox-for-parsec-30-on-ubuntu-xenial&#34;&gt;Toolbox for PARSEC 3.0 on Ubuntu Xenial&lt;/h1&gt;
&lt;p&gt;아래의 내용을 하나하나 읽어가면서 따라하는 것도 귀찮은 일입니다.  그래서
아래에서 설명하는, Ubuntu Xenial 에서 PARSEC 3.0 을 돌리기 위해 필요한 작업을
대부분 자동으로 해주는 도구들을 만들어 두었습니다.  오픈소스로 공개되어
있으니[1], 아래의 머리 아픈 내용을 읽기 귀찮다면 해당 도구들을 사용하시기
바랍니다.  해당 도구들의 사용법은 README 에 간략히 설명되어 있습니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://github.com/sjp38/parsec_on_ubuntu_xenial&#34;&gt;https://github.com/sjp38/parsec_on_ubuntu_xenial&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;parsec-30-download&#34;&gt;PARSEC 3.0 Download&lt;/h1&gt;
&lt;p&gt;공식 홈페이지[1] 에 들어가면 PARSEC 3.0 다운로드 링크가 첫페이지부터 있습니다.
해당 링크를 사용하면 &lt;code&gt;tar.gz&lt;/code&gt; 포맷의 tarball 로 정리된 PARSEC 3.0 을 다운받을
수 있습니다.  웹브라우저로 들어가서 다운로드를 받는 방법도 있겠고, &lt;code&gt;curl&lt;/code&gt; 이나
&lt;code&gt;wget&lt;/code&gt; 등의 command line tool 을 사용해 다운받을 수도 있겠습니다.  다음
커맨드는 PARSEC 3.0 을 다운받아 &lt;code&gt;parsec-3.0/&lt;/code&gt; 디렉토리 아래 압축을 풀고 압축을
푼 디렉토리로 이동합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wget http://parsec.cs.princeton.edu/download/3.0/parsec-3.0.tar.gz
$ tar zxvf parsec-3.0.tar.gz
$ cd parsec-3.0
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;build&#34;&gt;Build&lt;/h1&gt;
&lt;p&gt;이제 PARSEC 3.0 을 빌드해야 합니다.  PARSEC 은 여러 벤치마크를 포함하고
있으므로 개별적 벤치마크를 하나하나 직접적으로 다루기보다는 suite 내의 각
벤치마크를 통합적으로 관리할 수 있는 &lt;code&gt;parsecmgmt&lt;/code&gt; 라는 관리 프로그램을
사용하도록 되어 있습니다.  빌드 역시 마찬가지입니다.  참고로, &lt;code&gt;parsecmgmt&lt;/code&gt; 는
bash script 입니다.&lt;/p&gt;
&lt;p&gt;기본적인 PARSEC 3.0 빌드 방법은 다음과 같이 간단합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ source ./env.sh
$ parsecmgmt -a build
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;첫번째 커맨드는 parsecmgmt 의 경로를 PATH 에 추가하는 등, 환경 변수 설정 등의
일을 처리해 주며, 두번째의 간단한 커맨드가 전체 PARSEC 3.0 빌드 프로세스를
수행하게 됩니다.&lt;/p&gt;
&lt;h2 id=&#34;perl-version-problem&#34;&gt;Perl Version Problem&lt;/h2&gt;
&lt;p&gt;하지만 Ubuntu 16.04 server 에서는 다음과 같은 에러 메세지를 내뱉으며 빌드에
실패합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;smime.pod around line 272: Expected text after =item, not a number
smime.pod around line 276: Expected text after =item, not a number
smime.pod around line 280: Expected text after =item, not a number
smime.pod around line 285: Expected text after =item, not a number
smime.pod around line 289: Expected text after =item, not a number
POD document had syntax errors at /usr/bin/pod2man line 68.
make: *** [install_docs] Error 1
Makefile:680: recipe for target &#39;install_docs&#39; failed
[PARSEC] Error: &#39;env PATH=/usr/local/sbin:...&#39; failed.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;에러 메세지에서 유추할 수 있듯 PARSEC 3.0 의 소스 코드 중 smime.pod 파일이
문법에 맞지 않아 생긴 문제입니다.  참고로 pod 는 perl 프로그램 문서화에
사용되는 간단한 markup language 입니다[2].  Ubuntu 16.04 는 perl 5.22.1 버전을
기본으로 사용하고 있는데, PARSEC 3.0 에 있는 코드는 perl 5.14.2 버전에 맞춰져
있으며 최신 버전으로 오는 사이 문법이 바뀐 것으로 인한 문제로 보입니다.
해결책은 두가지가 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;방법 1: perl 5.14.2 설치&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Google groups 의 관련 쓰레드[3] 를 참고한 방법입니다.
5.14.2 버전의 perl 소스코드를 받아와 이를 설치하고 PARSEC 빌드에 이 버전의 perl
을 사용하는 방법입니다.  다음의 커맨드로 &lt;code&gt;~/localperl/&lt;/code&gt; 디렉토리 아래 5.14.2
버전 perl 을 설치하고 사용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget http://www.cpan.org/src/5.0/perl-5.14.2.tar.gz
$ tar zxvf perl-5.14.2.tar.gz
$ cd perl-5.14.2/
$ mkdir ~/localperl
$ ./Configure -des -Dprefix=$HOME/localperl
$ time make -j
$ make test
$ make install
$ ~/localperl/bin/perl -v
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;방법 2: pod 파일 문법 오류 수정&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;좀 더 정공법에 가까운 방법으로, 다음 글을 참고한 해결책입니다:
&lt;a href=&#34;https://yulistic.gitlab.io/2016/05/parsec-3.0-installation-issues/&#34;&gt;https://yulistic.gitlab.io/2016/05/parsec-3.0-installation-issues/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;최신 버전의 문법에 맞게 pod 파일의 문제시 되는 부분들을 고쳐주는 것으로,
문제되는 모든 pod 파일의 &lt;code&gt;=item [0-9]&lt;/code&gt; 을 &lt;code&gt;=item C&amp;lt;[0-9]&amp;gt;&lt;/code&gt; 으로 바꿔줍니다.
&lt;code&gt;diff&lt;/code&gt; 로 표현하면 다음과 같은 수정을 가하게 되겠습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--- a/pkgs/libs/ssl/src/doc/apps/smime.pod
+++ b/pkgs/libs/ssl/src/doc/apps/smime.pod
@@ -265,28 +265,28 @@ encrypted data is used for other purposes.

 =over 4

-=item 0
+=item C&amp;lt;0&amp;gt;

 the operation was completely successfully.

-=item 1
+=item C&amp;lt;1&amp;gt;

 an error occurred parsing the command options.

-=item 2
+=item C&amp;lt;2&amp;gt;

 one of the input files could not be read.

-=item 3
+=item C&amp;lt;3&amp;gt;

 an error occurred creating the PKCS#7 file or when reading the MIME
 message.

-=item 4
+=item C&amp;lt;4&amp;gt;

 an error occurred decrypting or verifying the message.

-=item 5
+=item C&amp;lt;5&amp;gt;

 the message was verified correctly but an error occurred writing out
 the signers certificates.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이렇게 파일 하나하나 수정하면 이 에러 메세지는 사라집니다.  참고한 링크에서는
하나하나 손으로 수정하기보다는 다음과 같이 간단한 bash shell script 를 짜서
일괄적으로 수정하는 걸 추천합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#! /bin/bash
for i in 0 1 2 3 4 5 6 7 8 9 
do
    echo &amp;quot;Replacing &#39;=item $i&#39; to &#39;=item C&amp;lt;$i&amp;gt;&#39;&amp;quot;
    grep -rl &amp;quot;=item $i&amp;quot; * | xargs sed -i &amp;quot;s/=item $i/=item C&amp;lt;$i&amp;gt;/g&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이어서 설명할 문제들과 해결책도 해당 링크를 참고한 것임을 밝혀둡니다.&lt;/p&gt;
&lt;h2 id=&#34;mbstatet-conflict&#34;&gt;&lt;code&gt;__mbstate_t&lt;/code&gt; Conflict&lt;/h2&gt;
&lt;p&gt;앞의 에러 메세지는 사라지지만 이제 다음과 같은 에러 메세지가 나올 겁니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/include/wchar.h:94:3: error: conflicting types for ‘__mbstate_t’
 } __mbstate_t;
   ^
In file included from ../include/machine/bsd_endian.h:37:0,
                 from ../include/sys/bsd_types.h:44,
                 from ../include/sys/bsd_param.h:64,
                 from if_host.c:48:
../include/sys/bsd__types.h:105:3: note: previous declaration of ‘__mbstate_t’ was here
 } __mbstate_t;
   ^
In file included from ../include/net/bsd_if_var.h:82:0,
                 from ../include/net/bsd_if.h:459,
                 from if_host.c:57:
../include/sys/bsd_buf_ring.h: In function ‘buf_ring_dequeue_sc’:
../include/sys/bsd_buf_ring.h:200:33: warning: variable ‘cons_next_next’ set but not used [-Wunused-but-set-variable]
  uint32_t cons_head, cons_next, cons_next_next;
                                 ^
make[1]: *** [if_host.o] Error 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;basd__types.h&lt;/code&gt; 파일에 &lt;code&gt;__mbstate_t&lt;/code&gt; 타입을 중복 정의했기 때문에 발생한
문제입니다.  해당 파일에서 해당 정의 부분을 다음과 같이 주석 처리하면 이 문제는
사라집니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff --git a/pkgs/libs/uptcpip/src/include/sys/bsd__types.h b/pkgs/libs/uptcpip/src/include/sys/bsd__types.h
index fa1b0f0f26d9..bd7e6a97f4c8 100644
--- a/pkgs/libs/uptcpip/src/include/sys/bsd__types.h
+++ b/pkgs/libs/uptcpip/src/include/sys/bsd__types.h
@@ -93,6 +93,7 @@ typedef       __ct_rune_t     __wint_t;       /* wint_t (see above) */

 typedef        __uint32_t      __fixpt_t;      /* fixed point number */

+#if 0  /* Skip conflicting __mbstate_t definition */
 /*
  * mbstate_t is an opaque object to keep conversion state during multibyte
  * stream conversions.
@@ -104,5 +105,6 @@ typedef union {
        __int64_t       _mbstateL;      /* for alignment */
 } __mbstate_t;
 #endif
+#endif /* Skip conflicting __mbstate_t definition */

 #endif /* !_BSD_SYS__TYPES_H_ */
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;pkgconfig-package-not-found&#34;&gt;pkg-config Package Not Found&lt;/h2&gt;
&lt;p&gt;성공적인 빌드를 위해선 당연하지만 PARSEC 3.0 이 의존성을 가진 패키지가 모두
설치되어 있어야 합니다.  이를 주의 깊게 미리 설치해 두지 않았다면 다음과 같은
에러 메세지를 만날 수도 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;configure: error: *** pkg-config not found. See http://www.freedesktop.org/software/pkgconfig/
[PARSEC] Error: ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위 메세지는 &lt;code&gt;pkg-config&lt;/code&gt; 프로그램이 설치되어 있지 않아서 발생한 문제임을 알 수
있습니다.  간단히 Ubuntu 의 package 시스템인 apt 를 사용해 다음과 같이 해당
프로그램을 설치해 주면 문제는 사라집니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt install pkg-config
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;build-success&#34;&gt;Build Success&lt;/h2&gt;
&lt;p&gt;이 정도까지가 나타날 수 있는 대부분의 문제입니다.  위 해결책들을 모두
적용했다면 아마 빌드에 성공할 겁니다.  빌드에 성공하면 다음과 같이 성공했다는
메세지를 볼 수 있을 겁니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[PARSEC]
[PARSEC] BIBLIOGRAPHY
[PARSEC]
[PARSEC] [1] Bienia. Benchmarking Modern Multiprocessors. Ph.D. Thesis, 2011.
[PARSEC] [2] Woo et al. The SPLASH-2 Programs: Characterization and Methodological Considerations. ISCA, 1995.
[PARSEC]
[PARSEC] Done.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;참고로 빌드에 꽤 긴 시간이 소모됩니다.  제가 사용한 72 코어 / 144 쓰레드
머신에서도 약 10분이 걸렸습니다.&lt;/p&gt;
&lt;h1 id=&#34;simple-usage&#34;&gt;Simple Usage&lt;/h1&gt;
&lt;p&gt;이제 빌드가 잘 되었는지 돌려봐야 할 차례입니다.  다음 커맨드는 각 벤치마크를
가장 작은 크기의 데이터셋을 가지고 실행해 보기 때문에 각 벤치마크가 돌아가긴
하는지만 보는데 적격입니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parsecmgmt -a run
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;가장 작은 크기의 데이터셋을 사용하기 때문에 모든 벤치마크를 수행하지만 빠르게
종료됩니다.&lt;/p&gt;
&lt;h2 id=&#34;parsecmgmt-options&#34;&gt;&lt;code&gt;parsecmgmt&lt;/code&gt; Options&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 옵션은 action 을 의미합니다.  앞의 섹션에서는 빌드를 위해 여기에 &lt;code&gt;build&lt;/code&gt;
값을 주었고, 여기선 벤치마크 수행을 위해 &lt;code&gt;run&lt;/code&gt; 값을 준 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-i&lt;/code&gt; 옵션을 통해 벤치마크들은 워크로드에서 사용할 데이터 크기를 지정할 수
있습니다.  이 인자의 값으로 test, simdev, simsmall, simmedium, simlarge, native
를 줄 수 있습니다.  Test 는 정확성 테스트만을 위한, 빨리 끝나는 데이터로 이
인자를 주지 않으면 default 로 이 값이 취해집니다.  native 는 가장 realworld
workload 에 가까운 벤치마크를 위한 데이터라 볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; 옵션을 통해 어떤 sub benchmark 를 돌릴지 정할 수 있습니다.  이 옵션을
별도로 주지 않으면 모든 benchmark 를 돌리게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; 옵션은 number of threads to use 입니다.&lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code&gt;parsecmgmt -p canneal -a run -i native -n 1&lt;/code&gt; 은 &lt;code&gt;canneal&lt;/code&gt; sub
benchmark 하나만을 쓰레드 한개 써서 &lt;code&gt;native&lt;/code&gt; 데이터셋으로 실행합니다.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://parsec.cs.princeton.edu&#34;&gt;http://parsec.cs.princeton.edu&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://en.wikipedia.org/wiki/Plain_Old_Documentation&#34;&gt;https://en.wikipedia.org/wiki/Plain_Old_Documentation&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://groups.google.com/forum/#&#34;&gt;https://groups.google.com/forum/#&lt;/a&gt;!topic/snipersim/_1qpbmpPRtg&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>원격 데스크탑의 clipboard 를 ssh 와 xclip 으로 복사해오기</title>
      <link>/post/xclip_copy_remote_clipboard/</link>
      <pubDate>Fri, 31 Mar 2017 13:53:54 +0900</pubDate>
      <guid>/post/xclip_copy_remote_clipboard/</guid>
      <description>&lt;p&gt;여러개의 리눅스 데스크탑 PC 를 한 책상 위에서 사용하는 경우가 있다.  이 때, 한
PC 에서 Ctrl-C 해서 clipboard 에 복사한 내용을 다른쪽 PC 에서 Ctrl-V 로
붙여넣고 싶은 경우가 있다.  여러가지 해결책이 있겠으나, 다음과 같이 ssh 와
xclip 을 사용해서 해결할 수도 있다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh &amp;lt;username&amp;gt;@&amp;lt;remote host&amp;gt; &#39;DISPLAY=:0 xclip -o -selection clipboard&#39; | \
	xclip -i -selection clipboard
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;참고: &lt;a href=&#34;http://askubuntu.com/questions/513442/can-two-pcs-with-ubuntu-share-the-clipboard-buffer&#34;&gt;http://askubuntu.com/questions/513442/can-two-pcs-with-ubuntu-share-the-clipboard-buffer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>spec cpu2006 벤치마크 설치 / 실행하기</title>
      <link>/post/spec_cpu2006_install/</link>
      <pubDate>Wed, 29 Mar 2017 05:10:55 +0900</pubDate>
      <guid>/post/spec_cpu2006_install/</guid>
      <description>&lt;p&gt;SPEC 은 벤치마크를 위한 협력기구 [0] 로, 다양한 벤치마크 suite 들을 만들고
공유합니다.  SPEC CPU 2006 은 여기서 만든 벤치마크 도구집합 중 하나 [1] 로 계산
작업 집중적인 워크로드에 대한 성능을 측정을 목표로 만들어졌으며, 많은 곳에서
사용되고 있습니다.  2006년 1.0 버전이, 2008년에 1.1 버전이, 그리고 2011년에 1.2
버전이 나왔습니다.  본 글은 Ubuntu 16.04 서버 위에서의 SPEC CPU 2006 v1.1 의
설치와 실행 방법에 대해 간단히 설명합니다.&lt;/p&gt;
&lt;h1 id=&#34;automated-toolbox&#34;&gt;Automated Toolbox&lt;/h1&gt;
&lt;p&gt;아래 내용들을 하나하나 읽고 따라하기엔 시간이 부족할 분들을 위해, 한방에 설치 /
수행이 가능하도록 스크립트를 짜서 Github 에 올려뒀습니다[1].  시간이 없는
분들은 이쪽을 사용 바랍니다.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://github.com/sjp38/spec_on_ubuntu_xenial&#34;&gt;https://github.com/sjp38/spec_on_ubuntu_xenial&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;-&#34;&gt;설치 환경&lt;/h1&gt;
&lt;p&gt;본 글에서 설명하는 내용은 다음과 같은 환경의 머신 위에서 수행되었습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Intel Xeon E7-8870 v3&lt;/li&gt;
&lt;li&gt;Linux 4.10 kernel&lt;/li&gt;
&lt;li&gt;Ubuntu 16.04.1 Server version&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;--&#34;&gt;소스 코드 구하기&lt;/h1&gt;
&lt;p&gt;먼저 소스 코드가 있어야겠죠.  SPEC CPU 2006 은 DVD 또는 &lt;code&gt;.iso&lt;/code&gt; 파일의 형태로
구매 [2] 될 수 있습니다 (작성 시점에서 SPEC CPU 2006 v1.2 의 가격은 $800 군요).
이렇게 구매된 DVD 안에는 벤치마크 소스코드와 벤치마크의 컴파일과 수행, 검증을
위한 tool 프로그램들의 소스코드, 미리 컴파일된 tool 프로그램들, 벤치마크 실행을
위한 규칙 파일, 그리고 문서등이 들어있습니다.  이 글에선 SPEC CPU 2006 v1.1 을
바탕으로 설명합니다.  &lt;code&gt;.iso&lt;/code&gt; 파일을 구했다면 다음과 같은 명령으로 mount 해서 그
안의 파일들을 보고 사용할 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir tmnt
$ sudo mount -o loop SPEC_CPU2006v1.1.iso ./tmnt
$ ls tmnt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;마운트한 위치에서 곧바로 설치 / 실행을 수행해도 좋지만 파일을 복사해두고
사용하겠습니다.  &lt;code&gt;mount&lt;/code&gt; 를 &lt;code&gt;sudo&lt;/code&gt; 로 해야하는 관계로 이 파일들의 owner 는
&lt;code&gt;root&lt;/code&gt; 이며 쓰기권한도 없습니다.  굳이 &lt;code&gt;root&lt;/code&gt; 가 되지 않고도 벤치마크를
설치하고 돌릴 수 있으므로 파일의 owner 와 권한을 바꿔줍니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir SPEC_CPU2006v1.1
$ cp -R ./tmnt/* SPEC_CPU2006v1.1/
$ sudo umount ./tmnt &amp;amp;&amp;amp; rm -fr ./tmnt
$ sudo chown -R &amp;lt;username&amp;gt; SPEC_CPU2006v1.1
$ sudo chmod -R 755 SPEC_CPU2006v1.1
$ cd SPEC_CPU2006v1.1
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;-1&#34;&gt;툴 빌드&lt;/h1&gt;
&lt;p&gt;SPEC 에서 사용되는 도구들은 앞서 가져온 &lt;code&gt;.iso&lt;/code&gt; 파일 안에 redhat, suse 등 여러
플랫폼 용으로 미리 빌드되어 있습니다.  하지만 Ubuntu 를 위한 버전은 없습니다.
따라서 다음과 같이 소스코드로부터 직접 빌드를 해야 합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd tools/src
$ ./buildtools
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;buildtools&lt;/code&gt; 는 셸 스크립트로, &lt;code&gt;tools/src&lt;/code&gt; 아래 있는 각 툴들을 빌드합니다.
곧바로 진행되면 좋겠지만, 다음과 같은 에러들이 발생합니다.&lt;/p&gt;
&lt;h2 id=&#34;conflicting-types-for-getline&#34;&gt;Conflicting types for &amp;lsquo;getline&amp;rsquo;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;md5sum&lt;/code&gt; 빌드 중 다음과 같은 에러 메세지가 나옵니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -DHAVE_CONFIG_H    -I/home/sjpark/SPEC_CPU2006v1.1/tools/output/include   -I. -Ilib  -c -o md5sum.o md5sum.c
In file included from md5sum.c:38:0:
lib/getline.h:31:1: error: conflicting types for &#39;getline&#39;
 getline PARAMS ((char **_lineptr, size_t *_n, FILE *_stream));
 ^
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;md5sum&lt;/code&gt; 빌드 중 &lt;code&gt;getline()&lt;/code&gt;, &lt;code&gt;getdelim()&lt;/code&gt; 함수가 &lt;code&gt;stdio.h&lt;/code&gt; 에서 선언되어
있는데도 &lt;code&gt;getline.h&lt;/code&gt; 파일에 또 선언되어서 conflicting type 으로 나는
문제입니다.  역시 툴 중 하나인 &lt;code&gt;tar&lt;/code&gt; 의 경우엔 GLIBC 버전을 체크해 2 이상일
경우엔 해당 declaration 을 제거해 두었는데, &lt;code&gt;md5sum&lt;/code&gt; 아래의 &lt;code&gt;getline.h&lt;/code&gt; 엔 이
체크가 없기 때문에 문제가 됩니다.  다음과 같이 GLIBC 버전 체크를 추가해
중복선언이 없도록 수정해 줍니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--- a/tools/src/specmd5sum/lib/getline.h
+++ b/tools/src/specmd5sum/lib/getline.h
@@ -27,10 +27,14 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 #  endif
 # endif

+# if __GLIBC__ &amp;lt; 2
+
 int
 getline PARAMS ((char **_lineptr, size_t *_n, FILE *_stream));

 int
 getdelim PARAMS ((char **_lineptr, size_t *_n, int _delimiter, FILE *_stream));

+#endif
+
 #endif /* not GETLINE_H_ */
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;undefined-reference-to-pow&#34;&gt;Undefined reference to &lt;code&gt;pow&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;이 문제와 아래의 두개의 문제는 인터넷 상의 SPEC CPU 2000 에 대한 비슷한 문제의
해결책[3] 을 참고했습니다.&lt;/p&gt;
&lt;p&gt;이제 &lt;code&gt;perl&lt;/code&gt; 빌드 중 다음과 같은 에러 메세지가 발생합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cc -L/home/sjpark/SPEC_CPU2006v1.1/tools/output/lib -L/usr/local/lib -o miniperl \
            miniperlmain.o opmini.o libperl.a
libperl.a(pp.o): In function `Perl_pp_pow&#39;:
pp.c:(.text+0x2a76): undefined reference to `pow&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;pow&lt;/code&gt; 함수를 찾지 못하는 문제로, &lt;code&gt;libm&lt;/code&gt; 라이브러리를 링크 시점에 링크하도록
알려줘야 합니다.  다음과 같이 &lt;code&gt;PERLFLAGS&lt;/code&gt; 환경변수를 설정하고 &lt;code&gt;buildtools&lt;/code&gt; 를
실행하는 것으로 해결할 수 있습니다:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ PERLFLAGS=&amp;quot;-A libs=-lm -A libs=-ldl&amp;quot; ./buildtools&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;you-havent-done-a-make-depend-yet&#34;&gt;You haven&#39;t done a &amp;ldquo;make depend&amp;rdquo; yet!&lt;/h2&gt;
&lt;p&gt;이어서 다음 에러 메세지가 나옵니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;You haven&#39;t done a &amp;quot;make depend&amp;quot; yet!
make[1]: *** [hash.o] Error 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;perl&lt;/code&gt; 빌드 중 사용되는 &lt;code&gt;/bin/sh&lt;/code&gt; 은 &lt;code&gt;/bin/dash&lt;/code&gt; 를 가리키고 있는데, &lt;code&gt;dash&lt;/code&gt;
에서 생기는 문제입니다.  다음과 같이 심볼릭 링크를 수정해 &lt;code&gt;bin/sh&lt;/code&gt; 이 &lt;code&gt;bash&lt;/code&gt; 를
가리키도록 하면 문제는 해결됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo rm /bin/sh
$ sudo ln -s /bin/bash /bin/sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;시스템을 원래대로 돌리고 싶다면 빌드 끝나고 나중에 심볼릭 링크를 되돌리면
됩니다.&lt;/p&gt;
&lt;h2 id=&#34;asmpageh-file-not-found&#34;&gt;&lt;code&gt;asm/page.h&lt;/code&gt; file not found&lt;/h2&gt;
&lt;p&gt;커널 헤더파일인 &lt;code&gt;asm/page.h&lt;/code&gt; 파일을 &lt;code&gt;tools/src/perl-5.8.8/ext/IPC/SysV/SysV.xs&lt;/code&gt;
파일에서 &lt;code&gt;include&lt;/code&gt; 하고 있어 발생하는 문제가 다음과 같이 발생합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cc -c   -I/home/sjpark/SPEC_CPU2006v1.1/tools/output/include -fno-strict-aliasing -pipe -Wdeclaration-after-statement -I/usr/local/include -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -O2   -DVERSION=\&amp;quot;1.04\&amp;quot; -DXS_VERSION=\&amp;quot;1.04\&amp;quot; -fpic &amp;quot;-I../../..&amp;quot;   SysV.c
SysV.xs:7:25: fatal error: asm/page.h: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;SysV.xs&lt;/code&gt; 파일의 해당 &lt;code&gt;include&lt;/code&gt; 문을 다음과 같이 막고 &lt;code&gt;PAGE_SIZE&lt;/code&gt; 를 정의해
줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--- a/tools/src/perl-5.8.8/ext/IPC/SysV/SysV.xs
+++ b/tools/src/perl-5.8.8/ext/IPC/SysV/SysV.xs
@@ -4,7 +4,7 @@

 #include &amp;lt;sys/types.h&amp;gt;
 #ifdef __linux__
-#   include &amp;lt;asm/page.h&amp;gt;
+#define PAGE_SIZE      4096
 #endif
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;perl-test-fail&#34;&gt;&lt;code&gt;perl&lt;/code&gt; test fail&lt;/h2&gt;
&lt;p&gt;위의 해결책을 모두 적용하고 &lt;code&gt;$ PERLFLAGS=&amp;quot;-A libs=-lm -A libs=-ldl&amp;quot; ./buildtools&lt;/code&gt; 를 수행하면 perl 쪽의 테스트 약 900개 가운데 9개 정도 fail 나는
문제가 있긴 하지만 이건 무시하겠다고 하면 무시가 되고 빌드 진행이 됩니다.
테스트 9개가 fail 났는데 무시하겠냐는 질문이 아래와 같이 뜨는데, 무시하겠다고
답해줍시다 (해당 프롬프트에서 설명하는대로, &lt;code&gt;y&lt;/code&gt; 를 입력하면 됩니다).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Failed 9 test scripts out of 907, 99.01% okay.
### Since not all tests were successful, you may want to run some of
### them individually and examine any diagnostic messages they produce.
### See the INSTALL document&#39;s section on &amp;quot;make test&amp;quot;.
### You have a good chance to get more information by running
###   ./perl harness
### in the &#39;t&#39; directory since most (&amp;gt;=80%) of the tests succeeded.
### You may have to set your dynamic library search path,
### LD_LIBRARY_PATH, to point to the build directory:
###   setenv LD_LIBRARY_PATH `pwd`:$LD_LIBRARY_PATH; cd t; ./perl harness
###   LD_LIBRARY_PATH=`pwd`:$LD_LIBRARY_PATH; export LD_LIBRARY_PATH; cd t; ./perl harness
###   export LD_LIBRARY_PATH=`pwd`:$LD_LIBRARY_PATH; cd t; ./perl harness
### for csh-style shells, like tcsh; or for traditional/modern
### Bourne-style shells, like bash, ksh, and zsh, respectively.
u=0.92  s=0.69  cu=89.23  cs=5.47  scripts=907  tests=112394
make[2]: *** [_test_tty] Error 1
make[2]: Leaving directory `/home/sjpark/SPEC_CPU2006v1.1/tools/src/perl-5.8.8&#39;
make[1]: *** [_test] Error 2
make[1]: Leaving directory `/home/sjpark/SPEC_CPU2006v1.1/tools/src/perl-5.8.8&#39;
make: *** [test] Error 2
+ &#39;[&#39; 2 -ne 0 &#39;]&#39;
+ set +x


Hey!  Some of the Perl tests failed!  If you think this is okay, enter y now:
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;build-success&#34;&gt;Build success&lt;/h2&gt;
&lt;p&gt;여기까지 오면 이제 빌드가 완료됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tools built successfully.  Go to the top of the tree and
source the shrc file.  Then you should be ready.
$
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;heading&#34;&gt;실행&lt;/h1&gt;
&lt;h2 id=&#34;configuration-file&#34;&gt;Configuration File&lt;/h2&gt;
&lt;p&gt;빌드가 완료되었다면 이제 실행을 해야겠죠.  벤치마크의 실행 환경을 구성해야
하는데, config/ 디렉토리 밑에 예제 구성 파일들이 있습니다.  이 가운데,
&lt;code&gt;Example-linux64-amd64-gcc43.cfg&lt;/code&gt; 정도가 이 글을 작성하며 사용한 시스템에는
적당할 겁니다.  해당 파일을 바탕으로 자신만의 구성 파일을 만들어 &lt;code&gt;config/&lt;/code&gt;
디렉토리 아래 저장합니다.  이 글에서는 &lt;code&gt;config/config.cfg&lt;/code&gt; 라는 이름의 파일로
&lt;code&gt;Example-linux64-amd64-gcc43.cfg&lt;/code&gt; 파일을 단순히 복사했습니다.&lt;/p&gt;
&lt;h2 id=&#34;environment-setup&#34;&gt;Environment Setup&lt;/h2&gt;
&lt;p&gt;SPEC CPU 벤치마크를 수행하기 위한 환경변수 등을 설정해야 합니다.  다음 명령으로
간단히 이를 수행할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ source ./shrc
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;running-workload&#34;&gt;Running Workload&lt;/h2&gt;
&lt;p&gt;최종적인 워크로드의 수행은 &lt;code&gt;runspec&lt;/code&gt; 이라는 프로그램을 사용해 이루어집니다.  이
프로그램은 SPEC CPU 소스코드의 &lt;code&gt;bin/&lt;/code&gt; 디렉토리 아래 위치해 있지만 앞서 행한
환경변수 설정으로 인해 커맨드라인에 경로를 직접 입력하지 않고도 수행할 수
있습니다.  예컨대 mcf 워크로드를 수행하고자 한다면 다음과 같은 커맨드를 사용할
수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ runspec --iterations 1 --size ref --action onlyrun --config config.cfg --noreportable mcf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위 커맨드를 수행하면 mcf 워크로드가 수행되며, 수행 결과를 요약한 로그 파일의
경로를 다음과 같이 화면에 뿌려줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...

Run Complete

The log for this run is in /home/username/spec/spec_src/result/CPU2006.003.log

runspec finished at Sun Sep 24 13:55:14 2017; 290 total seconds elapsed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;더 자신의 목적에 맞는 실험을 위해선 &lt;code&gt;runspec&lt;/code&gt; 의 사용법을 파악해야 합니다.  이
글에서의 범위는 벗어나므로, 이에 대해서는 다른 문서들을 참고하시기 바랍니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;SPEC CPU 2006 을 Ubuntu 16.04 에 설치하는 과정을 알아봤습니다.  다음 글에서는
SPEC CPU 벤치마크를 실행해 보는 방법을 설명합니다.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;p&gt;[0] &lt;a href=&#34;http://spec.org/&#34;&gt;http://spec.org/&lt;/a&gt;&lt;br&gt;
[1] &lt;a href=&#34;http://spec.org/benchmarks.html#cpu&#34;&gt;http://spec.org/benchmarks.html#cpu&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;http://spec.org/order.html&#34;&gt;http://spec.org/order.html&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://wiki.linaro.org/MichaelHope/Sandbox/BuildingSPECTools&#34;&gt;https://wiki.linaro.org/MichaelHope/Sandbox/BuildingSPECTools&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fetching linux kernel source code</title>
      <link>/post/fetching-linux-source-code/</link>
      <pubDate>Mon, 20 Mar 2017 22:37:03 +0900</pubDate>
      <guid>/post/fetching-linux-source-code/</guid>
      <description>&lt;p&gt;리눅스 커널은 오픈 소스 소프트웨어이므로 그 소스코드가 공개되어 있어 누구나
인터넷을 통해 쉽게 얻을 수 있습니다.  이 글에서는 리눅스 커널 소스코드를 받아올
수 있는 몇가지 방법을 설명합니다.&lt;/p&gt;
&lt;h1 id=&#34;kernelorg&#34;&gt;kernel.org&lt;/h1&gt;
&lt;p&gt;리눅스 커널 소스 코드를 받아오기 위한 기본적 공식 사이트는
[kernel.org] (&lt;a href=&#34;https://www.kernel.org&#34;&gt;https://www.kernel.org&lt;/a&gt;) 라 할 수 있겠는데, 이 사이트에는 소스
코드를 포함해 리눅스 커널을 위한 다양한 리소스가 정리되어 있습니다.  이
사이트에 웹브라우저를 통해 들어가보면 첫페이지에서부터 가장 최근에 릴리즈된
버전의 소스코드, 가장 최근의 안정화된 버전의 소스코드 등을 &lt;code&gt;tar.xz&lt;/code&gt; 포맷의 압축
파일 또는 &lt;code&gt;patch&lt;/code&gt; 등 다양한 형태로 다운받을 수 있는 링크가 있습니다.&lt;/p&gt;
&lt;p&gt;한가지 유의할 것은 kernel.org 는 공식적 사이트일 뿐으로 비슷하게 소스코드를
호스팅 하는 사이트는 github 을 포함해 여럿 있을 수 있다는 점입니다.  또한,
특정한 회사나 개인이 수정한 버전의 커널의 소스코드는 kernel.org 에서 받을 수
없을 수 있습니다.  하지만, 리눅스 커널의 라이센스가 GPL 인만큼, 그들도 자신이
수정한 버전을 상품 등으로 배포하고 있다면 소스코드를 공개해야 하므로, 해당
버전을 만든 사람 또는 회사에 문의해 보면 그 소스코드를 받을 수 있을 겁니다.
예를 들어 안드로이드의 경우 자신들이 수정한 커널을 사용하며, 그렇게 수정된
커널의 소스코드를 자신들의 소스코드 [호스팅 사이트]
(&lt;a href=&#34;https://android.googlesource.com/&#34;&gt;https://android.googlesource.com/&lt;/a&gt;) 에 공개하고 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;specific-version&#34;&gt;Specific Version&lt;/h2&gt;
&lt;p&gt;kernel.org 첫 페이지에는 몇가지 버전의 소스코드만 존재하므로 찾고 있는 버전은
해당 페이지에 링크가 존재하지 않을 수 있습니다.  특정 버전을 찾기 위한 페이지
역시 kernel.org 는 제공하는데, &lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/&#34;&gt;https://www.kernel.org/pub/linux/kernel/&lt;/a&gt; 주소로
들어가면 특정 버전의 커널 소스코드를 받을 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 4.2.1 버전을 받고 싶다면, 다음 커맨드를 셸에서 수행해 받아올 수
있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.2.1.tar.xz
$ tar xvf linux-4.2.1.tar.xz
$ ls linux-4.2.1
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;git-repository-cloning&#34;&gt;Git Repository Cloning&lt;/h1&gt;
&lt;p&gt;주요 리눅스 개발자들은 각자의 git repository 로 자신이 개발중인 버전의 리눅스
커널 소스코드를 관리하는데, 이 역시 남들이 볼 수 있게 공유해 두고 있습니다.
따라서, 원한다면 특정 리눅스 개발자의 개발중인 리눅스 커널 소스코드를 git 으로
clone 해올 수 있습니다.  많은 주요 개발자들이 kernel.org 위에 자신의 git
repository 를 호스팅 하고 있으며, github 을 사용하는 사람들도 많습니다.  예를
들어 리누스 토발즈는 kernel.org 위에 자신의 git repository 를 호스팅 하면서
github 에 미러링도 하고 있습니다.  각각의 repository 의 주소는 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux.git&#34;&gt;https://github.com/torvalds/linux.git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음과 같은 명령을 통해 리누스 토발즈의 개발중인 리눅스 커널 소스코드를 clone
해올 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
$ ls linux
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;개발자의 repository 를 클론해 오는 방식의 장점은, 일단 아직 릴리즈 되지 않은
따끈따끈한 버전의 소스코드를 그 commit history 와 함께 볼 수 있다는 점일
겁니다.  리눅스 커널 개발에 참여하고 싶다면 현재 어떤 기능이 구현되고 있고 어떤
버그가 아직 고쳐지지 않았는지 등을 알 수 있으므로 필수적입니다.  또하나의
장점은 git repository 에는 그동안 해당 repository 에서 릴리즈한 버전들이 모두
포함되어 있어, 해당 버전을 언제든지 &lt;code&gt;checkout&lt;/code&gt; 할 수 있다는 점입니다.&lt;/p&gt;
&lt;p&gt;단점은, commit history 와 개발중인 코드를 원하는게 아니라면 불필요하게 많은
용량의 데이터를 다운로드 받아야 한다는 것입니다.  현재 소스코드를 필요로 하는
목적에 맞춰, 특정 버전의 코드가 필요할 뿐이라면 압축 파일을, 그렇지 않다면 git
repository 를 사용한 접근을 하는 편이 옳을 겁니다.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;리눅스 커널의 소스코드를 얻어오는 몇가지 방법을 알아봤습니다.  리눅스 커널은
오픈소스 형태라 그 소스코드를 쉽게 구할 수 있으며, kernel.org 또는 github 등의
호스팅 사이트에서 압축 파일, 패치, 또는 git repository 의 형태로 얻을 수
있습니다.  개발중인 repository 의 clone 을 통한 형태는 commit history 와
개발중인 코드의 정보를 알 수 있다는 장점이 있지만 그만큼 다운로드 받아야 하는
데이터의 양이 크다는 단점도 존재합니다.  자신이 현재 소스코드를 얻고자 하는
목적에 맞춰 적합한 방법으로 소스코드를 얻어오는 것이 좋을 겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Updating Google Chrome on Fedora 23</title>
      <link>/post/fedora-chrome-update/</link>
      <pubDate>Mon, 20 Mar 2017 22:24:26 +0900</pubDate>
      <guid>/post/fedora-chrome-update/</guid>
      <description>&lt;p&gt;I am using Fedora 23 laptop and installed stable version Google Chrome from its
official website [0].  In this case, just using &lt;code&gt;Updates&lt;/code&gt; of Fedora &lt;code&gt;Software&lt;/code&gt;
program doesn&#39;t update Chrome automatically.  For the case, follow below
commands to update your Chrome:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo dnf update google-chrome-stable
...
$ sudo killall chrome
$ google-chrome-stable
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The second &lt;code&gt;killall&lt;/code&gt; command is necessary because Chrome doesn&#39;t kill its
process by just cliking &lt;code&gt;Close&lt;/code&gt; button.  Or, you may reboot your computer but
you wouldn&#39;t like that.&lt;/p&gt;
&lt;p&gt;[0] &lt;a href=&#34;https://www.google.com/chrome/browser/desktop/index.html?brand=CHBD&amp;amp;gclid=CKiMjdqX5dICFYcGKgodqZIM2Q&#34;&gt;https://www.google.com/chrome/browser/desktop/index.html?brand=CHBD&amp;amp;gclid=CKiMjdqX5dICFYcGKgodqZIM2Q&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang kakaotalk chat bot making</title>
      <link>/post/kakaobot/</link>
      <pubDate>Wed, 15 Mar 2017 22:40:32 +0900</pubDate>
      <guid>/post/kakaobot/</guid>
      <description>&lt;p&gt;I have developed a chat bot [1] for Kakaotalk [2] using Go language because I
have been curious about the process of Kakaotalk chat bot development process.
Implementation to major version has consumed only two hours owing to power of
Go language, simpleness of Kakaotalk auto-reply API, and simple simple
functionality requirement of my bot.  It has coded really simply and in
brute-force manner, do only simple echoing.  However, for the reason, the code
could be helpful for beginner of Kakaotalk chat bot or Go language Restful API
server programmer.  That&#39;s why I am introducing it here.  You can get the code
from below link:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/sjp38/kakaobot&#34;&gt;https://github.com/sjp38/kakaobot&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://en.wikipedia.org/wiki/Chatbot&#34;&gt;https://en.wikipedia.org/wiki/Chatbot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&#34;http://www.kakao.com/services/8&#34;&gt;http://www.kakao.com/services/8&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using arping to know ip-MAC mapping</title>
      <link>/post/arping-howto/</link>
      <pubDate>Tue, 07 Mar 2017 19:41:16 +0900</pubDate>
      <guid>/post/arping-howto/</guid>
      <description>&lt;p&gt;You can use &lt;code&gt;arping&lt;/code&gt; to know IP address to MAC address mapping of your local
network.  Usage is simple:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arping  [-AbDfhqUV]  [-c count] [-w deadline] [-s source] -I interface destination
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For example, you may use the command as below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ arping -I eth0 10.0.0.1
ARPING 10.0.0.1 from 10.0.0.2 eth0
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.123ms
Unicast reply from 10.0.0.1 [11:22:33:44:55:66]  0.251ms
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Secret of the tool is ARP protocol [1].  To know the MAC address of the machine
that has a specific IP address, IP protocol layer uses the protocol.  MAC
address that found in this way can be used to communicate with Ethernet
protocol layer.  &lt;code&gt;arping&lt;/code&gt; just sends the ARP REQUEST to local network
neighbour.&lt;/p&gt;
&lt;p&gt;It could be useful in case of internet connection problem if IP duplication is
suspicious.&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html&#34;&gt;http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>beautifulhugo 테마 tags 기능 구현</title>
      <link>/post/beautifulhugo_contribute/</link>
      <pubDate>Fri, 24 Feb 2017 22:58:25 +0900</pubDate>
      <guid>/post/beautifulhugo_contribute/</guid>
      <description>&lt;p&gt;꽤 맘에 드는 hugo 테마[1]를 찾았다.  하지만 tag 기능이 빠져있어 너무
아쉬워하다가 이대로 포기하기엔 너무 맘에 들어 이래저래 찾아보니 과거에 tag 기능
관련 이슈가 올라왔지만 close 처리된 상태.  이대로는 암만 기다려도 tag 기능을
구현해주진 않겠구나 싶어서 이것저것 보고 낑낑대며 서툴고 간단하게나마 tag
기능을 구현[2].  Pull request[3] 도 보냈는데 과연 받아들여줄런지.&lt;/p&gt;
&lt;p&gt;업데이트: 별다른 discussion 없이 머지됐다 ;)&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&#34;http://themes.gohugo.io/beautifulhugo/&#34;&gt;http://themes.gohugo.io/beautifulhugo/&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://github.com/sjp38/beautifulhugo-sj&#34;&gt;https://github.com/sjp38/beautifulhugo-sj&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;https://github.com/halogenica/beautifulhugo/pull/15&#34;&gt;https://github.com/halogenica/beautifulhugo/pull/15&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1990년대의 palmtop, HP 95LX 를 득템</title>
      <link>/post/hp_95lx/</link>
      <pubDate>Thu, 02 Feb 2017 16:24:02 +0900</pubDate>
      <guid>/post/hp_95lx/</guid>
      <description>&lt;p&gt;이사로 생긴 쓰레기 정리를 돕다가 보니 한 물건이 유난히 눈에 띄었다.  자그마한
크기에 왠지 모르게 90년대 감성.  자세히 살펴 보니 전자사전 같이 생겼는데 왠지
옛날에 유행하던 palmtop[1] 같은 느낌.  어차피 버릴 물건이기에 따로 챙겨두고
컴퓨터로 검색을 해보았다.&lt;/p&gt;
&lt;p&gt;![HP 95LX]
(/img/hp95lx/1.jpg)&lt;/p&gt;
&lt;p&gt;모델명인 HP 95LX 로 검색해보니[2] 한때 스프레드시트 프로그램의 대명사였던
&lt;code&gt;Lotus 123&lt;/code&gt; 을 탑재한 것으로 유명한 palmtop PC 로, MS-DOS 를 장착한 모델이다.
당연하게도 바로는 안켜지지만 잘 살펴보니 전용 배터리가 아니라 2A 건전지를
사용하고 있기에 건전지를 끼고 파워 버튼을 눌러봤지만 역시 잠잠.  시무룩.
하지만 또 여기저기 살펴보니 충전지 비슷한 물건이 있다.  배터리 교체 시에
in-memory 데이터가 날아가지 않도록 해당 충전지를 충전 후 동작하는 형태가 아닐까
싶어 잠시 동안 놔두었다 켜봤더니, 켜진다!&lt;/p&gt;
&lt;p&gt;![HP 95LX boot]
(/img/hp95lx/2.jpg)&lt;/p&gt;
&lt;p&gt;몇가지 주요 어플리케이션을 통해 주요 기능들을 제공한다.
파일 탐색, 약속 관리, 전화번호부 관리, 메모, 계산기, 그리고 Lotus 123 을 통한
스프레드 시트 관리가 가능하다.3&lt;/p&gt;
&lt;p&gt;파일 탐색 기능.  실행 파일의 실행도 가능한 듯 하다.
![HP 95LX filer]
(/img/hp95lx/4.jpg)&lt;/p&gt;
&lt;p&gt;약속 관리 기능.  2017년 달력도 존재.
![HP 95LX appointment book]
(/img/hp95lx/5.jpg)&lt;/p&gt;
&lt;p&gt;전화번호부.
![HP 95LX phone book]
(/img/hp95lx/6.jpg)&lt;/p&gt;
&lt;p&gt;메모.
![HP 95LX memo]
(/img/hp95lx/7.jpg)&lt;/p&gt;
&lt;p&gt;그리고, 시대를 풍미한 스프레드시트, Lotus 123.
![HP 95LX lotus 123]
(/img/hp95lx/8.jpg)&lt;/p&gt;
&lt;p&gt;한참 가지고 놀다가 뒤늦게야 시간과 사용자를 설정.  연도 설정이 두자리라 혹시나
Y2K 문제가 있진 않을까 걱정했지만 2017 년으로 잘 인식한다.  잘 짜여진
프로그램이란 이리도 멋지다.
![HP 95LX boot]
(/img/hp95lx/9.jpg)&lt;/p&gt;
&lt;p&gt;요즘 나오는 스마트폰에 비교하자면 보잘것없지만 그 시절에도 이만한 휴대성과
완성도의 물건을 아직도 동작할 만큼 튼튼하게 제품으로 만들어냈다는 사실에
경외로움을 숨길 수 없거니와, 여전히 텍스트 기반 UI 를 즐겨 사용하는 내
입장에서는 이 UI 도 여전히 멋지다.  물론 Unix 계열 셸을 제공했다면
완벽했겠지만&amp;hellip;  과거의 물건이 유난한 감동을 준 하루였다.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://en.wikipedia.org/wiki/Palmtop_PC&#34;&gt;https://en.wikipedia.org/wiki/Palmtop_PC&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://en.wikipedia.org/wiki/HP_95LX&#34;&gt;https://en.wikipedia.org/wiki/HP_95LX&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>uninstall kernel</title>
      <link>/post/uninstall-kernel/</link>
      <pubDate>Fri, 20 Jan 2017 13:18:56 +0900</pubDate>
      <guid>/post/uninstall-kernel/</guid>
      <description>&lt;p&gt;테스트 등을 위해 소스코드로부터 커널을 직접 빌드, 설치하기 시작하면 어느새
수많은 커널이 설치되어 있는 것을 확인할 수 있다.  삭제를 위해선 &lt;code&gt;make install&lt;/code&gt;
로 만들어진 파일들을 직접 제거하고 grub 을 업데이트 해줘야 한다.&lt;/p&gt;
&lt;p&gt;예를 들어 시스템이 현재 부팅되어 있는 버전의 커널을 언인스톨하고자 한다면
다음의 일련의 커맨드를 입력하면 된다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# rm /boot/vmlinuz-$(uname -r)
# rm /boot/initrd.img-$(uname -r)
# rm /boot/System.map-$(uname -r)
# rm /boot/config-$(uname -r)
# rm -fr /lib/modules/$(uname -r)
# rm /var/lib/initramfs-tools/$(uname -r)
# update-grub2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;다른 버전의 설치되어있는 커널을 제거하고 싶다면 위의 &lt;code&gt;$(uname -r)&lt;/code&gt; 부분을
제거하고자 하는 커널 버전으로 대체하면 된다.&lt;/p&gt;
&lt;h2 id=&#34;-&#34;&gt;참고 문서&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://askubuntu.com/questions/594443/how-can-i-remove-compiled-kernel&#34;&gt;http://askubuntu.com/questions/594443/how-can-i-remove-compiled-kernel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>donate mozilla</title>
      <link>/post/donate-mozilla/</link>
      <pubDate>Thu, 19 Jan 2017 18:06:54 +0900</pubDate>
      <guid>/post/donate-mozilla/</guid>
      <description>&lt;p&gt;나는 보통의 경우 크롬으로 웹브라우징을 한다.  하지만 몇달 전부터 몇가지 예외에
대해서는 파이어폭스를 함께 쓰고 있다.&lt;/p&gt;
&lt;h2 id=&#34;--&#34;&gt;부족한 하드웨어 스펙&lt;/h2&gt;
&lt;p&gt;나의 데스크탑 환경은 모니터 세대를 연결한 PC 하나로 구성되어 있었는데, FHD
모니터 세대를 돌리기는 벅찼는지 간헐적 입력 랙이 자주 발생했다.  또, 모니터를
한대 정도 더 늘리고 싶었다.  해서 집에서 놀고있던 5년된 HP 랩탑에 모니터 하나를
연결시키고 이 랩탑과 PC 를 키보드/마우스 하나로 제어하는 환경을 구축했다.  PC
에 연결되는 모니터는 두대로 줄어드니까 입력 랙도 줄어들 것이라 생각한것.
여기까지는 계산대로였는데, HP 랩탑이 5년전 모델이라 램이 2 GB.  난 크롬에서 탭
10여개를 띄워두는데, 가뜩이나 메모리 많이 먹는 크롬이라 도무지 무리.  램 2 GB
를 사서 추가로 달아줬지만 그래도 영 버벅였다.  기존 환경으로 돌아가긴 싫은데&amp;hellip;
싶던 와중 파이어폭스를 떠올렸고, 파이어폭스는 역시 적당한 메모리 사용량으로 내
워크로드를 충족해 주었다.&lt;/p&gt;
&lt;h2 id=&#34;----&#34;&gt;일부 성급한 최적화가 이루어진 사이트&lt;/h2&gt;
&lt;p&gt;리눅스용 크롬에서의 페이스북은 한글 입력 문제가 있다.  뭐라 설명하기도
짜증나는데 한마디로 한글로 글을 입력하려 하면 사람을 짱나게 만드는 문제가
존재한다.  모바일 페이지에선 안그러는 것 같은데, 암튼 짜증난다.  크롬 문제인지
페이스북 문제인지 리눅스 문제인지 모르겠지만 암튼 이불킥할 글을 좀 덜 쓰게
해주는 장점도 있지만 여간 불편한게 아니다.  파이어폭스에서는 문제가 없다.&lt;/p&gt;
&lt;h2 id=&#34;---&#34;&gt;모질라에 감사의 마음을 금전으로&lt;/h2&gt;
&lt;p&gt;파이어폭스를 만들고 있는 모질라는 세상에 많은 것을 기여하는 훌륭한 곳인데 돈이
항상 부족하다.  대안적 도구의 중요성을 되새기고 감사의 마음을 담아 소액이나마
기부해 보았다.  기부를 하고 싶다면 다음 링크를 사용하면 된다:
&lt;a href=&#34;https://donate.mozilla.org/ko/&#34;&gt;https://donate.mozilla.org/ko/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;뱀발&lt;/h2&gt;
&lt;p&gt;w3m 같은 CLI 웹브라우저들도 훌륭한 대안 웹브라우저다 ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>us sues oracle</title>
      <link>/post/us-sues-oracle/</link>
      <pubDate>Thu, 19 Jan 2017 10:17:09 +0900</pubDate>
      <guid>/post/us-sues-oracle/</guid>
      <description>&lt;p&gt;오라클이 백인 남성에게 더 많은 월급을 지불하고 아시아인, 그중에서도 인도 사람을
많이 개발직에 채용했다는 이유로 미국 정부가 오라클을 고소.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.reuters.com/article/us-oracle-usa-labor-idUSKBN1522O6?il=0&#34;&gt;http://www.reuters.com/article/us-oracle-usa-labor-idUSKBN1522O6?il=0&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GCMA: Guaranteed Contiguous Memory Allocator</title>
      <link>/post/gcma/</link>
      <pubDate>Sat, 14 Jan 2017 23:11:23 +0900</pubDate>
      <guid>/post/gcma/</guid>
      <description>&lt;p&gt;GCMA (Guaranteed Contiguous Memory Allocator) is a contiguous memory allocator
for Linux kernel that guarantees fast latency, success of allocation, and
reasonable system memory utilization.  Our evaluation on Raspberry Pi 2 shows
&lt;strong&gt;15 to 130 times faster&lt;/strong&gt; and more predictable allocation latency without
system performance degradation compared to Linux v3.18 default CMA.&lt;/p&gt;
&lt;p&gt;The project has been introduced by Linux Foundation Korea Forum 2014[1] and
Embedded Operating Systems Workshop 2015[2].  A paper about the project has
been published by proceeding of Embedded Operating Systems Workshop 2015 and
45th issue of ACM SIGBED Review[3].  The source code has been submitted to
LKML[4] for discussion.  It is also available at Github[5].&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://korealinuxforum2014.sched.com/event/1qZcBAO/gcma-guaranteed-contiguous-memory-allocator-seongjae-park-seoul-national-university-minchan-kim-lg&#34;&gt;https://korealinuxforum2014.sched.com/event/1qZcBAO/gcma-guaranteed-contiguous-memory-allocator-seongjae-park-seoul-national-university-minchan-kim-lg&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;http://ceur-ws.org/Vol-1464/&#34;&gt;http://ceur-ws.org/Vol-1464/&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;http://sigbed.seas.upenn.edu/vol13_num1.html#issue&#34;&gt;http://sigbed.seas.upenn.edu/vol13_num1.html#issue&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;https://lkml.org/lkml/2015/2/23/480&#34;&gt;https://lkml.org/lkml/2015/2/23/480&lt;/a&gt;&lt;br&gt;
[5] &lt;a href=&#34;https://github.com/sjp38/linux.gcma&#34;&gt;https://github.com/sjp38/linux.gcma&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/post/about/</link>
      <pubDate>Sat, 14 Jan 2017 04:51:08 +0900</pubDate>
      <guid>/post/about/</guid>
      <description>&lt;h1 id=&#34;bio&#34;&gt;Bio&lt;/h1&gt;
&lt;p&gt;SeongJae Park is a programmer who loves to analyse and develop systems just for
fun.&lt;/p&gt;
&lt;h1 id=&#34;contacts&#34;&gt;Contacts&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;mailto:sjpark@dcslab.snu.ac.kr&#34;&gt;&lt;a href=&#34;mailto:sjpark@dcslab.snu.ac.kr&#34;&gt;sjpark@dcslab.snu.ac.kr&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;mailto:sj38.park@gmail.com&#34;&gt;&lt;a href=&#34;mailto:sj38.park@gmail.com&#34;&gt;sj38.park@gmail.com&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;education&#34;&gt;Education&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ph.D, Computer Science and Engineering&lt;/strong&gt; at &lt;em&gt;Seoul National
University&lt;/em&gt;, Aug 2019&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B.S., Electrical Engineering / Information and Computer Engineering (dual
degree)&lt;/strong&gt; at &lt;em&gt;Ajou University&lt;/em&gt;, Jan 2009&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;experiences&#34;&gt;Experiences&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Kernel / Hypervisor Engineer&lt;/strong&gt; at &lt;strong&gt;Amazon&lt;/strong&gt;, Sep 2019 - Present&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Graduate Research Assistant&lt;/strong&gt; at &lt;strong&gt;DCSLAB, Seoul National University&lt;/strong&gt;,&lt;br&gt;
Jul 2012 - Aug 2019&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Part-time Linux Kernel Hacker&lt;/strong&gt; at &lt;strong&gt;Korea Open Source Software Lab&lt;/strong&gt;,&lt;br&gt;
Jan 2016 - May 2019&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Full-time Linux Kernel Hacker&lt;/strong&gt; at &lt;strong&gt;Korea Open Source Software Lab&lt;/strong&gt;,&lt;br&gt;
Dec 2013 - Dec 2014&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Free-lance S/W Developer&lt;/strong&gt;, Aug 2011 - Nov 2013&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Software Engineer&lt;/strong&gt; at &lt;strong&gt;Samsung Electronics&lt;/strong&gt;, Feb 2009 - Jul 2011&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Software Engineer&lt;/strong&gt; at &lt;strong&gt;Samsung Software Membership&lt;/strong&gt;, Jan 2008 - Jan 2009&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;publications-and-presentations&#34;&gt;Publications And Presentations&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;SeongJae Park, Yunjae Lee, Heon Y. Yeom, &lt;strong&gt;Profiling Dynamic Data Access
Patterns with Controlled Overhead and Quality.&lt;/strong&gt; In 20th ACM/IFIP
International Middleware Conference Industry, December 2019. (Accepted)&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Tracing Data Access Pattern with Bounded Overhead and
Best-effort Accuracy.&lt;/strong&gt; In &lt;em&gt;The Linux Kernel Summit&lt;/em&gt;, September 2019.
&lt;a href=&#34;https://linuxplumbersconf.org/event/4/contributions/548/attachments/311/590/damon_ksummit19.pdf&#34;&gt;Slides&lt;/a&gt;,
&lt;a href=&#34;https://linuxplumbersconf.org/event/4/contributions/548/&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, Yunjae Lee, Moonsub Kim Heon Y. Yeom, &lt;strong&gt;Automating Context
Based Access Pattern Hint Injection for System Performance and Swap Storage
Durability.&lt;/strong&gt; In 11th USENIX Workshop on Hot Topics in Storage and File
Systems (HotStorage), July 2019.
&lt;a href=&#34;https://www.usenix.org/system/files/hotstorage19-paper-park.pdf&#34;&gt;Paper&lt;/a&gt;,
&lt;a href=&#34;https://www.usenix.org/sites/default/files/conference/protected-files/hotstorage19_slides_park.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, Yunjae Lee, Yunhee Kim, Heon Y. Yeom, &lt;strong&gt;Profiling Dynamic Data
Access Patterns with Bounded Overhead and Accuracy.&lt;/strong&gt; In IEEE International
Workshop on Foundations and Applications of Self-* Systems (FAS* 2019),
June 2019.
&lt;a href=&#34;https://ieeexplore.ieee.org/abstract/document/8791992&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Biscuit: an operating system written in Go.&lt;/strong&gt; In &lt;em&gt;1st GDG
Golang Korea meetup&lt;/em&gt;, May 2019.
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/biscuit-an-operating-system-written-in-go&#34;&gt;Slides&lt;/a&gt;,
&lt;a href=&#34;https://youtu.be/e-5kCRZhOw8&#34;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, Minchan Kim, Heon Y. Yeom, &lt;strong&gt;GCMA: Guaranteed Contiguous
Memory Allocator.&lt;/strong&gt; In &lt;em&gt;Transactions on Computers&lt;/em&gt;, March 2019.
&lt;a href=&#34;https://ieeexplore.ieee.org/document/8456561&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, Yunjae Lee, Moonsub Kim, Heon Y. Yeom, &lt;strong&gt;Automated Data Access
Pattern Hint Instrumentation for System Performance and Durability of Swap
Storages.&lt;/strong&gt; (WiP) In 17th USENIX Conference on File and Storage Technologies
(FAST), February 2019.
&lt;a href=&#34;https://www.usenix.org/conference/fast19/wips&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;GCMA: Guaranteed Contiguous Memory Allocator.&lt;/strong&gt; In &lt;em&gt;The
Linux Kernel Summit&lt;/em&gt;, November 2018.
&lt;a href=&#34;https://linuxplumbersconf.org/event/2/contributions/247/attachments/74/85/gcma_ksummit2018.pdf&#34;&gt;Slides&lt;/a&gt;,
&lt;a href=&#34;https://www.youtube.com/watch?v=ARrelFfdVkw&#34;&gt;Video&lt;/a&gt;,
&lt;a href=&#34;https://linuxplumbersconf.org/event/2/contributions/247/&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Linux Kernel Memory Model.&lt;/strong&gt; In &lt;em&gt;4th Korea Linux Kernel
Conference&lt;/em&gt;, November 2018.
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/linux-kernel-memory-model&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;An Introduction to the Formalised Memory Model for Linux
Kernel.&lt;/strong&gt; In &lt;em&gt;Korea Open Source Software Conference (KOSSCON)&lt;/em&gt;, Aug 2018.
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/an-introduction-to-the-formalised-memory-model-for-linux-kernel&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Design Choices of Golang for High Scalability.&lt;/strong&gt; In &lt;em&gt;GDG
Korea Meeup&lt;/em&gt;,&lt;br&gt;
Sept 2017.
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/design-choices-of-golang-for-high-scalability&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Brief Introduction to Kselftest.&lt;/strong&gt; In &lt;em&gt;Korea Linux Kernel
Conference&lt;/em&gt;,&lt;br&gt;
July 2017.
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/brief-introduction-to-kselftest&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Understanding of Linux Kernel Memory Model.&lt;/strong&gt; In &lt;em&gt;Korea Open
Source Software Conference (KOSSCON)&lt;/em&gt;, November 2016.
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/understanding-of-linux-kernel-memory-model&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, Minchan Kim, Heon Y. Yeom, &lt;strong&gt;GCMA: Guaranteed Contiguous
Memory Allocator.&lt;/strong&gt; In &lt;em&gt;Embedded Operating Systems Workshop (EWiLi)&lt;/em&gt;, October
2015.
&lt;a href=&#34;http://ceur-ws.org/Vol-1464/ewili15_12.pdf&#34;&gt;Paper&lt;/a&gt;,
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/gcma-guaranteed-contiguous-memory-allocator&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Develop Android/iOS app using golang.&lt;/strong&gt; In &lt;em&gt;Gophercon Korea&lt;/em&gt;,&lt;br&gt;
August 2015.
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/develop-androidios-app-using-golang&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, Minchan Kim, &lt;strong&gt;GCMA: Guaranteed Contiguous Memory Allocator.&lt;/strong&gt;
In &lt;em&gt;Linux Foundation Korea Linux Forum (LFKLF)&lt;/em&gt;, October 2014.
&lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/gcma-guaranteed_contiguous_memory_allocator-lfklf2014_0.pdf&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;How GIT Works Internally.&lt;/strong&gt; In &lt;em&gt;Samsung Open-source Software
Conference (SOSCON)&lt;/em&gt;, September 2014.
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/deep-darkside-ofgit&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hyuck Han, SeongJae Park, Hyungsoo Jung, Alan Fekete, Uwe Rohm, Heon Y.
Yeom, &lt;strong&gt;Scalable Serializable Snapshot Isolation for Multicore Systems.&lt;/strong&gt; In
&lt;em&gt;IEEE 30th International Conference on Data Engineering (ICDE)&lt;/em&gt;, March 2014.
&lt;a href=&#34;http://ieeexplore.ieee.org/document/6816693/&#34;&gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SeongJae Park, &lt;strong&gt;Let The Contribution Begin.&lt;/strong&gt; In Google Developers Group
DevFest W, March 2013.
&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1/let-the-contribution-begin&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;other-links&#34;&gt;Other Links&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/seongjae-park-1a5b9954&#34;&gt;LinkedIn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sjp38&#34;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.openhub.net/accounts/sjpark&#34;&gt;Openhub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slideshare.net/SeongJaePark1&#34;&gt;Slideshare&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>&#34;Is Parallel Programming Hard, And, If So, What Can You Do About It?&#34; Translation</title>
      <link>/post/perfbook-kokr/</link>
      <pubDate>Tue, 10 Jan 2017 13:46:00 +0900</pubDate>
      <guid>/post/perfbook-kokr/</guid>
      <description>&lt;p&gt;&amp;ldquo;Is Parallel Programming is Hard, And, If So, What Can You Do About It?&amp;quot;[1] 은
parallel programming 분야에서 대가라 불릴만한 분으로, 이쪽 분야에서 매우 중요한
동기화 메커니즘인 RCU[2] 를 개발했으며 리눅스 커널의 RCU 메인테이너로 활동하고
있는 Paul E. McKenney[3] 가 오픈소스 방식으로 저술하고 있는, parallel
programming 에 대한 책입니다.&lt;/p&gt;
&lt;p&gt;개인적으로 이 책의 한국어 번역을 오픈소스[4]로 진행하고 있습니다.  이
프로젝트는 원저작자인 Paul 에게 공식 한국어 번역으로 인증받았습니다[5].&lt;/p&gt;
&lt;p&gt;컨트리뷰션에 대해서도 열려 있으니, 이에 관심 있는 분은 repository 내의 README
문서의 Contribution 섹션[6] 을 참고 바랍니다.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html&#34;&gt;https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html&lt;/a&gt;&lt;br&gt;
[2] &lt;a href=&#34;https://en.wikipedia.org/wiki/Read-copy-update&#34;&gt;https://en.wikipedia.org/wiki/Read-copy-update&lt;/a&gt;&lt;br&gt;
[3] &lt;a href=&#34;http://www.rdrop.com/~paulmck/&#34;&gt;http://www.rdrop.com/~paulmck/&lt;/a&gt;&lt;br&gt;
[4] &lt;a href=&#34;https://github.com/sjp38/perfbook-ko_KR&#34;&gt;https://github.com/sjp38/perfbook-ko_KR&lt;/a&gt;&lt;br&gt;
[5] &lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git/commit/?id=edbfcdee046026d3f98592c411a20219b96c8e50&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git/commit/?id=edbfcdee046026d3f98592c411a20219b96c8e50&lt;/a&gt;&lt;br&gt;
[6] &lt;a href=&#34;https://github.com/sjp38/perfbook-ko_KR#contribution&#34;&gt;https://github.com/sjp38/perfbook-ko_KR#contribution&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
