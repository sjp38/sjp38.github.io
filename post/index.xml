<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hacklog</title>
    <link>https://sjp38.github.io/post/</link>
    <description>Recent content in Posts on Hacklog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Your Name</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0900</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LKML News v5.2-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.2-rc4/</link>
      <pubDate>Tue, 04 Jun 2019 10:49:00 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.2-rc4/</guid>
      <description>

&lt;h2 id=&#34;patch-00-15-slab-movable-objects-smo&#34;&gt;[PATCH 00/15] Slab Movable Objects (SMO)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190603042637.2018-1-tobin@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190603042637.2018-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;전에도 RFC 패치셋은 여기서도 소개했었죠.  Slab 할당자에 할당받은 객체들의
이동이 가능하게끔 하는 패치셋의 정식 패치 버전이 나왔습니다.  변경된
인터페이스는 XArray 와 dcache 에 적용되는군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v1-0-4-introduce-madv-cold-and-madv-pageout&#34;&gt;[PATCH v1 0/4] Introduce MADV_COLD and MADV_PAGEOUT&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190603053655.127730-1-minchan@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190603053655.127730-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;바로 지난주에도 소개한 external madvise 패치셋이 쪼개졌네요.  &lt;code&gt;MADV_COLD&lt;/code&gt; 와
&lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 두개의 새로운 advice 기능 추가 버전만 담은 패치셋입니다.  이게
더 일찍 머지될 가능성이 생겼군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Development History Visualization Youtube Channel</title>
      <link>https://sjp38.github.io/post/linux_develop_visualization_youtube/</link>
      <pubDate>Tue, 04 Jun 2019 10:44:33 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/linux_develop_visualization_youtube/</guid>
      <description>&lt;p&gt;재미 삼아 리눅스 커널 릴리즈 때마다 git history 를 visualize 해서 올리는 유투브
채널[1]을 개설해 봤습니다. 지금은 visualization 에는 gource[2] 를 사용하고
있습니다. 이 비디오를 만드는데 사용되는 스크립트도 GPL v3 로 공개[3]했으니
필요한 분은 사용해 보셔도 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;I created a Youtube channel[1]. I will upload videos for the git history
between each release of the Linux kernel, just for jun. I use gource[2] for the
visualization for now. The scripts I use for these videos are available[3]
under GPL v3. If you want, you may use the scripts for your own video
generation.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://www.youtube.com/channel/UCI7qoGt1hOfCsI8hFqriYCg&#34; target=&#34;_blank&#34;&gt;https://www.youtube.com/channel/UCI7qoGt1hOfCsI8hFqriYCg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;https://gource.io/&#34; target=&#34;_blank&#34;&gt;https://gource.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] &lt;a href=&#34;https://github.com/sjp38/linux_development_visualization&#34; target=&#34;_blank&#34;&gt;https://github.com/sjp38/linux_development_visualization&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DAPHICX: Data Access Pattern Hint Injecting Compiler Extension</title>
      <link>https://sjp38.github.io/post/daphicx/</link>
      <pubDate>Thu, 30 May 2019 18:59:53 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/daphicx/</guid>
      <description>&lt;p&gt;Memory pressure is inevitable as the size of working sets is rapidly growing
while the capacity of dynamic random access memory (DRAM) is not. Meanwhile,
storage devices have evolved so that their speed is comparable to the speed of
DRAM while their capacity scales are comparable to that of hard disk drives
(HDD). Thus, hierarchial memory systems configuring DRAM as the main memory and
high-end storages as swap devices will be common.&lt;/p&gt;

&lt;p&gt;Due to the unique characteristics of these modern storage devices, the swap
target decision should be optimal. It is essential to know the exact data
access patterns of workloads for such an optimal decision, although underlying
systems cannot accurately estimate such complex and dynamic patterns. For this
reason, memory systems allow programs to voluntarily hint their data access
pattern. Nevertheless, it is exhausting for a human to manually figure out the
patterns and embed optimal hints if the workloads are huge and complex.&lt;/p&gt;

&lt;p&gt;This project introduces a compiler extension that automatically optimizes a
program to voluntarily hint its dynamic data access patterns to the underlying
swap system using a static/dynamic analysis based profiling result. To our best
knowledge, this is the first profile-guided optimization (PGO) for modern swap
devices. Our empirical evaluation of the scheme using realistic workloads shows
consistent improvement in performance and swap device lifetime up to 2.65 times
and 2.98 times, respectively.&lt;/p&gt;

&lt;p&gt;DAPHICX has introduced by the &lt;a href=&#34;https://www.usenix.org/conference/fast19/wips&#34; target=&#34;_blank&#34;&gt;FAST&amp;rsquo;19 WiP&lt;/a&gt; and the &lt;a href=&#34;https://www.usenix.org/conference/hotstorage19/presentation/park&#34; target=&#34;_blank&#34;&gt;HotStorage&amp;rsquo;19&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc3</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.2-rc3/</link>
      <pubDate>Tue, 28 May 2019 23:28:37 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.2-rc3/</guid>
      <description>

&lt;h2 id=&#34;patch-tip-core-rcu-0-12&#34;&gt;[PATCH tip/core/rcu 0/12]&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190530145204.GA28526@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190530145204.GA28526@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Paul E. McKenney 로부터의 RCU flavor consolidation 관련 추가 작업과 코드 정리를
위한 패치셋입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-tip-core-rcu-0-2-documentation-updates-for-v5-3&#34;&gt;[PATCH tip/core/rcu 0/2] Documentation updates for v5.3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190530145504.GA29820@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190530145504.GA29820@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RCU 문서 업데이트를 담고 있는 패치셋입니다.  &lt;code&gt;rcuref&lt;/code&gt; 의 실제 예제와
&lt;code&gt;rcu_task_stall_timeout&lt;/code&gt; 의 정의에 대한 내용이 추가되었군요!&lt;/p&gt;

&lt;h2 id=&#34;patch-tip-core-rcu-0-21-torture-test-updates-for-v5-3&#34;&gt;[PATCH tip/core/rcu 0/21] Torture-test updates for v5.3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190530151650.GA422@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190530151650.GA422@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RCU 와 spinlock 등을 위해 사용되는 torture 테스트 업데이트를 담은 패치셋입니다.
무려 21개 패치네요!&lt;/p&gt;

&lt;h2 id=&#34;rfcv2-0-6-introduce-memory-hinting-api-for-external-process&#34;&gt;[RFCv2 0/6] introduce memory hinting API for external process&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190531064313.193437-1-minchan@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190531064313.193437-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다른 어플리케이션의 virtual memory 에 대해 madvise() 를 할 수 있게 하고
&lt;code&gt;MADV_COLD&lt;/code&gt; 등의 힌트를 추가한 패치셋의 두번째 RFC 버전입니다.  LWN 에서도
소개되었고 관련 반응이 매우 뜨겁네요.  저도 매우 흥미롭게 보고 있습니다.
두번째 버전에서는 &lt;code&gt;MADV_COOL&lt;/code&gt; 은 빠졌습니다.  &lt;code&gt;MADV_COLD&lt;/code&gt; 와 &lt;code&gt;MADV_PAGEOUT&lt;/code&gt; 만
남았군요.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-2-rc3&#34;&gt;Linux 5.2-rc3&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CAHk-=wg1evGTxx-aSNHO+m5xSa1sc6fQe7Y8fH=_ruGcwMyfyA@mail.gmail.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;상당히 고요한 한 주였고, 그로 인해 rc3 는 rc2 와 사이즈가 비슷했습니다.  이는
조금 이상한 일인데, 보통 rc2 이후로는 사람들이 드디어 문제를 파악하기 시작하고
rc3 주간에 수정을 하느라 조금은 떠들썩해 왔기 때문이랍니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Biscuit (OS Written in Go) Install</title>
      <link>https://sjp38.github.io/post/biscuit_os_install/</link>
      <pubDate>Sun, 26 May 2019 23:27:44 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/biscuit_os_install/</guid>
      <description>&lt;pre&gt;&lt;code&gt;$ git clone https://go.googlesource.com/go go1.4; cd go1.4
$ git checkout release-branch.go1.4; cd src
$ ./make.bash
$ cd ../../
$ git clone https://github.com/mit-pdos/biscuit.git; cd biscuit/src
$ ./make.bash
$ cd ../biscuit/
$ make qemu CPUS=2
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc2</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.2-rc2/</link>
      <pubDate>Tue, 21 May 2019 01:27:47 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.2-rc2/</guid>
      <description>

&lt;h2 id=&#34;rfc-patch-v5-00-16-slab-movable-objects-smo&#34;&gt;[RFC PATCH v5 00/16] Slab Movable Objects (SMO)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190520054017.32299-1-tobin@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190520054017.32299-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 블로그에서도 소개한 Slab movable objects 패치셋의 다섯번째 버전입니다.  RFC
로는 아마도 마지막 버전이 될거라는군요.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-00-14-mmap-sem-range-locking&#34;&gt;[RFC PATCH 00/14] mmap_sem range locking&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190521045242.24378-1-dave@stgolabs.net&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190521045242.24378-1-dave@stgolabs.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번 LSFMM 에서 개인적으로 가장 기대했던 세션이 &lt;code&gt;mmap_sem&lt;/code&gt; 해결에 대한
세션이었습니다.  해당 세션에서는 예전부터 이야기가 나온 range locking 에
대해서도 이야기가 있었는데요, 이 패치셋은 이 range locking 을 사용한 &lt;code&gt;mmap_sem&lt;/code&gt;
문제 해결 시도를 다시 정리해 RFC 의 형태로 올린 것입니다.&lt;/p&gt;

&lt;p&gt;RFC 라는 데서 알 수 있겠지만 이 패치 자체에도 문제가 많지만, 코드 자체보다는 이
range locking 이라는 아이디어가 갖는 한계와 그에 대한 대책 등을 논의해 보고자
올린 것이라고 합니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-0-7-introduce-memory-hinting-api-for-external-process&#34;&gt;[RFC 0/7] introduce memory hinting API for external process&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190520035254.57579-1-minchan@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190520035254.57579-1-minchan@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앞서 여기서도 다룬 구글의 proactive swap 의 안드로이드 버전과 비슷한 일을 위한
패치셋입니다.  안쓰는 데이터 잔뜩 쥐고서는 스왑도 안당하고 있는 앱이 문제죠.
이런 데이터를 &lt;code&gt;madvise()&lt;/code&gt; 에 &lt;code&gt;MADVISE_COLD&lt;/code&gt; 와 &lt;code&gt;MADVISE_COOL&lt;/code&gt; 이라는 추가
힌트를 줘서 어플리케이션 레벨에서 이런 스왑하는게 좋을 데이터를 알려주는
형태입니다.  기존의 &lt;code&gt;MADVISE_WONTNEED&lt;/code&gt; 는 스왑을 하는게 아니라 걍 데이터를
버려버리기 때문에 이런 두개의 힌트를 추가한거죠.&lt;/p&gt;

&lt;p&gt;인공적 벤치마크가 아니라 수백명의 진짜 사용자를 통해 성능 실험을 했다고
하는데요, 구글에서 고용한 테스트 집단일까요?&lt;/p&gt;

&lt;h2 id=&#34;patch-v4-00-14-provide-generic-top-down-mmap-layout-functions&#34;&gt;[PATCH v4 00/14] Provide generic top-down mmap layout functions&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190526134746.9315-1-alex@ghiti.fr&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190526134746.9315-1-alex@ghiti.fr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;각 아키텍쳐별로 존재하는 중복 코드를 제거하기 위해 만들어진 범용 top-down mmap
을 위한 패치의 네번째 버전입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-3-remove-tmem-and-code-depending-on-it&#34;&gt;[PATCH 0/3] remove tmem and code depending on it&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190527103207.13287-1-jgross@suse.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190527103207.13287-1-jgross@suse.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Xen 의 tmem 기능이 제거되었군요.  관련 코드를 리눅스 커널에서도 제거하는
패치셋입니다.  덕분에 cleancache 가 아예 사라질 모양입니다.  Cleancache 에
의존하는 GCMA 를 만들고 있는 제 입장에선 쇼킹한 일입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-2-rc2&#34;&gt;Linux 5.2-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgob1t2g9iQZCuZ8My39CY26xGb6nqjVhCtb1nTirsR2Q@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgob1t2g9iQZCuZ8My39CY26xGb6nqjVhCtb1nTirsR2Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;일정대로 두번째 rc2 가 릴리즈 되었습니다.  이번엔 그야말로 특기할 만한 점이
없다는군요.  그나마 큰 변화는 SPDX 관련 변경들 뿐이었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.2-rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.2-rc1/</link>
      <pubDate>Wed, 08 May 2019 10:22:05 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.2-rc1/</guid>
      <description>

&lt;h2 id=&#34;patch-mm-introduce-page-size&#34;&gt;[PATCH] mm: Introduce page_size()&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190510181242.24580-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190510181242.24580-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Huge page 등의 경우를 위해 페이지의 실제 크기를 구하려면 &lt;code&gt;PAGE_SIZE &amp;lt;&amp;lt;
compound_order(page)&lt;/code&gt; 를 해야 하는게 짜증난 Matthew Wilcox 가 별도의 함수를
만들고 기존 코드들을 이 함수를 사용하도록 변경한 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v2-00-15-remove-order-argument-from-many-mm-functions&#34;&gt;[PATCH v2 00/15] Remove &amp;lsquo;order&amp;rsquo; argument from many mm functions&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190510135038.17129-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190510135038.17129-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;mm 쪽 함수들은 order 를 인자로 많이 받죠.  어차피 gfp_t 는 무조건 받으니까 이
타입의 상위 bit 을 order 목적으로 사용하자는 패치입니다.  이 패치의 장점은?
커널 텍스트 사이즈를 줄인다는 것입니다 :)&lt;/p&gt;

&lt;h2 id=&#34;maintainer-s-kernel-summit-2019-planning-kick-off&#34;&gt;Maintainer&amp;rsquo;s / Kernel Summit 2019 planning kick-off&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190513230643.GA4347@mit.edu&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190513230643.GA4347@mit.edu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;올해의 커널 서밋 / 메인테이너 서밋을 위한 안내 메일입니다.  작년엔 커널 서밋은
LPC 와, 메인테이너 서밋은 OSSEU 와 함께 열렸었죠.  올해는 둘 다 LPC 와 함께
합니다.&lt;/p&gt;

&lt;p&gt;메인테이너 서밋은 올해는 아예 30명으로 더욱 작게 모이는군요.&lt;/p&gt;

&lt;p&gt;커널 서밋 발표 주제는 5월 31일까지 받습니다.  발표주제 선정되면 LPC 티켓도
준다는군요!&lt;/p&gt;

&lt;h2 id=&#34;linux-5-2-rc1&#34;&gt;Linux 5.2-rc1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgxi6fnxZ+p5Zdqr-i4s=xhOCBJL6s_RauYkjxM2CpXeA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgxi6fnxZ+p5Zdqr-i4s=xhOCBJL6s_RauYkjxM2CpXeA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.2 릴리즈를 위한 머지윈도우가 끝나고 rc1 버전이 릴리즈 되었습니다.  이번 머지
윈도우 중간에 토발즈의 개인적 여행이 있다고 했지만 다행히 잘 정리되었나보군요.
별다른 건은 없었다고 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.1/</link>
      <pubDate>Tue, 30 Apr 2019 14:16:49 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.1/</guid>
      <description>

&lt;h2 id=&#34;rfc-patch-v4-00-15-slab-movable-objects-smo&#34;&gt;[RFC PATCH v4 00/15] Slab Movable Objects (SMO)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190430030746.26102-1-tobin@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190430030746.26102-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앞서 이 블로그에서도 공유한 SMO 패치의 새 버전입니다.  이번 버전은 dcache 쪽
코드를 많이 수정했군요.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-1&#34;&gt;Linux 5.1&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whsbDxdapMJGvy9OkVSrKMsKRJBTrH-Qj-qTbkMUGnWUw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whsbDxdapMJGvy9OkVSrKMsKRJBTrH-Qj-qTbkMUGnWUw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.1 릴리즈입니다.  일요일 오후 릴리즈란 점은 평소와 같지만 평소보다 조금 늦은
시간이긴 했는데요, 오늘 갑자기 받은 풀 리퀘스트도 있었고, 이번 머지윈도우
기간에 졸업식에 참석해야 해서 조금 망설였다는군요.&lt;/p&gt;

&lt;p&gt;하지만 풀리퀘스트도 그렇게 크진 않고, 몇일 머지윈도우에 자리 비우는 정도는
어떻게든 할 수 있을거라 생각해서 5.1 릴리즈가 이뤄졌습니다!&lt;/p&gt;

&lt;p&gt;이제 5.2 머지윈도우의 시작이군요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fedora28 ibus-hangul input problem</title>
      <link>https://sjp38.github.io/post/fedora28_hangul_problem/</link>
      <pubDate>Fri, 26 Apr 2019 11:05:59 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/fedora28_hangul_problem/</guid>
      <description>&lt;p&gt;어느날부터 Fedora 터미널에서 한글 입력이 매우 불편해졌습니다.  한글 모드에서는
backspace, enter, esc 등의 특수키가 하나도 안먹힙니다.  Vim 을 쓰는 입장에선
매우 불편하죠.  알고보니 ibus-hangul 버그인 것 같습니다[1].  아래 커맨드로
ibus-hangul 을 문제 없던 버전으로 다운그레이드 시키고 세션을 재시작 하면 문제가
사라집니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dnf downgrade ibus-hangul-1.5.0-12.fc28.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://www.fedoralinux.or.kr/board-read.do?boardId=bbs3&amp;amp;boardNo=153170459823549&amp;amp;command=READ&amp;amp;page=1&amp;amp;categoryId=-1&#34; target=&#34;_blank&#34;&gt;http://www.fedoralinux.or.kr/board-read.do?boardId=bbs3&amp;amp;boardNo=153170459823549&amp;amp;command=READ&amp;amp;page=1&amp;amp;categoryId=-1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.1-rc7/</link>
      <pubDate>Fri, 26 Apr 2019 11:02:24 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.1-rc7/</guid>
      <description>

&lt;h2 id=&#34;re-lsf-mm-preliminary-agenda-anyone-anyone-bueller&#34;&gt;Re: [LSF/MM] Preliminary agenda ? Anyone &amp;hellip; anyone ? Bueller ?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/83fda245-849a-70cc-dde0-5c451938ee97@kernel.dk&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/83fda245-849a-70cc-dde0-5c451938ee97@kernel.dk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;올해의 LSFMM 스케쥴이 구글 문서로 공유되고 있었군요:
&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1Z1pDL-XeUT1ZwMWrBL8T8q3vtSqZpLPgF3Bzu_jejfk/edit#gid=0&#34; target=&#34;_blank&#34;&gt;https://docs.google.com/spreadsheets/d/1Z1pDL-XeUT1ZwMWrBL8T8q3vtSqZpLPgF3Bzu_jejfk/edit#gid=0&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-proactive-memory-reclaim&#34;&gt;[LSF/MM TOPIC] Proactive Memory Reclaim&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CALvZod4V+56pZbPkFDYO3+60Xr0_ZjiSgrfJKs_=Bd4AjdvFzA@mail.gmail.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이제 LSFMM 이 얼마 안남았습니다만, 또하나의 주제 제안이 올라왔습니다.&lt;/p&gt;

&lt;p&gt;메모리 오버커밋으로 인해 direct reclaim 이 발생하고, 이는 latency sensitive
어플리케이션의 latency 를 크게 저하시키니, 시스템이 좀 더 적극적으로 memory
reclaim 을 해서 direct reclaim 을 최소화 시켜보자는 건데요.  잘 접근되지 않는
cold memory 를 추적해서 미리미리 reclaim 시키자는 겁니다.  챌린지는 물론 cold
memory 를 어떻게 잘 추적하냐는 거지요.  이와 함께 커널의 &lt;code&gt;idle_page_tracking&lt;/code&gt;
의 비효율성도 이야기 했습니다.&lt;/p&gt;

&lt;p&gt;이 주제로 올해 ASPLOS 에 논문도 냈군요: &lt;a href=&#34;https://youtu.be/aKddds6jn1s&#34; target=&#34;_blank&#34;&gt;https://youtu.be/aKddds6jn1s&lt;/a&gt;
개인적으로 최근 연구하고 있는 주제와도 관계 있을 수 있어서 흥미롭습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-docs-vm-add-documentation-of-memory-models&#34;&gt;[PATCH] docs/vm: add documentation of memory models&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1556101715-31966-1-git-send-email-rppt@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1556101715-31966-1-git-send-email-rppt@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;FLAT, DISCONTIG, SPARSE 등의 다양한 메모리 모델에 대한 문서화 추가 패치입니다.
처음 코드 들여다 볼 때 조금 헷갈리던 부분인데 잘 설명되었군요.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-lightning-round&#34;&gt;[LSF/MM TOPIC] Lightning round?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190425211906.GH4739@mit.edu&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190425211906.GH4739@mit.edu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번 LSFMM 에는 라이트닝 토크 세션이 있는데요, 거기서 block layer 에 암호화
레이어를 추가하는 방안에 대해 이야기 해보자는 Ted 의 의견입니다.  안드로이드
쪽에서 이걸 열심히 해보고 있나보군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-4-tools-vm-slabinfo-add-fragmentation-output&#34;&gt;[PATCH 0/4] tools/vm/slabinfo: Add fragmentation output&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190426022622.4089-1-tobin@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190426022622.4089-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SLAB vs SLUB 토론 중 현재 slab allocator 의 fragmentation 정도를 알려주는
도구가 있으면 좋겠다는 이야기가 있었는데, 이를 위한 기능을 추가한 패치입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-1-rc7&#34;&gt;Linux 5.1-rc7&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=whvWQbP20g77U4QRXQDS5w+kf=V-P2QjMkgA-OwJJjHtg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=whvWQbP20g77U4QRXQDS5w+kf=V-P2QjMkgA-OwJJjHtg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;지난번 rc6 가 거대했던 건 역시 풀 리퀘스트 타이밍 때문이었는지, 이번 rc7 은
다행히도 크기가 작은 편이라고 합니다.  네트워킹 쪽 변경이 좀 있고, 나머진
평소같이 아키텍쳐, 파일 시스템, 그외 드라이버 등의 변경이 내용을 차지했네요.
따라서 다음주엔 5.1이 예정대로 나올 것 같다고 합니다!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the Hotstorage&#39;19</title>
      <link>https://sjp38.github.io/post/hotstorage2019_talk/</link>
      <pubDate>Thu, 18 Apr 2019 09:37:04 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/hotstorage2019_talk/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.usenix.org/conference//hotstorage19&#34; target=&#34;_blank&#34;&gt;HotStorage&amp;rsquo;19&lt;/a&gt; 에 제출한 제
최근 연구에 대한 논문이 accept 되어 7월에 해당 워크샵에서 이에 대한 내용을
발표하게 되었습니다.  논문 제목은 &amp;ldquo;Automating Context Based Access Pattern Hint
Injection for System Performance and Swap Storage Durability&amp;rdquo; 입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.1-rc6/</link>
      <pubDate>Tue, 16 Apr 2019 23:02:17 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.1-rc6/</guid>
      <description>

&lt;h2 id=&#34;patch-v12-00-31-speculative-page-faults&#34;&gt;[PATCH v12 00/31] Speculative page faults&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernl.org/r/20190416134522.17540-1-ldufour@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernl.org/r/20190416134522.17540-1-ldufour@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오랫만에 업데이트 된 SPF 패치셋으로, 이번 패치셋은 v5.1 위로 리베이스
되었습니다.  RCU 에서 Fine-grained reader-writer locking 으로 옮겼던 vma 보호를
다시 RCU 로 되돌린 게 눈에 띄는군요.  기존엔 패치셋만 공개했는데, 이젠 패치셋이
적용된 코드 트리를 github 으로도 제공합니다:
&lt;a href=&#34;https://github.com/ldu4/linux/tree/spf-v12&#34; target=&#34;_blank&#34;&gt;https://github.com/ldu4/linux/tree/spf-v12&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;patch-v3-00-11-provide-generic-top-down-mmap-layout-functions&#34;&gt;[PATCH v3 00/11] Provide generic top-down mmap layout functions&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190417052247.17809-1-alex@ghiti.fr&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190417052247.17809-1-alex@ghiti.fr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아키텍쳐별로 별도 구현을 하지 않고도 전체 mmap 레이아웃을 접근할 수 있게 해주는
범용 함수들을 구현하는 패치셋입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-v5-1-rc6&#34;&gt;Linux v5.1-rc6&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wii=Ym24FWf7J2s1CEwCXU3hjVXeHSkV3A8X5iAj6eT8Q@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wii=Ym24FWf7J2s1CEwCXU3hjVXeHSkV3A8X5iAj6eT8Q@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;부활절이었군요.  어쨌건 토발즈는 그런 사소한 휴일에 릴리즈 일정을 바꾸진
않았습니다.&lt;/p&gt;

&lt;p&gt;이번 rc6 는 평소보다 조금 커다란 릴리즈였고, 때문에 토발즈도 다시 한번 꼼꼼히
살펴봤지만 그렇게까지 이상한 일은 아니라는군요.  4.18 때와 5.0 때도
이정도였답니다.&lt;/p&gt;

&lt;p&gt;네트워킹 쪽 변경이 좀 컸고, 드라이버, arch, selftests 와 perf 쪽에 변경이
있었으며, core mm, filesystem, scheduler, tracing 쪽에도 변경이 조금씩 있었다고
하는군요.&lt;/p&gt;

&lt;p&gt;어쨌건 그다지 이상한 건 없다고 합니다.  적어도 아직까진 5.1 을 향한 여정엔
문제가 없어 보이네요!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hooking Library Function Calls</title>
      <link>https://sjp38.github.io/post/hooking_library_calls/</link>
      <pubDate>Wed, 10 Apr 2019 11:39:06 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/hooking_library_calls/</guid>
      <description>

&lt;p&gt;&lt;code&gt;LD_PRELOAD&lt;/code&gt; 환경변수를 사용하면 로더가 프로그램을 로드할 때 동적 로드해야 할
바이너리 코드를 해당 변수의 값의 디렉토리에서부터 뒤지도록 합니다.
따라서 이를 이용해 &lt;code&gt;malloc()&lt;/code&gt;, &lt;code&gt;free()&lt;/code&gt; 등의 일반적으로 사용하는 라이브러리
함수를 우리의 구현으로 대체하거나 후킹할 수 있습니다.
이 글은 이런 방법으로 &lt;code&gt;malloc()&lt;/code&gt; 을 후킹하는 방법을 예제를 통해 간단히
설명합니다.&lt;/p&gt;

&lt;h2 id=&#34;original-program&#34;&gt;Original Program&lt;/h2&gt;

&lt;p&gt;먼저 다음과 같은 프로그램이 있을 수 있을 겁니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main(void)
{
	char *abc;

	abc = (char *)malloc(8);
	printf(&amp;quot;malloced address: %p\n&amp;quot;, abc);
	sprintf(abc, &amp;quot;hello\n&amp;quot;);
	printf(&amp;quot;%s\n&amp;quot;, abc);
	free(abc);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;단순히 &lt;code&gt;malloc()&lt;/code&gt; 을 통해 8바이트 메모리를 할당받아 그 영역을 표시하고 종료하는
프로그램입니다.  위 코드를 &lt;code&gt;program.c&lt;/code&gt; 라는 파일로 저장하고, 아래와 같이
컴파일하고 수행해 보면 우리가 익히 아는, 예상대로의 결과가 나옵니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -o program program.c
$ ./program
malloced address: 0x1cc5010
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;malloc-hooking-code&#34;&gt;malloc Hooking Code&lt;/h2&gt;

&lt;p&gt;이제 &lt;code&gt;malloc()&lt;/code&gt; 함수를 후킹하는 코드를 만들어 봅시다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define _GNU_SOURCE

#include &amp;lt;dlfcn.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

typedef void *(*malloc_t)(size_t size);

void *malloc(size_t size)
{
	malloc_t malloc_fn;

	fprintf(stderr, &amp;quot;malloc(%zu) hooked\n&amp;quot;, size);
	malloc_fn = (malloc_t)dlsym(RTLD_NEXT, &amp;quot;malloc&amp;quot;);
	return malloc_fn(size);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 코드는 우리가 아는 &lt;code&gt;malloc()&lt;/code&gt; 함수와 동일한 함수명, signature 의 함수를
구현하고 있습니다.
단순히 우리가 후킹했음을 알리고, 동적 라이브러리 구조를 통해 이 다음으로
검색되는 &lt;code&gt;malloc&lt;/code&gt; 이름의 라이브러리 함수 (이게 우리가 익히 아는 그 &lt;code&gt;malloc()&lt;/code&gt;
구현이겠죠) 를 찾아, 같은 인자로 수행하고 그 결과를 리턴합니다.
즉, 우리가 아는 &lt;code&gt;malloc()&lt;/code&gt; 과 같은 일을 하긴 하지만 &lt;code&gt;malloc()&lt;/code&gt; 이 호출되었음을
알리는 것이죠.&lt;/p&gt;

&lt;p&gt;이 코드를 &lt;code&gt;mallochook.c&lt;/code&gt; 라는 이름으로 저장 후, 다음과 같이 라이브러리로
빌드합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -shared -fPIC mallochook.c -o mallochook.so -ldl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-the-hook&#34;&gt;Install The Hook&lt;/h2&gt;

&lt;p&gt;프로그램이 기존 &lt;code&gt;malloc()&lt;/code&gt; 대신 우리가 구현한 &lt;code&gt;malloc()&lt;/code&gt; 을 수행하게 하는 건
&lt;code&gt;LD_PRELOAD&lt;/code&gt; 를 활용하면 간단합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ LD_PRELOAD=./mallochook.so ./program
malloc(8) hooked
malloc(1024) hooked
malloced address: 0x20a5010
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두번째, 세번째 줄을 보면 &lt;code&gt;malloc()&lt;/code&gt; 이 후킹되어 우리의 메세지가 나오는 걸 볼 수
있습니다.  앞의 &lt;code&gt;program.c&lt;/code&gt; 에서는 8 바이트 &lt;code&gt;malloc()&lt;/code&gt; 호출만 있었는데 세번째
줄의 1024 바이트 malloc()&lt;code&gt;은 어디서 나온 걸까요?  아마도 뒤의&lt;/code&gt;sprintf()` 등의
라이브러리 함수가 호출한 거 아닐까 싶은데 그걸 분석하는 건 여러분의 몫으로
두겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;자세한 원리는 생략했습니다만, 간단히 주요 라이브러리 함수를 후킹하는 방법을
알아봤습니다.
여기서 사용된 예제 코드와 명령어는 제 &lt;a href=&#34;https://github.com/sjp38/mallochook&#34; target=&#34;_blank&#34;&gt;Github repo&lt;/a&gt; 에 올려뒀으니 필요하면 참고 바랍니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Backtrace on C language program</title>
      <link>https://sjp38.github.io/post/backtrace_c_language/</link>
      <pubDate>Tue, 09 Apr 2019 17:33:50 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/backtrace_c_language/</guid>
      <description>

&lt;p&gt;디버깅 과정에선 현재 어떤 코드가 어떤 함수를 거쳐 수행됐는지를 통한 컨텍스트
파악이 중요합니다.  Java, Python, Go 등 대부분의 언어가 이를 위해 콜스택을 뽑을
수 있는 기능을 제공하죠.  C 언어의 경우 gdb 등을 사용하면 쉽게 이를 볼 수
있지만 경우에 따라선 gdb 를 포기하고 &lt;code&gt;printf()&lt;/code&gt; 등에만 의존해야 하기도 합니다.
이를 위한 기능이 c 라이브러리에도 있습니다, &lt;code&gt;backtrace()&lt;/code&gt; 함수입니다.
&lt;a href=&#34;http://man7.org/linux/man-pages/man3/backtrace.3.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;man&lt;/code&gt;&lt;/a&gt; 에도 이에 대한
설명이 있습니다만, 여기서도 간단히 소개해 봅니다.&lt;/p&gt;

&lt;h2 id=&#34;example-source-code&#34;&gt;Example Source Code&lt;/h2&gt;

&lt;p&gt;예제로 설명하는게 가장 쉽죠.  간단한 사용법은 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;execinfo.h&amp;gt;

void baz(void)
{
	void *callstack[128];
	int i, frames;
	char **strs;

	frames = backtrace(callstack, 128);
	strs = backtrace_symbols(callstack, frames);
	for (i = 0; i &amp;lt; frames; i++)
		printf(&amp;quot;%s\n&amp;quot;, strs[i]);
	free(strs);
}

void bar(void)
{
	baz();
}

void foo(void)
{
	bar();
}

int main(void)
{
	foo();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;compile&#34;&gt;Compile&lt;/h2&gt;

&lt;p&gt;아래와 같이 컴파일 합니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -rdynamic -g -o hello ./hello.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-rdynamic&lt;/code&gt; 과 &lt;code&gt;-g&lt;/code&gt; 옵션을 잊지 맙시다.&lt;/p&gt;

&lt;p&gt;이제 프로그램을 실행해 보면:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./hello

./hello(baz+0x2e) [0x400964]
./hello(bar+0x9) [0x4009fd]
./hello(foo+0x9) [0x400a09]
./hello(main+0x9) [0x400a15]
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0) [0x7f87c51e6830]
./hello(_start+0x29) [0x400869]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;main()&lt;/code&gt;, &lt;code&gt;foo()&lt;/code&gt;, &lt;code&gt;bar()&lt;/code&gt;, 를 거쳐 &lt;code&gt;baz()&lt;/code&gt; 가 수행되었음을 보입니다.  더
나아가서 어떤 소스파일의 몇번 라인인지를 보고 싶다면 &lt;code&gt;addr2line&lt;/code&gt; 커맨드를
사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ addr2line -e hello 0x400964
./hello.c:10
$ addr2line -e hello 0x4009fd
./hello.c:20
$ addr2line -e hello 0x400a09
./hello.c:25
$ addr2line -e hello 0x400a15
./hello.c:30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;쉽죠? ;)&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;C 프로그램에서 backtrace 를 떠보는 방법을 알아보았습니다.
위의 내용을 여러분의 환경에서도 쉽게 테스트 해 볼 수 있게끔 제 &lt;a href=&#34;https://github.com/sjp38/backtrace_example&#34; target=&#34;_blank&#34;&gt;Github repo&lt;/a&gt; 에도 정리해 두었습니다.
클론하고, &lt;code&gt;$ make run&lt;/code&gt; 해주시면 예제가 자동으로 빌드되고 돌아갈 겁니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News v5.1-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v5.1-rc5/</link>
      <pubDate>Tue, 09 Apr 2019 17:33:01 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v5.1-rc5/</guid>
      <description>

&lt;h2 id=&#34;v2-rfc-patch-0-9-another-approach-to-use-pmem-as-numa-node&#34;&gt;[v2 RFC PATCH 0/9] Another Approach to Use PMEM as NUMA Node&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1554955019-29472-1-git-send-email-yang.shi@linux.alibaba.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1554955019-29472-1-git-send-email-yang.shi@linux.alibaba.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;본 블로그를 통해 지속적으로 소개하고 있는, PMEM as NUMA node 를 위한, 보다 나은
hotness 기반 page location 을 위한 패치셋입니다.
기존 코멘트에 기반해서 두번째 버전을 내놓았군요.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-v3-00-15-slab-movable-objects-smo&#34;&gt;[RFC PATCH v3 00/15] Slab Movable Objects (SMO)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20190411013441.5415-1-tobin@kernel.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20190411013441.5415-1-tobin@kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;최근 LWN 에서도 소개된 (&lt;a href=&#34;https://lwn.net/Articles/784964/&#34; target=&#34;_blank&#34;&gt;https://lwn.net/Articles/784964/&lt;/a&gt;) 패치입니다.
Slab allocator 에서 할당된 object 가 free page 가운데에 박혀 있어 page 를
회수할 수 없는 fragmentation 이 발생합니다.
이 패치셋은 slab allocator 로 할당된 object 의 사용자에게 가능하면 해당 object
들을 움직여 달라고 callback 할 수 있게 함으로써 이 fragmentation 을 해결하려
합니다.&lt;/p&gt;

&lt;p&gt;앞의 버전에 비해서 변경된 건 LWN 기사에 달린 코멘트를 기반으로 한 개선들이군요.&lt;/p&gt;

&lt;h2 id=&#34;lsf-mm-topic-guarantee-natural-alignment-for-kmalloc&#34;&gt;[LSF/MM TOPIC] guarantee natural alignment for kmalloc()?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/790b68b7-3689-0ff6-08ae-936728bc6458@suse.cz&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/790b68b7-3689-0ff6-08ae-936728bc6458@suse.cz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LSFMM 을 위한 늦은 주제네요.
kmalloc() 이 2의 승수 크기 얼라인먼트를 지키도록 하는 패치에 대해서 논의하고
싶어합니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-5-1-rc5&#34;&gt;Linux 5.1-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjvcuyCQGnfOhooaL1H4H63qXO=xgo+9yncSOG=eK+kbA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjvcuyCQGnfOhooaL1H4H63qXO=xgo+9yncSOG=eK+kbA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다섯번째 rc 커널입니다.  v5.1이 얼마 남지 않았군요.
이번 릴리즈에선 대부분 드라이버 쪽 변경이 있었으며, 딱히 이상하거나 수상한
움직임은 없다고 합니다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
