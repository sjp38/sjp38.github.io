<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hacklog</title>
    <link>https://sjp38.github.io/post/</link>
    <description>Recent content in Posts on Hacklog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Your Name</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0900</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LKML News by 4.20-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20-rc5/</link>
      <pubDate>Thu, 29 Nov 2018 08:14:01 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20-rc5/</guid>
      <description>

&lt;h2 id=&#34;patch-v12-00-20-block-support-multi-page-bvec&#34;&gt;[PATCH V12 00/20] block: support multi-page bvec&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181126021720.19471-1-ming.lei@redhat.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181126021720.19471-1-ming.lei@redhat.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;struct bio_bvec&lt;/code&gt; 하나가 물리적으로 연속적인 여러개의 페이지를 담을 수 있게
해서 block layer 의 효율성을 높이기 위한 시도입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-aio-convert-ioctx-table-to-xarray&#34;&gt;[PATCH] aio: Convert ioctx_table to XArray&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181128183531.5139-1-willy@infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181128183531.5139-1-willy@infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;aio 쪽의 &lt;code&gt;ioctx_table&lt;/code&gt; 이라는 자료구조가 스펙터에 취약한 자료구조인데, 인덱스
오버플로 문제가 없는 XArray 로 교체하는 패치입니다.  정말 코드가
깔끔해지는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20-rc4/</link>
      <pubDate>Mon, 26 Nov 2018 08:06:40 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20-rc4/</guid>
      <description>

&lt;h2 id=&#34;patch-v7-00-21-swap-swapout-swapin-thp-in-one-piece&#34;&gt;[PATCH -V7 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181120085449.5542-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181120085449.5542-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Transparent Huge Page 를 쪼개지 않고 swap out / swap in 함으로써 스왑 성능을
최적화 하는 패치의 일곱번째 버전입니다.  이 블로그에서도 소개한 바 있죠.  크게
바뀐 부분은 없지만 최신 버전에 맞춰 리베이스 되었고, Daniel 에 의해 발견된 주소
정렬 관련 문제를 해결했군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-5-fragmentation-avoidance-improvements-v5&#34;&gt;[PATCH 0/5] Fragmentation avoidance improvements v5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181123114528.28802-1-mgorman@techsingularity.net&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181123114528.28802-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;시스템이 충분히 오래 운영되거나 특정한 패턴의 워크로드가 동작하게 되면 시스템의
메모리는 fragment 되게 마련이어서, 장기적으로 물리적 연속 페이지 할당이
실패하게 됩니다.  이 패치셋은 메모리 분절화를 야기하는 워크로드 (이벤트)를
정의하고 그런 이벤트의 발생을 줄이는 내용을 담고 있습니다.&lt;/p&gt;

&lt;p&gt;최적화 방법은 다음과 같습니다.  먼저, lower id free list 가 사용 가능하면 high
order free list 를 쪼개기보다 그걸 먼저 사용합니다.  메모리 분절화 이벤트가
발생하면 임시적으로 워터마크를 높입니다.  kswapd 가 일어나서 적은양의 오래된
메모리를 리클레임하고, 이어서 kcompactd 가 일어나서 시스템 메모리 연속성을
복구시킵니다.  물론 이는 오버헤드를 추가합니다.  마지막으로, kswapd 가 진전을
일으킬 수 있도록 일부 movable 페이지 할당을 기다리게 합니다.  이 기다리는 시간
역시 오버헤드와 연관되므로 적절히 맞춰질 필요가 있겠죠.&lt;/p&gt;

&lt;p&gt;이 패치셋을 적용한 결과 94% 이상 메모리 분절화를 줄일 수 있었다고 합니다.&lt;/p&gt;

&lt;h2 id=&#34;git-pull-xarray-updates&#34;&gt;[GIT PULL] XArray updates&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181124173209.GZ3065@bombadil.infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181124173209.GZ3065@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;XArray 는 작년 OSSummit 에서 처음 발표를 들은 후 주의 깊게 보고 있었는데 이번에
머지되었고 커널 서밋에서도 발표를 들었는데 매우 인상적이었습니다.  DAX 가
XArray 를 사용하도록 수정한 후 DAX 의 버그가 발견되었고, 그에 대한 수정을
포함한 수정사항들을 담은 풀 리퀘스트입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-4-20-rc4&#34;&gt;Linux 4.20-rc4&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wgdsXyCaLsFEpyUpAeRqVS69u=xo4rzEN+cS=xwz2gajg@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wgdsXyCaLsFEpyUpAeRqVS69u=xo4rzEN+cS=xwz2gajg@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.x 의 마지막이 될 예정인 4.20을 향한 네번째 rc 버전 릴리즈입니다.  변경의 60
퍼센트가 드라이버고, 나머진 네트워킹, 파일시스템쪽 수정과 arch, 문서화
업데이트고 xarray 쪽 수정도 있었군요.  평소와 다를바 없어서 평이한 릴리즈라 할
수 있지만, STIBP 수정이라던지 mm 쪽 수정에 대한 논의가 안끝났다던지 하는 부분은
남아있다는군요.&lt;/p&gt;

&lt;p&gt;한가지 지난 릴리즈 때 이야기 할 것을 빼먹은 것도 이야기 하는데, 풀 리퀘스트에
대한 응답 메일을 Konstantin 이 자동화 했기 때문에 더이상 토발즈 자신이 하나하나
답장을 보내지 않는다는 겁니다.  그리고 이 자동화의 구성상 LKML 의 &lt;code&gt;linux-*&lt;/code&gt;
그룹을 cc 하지 않으면 ack 을 주지 않는데, 그걸로 인해 혼동이 있을 수 있었겠다고
하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc3</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20-rc3/</link>
      <pubDate>Mon, 19 Nov 2018 16:53:04 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20-rc3/</guid>
      <description>

&lt;h2 id=&#34;linux-4-20-rc3&#34;&gt;Linux 4.20-rc3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wiZmPvR64hDy-pcVJqcxoAwMRd4GrRhRjK04Mhng4nL4g@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wiZmPvR64hDy-pcVJqcxoAwMRd4GrRhRjK04Mhng4nL4g@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리누스 토발즈의 개인적 여행이 있었다는 점을 제외하고는 이상할 것 없는
한주였습니다만, 이번 릴리즈의 변경 사항은 rc3 치고는 상당히 적었다고 하는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc2</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20-rc2/</link>
      <pubDate>Mon, 12 Nov 2018 08:30:21 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20-rc2/</guid>
      <description>

&lt;h2 id=&#34;patch-0-5-fragmentation-avoidance-improvements-v2&#34;&gt;[PATCH 0/5] Fragmentation avoidance improvements v2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181107183822.15567-1-mgorman@techsingularity.net&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181107183822.15567-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;장시간 운영되는 시스템은 결국 메모리가 단편화 (fragmentation) 되게 되어
있습니다.  페이징을 사용하면 단일 페이지 단위 할당은 문제가 없지만, 물리적으로
연속적인 페이지를 할당받기가 어려워지죠.  Mel Gorman 의 이 패치는 이런 메모리
분절화를 좀 더 잘 막을 수 있는 방법을 포함하고 있습니다.&lt;/p&gt;

&lt;p&gt;첫번째 패치는 단일 페이지 또는 적은 물리적 연속 페이지들의 할당 시에 불필요하게
higher order free page zone 을 사용하지 않게 하고, 두번째와 세번째 패치는
kswapd 와 kcompactd 를 사용한 defragmentation 을 좀 더 적극적으로 하게 합니다.
네번째 패치는 movable allocation request 시에 kswapd 를 또 깨우고, kswapd 가
일을 마칠 때까지 멈춰서 기다려 줍니다.
마지막으로 다섯번째 패치는 분절화가 발생해야만 하는 경우, kcompactd 가 처리할
블록들로 해당 분절된 영역을 마크해 둡니다.&lt;/p&gt;

&lt;p&gt;물론 분절화를 막는 대신 오버헤드를 가져올 수 있겠고, Mel 은 이 기능들을 tuning
하거나 꺼버릴 수 있게 했군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-4-fragmentation-avoidance-improvements-v3&#34;&gt;[PATCH 0/4] Fragmentation avoidance improvements v3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181108091218.32715-1-mgorman@techsingularity.net&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181108091218.32715-1-mgorman@techsingularity.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mel 의 분절화 방지 패치셋은 오버헤드를 가질 수밖에 없었죠.  결국 얼마 되지 않아
세번째 버전의 패치셋[1]을 내놓았는데, 여기선 다섯번째 패치를 걍 없애버렸고,
네번째 패치도 그 오버헤드가 덜하게끔 만들었습니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-mm-thp-implement-thp-reservations-for-anonymous-memory&#34;&gt;[RFC PATCH] mm: thp: implement THP reservations for anonymous memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/1541746138-6706-1-git-send-email-anthony.yznaga@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/1541746138-6706-1-git-send-email-anthony.yznaga@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Transparent huge page (THP) 가 켜져 있는 경우, promotion 이 꽤나 급하게
이루어지기 때문에 huge page 를 할당받고는 정작 그 영역을 모두 접근하지 않는
경우엔 메모리 소모가 큽니다.  기존에 이 문제를 해결하기 위한 패치가 있었는데,
그에 대해 Mel Gorman 의 피드백이 있었고, 이 패치는 그 피드백을 받아들여 새로
작성된 패치셋입니다.&lt;/p&gt;

&lt;p&gt;Page fault 가 날 경우 huge page 를 할당할 수 있는 양의 페이지를 할당받되 페이지
한개만 map 해두고 나머지는 reserve 를 해두고, 이후 주변 영역에 fault 가 날
때마다 나머지 페이지들을 계속 map 해주다가 충분히 많은 영역이 fault 났을 경우에
huge page 로 promote 를 해주고, 그 전에 memory pressure 가 발생하면 reserve
해둔 페이지들을 reclaim 하는 형태입니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-tip-core-rcu-0-20-documentation-updates-for-v4-21-v5-0&#34;&gt;[PATCH tip/core/rcu 0/20] Documentation updates for v4.21/v5.0&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181111195619.GA6958@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181111195619.GA6958@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RCU 문서 업데이트 패치셋입니다.  생각해 보면 리눅스 커널만큼 문서화 잘 된
프로젝트도 드물죠.&lt;/p&gt;

&lt;h2 id=&#34;patch-tip-core-rcu-0-8-automate-initrd-generation-for-v4-21-v5-0&#34;&gt;[PATCH tip/core/rcu 0/8] Automate initrd generation for v4.21/v5.0&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181111200127.GA9511@linux.ibm.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181111200127.GA9511@linux.ibm.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RCU 테스트 프레임웍인 rcutorture 는 가상머신 환경을 사용하는데, 이를 위한
initrd 생성을 자동화 하는 패치셋입니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-v4-20-rc2&#34;&gt;Linux v4.20-rc2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/R7SW0SuwOMMMyRgTFGA@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/R7SW0SuwOMMMyRgTFGA@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;토발즈가 여행 중이란 걸 제외하고는 별 특이사항 없는 두번째 rc 버전
릴리즈입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I will have a talk at the kernel summit</title>
      <link>https://sjp38.github.io/post/ksummit2018_talk/</link>
      <pubDate>Thu, 08 Nov 2018 06:11:48 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/ksummit2018_talk/</guid>
      <description>&lt;p&gt;지난 토요일, Theodore Ts&amp;rsquo;o 로부터 올해 Linux Plumbers Conference 의 한 트랙으로
열리는 커널 서밋에서 GCMA 발표를 해줄 수 있겠냐는 제의를 받았고 물론
그러겠노라고 했습니다.  발표 일정의 [첫번째 드래프트][1]가 올라왔군요.  화요일
아침에 발표하게 됐습니다.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2018-November/006238.html&#34; target=&#34;_blank&#34;&gt;https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2018-November/006238.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKMM Setup and Usage</title>
      <link>https://sjp38.github.io/post/lkmm-install/</link>
      <pubDate>Thu, 08 Nov 2018 04:30:42 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkmm-install/</guid>
      <description>

&lt;p&gt;리눅스 커널은 Formalised and executable memory consistent model 을 제공합니다.
줄여서 linux kernel memory model (LKMM) 이라고 하죠.  이 글은 4.19 버전을
기준으로 LKMM 을 실제로 수행해 보기 위한 환경 셋업 과정과 간단한 실행 방법을
정리해 봅니다.  글 작성을 위한 테스트는 Ubuntu 16.04 서버가 설치된 가상머신에서
진행되었습니다.&lt;/p&gt;

&lt;h1 id=&#34;herd7-install&#34;&gt;herd7 install&lt;/h1&gt;

&lt;p&gt;LKMM 은 버전 7.49 의 &amp;ldquo;herd7&amp;rdquo; 과 &amp;ldquo;klitmus7&amp;rdquo; 을 필요로 합니다.  하지만 herd7 은
또 Ocaml 을 위한 패키지 매니저인 OPAM 을 설치할 것을 필요로 하죠.  우분투에선
패키지 시스템이 OPAM 을 지원하므로 아래와 같이 쉽게 설치할 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt install opam
$ opam init
$ sudo opam update
$ sudo opam upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두번째 커맨드 수행 중 다음과 같은 질문이 나오는데, 디폴트 선택을 주기 위해 그냥
엔터를 칩니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Do you want OPAM to modify ~/.profile and ~/.ocamlinit?
(default is &#39;no&#39;, use &#39;f&#39; to name a file other than ~/.profile)
    [N/y/f]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또한 &lt;code&gt;update&lt;/code&gt; 와 &lt;code&gt;upgrade&lt;/code&gt; 명령 시에 root 권한으로 이 커맨드를 수행하는 걸
권장하지 않는다고 하지만 정작 &lt;code&gt;sudo&lt;/code&gt; 없이 하면 권한 없어서 실패합니다.&lt;/p&gt;

&lt;p&gt;이제 다음 명령을 통해 herdtools 의 빌드와 설치를 진행합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/herd/herdtools7 &amp;amp;&amp;amp; cd herdtools7
$ git checkout 7.49
$ make all
$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빌드에 약 3분 10여초가 소요됐습니다.  설치가 잘 되었는지 아래와 같이 확인해
봅니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ herd7 -version
7.49, Rev: 93dcbdd89086d5f3e981b280d437309fdeb8b427
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;lkmm-download&#34;&gt;LKMM Download&lt;/h1&gt;

&lt;p&gt;LKMM 은 리눅스 소스 트리의 &lt;code&gt;tools/memory-model/&lt;/code&gt; 디렉토리에 있습니다.
&lt;code&gt;https://kernel.org&lt;/code&gt; 에서 다운받거나 해서 사용하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls ~/linux/tools/memory-model/
Documentation      linux-kernel.cat  linux-kernel.def  lock.cat  scripts
linux-kernel.bell  linux-kernel.cfg  litmus-tests      README
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;herd7-based-litmus-tests-execution&#34;&gt;Herd7 Based Litmus Tests Execution&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ herd7 -conf linux-kernel.cfg litmus-tests/SB+fencembonceonces.litmus
Test SB+fencembonceonces Allowed
States 3
0:r0=0; 1:r0=1;
0:r0=1; 1:r0=0;
0:r0=1; 1:r0=1;
No
Witnesses
Positive: 0 Negative: 3
Condition exists (0:r0=0 /\ 1:r0=0)
Observation SB+fencembonceonces Never 0 3
Time SB+fencembonceonces 0.01
Hash=d66d99523e2cac6b06e66f4c995ebb48
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;klistmus7-based-litmus-tests-execution&#34;&gt;Klistmus7 Based Litmus Tests Execution&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir klitmus_test
$ klitmus7 -o klitmus_test/ litmus-tests/SB+fencembonceonces.litmus
$ cd klitmus_test/
$ ls
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ make
$ sudo sh run.sh
$ sudo sh ./run.sh
[sudo] password for sjpark:
Thu Nov  8 04:55:44 KST 2018
Compilation command: klitmus7 -o klitmus_test/ litmus-tests/SB+fencembonceonces.litmus
OPT=
uname -r=4.19.0

Test SB+fencembonceonces Allowed
Histogram (3 states)
16580117:&amp;gt;0:r0=1; 1:r0=0;
16402936:&amp;gt;0:r0=0; 1:r0=1;
3016947 :&amp;gt;0:r0=1; 1:r0=1;
No

Witnesses
Positive: 0, Negative: 36000000
Condition exists (0:r0=0 /\ 1:r0=0) is NOT validated
Hash=d66d99523e2cac6b06e66f4c995ebb48
Observation SB+fencembonceonces Never 0 36000000
Time SB+fencembonceonces 1.40

Thu Nov  8 04:55:45 KST 2018
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LKML News by v4.20-rc1</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.20-rc1/</link>
      <pubDate>Wed, 07 Nov 2018 14:43:56 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.20-rc1/</guid>
      <description>

&lt;p&gt;리눅스 4.19 버전 릴리즈 후부터 4.20-rc1 버전의 릴리즈까지 LKML 에 오간 메일 중
흥미로운 메일들을 소개합니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-v4-00-13-ktask-multithread-cpu-intensive-kernel-work&#34;&gt;[RFC PATCH v4 00/13] ktask: multithread CPU-intensive kernel work&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181105165558.11698-1-daniel.m.jordan@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181105165558.11698-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CPU intensive 한 커널의 일을 여러 work queue 를 이용해 병렬화 시키기 위한
새로운 프레임웍, ktask 구현 및 적용 패치입니다.  이 프레임웍을 이용해 병렬화
시킬 일은 여러가지가 있을텐데, 이 패치는 ktask 프레임웍의 구현과 함께 VFIO
페이지 pinning, 부팅 시점에서의 &lt;code&gt;struct page&lt;/code&gt; 초기화, &lt;code&gt;gigantic page&lt;/code&gt; 의
초기화, 그리고 &lt;code&gt;HugeTLB&lt;/code&gt; 페이지의 할당에 ktask 를 적용하고 있습니다.&lt;/p&gt;

&lt;p&gt;예전에도 올라온 패치인데 이번에 Linux Plumbers Conference 에서 발표할
예정이기에 기존 피드백을 반영한 버전을 올렸군요.&lt;/p&gt;

&lt;h2 id=&#34;patch-0-9-allow-persistent-memory-to-be-used-like-normal-ram&#34;&gt;[PATCH 0/9] Allow persistent memory to be used like normal RAM&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181022201317.8558C1D8@viggo.jf.intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181022201317.8558C1D8@viggo.jf.intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;기존의 메인 메모리로 쓰이는 DRAM 과 달리 파워가 꺼져도 내용이 날아가지 않는
메모리를 Non-volatile memory 또는 persistent memory 라 하죠.  최근 들어서는
정말 상용으로도 나오고 있는데, 현재로썬 이 pmem 을 쓰려면 어플리케이션을 고쳐야
합니다.&lt;/p&gt;

&lt;p&gt;이 패치는 그러지 않고도 일반 RAM 처럼 pmem 을 사용할 수 있도록 하는 pmem 용
드라이버를 구현했습니다.&lt;/p&gt;

&lt;h2 id=&#34;git-pull-xarray-for-4-20&#34;&gt;[GIT PULL] XArray for 4.20&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181023200825.GA25444@bombadil.infradead.org&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181023200825.GA25444@bombadil.infradead.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 블로그에서도 여러번 소개한, XArray 의 4.20 버전을 향한 pull request 입니다.
4.19 때도 시도했지만 들어가지 못했죠.&lt;/p&gt;

&lt;p&gt;이번엔 일단 토발즈에 의해 pull 되었습니다.  그리고 토발즈도 XArray 의
인터페이스 덕에 코드가 한결 간결하고 깔끔해졌음을 이야기 하네요.  특히, dax 쪽
수정사항과 conflict 이 있었는데 이는 dax 쪽의 버그 수정에 의한 것으로, XArray
인터페이스를 쓰면 애초에 그 버그가 발생도 안한다고 합니다.&lt;/p&gt;

&lt;h2 id=&#34;linux-4-20-rc1&#34;&gt;Linux 4.20-rc1&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;https://lkml.kernel.org/r/CAHk-=whDiwASMgw8Q7TNA2MJhf3s=ouK4+_3ioqmobs-yagnkQ@mail.gmail.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;오랫만에 토발즈가 하는 릴리즈입니다.  3.19 다음 4.0 버전이 릴리즈 되었으니 이번
버전은 5.0 이 될 것인지, 4.20 이 될 것인지 흥미진진한 릴리즈였는데요.
결론적으로 4.20 이 되었습니다.  이제 버전을 셀 손가락도 발가락도 남지
않았으므로 다음 버전은 5.0 이 될 거라고 하는군요.&lt;/p&gt;

&lt;p&gt;꽤 많은 변경 사항이 있던 머지 윈도우였지만 그렇다고 기록적인 수준은 아닙니다.&lt;/p&gt;

&lt;p&gt;한편 2주일로 예정되는 머지 윈도우에서 첫번째 주에는 일반적인 풀리퀘스트를 받고,
좀 시간을 두고 들여다봐야 하겠다 싶은 패치들은 두번째 주까지 미뤄뒀다 천천히
보면서 머지하는게 토발즈의 작업 습관이고 다른 메인테이너들도 이 습관을 알고
암묵적으로 지켜왔던 모양인데, 이번엔 두번째 주 수요일에 새로운 풀 리퀘스트가
들어와 토발즈가 조금 불편했던 모양입니다.&lt;/p&gt;

&lt;p&gt;이걸 명시적인 규칙으로 만들어야 할지도 모르겠다 싶기 시작했는데, 빈번하게 있는
일도 아니므로 아직은 그래야 할 필요성이 있을지도 모르겠다 하는 수준의
이야기군요.&lt;/p&gt;

&lt;p&gt;그리고 이번 머지 윈도우에서는 Greg 이 그랬던 것처럼 토발즈도 풀리퀘스트에 ack
메일을 보냈었죠.  이런 작업 방식에 대해서 고민을 하는 이야기도 있었구요.
하지만 아무래도 몇개는 빼먹은 것 같다고 하는군요.  이런 경우 결론은 자동화.
다음 머지 윈도우까지는 이 ack 메일을 자동화 되길 바란다고 하네요.  물론,
토발즈의 바람대로 자동화가 잘 마무리 되지 않으면 운좋게도 토발즈로부터의 ack
메일을 받을 수 있겠습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.19/</link>
      <pubDate>Mon, 22 Oct 2018 17:45:08 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.19/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19&#34;&gt;Linux 4.19&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181022073224.GA5658@kroah.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181022073224.GA5658@kroah.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;드디어 9 주간의 안정화를 거쳐 4.19 버전이 릴리즈 되었습니다.  역시 토발즈가
쉬고 있는 관계로 Greg KroahHartman 이 릴리즈 했습니다.  지난 네번의 릴리즈
가운데 가장 큰 릴리즈군요.  그리고 이 버전은 &amp;ldquo;Long Tern&amp;rdquo; 커널 중 하나가 될
예정입니다.&lt;/p&gt;

&lt;p&gt;이번 릴리즈 메일은 토발즈가 잠시 쉬겠다고 했던 메일을 연상케 할정도로 내용이
긴데요, 꽤 많은 부분은 이번 버전 개발 과정에서 이야기 되었던, 새로운 커뮤니티
참여자들과의 관계와 태도에 대한 내용입니다.  Greg 이 매년 발표하고 있는 커널
커뮤니티의 작업 방식 이야기를 예로 들며 설명하네요.  관련해서는 다음주 영국에서
열리는 Maintainers Summit 에서도 좀 더 이야기 할 생각인가 봅니다.&lt;/p&gt;

&lt;p&gt;그리고, 릴리즈 메일의 말미에서 이렇게 이야기 하며 릴리즈 메일을 끝맺는군요:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;And with that, Linus, I&#39;m handing the kernel tree back to you.  You can
have the joy of dealing with the merge window :)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;토발즈가 돌아오려나요?  아니면 새로운 대리인이?&lt;/p&gt;

&lt;h2 id=&#34;git-pull-ack-emails&#34;&gt;Git pull ack emails..&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CAHk-=wjS6cjjP+fkZWzzrdZ_fZ1F=PrAGcBc57vKCpNyoD73Vw@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CAHk-=wjS6cjjP+fkZWzzrdZ_fZ1F=PrAGcBc57vKCpNyoD73Vw@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앞서 4.19 릴리즈와 함께 Greg 이 토발즈의 대리인을 그만두기로 했다고 했지만,
그에 대한 토발즈의 공식적 답변은 없었습니다.  때문에 토발즈가 돌아오는건지,
또는 Greg 이 아닌 또다른 사람이 릴리즈 관리를 할지 애매했는데, 토발즈가
돌아왔습니다.&lt;/p&gt;

&lt;p&gt;이 메일을 이렇게 시작하는군요:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;So I&amp;rsquo;ve obviously started pulling stuff for the merge window,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마침 Maintainers Summit 이 있었으니, 거의 Summit 직후 돌아왔다고 볼 수 있을 것
같네요.&lt;/p&gt;

&lt;p&gt;이 메일에선 이와 함께 Greg 이 pull request 마다 꼬박꼬박 응답을 보내줬던 걸
지속할지 말지에 대한 이야기를 하고 있습니다.  토발즈는 풀 리퀘스트를 받으면
일단 빌드 테스트를 진행하고, 그동안 다른 풀 리퀘스트를 보고 그 빌드 테스트도
병렬로 진행하는 파이프라인 형태의 작업 형태를 가지고 있는데, Greg 처럼 하나하나
순차적으로 응답하려면 좀 애매하기 때문입니다.  일단은 응답 보내보고, 그게 정말
중요한지 판단해 보겠다는군요.&lt;/p&gt;

&lt;p&gt;아무튼, 잘 돌아왔어요, 리누스!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc8</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.19-rc8/</link>
      <pubDate>Mon, 15 Oct 2018 15:59:17 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.19-rc8/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19-rc8&#34;&gt;Linux 4.19-rc8&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181015064915.GA10710@kroah.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181015064915.GA10710@kroah.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여덟번째 rc 버전입니다.  여전히 그렉이 릴리즈 하는군요.  여덟번째 rc 인만큼, 큰
변화는 없었고, 대부분 앞서 고친 것들에 대한 수정이었군요.  아마도 다음주에는
예상대로 4.19 버전이 나올 것 같다고 합니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-v4-patch-0-5-eliminate-zone-lock-contention-for-will-it-scale-page-fault1-and-parallel-free&#34;&gt;[RFC v4 PATCH 0/5] Eliminate zone-&amp;gt;lock contention for will-it-scale/page_fault1 and parallel free&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181017063330.15384-1-aaron.lu@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181017063330.15384-1-aaron.lu@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4 KB 크기 페이지를 위한 &lt;code&gt;will-it-scale/page_fault1&lt;/code&gt; 워크로드를 2 소켓 112 코어
인텔 스카이레이크 서버에서 돌려보면 80% 의 CPU 시간이 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 을
기다리는데 소모된다고 합니다.  이는 &lt;code&gt;struct page&lt;/code&gt; 의 캐시 미스 때문이라는군요.
이 패치셋은 이런 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 오버헤드를 없애기 위한 RFC 입니다.&lt;/p&gt;

&lt;p&gt;일단 버디 얼로케이터에서 4 KB 크기 페이지의 머지를 건너뛰게 했는데,
이것만으로도 상기한 워크로드에서 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 소모시간이 35% 에서 1.1% 로
줄었다는군요.&lt;/p&gt;

&lt;p&gt;다음으로 페이지 할당 과정에서 &lt;code&gt;free_list&lt;/code&gt; 의 페이지들을 하나씩 만지지 않고
cluster 단위로 만지게 해서 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 오버헤드를 거의 없앴습니다.  하지만 이
cluster 단위 관리로 인한 오버헤드가 페이지 해제 과정에서의 &lt;code&gt;zone-&amp;gt;lock&lt;/code&gt; 경쟁을
0% 에서 25% 까지 증가시켰습니다.
하지만 이어지는 최적화로 이 증가된 오버헤드도 없앴군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc7</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.19-rc7/</link>
      <pubDate>Mon, 08 Oct 2018 07:54:09 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.19-rc7/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19-rc7&#34;&gt;Linux 4.19-rc7&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181007154529.GA4493@kroah.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181007154529.GA4493@kroah.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;토발즈 없이 진행되는 4.19를 위한 일곱번째 rc 릴리즈입니다.  이번에도 그렉이
대신 하는군요.  이번 릴리즈는 후반부임에도 rc6 보다 조금 더 커졌습니다.  하지만
그렇게까지 큰 차이는 아니라고 하는군요.&lt;/p&gt;

&lt;p&gt;일반적이라면 다음 릴리즈가 4.19 정식 릴리즈일텐데, 10월에 컨퍼런스가 많이
있다보니 rc 릴리즈를 한번 더 할 생각이라는군요.  간만에 rc8 을 보겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v6-00-21-swap-swapout-swapin-thp-in-one-piece&#34;&gt;[PATCH -V6 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20181010071924.18767-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20181010071924.18767-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;THP 를 한방에 swap out / swap in 하는 Huang Ying 의 패치, 여섯번째 버전입니다.
기존 버전 대비 달라진 점은 크지 않군요.  좀 더 최신 mmotm/master 위로 rebase 한
정도입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc6</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.19-rc6/</link>
      <pubDate>Mon, 01 Oct 2018 12:20:27 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.19-rc6/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19-rc6&#34;&gt;Linux 4.19-rc6&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180930150308.GA5010@kroah.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180930150308.GA5010@kroah.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번주도 Greg 에 의해 여섯번째 rc 버전이 릴리즈 되었습니다.  평소 일정대로면
2주일 후 4.19 정식 버전이 릴리즈 될텐데, 아마도 그때까지도 Greg 이 릴리즈 하지
않을까 싶기도 하군요.
전체적으로 특이사항은 없고 Greg 의 시스템에서는 잘 동작하고 있으며 별다른
이슈를 보고받지도 못했다는군요.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc5</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.19-rc5/</link>
      <pubDate>Mon, 24 Sep 2018 10:10:40 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.19-rc5/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19-rc5&#34;&gt;Linux 4.19-rc5&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180923175547.GA4462@kroah.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180923175547.GA4462@kroah.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;지난주 토발즈가 휴식을 선언한 이유로 한동안 릴리즈는 Greg 이 맡게 되었죠.  이번
릴리즈는 그래서 Greg 이 합니다.&lt;/p&gt;

&lt;p&gt;사회적으로야 이런저런 일이 많았지만 (토발즈의 휴가, Code of Conduct 머지에
관련해 갑론을박이 많군요.) 기술적으로는 별 일 없었던 한주라 평가되는군요.&lt;/p&gt;

&lt;p&gt;사소하지만 재밌는 건 Greg 의 자기 서명.
&lt;code&gt;greg &amp;quot;keeping the seat warm for a few weeks&amp;quot; k-h&lt;/code&gt; 라고 하는군요.
토발즈가 휴가 가있는 동안 의자를 뎁혀 두는 역할이라는 겸손함이 눈에 띄네요.&lt;/p&gt;

&lt;h2 id=&#34;patch-v5-resend-00-21-swap-swapout-swapin-thp-in-one-piece&#34;&gt;[PATCH -V5 RESEND 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180925071348.31458-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180925071348.31458-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;THP 의 Swap in/out 을 regular page 로 쪼개지 않고 한방에 하는 패치의 최신
버전입니다&amp;hellip; 만, 기존 대비 버전업이 되진 않았고 리뷰를 요청하기 위해 다시 한번
보냈군요.  그런데 아직 별다른 리뷰가 없네요&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc4</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.19-rc4/</link>
      <pubDate>Mon, 17 Sep 2018 08:03:05 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.19-rc4/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19-rc4-released-an-apology-and-a-maintainership-note&#34;&gt;Linux 4.19-rc4 released, an apology, and a maintainership note&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFy+Hv9O5citAawS+mVZO+ywCKd9NQ2wxUmGsz9ZJzqgJQ@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFy+Hv9O5citAawS+mVZO+ywCKd9NQ2wxUmGsz9ZJzqgJQ@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;한국시간 새벽 네시 좀 넘어 이 메일을 받았습니다.  평범한 릴리즈 메일이겠거니
했는데 제목이 뭔가 심상치 않군요.&lt;/p&gt;

&lt;p&gt;일단 4.19를 위한 네번째 release candidate 릴리즈가 되었습니다.  약 3주 후 정식 4.19 버전이 릴리즈 되겠군요.  하지만 이 메일은 그보다 많은 내용을 담고 있습니다.&lt;/p&gt;

&lt;p&gt;자유분방하고 형식에 구애되지 않는 해커 문화에 기원을 두고 있는 리눅스
커뮤니티는 조금 거친 언어 문화로 유명했습니다.  예를 들어 이상한 코드를 보내면
리누스 토발즈와 커뮤니티의 일부 사람들이 이 코드를 꾸짖을 수 있는데 그 과정에서
욕설도 있을 수 있다는 거죠.  어느새 5년이 넘게 흐른 사건이지만 토발즈는
공식석상에서 Nvidia 에 가운데 손가락을 펴서 보여주기도 했죠.  이로 인해 마음에
상처를 받았다는 사람도 꽤 되고, 7년간 리눅스에 패치를 올렸던 Sarah Sharp 라는
인텔의 프로그래머는 이를 이유로 들어 결국 리눅스 커뮤니티에서 빠지기로 해서[1]
한때 많은 논란이 있기도 했습니다.  당시 토발즈는 욕설을 멈출 생각이 없다고
강경하게 맞서기도 했죠[2].&lt;/p&gt;

&lt;p&gt;그랬던 토발즈가 생각이 바뀌었다고 합니다.  올해 커널 메인테이너 서밋은 Linux
Plumbers Conference 와 함께 열릴 예정이었는데 토발즈가 그걸 깜박하고 가족
휴가를 잡는 바람에 토론이 있었고, 이 토론 과정에서 토발즈는 자신의 행위가 커널
개발에 정말로 악영향을 끼치고 있다고 느낀 것 같습니다.  이로 인해 토발즈는 이
메일을 통해 자신의 행위가 잘못되었음을 인정하고 그로 인해 상처 받은 사람들에게
공식적으로 사과를 하고 있습니다.  또한 앞으로 그런 행위를 반복하지 않기 위해
커널 개발에서 잠시 손을 떼고 거울 속의 자신을 바라보며 더 낫게 행동할 수 있도록
하는 시간을 갖겠다고 하는군요.&lt;/p&gt;

&lt;p&gt;리누스 토발즈가 커널 개발에서 손을 떼는건 과거 git 개발을 위해 손을 뗐던
사건[3] 후 처음입니다.  이 사이의 릴리즈 작업은 Greg Kroah-Hartman 에게
부탁했다고 하니 곧바로 전체 개발 작업이 멈추진 않겠습니다.&lt;/p&gt;

&lt;p&gt;이 휴식 시간이 아주 길지는 않을 거고, 토발즈 자신은 너무 지쳐 더이상 리눅스
커널 개발에 손을 데고 싶지 않다는 의도가 아니라고 합니다.  이건 얼마전 너무
지쳤다며 자비로운 종신 독재자 직을 그만둔 귀도 반 로썸의 예[4]와 비교되기도
하는군요, 토발즈도 이를 조금 의식한 거 아닐까 싶습니다.  토발즈는 자신은 여전히
리눅스 커널 개발을 하고 싶고, 잘하고 싶기 때문에 이 선택을 한 것 뿐이며, 어쩌면
단순히 욕설을 감지해 욕설이 포함된 메일은 자동으로 보내지 않는 메일
클라이언트를 개발하고 복귀하는 간단한 일이 될수도 있을 거라고 합니다.&lt;/p&gt;

&lt;p&gt;개인적인 감상은, 글쎄요.  조금 반갑기도 하고 조금 아쉽기도 합니다.  커널
커뮤니티가 거칠고 모욕적인건 사실이지만 어느정도의 긴장감은 필요하다고
생각하기도 했고, 어떤 면에선 더욱 자유분방한 그 분위기를 저는 좋아했던 것도
같아서일 겁니다.  특히 AOSP 와 같이 악플은 커녕 무플이 심한 프로젝트에 참여했던
경험이 있는 저로썬 무플보단 악플이 낫다는 주의를 가졌던 것도 한 이유겠죠.
분명한 건 이 선언은 리눅스 커뮤니티의 외연 확장을 크게 도울 것 같습니다.  그게
마냥 좋기만 한 일일지, 윤리에 대한 자기검열이 커뮤니티의 토론 열기를 식히지는
않을지 걱정되기도 하지만요.  그리고, 이 선언의 최종 결과가 어떨지를 떠나,
그정도 위치에 있고 과거에 뱉어놓은 말들이 많은 리누스 토발즈가 이렇게 깔끔하게
사과를 하는 것도 대단한 멘탈이라 생각됩니다.&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://sarah.thesharps.us/2013/07/15/no-more-verbal-abuse/&#34; target=&#34;_blank&#34;&gt;http://sarah.thesharps.us/2013/07/15/no-more-verbal-abuse/&lt;/a&gt;&lt;br /&gt;
[2] &lt;a href=&#34;https://arstechnica.com/information-technology/2013/07/linus-torvalds-defends-his-right-to-shame-linux-kernel-developers/&#34; target=&#34;_blank&#34;&gt;https://arstechnica.com/information-technology/2013/07/linus-torvalds-defends-his-right-to-shame-linux-kernel-developers/&lt;/a&gt;&lt;br /&gt;
[3] &lt;a href=&#34;https://sjp38.github.io/post/git_origin_story_ko/&#34; target=&#34;_blank&#34;&gt;https://sjp38.github.io/post/git_origin_story_ko/&lt;/a&gt;&lt;br /&gt;
[4] &lt;a href=&#34;https://www.i-programmer.info/news/216-python/11967-guido-van-rossum-quits-as-python-bdfl.html&#34; target=&#34;_blank&#34;&gt;https://www.i-programmer.info/news/216-python/11967-guido-van-rossum-quits-as-python-bdfl.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LKML News after v4.19-rc3</title>
      <link>https://sjp38.github.io/post/lkml_news_v4.19-rc3/</link>
      <pubDate>Tue, 11 Sep 2018 06:01:49 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/lkml_news_v4.19-rc3/</guid>
      <description>

&lt;h2 id=&#34;linux-4-19-rc3&#34;&gt;Linux 4.19-rc3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/CA+55aFwSxCt0aKkTxcBstthYXqJ5LtxRbO-CDyqgNwU94Ldq+w@mail.gmail.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/CA+55aFwSxCt0aKkTxcBstthYXqJ5LtxRbO-CDyqgNwU94Ldq+w@mail.gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;세번째 rc 릴리즈입니다.  어느새 이번 안정화 기간도 중반을 향하는군요.  시간 참
빠릅니다.  전체적으로 평범한 릴리즈입니다.  딱히 언급할 거리가 없군요.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-v2-0-8-lru-lock-scalability-and-smp-list-functions&#34;&gt;[RFC PATCH v2 0/8] lru_lock scalability and SMP list functions&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180911004240.4758-1-daniel.m.jordan@oracle.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180911004240.4758-1-daniel.m.jordan@oracle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;올해 LSF/MM 서밋에서도 이야기되었던, &lt;code&gt;lru_lock&lt;/code&gt; 의 확장성을 개선하기 위한
노력의 정리입니다.  LRU 리스트에 여러 쓰레드가 실제 데이터를 겹쳐 쓰지 않는다면
동시에 접근할 수 있는 새로운 오퍼레이션 세개 (&lt;code&gt;smp_list_del()&lt;/code&gt;,
&lt;code&gt;smp_list_splice()&lt;/code&gt;, &lt;code&gt;smp_list_add()&lt;/code&gt;)을 추가했구요.  두번째로, &lt;code&gt;lru_lock&lt;/code&gt; 을
&lt;code&gt;spinlock&lt;/code&gt; 에서 &lt;code&gt;rwlock&lt;/code&gt; 으로 교체했군요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;will-it-scale/page_fault1&lt;/code&gt; 이라는 마이크로 벤치마크를 사용해서 성능을
비교했는데, 44 코어 시스템에서 최대 73.8% 더 초당 페이지 폴트 처리량을 늘릴 수
있었다고 합니다.&lt;/p&gt;

&lt;h2 id=&#34;rfc-patch-0-9-improve-zone-lock-scalability-using-daniel-jordan-s-list-work&#34;&gt;[RFC PATCH 0/9] Improve zone lock scalability using Daniel Jordan&amp;rsquo;s list work&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180911053616.6894-1-aaron.lu@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180911053616.6894-1-aaron.lu@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;바로 앞에서 설명한, 여러 쓰레드가 동시에 리스트에 접근할 수 있도록 새로
만들어진 메커니즘은 &lt;code&gt;zone lock&lt;/code&gt; 에도 도움이 될 수 있다고 LSF/MM 에서 여럿이
생각했다고 합니다.  이 패치셋은 실제로 이 기능들을 이용해 &lt;code&gt;zone lock&lt;/code&gt; 의
확장성을 개선했습니다.&lt;/p&gt;

&lt;h2 id=&#34;patch-v5-resend-00-21-swap-swapout-swapin-thp-in-one-piece&#34;&gt;[PATCH -V5 RESEND 00/21] swap: Swapout/swapin THP in one piece&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.kernel.org/r/20180912004414.22583-1-ying.huang@intel.com&#34; target=&#34;_blank&#34;&gt;https://lkml.kernel.org/r/20180912004414.22583-1-ying.huang@intel.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;THP 를 덩어리째 스왑아웃 / 스왑인 하기 위한 패치, 다섯번째 버전입니다.
생각보다 쉽게 머지되지 못하고 있군요.  리뷰가 많지 않은 것도 한 이유 아닐까
싶습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Kernel Build</title>
      <link>https://sjp38.github.io/post/linux-kernel-build/</link>
      <pubDate>Fri, 07 Sep 2018 16:00:23 +0900</pubDate>
      
      <guid>https://sjp38.github.io/post/linux-kernel-build/</guid>
      <description>

&lt;p&gt;제가 새 기계에서 리눅스 커널 빌드 환경을 셋업하고 실제 빌드, 설치하는 과정을
정리해 봅니다.  글 작성 과정에서 실제 커맨드를 수행한 환경은 Ubuntu 16.04.3
Server OS 를 설치한 &lt;code&gt;x86_64&lt;/code&gt; 가상머신입니다.&lt;/p&gt;

&lt;h1 id=&#34;install-dependent-packages&#34;&gt;Install Dependent Packages&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt install build-essential libncurses5-dev libssl-dev bc bison flex \
		libelf-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커널을 빌드하려면 컴파일러와 라이브러리 등이 필요하겠죠.  위 커맨드는
우분투에서 커널 빌드에 필요한 패키지들을 깔아줍니다.  커널 트리의
&lt;code&gt;Documentation/process/changes.rst&lt;/code&gt; 에도 커널 빌드에 필요한 패키지들이 나열되어
있으므로, 다른 환경이라면 이를 참고해 필요한 패키지를 설치합시다.&lt;/p&gt;

&lt;p&gt;페도라라면 아래와 같이 패키지를 깔면 됩니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo dnf install ncurses-devel bison-devel bison flex-devel flex \
		elfutils-libelf-devel openssl-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;fetch-linux-kernel-source-code&#34;&gt;Fetch Linux Kernel Source Code&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빌드를 하려면 소스코드를 가져와야죠.  위 커맨드를 통해 토발즈의 리눅스
소스코드를 가져올 수 있습니다.  네트워크를 통해 가져오는데, 소스코드는 물론이고
개발 이력 정보를 모두 담고 있으므로 많은 데이터를 가져와야해 시간이 상당히
걸립니다.  이 글을 쓰는 2018년 9월 초 기준, 버전정보만 약 1.2 GiB 군요.&lt;/p&gt;

&lt;p&gt;토발즈는 github 에 &lt;a href=&#34;https://github.com/torvalds/linux&#34; target=&#34;_blank&#34;&gt;미러&lt;/a&gt; 를 두고 있으므로,
여길 이용하는 것도 생각해 볼 수 있고, 굳이 버전 정보는 필요하지 않다면
&lt;a href=&#34;https://kernel.org&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;kernel.org&lt;/code&gt;&lt;/a&gt; 에서 tarball 로 소스코드만 받는것도 한
방법입니다.&lt;/p&gt;

&lt;p&gt;저는 아예 &lt;code&gt;.git&lt;/code&gt; 디렉토리를 압축해서 별도 저장소에
보관하기도 합니다.&lt;/p&gt;

&lt;h1 id=&#34;make-configuration-file&#34;&gt;Make Configuration File&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ cd linux
$ cp /boot/config-$(uname -r) ./.config
$ make menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;리눅스 빌드 설정 파일을 만들어야 합니다.  앞의 커맨드를 통해 배포판에서 제공한
커널을 빌드하는데 사용된 설정 파일을 기반으로 gui 환경에서 필요한 설정을
추가/제거 할 수 있습니다.  별달리 변경할 게 없다면 그냥 저장하고 나오면 됩니다.&lt;/p&gt;

&lt;p&gt;저는 빌드에 많은 시간이 걸리지 않고 저장 공간이 큰 시스템에서는 이 방법을
사용하고, 작은 가상머신 등의 환경에서는 &lt;code&gt;localmodconfig&lt;/code&gt; 빌드 타겟을 사용해
가벼운 설정 파일을 만드는 편입니다.&lt;/p&gt;

&lt;h2 id=&#34;seperated-build-directory&#34;&gt;Seperated Build Directory&lt;/h2&gt;

&lt;p&gt;이렇게 빌드를 하면 컴파일된 파일들이 소스코드와 같은 디렉토리에 위치하게
되는데, &lt;code&gt;grep&lt;/code&gt; 등을 할때 성가시고, 실수로 git 에 이렇게 만들어진 파일들을
추가하는 실수도 흔합니다.  리눅스 커널 빌드 시스템은 &lt;code&gt;make&lt;/code&gt; 커맨드에 &lt;code&gt;O&lt;/code&gt; 옵션을
제공하는데, 이 옵션의 인자로 빌드 디렉토리를 지정할 수 있습니다.  빌드 과정에서
만들어진 파일들은 이 디렉토리로 저장되므로, 소스코드 디렉토리를 깨끗하게 유지할
수 있습니다.  예를 들어 &lt;code&gt;/foo&lt;/code&gt; 라는 디렉토리에 빌드 과정에서 만들어진 파일을
저장하고 싶다면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make O=/foo menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;build&#34;&gt;Build&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ make -j $(grep &amp;quot;^processor&amp;quot; /proc/cpuinfo | wc -l)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 커맨드는 리눅스 커널을 빌드합니다.  이 때 뒤의 &lt;code&gt;-j&lt;/code&gt; 옵션을 통해 빌드 과정
작업을 한순간에 최대 몇개까지 수행해도 되는지 지정해주는데, 이 커맨드에선
빌드를 수행하는 시스템에 장착된 논리적 코어의 갯수를 줬습니다.  커널 빌드엔 긴
시간이 걸립니다.  프로세서 3개를 준 제 가상머신에서는 12분 30초 정도 걸렸군요.
이것도 &lt;code&gt;localmodconfig&lt;/code&gt; 를 해줬기 때문이고, 이런저런 모듈 다 빌드하라고 했다면
훨씬 많이 걸렸을 겁니다.&lt;/p&gt;

&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ sudo make modules_install install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 커맨드는 빌드한 모듈들과 커널 자체를 설치합니다.  커널 빌드 시스템은 이
과정에서 가장 최신의 커널로 grub 의 디폴트 부트 대상도 바꿔줍니다.  이제 기계를
껐다 켜되, grub 등에서 부트할 커널 버전을 해당 버전으로 선택하면 빌드한 커널로
부팅됩니다.  현재 시스템이 사용중인 커널의 버전은 &lt;code&gt;uname -r&lt;/code&gt; 로 알 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;이상으로 Ubuntu 16.04.3 을 기본으로 리눅스 커널을 빌드하고 설치하는 방법을
알아봤습니다.  총 일곱개의 커맨드 뿐.   쉽죠?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
